(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
* @jsx React.DOM
*/
(function () {

  var React = require('react');
  var WebGLGlobe = require('./globe/webgl-globe.jsx');
  //Needed for React Developer Tools
  window.React = React;

  //Render the main app component
  var App = React.createClass({displayName: 'App',
    render: function() {
      return React.createElement(WebGLGlobe, null);
    }
  });
  React.render(React.createElement(App, null), document.body);

})();

},{"./globe/webgl-globe.jsx":153,"react":148}],2:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canMutationObserver = typeof window !== 'undefined'
    && window.MutationObserver;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    var queue = [];

    if (canMutationObserver) {
        var hiddenDiv = document.createElement("div");
        var observer = new MutationObserver(function () {
            var queueList = queue.slice();
            queue.length = 0;
            queueList.forEach(function (fn) {
                fn();
            });
        });

        observer.observe(hiddenDiv, { attributes: true });

        return function nextTick(fn) {
            if (!queue.length) {
                hiddenDiv.setAttribute('yes', 'no');
            }
            queue.push(fn);
        };
    }

    if (canPost) {
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],3:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule AutoFocusMixin
 * @typechecks static-only
 */

"use strict";

var focusNode = require("./focusNode");

var AutoFocusMixin = {
  componentDidMount: function() {
    if (this.props.autoFocus) {
      focusNode(this.getDOMNode());
    }
  }
};

module.exports = AutoFocusMixin;

},{"./focusNode":113}],4:[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule BeforeInputEventPlugin
 * @typechecks static-only
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPropagators = require("./EventPropagators");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var SyntheticInputEvent = require("./SyntheticInputEvent");

var keyOf = require("./keyOf");

var canUseTextInputEvent = (
  ExecutionEnvironment.canUseDOM &&
  'TextEvent' in window &&
  !('documentMode' in document || isPresto())
);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return (
    typeof opera === 'object' &&
    typeof opera.version === 'function' &&
    parseInt(opera.version(), 10) <= 12
  );
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

var topLevelTypes = EventConstants.topLevelTypes;

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: keyOf({onBeforeInput: null}),
      captured: keyOf({onBeforeInputCapture: null})
    },
    dependencies: [
      topLevelTypes.topCompositionEnd,
      topLevelTypes.topKeyPress,
      topLevelTypes.topTextInput,
      topLevelTypes.topPaste
    ]
  }
};

// Track characters inserted via keypress and composition events.
var fallbackChars = null;

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (
    (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
    // ctrlKey && altKey is equivalent to AltGr, and is not a command.
    !(nativeEvent.ctrlKey && nativeEvent.altKey)
  );
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 */
var BeforeInputEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {

    var chars;

    if (canUseTextInputEvent) {
      switch (topLevelType) {
        case topLevelTypes.topKeyPress:
          /**
           * If native `textInput` events are available, our goal is to make
           * use of them. However, there is a special case: the spacebar key.
           * In Webkit, preventing default on a spacebar `textInput` event
           * cancels character insertion, but it *also* causes the browser
           * to fall back to its default spacebar behavior of scrolling the
           * page.
           *
           * Tracking at:
           * https://code.google.com/p/chromium/issues/detail?id=355103
           *
           * To avoid this issue, use the keypress event as if no `textInput`
           * event is available.
           */
          var which = nativeEvent.which;
          if (which !== SPACEBAR_CODE) {
            return;
          }

          hasSpaceKeypress = true;
          chars = SPACEBAR_CHAR;
          break;

        case topLevelTypes.topTextInput:
          // Record the characters to be added to the DOM.
          chars = nativeEvent.data;

          // If it's a spacebar character, assume that we have already handled
          // it at the keypress level and bail immediately. Android Chrome
          // doesn't give us keycodes, so we need to blacklist it.
          if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
            return;
          }

          // Otherwise, carry on.
          break;

        default:
          // For other native event types, do nothing.
          return;
      }
    } else {
      switch (topLevelType) {
        case topLevelTypes.topPaste:
          // If a paste event occurs after a keypress, throw out the input
          // chars. Paste events should not lead to BeforeInput events.
          fallbackChars = null;
          break;
        case topLevelTypes.topKeyPress:
          /**
           * As of v27, Firefox may fire keypress events even when no character
           * will be inserted. A few possibilities:
           *
           * - `which` is `0`. Arrow keys, Esc key, etc.
           *
           * - `which` is the pressed key code, but no char is available.
           *   Ex: 'AltGr + d` in Polish. There is no modified character for
           *   this key combination and no character is inserted into the
           *   document, but FF fires the keypress for char code `100` anyway.
           *   No `input` event will occur.
           *
           * - `which` is the pressed key code, but a command combination is
           *   being used. Ex: `Cmd+C`. No character is inserted, and no
           *   `input` event will occur.
           */
          if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
            fallbackChars = String.fromCharCode(nativeEvent.which);
          }
          break;
        case topLevelTypes.topCompositionEnd:
          fallbackChars = nativeEvent.data;
          break;
      }

      // If no changes have occurred to the fallback string, no relevant
      // event has fired and we're done.
      if (fallbackChars === null) {
        return;
      }

      chars = fallbackChars;
    }

    // If no characters are being inserted, no BeforeInput event should
    // be fired.
    if (!chars) {
      return;
    }

    var event = SyntheticInputEvent.getPooled(
      eventTypes.beforeInput,
      topLevelTargetID,
      nativeEvent
    );

    event.data = chars;
    fallbackChars = null;
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }
};

module.exports = BeforeInputEventPlugin;

},{"./EventConstants":17,"./EventPropagators":22,"./ExecutionEnvironment":23,"./SyntheticInputEvent":91,"./keyOf":135}],5:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSProperty
 */

"use strict";

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  columnCount: true,
  fillOpacity: true,
  flex: true,
  flexGrow: true,
  flexShrink: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  widows: true,
  zIndex: true,
  zoom: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function(prop) {
  prefixes.forEach(function(prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundImage: true,
    backgroundPosition: true,
    backgroundRepeat: true,
    backgroundColor: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  }
};

var CSSProperty = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

module.exports = CSSProperty;

},{}],6:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSPropertyOperations
 * @typechecks static-only
 */

"use strict";

var CSSProperty = require("./CSSProperty");
var ExecutionEnvironment = require("./ExecutionEnvironment");

var camelizeStyleName = require("./camelizeStyleName");
var dangerousStyleValue = require("./dangerousStyleValue");
var hyphenateStyleName = require("./hyphenateStyleName");
var memoizeStringOnly = require("./memoizeStringOnly");
var warning = require("./warning");

var processStyleName = memoizeStringOnly(function(styleName) {
  return hyphenateStyleName(styleName);
});

var styleFloatAccessor = 'cssFloat';
if (ExecutionEnvironment.canUseDOM) {
  // IE8 only supports accessing cssFloat (standard) as styleFloat
  if (document.documentElement.style.cssFloat === undefined) {
    styleFloatAccessor = 'styleFloat';
  }
}

if ("production" !== process.env.NODE_ENV) {
  var warnedStyleNames = {};

  var warnHyphenatedStyleName = function(name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    ("production" !== process.env.NODE_ENV ? warning(
      false,
      'Unsupported style property ' + name + '. Did you mean ' +
      camelizeStyleName(name) + '?'
    ) : null);
  };
}

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations = {

  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @return {?string}
   */
  createMarkupForStyles: function(styles) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      if ("production" !== process.env.NODE_ENV) {
        if (styleName.indexOf('-') > -1) {
          warnHyphenatedStyleName(styleName);
        }
      }
      var styleValue = styles[styleName];
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   */
  setValueForStyles: function(node, styles) {
    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      if ("production" !== process.env.NODE_ENV) {
        if (styleName.indexOf('-') > -1) {
          warnHyphenatedStyleName(styleName);
        }
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
      if (styleName === 'float') {
        styleName = styleFloatAccessor;
      }
      if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }

};

module.exports = CSSPropertyOperations;

}).call(this,require('_process'))
},{"./CSSProperty":5,"./ExecutionEnvironment":23,"./camelizeStyleName":102,"./dangerousStyleValue":107,"./hyphenateStyleName":126,"./memoizeStringOnly":137,"./warning":147,"_process":2}],7:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CallbackQueue
 */

"use strict";

var PooledClass = require("./PooledClass");

var assign = require("./Object.assign");
var invariant = require("./invariant");

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */
function CallbackQueue() {
  this._callbacks = null;
  this._contexts = null;
}

assign(CallbackQueue.prototype, {

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */
  enqueue: function(callback, context) {
    this._callbacks = this._callbacks || [];
    this._contexts = this._contexts || [];
    this._callbacks.push(callback);
    this._contexts.push(context);
  },

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */
  notifyAll: function() {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    if (callbacks) {
      ("production" !== process.env.NODE_ENV ? invariant(
        callbacks.length === contexts.length,
        "Mismatched list of contexts in callback queue"
      ) : invariant(callbacks.length === contexts.length));
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0, l = callbacks.length; i < l; i++) {
        callbacks[i].call(contexts[i]);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  },

  /**
   * Resets the internal queue.
   *
   * @internal
   */
  reset: function() {
    this._callbacks = null;
    this._contexts = null;
  },

  /**
   * `PooledClass` looks for this.
   */
  destructor: function() {
    this.reset();
  }

});

PooledClass.addPoolingTo(CallbackQueue);

module.exports = CallbackQueue;

}).call(this,require('_process'))
},{"./Object.assign":28,"./PooledClass":29,"./invariant":128,"_process":2}],8:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ChangeEventPlugin
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");
var EventPropagators = require("./EventPropagators");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var ReactUpdates = require("./ReactUpdates");
var SyntheticEvent = require("./SyntheticEvent");

var isEventSupported = require("./isEventSupported");
var isTextInputElement = require("./isTextInputElement");
var keyOf = require("./keyOf");

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: keyOf({onChange: null}),
      captured: keyOf({onChangeCapture: null})
    },
    dependencies: [
      topLevelTypes.topBlur,
      topLevelTypes.topChange,
      topLevelTypes.topClick,
      topLevelTypes.topFocus,
      topLevelTypes.topInput,
      topLevelTypes.topKeyDown,
      topLevelTypes.topKeyUp,
      topLevelTypes.topSelectionChange
    ]
  }
};

/**
 * For IE shims
 */
var activeElement = null;
var activeElementID = null;
var activeElementValue = null;
var activeElementValueProp = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  return (
    elem.nodeName === 'SELECT' ||
    (elem.nodeName === 'INPUT' && elem.type === 'file')
  );
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (
    !('documentMode' in document) || document.documentMode > 8
  );
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = SyntheticEvent.getPooled(
    eventTypes.change,
    activeElementID,
    nativeEvent
  );
  EventPropagators.accumulateTwoPhaseDispatches(event);

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue();
}

function startWatchingForChangeEventIE8(target, targetID) {
  activeElement = target;
  activeElementID = targetID;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementID = null;
}

function getTargetIDForChangeEvent(
    topLevelType,
    topLevelTarget,
    topLevelTargetID) {
  if (topLevelType === topLevelTypes.topChange) {
    return topLevelTargetID;
  }
}
function handleEventsForChangeEventIE8(
    topLevelType,
    topLevelTarget,
    topLevelTargetID) {
  if (topLevelType === topLevelTypes.topFocus) {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForChangeEventIE8();
  }
}


/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events
  isInputEventSupported = isEventSupported('input') && (
    !('documentMode' in document) || document.documentMode > 9
  );
}

/**
 * (For old IE.) Replacement getter/setter for the `value` property that gets
 * set on the active element.
 */
var newValueProp =  {
  get: function() {
    return activeElementValueProp.get.call(this);
  },
  set: function(val) {
    // Cast to a string so we can do equality checks.
    activeElementValue = '' + val;
    activeElementValueProp.set.call(this, val);
  }
};

/**
 * (For old IE.) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetID) {
  activeElement = target;
  activeElementID = targetID;
  activeElementValue = target.value;
  activeElementValueProp = Object.getOwnPropertyDescriptor(
    target.constructor.prototype,
    'value'
  );

  Object.defineProperty(activeElement, 'value', newValueProp);
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For old IE.) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  // delete restores the original property definition
  delete activeElement.value;
  activeElement.detachEvent('onpropertychange', handlePropertyChange);

  activeElement = null;
  activeElementID = null;
  activeElementValue = null;
  activeElementValueProp = null;
}

/**
 * (For old IE.) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  var value = nativeEvent.srcElement.value;
  if (value === activeElementValue) {
    return;
  }
  activeElementValue = value;

  manualDispatchChangeEvent(nativeEvent);
}

/**
 * If a `change` event should be fired, returns the target's ID.
 */
function getTargetIDForInputEvent(
    topLevelType,
    topLevelTarget,
    topLevelTargetID) {
  if (topLevelType === topLevelTypes.topInput) {
    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
    // what we want so fall through here and trigger an abstract event
    return topLevelTargetID;
  }
}

// For IE8 and IE9.
function handleEventsForInputEventIE(
    topLevelType,
    topLevelTarget,
    topLevelTargetID) {
  if (topLevelType === topLevelTypes.topFocus) {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetIDForInputEventIE(
    topLevelType,
    topLevelTarget,
    topLevelTargetID) {
  if (topLevelType === topLevelTypes.topSelectionChange ||
      topLevelType === topLevelTypes.topKeyUp ||
      topLevelType === topLevelTypes.topKeyDown) {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    if (activeElement && activeElement.value !== activeElementValue) {
      activeElementValue = activeElement.value;
      return activeElementID;
    }
  }
}


/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  return (
    elem.nodeName === 'INPUT' &&
    (elem.type === 'checkbox' || elem.type === 'radio')
  );
}

function getTargetIDForClickEvent(
    topLevelType,
    topLevelTarget,
    topLevelTargetID) {
  if (topLevelType === topLevelTypes.topClick) {
    return topLevelTargetID;
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {

    var getTargetIDFunc, handleEventFunc;
    if (shouldUseChangeEvent(topLevelTarget)) {
      if (doesChangeEventBubble) {
        getTargetIDFunc = getTargetIDForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(topLevelTarget)) {
      if (isInputEventSupported) {
        getTargetIDFunc = getTargetIDForInputEvent;
      } else {
        getTargetIDFunc = getTargetIDForInputEventIE;
        handleEventFunc = handleEventsForInputEventIE;
      }
    } else if (shouldUseClickEvent(topLevelTarget)) {
      getTargetIDFunc = getTargetIDForClickEvent;
    }

    if (getTargetIDFunc) {
      var targetID = getTargetIDFunc(
        topLevelType,
        topLevelTarget,
        topLevelTargetID
      );
      if (targetID) {
        var event = SyntheticEvent.getPooled(
          eventTypes.change,
          targetID,
          nativeEvent
        );
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(
        topLevelType,
        topLevelTarget,
        topLevelTargetID
      );
    }
  }

};

module.exports = ChangeEventPlugin;

},{"./EventConstants":17,"./EventPluginHub":19,"./EventPropagators":22,"./ExecutionEnvironment":23,"./ReactUpdates":81,"./SyntheticEvent":89,"./isEventSupported":129,"./isTextInputElement":131,"./keyOf":135}],9:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ClientReactRootIndex
 * @typechecks
 */

"use strict";

var nextReactRootIndex = 0;

var ClientReactRootIndex = {
  createReactRootIndex: function() {
    return nextReactRootIndex++;
  }
};

module.exports = ClientReactRootIndex;

},{}],10:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CompositionEventPlugin
 * @typechecks static-only
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPropagators = require("./EventPropagators");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var ReactInputSelection = require("./ReactInputSelection");
var SyntheticCompositionEvent = require("./SyntheticCompositionEvent");

var getTextContentAccessor = require("./getTextContentAccessor");
var keyOf = require("./keyOf");

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var useCompositionEvent = (
  ExecutionEnvironment.canUseDOM &&
  'CompositionEvent' in window
);

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. In Korean, for example,
// the compositionend event contains only one character regardless of
// how many characters have been composed since compositionstart.
// We therefore use the fallback data while still using the native
// events as triggers.
var useFallbackData = (
  !useCompositionEvent ||
  (
    'documentMode' in document &&
    document.documentMode > 8 &&
    document.documentMode <= 11
  )
);

var topLevelTypes = EventConstants.topLevelTypes;
var currentComposition = null;

// Events and their corresponding property names.
var eventTypes = {
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({onCompositionEnd: null}),
      captured: keyOf({onCompositionEndCapture: null})
    },
    dependencies: [
      topLevelTypes.topBlur,
      topLevelTypes.topCompositionEnd,
      topLevelTypes.topKeyDown,
      topLevelTypes.topKeyPress,
      topLevelTypes.topKeyUp,
      topLevelTypes.topMouseDown
    ]
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({onCompositionStart: null}),
      captured: keyOf({onCompositionStartCapture: null})
    },
    dependencies: [
      topLevelTypes.topBlur,
      topLevelTypes.topCompositionStart,
      topLevelTypes.topKeyDown,
      topLevelTypes.topKeyPress,
      topLevelTypes.topKeyUp,
      topLevelTypes.topMouseDown
    ]
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: keyOf({onCompositionUpdate: null}),
      captured: keyOf({onCompositionUpdateCapture: null})
    },
    dependencies: [
      topLevelTypes.topBlur,
      topLevelTypes.topCompositionUpdate,
      topLevelTypes.topKeyDown,
      topLevelTypes.topKeyPress,
      topLevelTypes.topKeyUp,
      topLevelTypes.topMouseDown
    ]
  }
};

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case topLevelTypes.topCompositionStart:
      return eventTypes.compositionStart;
    case topLevelTypes.topCompositionEnd:
      return eventTypes.compositionEnd;
    case topLevelTypes.topCompositionUpdate:
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackStart(topLevelType, nativeEvent) {
  return (
    topLevelType === topLevelTypes.topKeyDown &&
    nativeEvent.keyCode === START_KEYCODE
  );
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case topLevelTypes.topKeyUp:
      // Command keys insert or clear IME input.
      return (END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1);
    case topLevelTypes.topKeyDown:
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return (nativeEvent.keyCode !== START_KEYCODE);
    case topLevelTypes.topKeyPress:
    case topLevelTypes.topMouseDown:
    case topLevelTypes.topBlur:
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Helper class stores information about selection and document state
 * so we can figure out what changed at a later date.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
  this.root = root;
  this.startSelection = ReactInputSelection.getSelection(root);
  this.startValue = this.getText();
}

/**
 * Get current text of input.
 *
 * @return {string}
 */
FallbackCompositionState.prototype.getText = function() {
  return this.root.value || this.root[getTextContentAccessor()];
};

/**
 * Text that has changed since the start of composition.
 *
 * @return {string}
 */
FallbackCompositionState.prototype.getData = function() {
  var endValue = this.getText();
  var prefixLength = this.startSelection.start;
  var suffixLength = this.startValue.length - this.startSelection.end;

  return endValue.substr(
    prefixLength,
    endValue.length - suffixLength - prefixLength
  );
};

/**
 * This plugin creates `onCompositionStart`, `onCompositionUpdate` and
 * `onCompositionEnd` events on inputs, textareas and contentEditable
 * nodes.
 */
var CompositionEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {

    var eventType;
    var data;

    if (useCompositionEvent) {
      eventType = getCompositionEventType(topLevelType);
    } else if (!currentComposition) {
      if (isFallbackStart(topLevelType, nativeEvent)) {
        eventType = eventTypes.compositionStart;
      }
    } else if (isFallbackEnd(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionEnd;
    }

    if (useFallbackData) {
      // The current composition is stored statically and must not be
      // overwritten while composition continues.
      if (!currentComposition && eventType === eventTypes.compositionStart) {
        currentComposition = new FallbackCompositionState(topLevelTarget);
      } else if (eventType === eventTypes.compositionEnd) {
        if (currentComposition) {
          data = currentComposition.getData();
          currentComposition = null;
        }
      }
    }

    if (eventType) {
      var event = SyntheticCompositionEvent.getPooled(
        eventType,
        topLevelTargetID,
        nativeEvent
      );
      if (data) {
        // Inject data generated from fallback path into the synthetic event.
        // This matches the property of native CompositionEventInterface.
        event.data = data;
      }
      EventPropagators.accumulateTwoPhaseDispatches(event);
      return event;
    }
  }
};

module.exports = CompositionEventPlugin;

},{"./EventConstants":17,"./EventPropagators":22,"./ExecutionEnvironment":23,"./ReactInputSelection":61,"./SyntheticCompositionEvent":87,"./getTextContentAccessor":123,"./keyOf":135}],11:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMChildrenOperations
 * @typechecks static-only
 */

"use strict";

var Danger = require("./Danger");
var ReactMultiChildUpdateTypes = require("./ReactMultiChildUpdateTypes");

var getTextContentAccessor = require("./getTextContentAccessor");
var invariant = require("./invariant");

/**
 * The DOM property to use when setting text content.
 *
 * @type {string}
 * @private
 */
var textContentAccessor = getTextContentAccessor();

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
function insertChildAt(parentNode, childNode, index) {
  // By exploiting arrays returning `undefined` for an undefined index, we can
  // rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. However, using `undefined` is not allowed by all
  // browsers so we must replace it with `null`.
  parentNode.insertBefore(
    childNode,
    parentNode.childNodes[index] || null
  );
}

var updateTextContent;
if (textContentAccessor === 'textContent') {
  /**
   * Sets the text content of `node` to `text`.
   *
   * @param {DOMElement} node Node to change
   * @param {string} text New text content
   */
  updateTextContent = function(node, text) {
    node.textContent = text;
  };
} else {
  /**
   * Sets the text content of `node` to `text`.
   *
   * @param {DOMElement} node Node to change
   * @param {string} text New text content
   */
  updateTextContent = function(node, text) {
    // In order to preserve newlines correctly, we can't use .innerText to set
    // the contents (see #1080), so we empty the element then append a text node
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
    if (text) {
      var doc = node.ownerDocument || document;
      node.appendChild(doc.createTextNode(text));
    }
  };
}

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations = {

  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,

  updateTextContent: updateTextContent,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @param {array<string>} markupList List of markup strings.
   * @internal
   */
  processUpdates: function(updates, markupList) {
    var update;
    // Mapping from parent IDs to initial child orderings.
    var initialChildren = null;
    // List of children that will be moved or removed.
    var updatedChildren = null;

    for (var i = 0; update = updates[i]; i++) {
      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING ||
          update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
        var updatedIndex = update.fromIndex;
        var updatedChild = update.parentNode.childNodes[updatedIndex];
        var parentID = update.parentID;

        ("production" !== process.env.NODE_ENV ? invariant(
          updatedChild,
          'processUpdates(): Unable to find child %s of element. This ' +
          'probably means the DOM was unexpectedly mutated (e.g., by the ' +
          'browser), usually due to forgetting a <tbody> when using tables, ' +
          'nesting tags like <form>, <p>, or <a>, or using non-SVG elements '+
          'in an <svg> parent. Try inspecting the child nodes of the element ' +
          'with React ID `%s`.',
          updatedIndex,
          parentID
        ) : invariant(updatedChild));

        initialChildren = initialChildren || {};
        initialChildren[parentID] = initialChildren[parentID] || [];
        initialChildren[parentID][updatedIndex] = updatedChild;

        updatedChildren = updatedChildren || [];
        updatedChildren.push(updatedChild);
      }
    }

    var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);

    // Remove updated children first so that `toIndex` is consistent.
    if (updatedChildren) {
      for (var j = 0; j < updatedChildren.length; j++) {
        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
      }
    }

    for (var k = 0; update = updates[k]; k++) {
      switch (update.type) {
        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
          insertChildAt(
            update.parentNode,
            renderedMarkup[update.markupIndex],
            update.toIndex
          );
          break;
        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
          insertChildAt(
            update.parentNode,
            initialChildren[update.parentID][update.fromIndex],
            update.toIndex
          );
          break;
        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
          updateTextContent(
            update.parentNode,
            update.textContent
          );
          break;
        case ReactMultiChildUpdateTypes.REMOVE_NODE:
          // Already removed by the for-loop above.
          break;
      }
    }
  }

};

module.exports = DOMChildrenOperations;

}).call(this,require('_process'))
},{"./Danger":14,"./ReactMultiChildUpdateTypes":67,"./getTextContentAccessor":123,"./invariant":128,"_process":2}],12:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMProperty
 * @typechecks static-only
 */

/*jslint bitwise: true */

"use strict";

var invariant = require("./invariant");

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_ATTRIBUTE: 0x1,
  MUST_USE_PROPERTY: 0x2,
  HAS_SIDE_EFFECTS: 0x4,
  HAS_BOOLEAN_VALUE: 0x8,
  HAS_NUMERIC_VALUE: 0x10,
  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function(domPropertyConfig) {
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty._isCustomAttributeFunctions.push(
        domPropertyConfig.isCustomAttribute
      );
    }

    for (var propName in Properties) {
      ("production" !== process.env.NODE_ENV ? invariant(
        !DOMProperty.isStandardName.hasOwnProperty(propName),
        'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' +
        '\'%s\' which has already been injected. You may be accidentally ' +
        'injecting the same DOM property config twice, or you may be ' +
        'injecting two configs that have conflicting property names.',
        propName
      ) : invariant(!DOMProperty.isStandardName.hasOwnProperty(propName)));

      DOMProperty.isStandardName[propName] = true;

      var lowerCased = propName.toLowerCase();
      DOMProperty.getPossibleStandardName[lowerCased] = propName;

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        DOMProperty.getPossibleStandardName[attributeName] = propName;
        DOMProperty.getAttributeName[propName] = attributeName;
      } else {
        DOMProperty.getAttributeName[propName] = lowerCased;
      }

      DOMProperty.getPropertyName[propName] =
        DOMPropertyNames.hasOwnProperty(propName) ?
          DOMPropertyNames[propName] :
          propName;

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        DOMProperty.getMutationMethod[propName] = DOMMutationMethods[propName];
      } else {
        DOMProperty.getMutationMethod[propName] = null;
      }

      var propConfig = Properties[propName];
      DOMProperty.mustUseAttribute[propName] =
        checkMask(propConfig, DOMPropertyInjection.MUST_USE_ATTRIBUTE);
      DOMProperty.mustUseProperty[propName] =
        checkMask(propConfig, DOMPropertyInjection.MUST_USE_PROPERTY);
      DOMProperty.hasSideEffects[propName] =
        checkMask(propConfig, DOMPropertyInjection.HAS_SIDE_EFFECTS);
      DOMProperty.hasBooleanValue[propName] =
        checkMask(propConfig, DOMPropertyInjection.HAS_BOOLEAN_VALUE);
      DOMProperty.hasNumericValue[propName] =
        checkMask(propConfig, DOMPropertyInjection.HAS_NUMERIC_VALUE);
      DOMProperty.hasPositiveNumericValue[propName] =
        checkMask(propConfig, DOMPropertyInjection.HAS_POSITIVE_NUMERIC_VALUE);
      DOMProperty.hasOverloadedBooleanValue[propName] =
        checkMask(propConfig, DOMPropertyInjection.HAS_OVERLOADED_BOOLEAN_VALUE);

      ("production" !== process.env.NODE_ENV ? invariant(
        !DOMProperty.mustUseAttribute[propName] ||
          !DOMProperty.mustUseProperty[propName],
        'DOMProperty: Cannot require using both attribute and property: %s',
        propName
      ) : invariant(!DOMProperty.mustUseAttribute[propName] ||
        !DOMProperty.mustUseProperty[propName]));
      ("production" !== process.env.NODE_ENV ? invariant(
        DOMProperty.mustUseProperty[propName] ||
          !DOMProperty.hasSideEffects[propName],
        'DOMProperty: Properties that have side effects must use property: %s',
        propName
      ) : invariant(DOMProperty.mustUseProperty[propName] ||
        !DOMProperty.hasSideEffects[propName]));
      ("production" !== process.env.NODE_ENV ? invariant(
        !!DOMProperty.hasBooleanValue[propName] +
          !!DOMProperty.hasNumericValue[propName] +
          !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1,
        'DOMProperty: Value can be one of boolean, overloaded boolean, or ' +
        'numeric value, but not a combination: %s',
        propName
      ) : invariant(!!DOMProperty.hasBooleanValue[propName] +
        !!DOMProperty.hasNumericValue[propName] +
        !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1));
    }
  }
};
var defaultValueCache = {};

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty = {

  ID_ATTRIBUTE_NAME: 'data-reactid',

  /**
   * Checks whether a property name is a standard property.
   * @type {Object}
   */
  isStandardName: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties.
   * @type {Object}
   */
  getPossibleStandardName: {},

  /**
   * Mapping from normalized names to attribute names that differ. Attribute
   * names are used when rendering markup or with `*Attribute()`.
   * @type {Object}
   */
  getAttributeName: {},

  /**
   * Mapping from normalized names to properties on DOM node instances.
   * (This includes properties that mutate due to external factors.)
   * @type {Object}
   */
  getPropertyName: {},

  /**
   * Mapping from normalized names to mutation methods. This will only exist if
   * mutation cannot be set simply by the property or `setAttribute()`.
   * @type {Object}
   */
  getMutationMethod: {},

  /**
   * Whether the property must be accessed and mutated as an object property.
   * @type {Object}
   */
  mustUseAttribute: {},

  /**
   * Whether the property must be accessed and mutated using `*Attribute()`.
   * (This includes anything that fails `<propName> in <element>`.)
   * @type {Object}
   */
  mustUseProperty: {},

  /**
   * Whether or not setting a value causes side effects such as triggering
   * resources to be loaded or text selection changes. We must ensure that
   * the value is only set if it has changed.
   * @type {Object}
   */
  hasSideEffects: {},

  /**
   * Whether the property should be removed when set to a falsey value.
   * @type {Object}
   */
  hasBooleanValue: {},

  /**
   * Whether the property must be numeric or parse as a
   * numeric and should be removed when set to a falsey value.
   * @type {Object}
   */
  hasNumericValue: {},

  /**
   * Whether the property must be positive numeric or parse as a positive
   * numeric and should be removed when set to a falsey value.
   * @type {Object}
   */
  hasPositiveNumericValue: {},

  /**
   * Whether the property can be used as a flag as well as with a value. Removed
   * when strictly equal to false; present without a value when strictly equal
   * to true; present with a value otherwise.
   * @type {Object}
   */
  hasOverloadedBooleanValue: {},

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function(attributeName) {
    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  /**
   * Returns the default property value for a DOM property (i.e., not an
   * attribute). Most default values are '' or false, but not all. Worse yet,
   * some (in particular, `type`) vary depending on the type of element.
   *
   * TODO: Is it better to grab all the possible properties when creating an
   * element to avoid having to create the same element twice?
   */
  getDefaultValueForProperty: function(nodeName, prop) {
    var nodeDefaults = defaultValueCache[nodeName];
    var testElement;
    if (!nodeDefaults) {
      defaultValueCache[nodeName] = nodeDefaults = {};
    }
    if (!(prop in nodeDefaults)) {
      testElement = document.createElement(nodeName);
      nodeDefaults[prop] = testElement[prop];
    }
    return nodeDefaults[prop];
  },

  injection: DOMPropertyInjection
};

module.exports = DOMProperty;

}).call(this,require('_process'))
},{"./invariant":128,"_process":2}],13:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMPropertyOperations
 * @typechecks static-only
 */

"use strict";

var DOMProperty = require("./DOMProperty");

var escapeTextForBrowser = require("./escapeTextForBrowser");
var memoizeStringOnly = require("./memoizeStringOnly");
var warning = require("./warning");

function shouldIgnoreValue(name, value) {
  return value == null ||
    (DOMProperty.hasBooleanValue[name] && !value) ||
    (DOMProperty.hasNumericValue[name] && isNaN(value)) ||
    (DOMProperty.hasPositiveNumericValue[name] && (value < 1)) ||
    (DOMProperty.hasOverloadedBooleanValue[name] && value === false);
}

var processAttributeNameAndPrefix = memoizeStringOnly(function(name) {
  return escapeTextForBrowser(name) + '="';
});

if ("production" !== process.env.NODE_ENV) {
  var reactProps = {
    children: true,
    dangerouslySetInnerHTML: true,
    key: true,
    ref: true
  };
  var warnedProperties = {};

  var warnUnknownProperty = function(name) {
    if (reactProps.hasOwnProperty(name) && reactProps[name] ||
        warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return;
    }

    warnedProperties[name] = true;
    var lowerCasedName = name.toLowerCase();

    // data-* attributes should be lowercase; suggest the lowercase version
    var standardName = (
      DOMProperty.isCustomAttribute(lowerCasedName) ?
        lowerCasedName :
      DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ?
        DOMProperty.getPossibleStandardName[lowerCasedName] :
        null
    );

    // For now, only warn when we have a suggested correction. This prevents
    // logging too much when using transferPropsTo.
    ("production" !== process.env.NODE_ENV ? warning(
      standardName == null,
      'Unknown DOM property ' + name + '. Did you mean ' + standardName + '?'
    ) : null);

  };
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations = {

  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function(id) {
    return processAttributeNameAndPrefix(DOMProperty.ID_ATTRIBUTE_NAME) +
      escapeTextForBrowser(id) + '"';
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function(name, value) {
    if (DOMProperty.isStandardName.hasOwnProperty(name) &&
        DOMProperty.isStandardName[name]) {
      if (shouldIgnoreValue(name, value)) {
        return '';
      }
      var attributeName = DOMProperty.getAttributeName[name];
      if (DOMProperty.hasBooleanValue[name] ||
          (DOMProperty.hasOverloadedBooleanValue[name] && value === true)) {
        return escapeTextForBrowser(attributeName);
      }
      return processAttributeNameAndPrefix(attributeName) +
        escapeTextForBrowser(value) + '"';
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return processAttributeNameAndPrefix(name) +
        escapeTextForBrowser(value) + '"';
    } else if ("production" !== process.env.NODE_ENV) {
      warnUnknownProperty(name);
    }
    return null;
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function(node, name, value) {
    if (DOMProperty.isStandardName.hasOwnProperty(name) &&
        DOMProperty.isStandardName[name]) {
      var mutationMethod = DOMProperty.getMutationMethod[name];
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(name, value)) {
        this.deleteValueForProperty(node, name);
      } else if (DOMProperty.mustUseAttribute[name]) {
        // `setAttribute` with objects becomes only `[object]` in IE8/9,
        // ('' + value) makes it output the correct toString()-value.
        node.setAttribute(DOMProperty.getAttributeName[name], '' + value);
      } else {
        var propName = DOMProperty.getPropertyName[name];
        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
        // property type before comparing; only `value` does and is string.
        if (!DOMProperty.hasSideEffects[name] ||
            ('' + node[propName]) !== ('' + value)) {
          // Contrary to `setAttribute`, object properties are properly
          // `toString`ed by IE8/9.
          node[propName] = value;
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        node.removeAttribute(name);
      } else {
        node.setAttribute(name, '' + value);
      }
    } else if ("production" !== process.env.NODE_ENV) {
      warnUnknownProperty(name);
    }
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function(node, name) {
    if (DOMProperty.isStandardName.hasOwnProperty(name) &&
        DOMProperty.isStandardName[name]) {
      var mutationMethod = DOMProperty.getMutationMethod[name];
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (DOMProperty.mustUseAttribute[name]) {
        node.removeAttribute(DOMProperty.getAttributeName[name]);
      } else {
        var propName = DOMProperty.getPropertyName[name];
        var defaultValue = DOMProperty.getDefaultValueForProperty(
          node.nodeName,
          propName
        );
        if (!DOMProperty.hasSideEffects[name] ||
            ('' + node[propName]) !== defaultValue) {
          node[propName] = defaultValue;
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      node.removeAttribute(name);
    } else if ("production" !== process.env.NODE_ENV) {
      warnUnknownProperty(name);
    }
  }

};

module.exports = DOMPropertyOperations;

}).call(this,require('_process'))
},{"./DOMProperty":12,"./escapeTextForBrowser":111,"./memoizeStringOnly":137,"./warning":147,"_process":2}],14:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Danger
 * @typechecks static-only
 */

/*jslint evil: true, sub: true */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

var createNodesFromMarkup = require("./createNodesFromMarkup");
var emptyFunction = require("./emptyFunction");
var getMarkupWrap = require("./getMarkupWrap");
var invariant = require("./invariant");

var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
var RESULT_INDEX_ATTR = 'data-danger-index';

/**
 * Extracts the `nodeName` from a string of markup.
 *
 * NOTE: Extracting the `nodeName` does not require a regular expression match
 * because we make assumptions about React-generated markup (i.e. there are no
 * spaces surrounding the opening tag and there is at least one attribute).
 *
 * @param {string} markup String of markup.
 * @return {string} Node name of the supplied markup.
 * @see http://jsperf.com/extract-nodename
 */
function getNodeName(markup) {
  return markup.substring(1, markup.indexOf(' '));
}

var Danger = {

  /**
   * Renders markup into an array of nodes. The markup is expected to render
   * into a list of root nodes. Also, the length of `resultList` and
   * `markupList` should be the same.
   *
   * @param {array<string>} markupList List of markup strings to render.
   * @return {array<DOMElement>} List of rendered nodes.
   * @internal
   */
  dangerouslyRenderMarkup: function(markupList) {
    ("production" !== process.env.NODE_ENV ? invariant(
      ExecutionEnvironment.canUseDOM,
      'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' +
      'thread. Make sure `window` and `document` are available globally ' +
      'before requiring React when unit testing or use ' +
      'React.renderToString for server rendering.'
    ) : invariant(ExecutionEnvironment.canUseDOM));
    var nodeName;
    var markupByNodeName = {};
    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
    for (var i = 0; i < markupList.length; i++) {
      ("production" !== process.env.NODE_ENV ? invariant(
        markupList[i],
        'dangerouslyRenderMarkup(...): Missing markup.'
      ) : invariant(markupList[i]));
      nodeName = getNodeName(markupList[i]);
      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
      markupByNodeName[nodeName][i] = markupList[i];
    }
    var resultList = [];
    var resultListAssignmentCount = 0;
    for (nodeName in markupByNodeName) {
      if (!markupByNodeName.hasOwnProperty(nodeName)) {
        continue;
      }
      var markupListByNodeName = markupByNodeName[nodeName];

      // This for-in loop skips the holes of the sparse array. The order of
      // iteration should follow the order of assignment, which happens to match
      // numerical index order, but we don't rely on that.
      for (var resultIndex in markupListByNodeName) {
        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
          var markup = markupListByNodeName[resultIndex];

          // Push the requested markup with an additional RESULT_INDEX_ATTR
          // attribute.  If the markup does not start with a < character, it
          // will be discarded below (with an appropriate console.error).
          markupListByNodeName[resultIndex] = markup.replace(
            OPEN_TAG_NAME_EXP,
            // This index will be parsed back out below.
            '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" '
          );
        }
      }

      // Render each group of markup with similar wrapping `nodeName`.
      var renderNodes = createNodesFromMarkup(
        markupListByNodeName.join(''),
        emptyFunction // Do nothing special with <script> tags.
      );

      for (i = 0; i < renderNodes.length; ++i) {
        var renderNode = renderNodes[i];
        if (renderNode.hasAttribute &&
            renderNode.hasAttribute(RESULT_INDEX_ATTR)) {

          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
          renderNode.removeAttribute(RESULT_INDEX_ATTR);

          ("production" !== process.env.NODE_ENV ? invariant(
            !resultList.hasOwnProperty(resultIndex),
            'Danger: Assigning to an already-occupied result index.'
          ) : invariant(!resultList.hasOwnProperty(resultIndex)));

          resultList[resultIndex] = renderNode;

          // This should match resultList.length and markupList.length when
          // we're done.
          resultListAssignmentCount += 1;

        } else if ("production" !== process.env.NODE_ENV) {
          console.error(
            "Danger: Discarding unexpected node:",
            renderNode
          );
        }
      }
    }

    // Although resultList was populated out of order, it should now be a dense
    // array.
    ("production" !== process.env.NODE_ENV ? invariant(
      resultListAssignmentCount === resultList.length,
      'Danger: Did not assign to every index of resultList.'
    ) : invariant(resultListAssignmentCount === resultList.length));

    ("production" !== process.env.NODE_ENV ? invariant(
      resultList.length === markupList.length,
      'Danger: Expected markup to render %s nodes, but rendered %s.',
      markupList.length,
      resultList.length
    ) : invariant(resultList.length === markupList.length));

    return resultList;
  },

  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {
    ("production" !== process.env.NODE_ENV ? invariant(
      ExecutionEnvironment.canUseDOM,
      'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' +
      'worker thread. Make sure `window` and `document` are available ' +
      'globally before requiring React when unit testing or use ' +
      'React.renderToString for server rendering.'
    ) : invariant(ExecutionEnvironment.canUseDOM));
    ("production" !== process.env.NODE_ENV ? invariant(markup, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(markup));
    ("production" !== process.env.NODE_ENV ? invariant(
      oldChild.tagName.toLowerCase() !== 'html',
      'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' +
      '<html> node. This is because browser quirks make this unreliable ' +
      'and/or slow. If you want to render to the root you must use ' +
      'server rendering. See renderComponentToString().'
    ) : invariant(oldChild.tagName.toLowerCase() !== 'html'));

    var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
    oldChild.parentNode.replaceChild(newChild, oldChild);
  }

};

module.exports = Danger;

}).call(this,require('_process'))
},{"./ExecutionEnvironment":23,"./createNodesFromMarkup":106,"./emptyFunction":109,"./getMarkupWrap":120,"./invariant":128,"_process":2}],15:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DefaultEventPluginOrder
 */

"use strict";

 var keyOf = require("./keyOf");

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DefaultEventPluginOrder = [
  keyOf({ResponderEventPlugin: null}),
  keyOf({SimpleEventPlugin: null}),
  keyOf({TapEventPlugin: null}),
  keyOf({EnterLeaveEventPlugin: null}),
  keyOf({ChangeEventPlugin: null}),
  keyOf({SelectEventPlugin: null}),
  keyOf({CompositionEventPlugin: null}),
  keyOf({BeforeInputEventPlugin: null}),
  keyOf({AnalyticsEventPlugin: null}),
  keyOf({MobileSafariClickEventPlugin: null})
];

module.exports = DefaultEventPluginOrder;

},{"./keyOf":135}],16:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EnterLeaveEventPlugin
 * @typechecks static-only
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPropagators = require("./EventPropagators");
var SyntheticMouseEvent = require("./SyntheticMouseEvent");

var ReactMount = require("./ReactMount");
var keyOf = require("./keyOf");

var topLevelTypes = EventConstants.topLevelTypes;
var getFirstReactDOM = ReactMount.getFirstReactDOM;

var eventTypes = {
  mouseEnter: {
    registrationName: keyOf({onMouseEnter: null}),
    dependencies: [
      topLevelTypes.topMouseOut,
      topLevelTypes.topMouseOver
    ]
  },
  mouseLeave: {
    registrationName: keyOf({onMouseLeave: null}),
    dependencies: [
      topLevelTypes.topMouseOut,
      topLevelTypes.topMouseOver
    ]
  }
};

var extractedEvents = [null, null];

var EnterLeaveEventPlugin = {

  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {
    if (topLevelType === topLevelTypes.topMouseOver &&
        (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== topLevelTypes.topMouseOut &&
        topLevelType !== topLevelTypes.topMouseOver) {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (topLevelTarget.window === topLevelTarget) {
      // `topLevelTarget` is probably a window object.
      win = topLevelTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = topLevelTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from, to;
    if (topLevelType === topLevelTypes.topMouseOut) {
      from = topLevelTarget;
      to =
        getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement) ||
        win;
    } else {
      from = win;
      to = topLevelTarget;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromID = from ? ReactMount.getID(from) : '';
    var toID = to ? ReactMount.getID(to) : '';

    var leave = SyntheticMouseEvent.getPooled(
      eventTypes.mouseLeave,
      fromID,
      nativeEvent
    );
    leave.type = 'mouseleave';
    leave.target = from;
    leave.relatedTarget = to;

    var enter = SyntheticMouseEvent.getPooled(
      eventTypes.mouseEnter,
      toID,
      nativeEvent
    );
    enter.type = 'mouseenter';
    enter.target = to;
    enter.relatedTarget = from;

    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);

    extractedEvents[0] = leave;
    extractedEvents[1] = enter;

    return extractedEvents;
  }

};

module.exports = EnterLeaveEventPlugin;

},{"./EventConstants":17,"./EventPropagators":22,"./ReactMount":65,"./SyntheticMouseEvent":93,"./keyOf":135}],17:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventConstants
 */

"use strict";

var keyMirror = require("./keyMirror");

var PropagationPhases = keyMirror({bubbled: null, captured: null});

/**
 * Types of raw signals from the browser caught at the top level.
 */
var topLevelTypes = keyMirror({
  topBlur: null,
  topChange: null,
  topClick: null,
  topCompositionEnd: null,
  topCompositionStart: null,
  topCompositionUpdate: null,
  topContextMenu: null,
  topCopy: null,
  topCut: null,
  topDoubleClick: null,
  topDrag: null,
  topDragEnd: null,
  topDragEnter: null,
  topDragExit: null,
  topDragLeave: null,
  topDragOver: null,
  topDragStart: null,
  topDrop: null,
  topError: null,
  topFocus: null,
  topInput: null,
  topKeyDown: null,
  topKeyPress: null,
  topKeyUp: null,
  topLoad: null,
  topMouseDown: null,
  topMouseMove: null,
  topMouseOut: null,
  topMouseOver: null,
  topMouseUp: null,
  topPaste: null,
  topReset: null,
  topScroll: null,
  topSelectionChange: null,
  topSubmit: null,
  topTextInput: null,
  topTouchCancel: null,
  topTouchEnd: null,
  topTouchMove: null,
  topTouchStart: null,
  topWheel: null
});

var EventConstants = {
  topLevelTypes: topLevelTypes,
  PropagationPhases: PropagationPhases
};

module.exports = EventConstants;

},{"./keyMirror":134}],18:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EventListener
 * @typechecks
 */

var emptyFunction = require("./emptyFunction");

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function(target, eventType, callback) {
    if (!target.addEventListener) {
      if ("production" !== process.env.NODE_ENV) {
        console.error(
          'Attempted to listen to events during the capture phase on a ' +
          'browser that does not support the capture phase. Your application ' +
          'will not receive some events.'
        );
      }
      return {
        remove: emptyFunction
      };
    } else {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    }
  },

  registerDefault: function() {}
};

module.exports = EventListener;

}).call(this,require('_process'))
},{"./emptyFunction":109,"_process":2}],19:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginHub
 */

"use strict";

var EventPluginRegistry = require("./EventPluginRegistry");
var EventPluginUtils = require("./EventPluginUtils");

var accumulateInto = require("./accumulateInto");
var forEachAccumulated = require("./forEachAccumulated");
var invariant = require("./invariant");

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @private
 */
var executeDispatchesAndRelease = function(event) {
  if (event) {
    var executeDispatch = EventPluginUtils.executeDispatch;
    // Plugins can provide custom behavior when dispatching events.
    var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);
    if (PluginModule && PluginModule.executeDispatch) {
      executeDispatch = PluginModule.executeDispatch;
    }
    EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};

/**
 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
 *   hierarchy given ids of the logical DOM elements involved.
 */
var InstanceHandle = null;

function validateInstanceHandle() {
  var invalid = !InstanceHandle||
    !InstanceHandle.traverseTwoPhase ||
    !InstanceHandle.traverseEnterLeave;
  if (invalid) {
    throw new Error('InstanceHandle not injected before use!');
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {

  /**
   * Methods for injecting dependencies.
   */
  injection: {

    /**
     * @param {object} InjectedMount
     * @public
     */
    injectMount: EventPluginUtils.injection.injectMount,

    /**
     * @param {object} InjectedInstanceHandle
     * @public
     */
    injectInstanceHandle: function(InjectedInstanceHandle) {
      InstanceHandle = InjectedInstanceHandle;
      if ("production" !== process.env.NODE_ENV) {
        validateInstanceHandle();
      }
    },

    getInstanceHandle: function() {
      if ("production" !== process.env.NODE_ENV) {
        validateInstanceHandle();
      }
      return InstanceHandle;
    },

    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

  },

  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,

  registrationNameModules: EventPluginRegistry.registrationNameModules,

  /**
   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {?function} listener The callback to store.
   */
  putListener: function(id, registrationName, listener) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !listener || typeof listener === 'function',
      'Expected %s listener to be a function, instead got type %s',
      registrationName, typeof listener
    ) : invariant(!listener || typeof listener === 'function'));

    var bankForRegistrationName =
      listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[id] = listener;
  },

  /**
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function(id, registrationName) {
    var bankForRegistrationName = listenerBank[registrationName];
    return bankForRegistrationName && bankForRegistrationName[id];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function(id, registrationName) {
    var bankForRegistrationName = listenerBank[registrationName];
    if (bankForRegistrationName) {
      delete bankForRegistrationName[id];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {string} id ID of the DOM element.
   */
  deleteAllListeners: function(id) {
    for (var registrationName in listenerBank) {
      delete listenerBank[registrationName][id];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0, l = plugins.length; i < l; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(
          topLevelType,
          topLevelTarget,
          topLevelTargetID,
          nativeEvent
        );
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function(events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function() {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);
    ("production" !== process.env.NODE_ENV ? invariant(
      !eventQueue,
      'processEventQueue(): Additional events were enqueued while processing ' +
      'an event queue. Support for this has not yet been implemented.'
    ) : invariant(!eventQueue));
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function() {
    listenerBank = {};
  },

  __getListenerBank: function() {
    return listenerBank;
  }

};

module.exports = EventPluginHub;

}).call(this,require('_process'))
},{"./EventPluginRegistry":20,"./EventPluginUtils":21,"./accumulateInto":99,"./forEachAccumulated":114,"./invariant":128,"_process":2}],20:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginRegistry
 * @typechecks static-only
 */

"use strict";

var invariant = require("./invariant");

/**
 * Injectable ordering of event plugins.
 */
var EventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!EventPluginOrder) {
    // Wait until an `EventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var PluginModule = namesToPlugins[pluginName];
    var pluginIndex = EventPluginOrder.indexOf(pluginName);
    ("production" !== process.env.NODE_ENV ? invariant(
      pluginIndex > -1,
      'EventPluginRegistry: Cannot inject event plugins that do not exist in ' +
      'the plugin ordering, `%s`.',
      pluginName
    ) : invariant(pluginIndex > -1));
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    ("production" !== process.env.NODE_ENV ? invariant(
      PluginModule.extractEvents,
      'EventPluginRegistry: Event plugins must implement an `extractEvents` ' +
      'method, but `%s` does not.',
      pluginName
    ) : invariant(PluginModule.extractEvents));
    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
    var publishedEvents = PluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      ("production" !== process.env.NODE_ENV ? invariant(
        publishEventForPlugin(
          publishedEvents[eventName],
          PluginModule,
          eventName
        ),
        'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',
        eventName,
        pluginName
      ) : invariant(publishEventForPlugin(
        publishedEvents[eventName],
        PluginModule,
        eventName
      )));
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
  ("production" !== process.env.NODE_ENV ? invariant(
    !EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName),
    'EventPluginHub: More than one plugin attempted to publish the same ' +
    'event name, `%s`.',
    eventName
  ) : invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName)));
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(
          phasedRegistrationName,
          PluginModule,
          eventName
        );
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(
      dispatchConfig.registrationName,
      PluginModule,
      eventName
    );
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, PluginModule, eventName) {
  ("production" !== process.env.NODE_ENV ? invariant(
    !EventPluginRegistry.registrationNameModules[registrationName],
    'EventPluginHub: More than one plugin attempted to publish the same ' +
    'registration name, `%s`.',
    registrationName
  ) : invariant(!EventPluginRegistry.registrationNameModules[registrationName]));
  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] =
    PluginModule.eventTypes[eventName].dependencies;
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {

  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function(InjectedEventPluginOrder) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !EventPluginOrder,
      'EventPluginRegistry: Cannot inject event plugin ordering more than ' +
      'once. You are likely trying to load more than one copy of React.'
    ) : invariant(!EventPluginOrder));
    // Clone the ordering so it cannot be dynamically mutated.
    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function(injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var PluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) ||
          namesToPlugins[pluginName] !== PluginModule) {
        ("production" !== process.env.NODE_ENV ? invariant(
          !namesToPlugins[pluginName],
          'EventPluginRegistry: Cannot inject two different event plugins ' +
          'using the same name, `%s`.',
          pluginName
        ) : invariant(!namesToPlugins[pluginName]));
        namesToPlugins[pluginName] = PluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function(event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[
        dispatchConfig.registrationName
      ] || null;
    }
    for (var phase in dispatchConfig.phasedRegistrationNames) {
      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
        continue;
      }
      var PluginModule = EventPluginRegistry.registrationNameModules[
        dispatchConfig.phasedRegistrationNames[phase]
      ];
      if (PluginModule) {
        return PluginModule;
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function() {
    EventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }
  }

};

module.exports = EventPluginRegistry;

}).call(this,require('_process'))
},{"./invariant":128,"_process":2}],21:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginUtils
 */

"use strict";

var EventConstants = require("./EventConstants");

var invariant = require("./invariant");

/**
 * Injected dependencies:
 */

/**
 * - `Mount`: [required] Module that can convert between React dom IDs and
 *   actual node references.
 */
var injection = {
  Mount: null,
  injectMount: function(InjectedMount) {
    injection.Mount = InjectedMount;
    if ("production" !== process.env.NODE_ENV) {
      ("production" !== process.env.NODE_ENV ? invariant(
        InjectedMount && InjectedMount.getNode,
        'EventPluginUtils.injection.injectMount(...): Injected Mount module ' +
        'is missing getNode.'
      ) : invariant(InjectedMount && InjectedMount.getNode));
    }
  }
};

var topLevelTypes = EventConstants.topLevelTypes;

function isEndish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseUp ||
         topLevelType === topLevelTypes.topTouchEnd ||
         topLevelType === topLevelTypes.topTouchCancel;
}

function isMoveish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseMove ||
         topLevelType === topLevelTypes.topTouchMove;
}
function isStartish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseDown ||
         topLevelType === topLevelTypes.topTouchStart;
}


var validateEventDispatches;
if ("production" !== process.env.NODE_ENV) {
  validateEventDispatches = function(event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchIDs = event._dispatchIDs;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var idsIsArr = Array.isArray(dispatchIDs);
    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
    var listenersLen = listenersIsArr ?
      dispatchListeners.length :
      dispatchListeners ? 1 : 0;

    ("production" !== process.env.NODE_ENV ? invariant(
      idsIsArr === listenersIsArr && IDsLen === listenersLen,
      'EventPluginUtils: Invalid `event`.'
    ) : invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen));
  };
}

/**
 * Invokes `cb(event, listener, id)`. Avoids using call if no scope is
 * provided. The `(listener,id)` pair effectively forms the "dispatch" but are
 * kept separate to conserve memory.
 */
function forEachEventDispatch(event, cb) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if ("production" !== process.env.NODE_ENV) {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      cb(event, dispatchListeners[i], dispatchIDs[i]);
    }
  } else if (dispatchListeners) {
    cb(event, dispatchListeners, dispatchIDs);
  }
}

/**
 * Default implementation of PluginModule.executeDispatch().
 * @param {SyntheticEvent} SyntheticEvent to handle
 * @param {function} Application-level callback
 * @param {string} domID DOM id to pass to the callback.
 */
function executeDispatch(event, listener, domID) {
  event.currentTarget = injection.Mount.getNode(domID);
  var returnValue = listener(event, domID);
  event.currentTarget = null;
  return returnValue;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, executeDispatch) {
  forEachEventDispatch(event, executeDispatch);
  event._dispatchListeners = null;
  event._dispatchIDs = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return id of the first dispatch execution who's listener returns true, or
 * null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if ("production" !== process.env.NODE_ENV) {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchIDs[i])) {
        return dispatchIDs[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchIDs)) {
      return dispatchIDs;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchIDs = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if ("production" !== process.env.NODE_ENV) {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchID = event._dispatchIDs;
  ("production" !== process.env.NODE_ENV ? invariant(
    !Array.isArray(dispatchListener),
    'executeDirectDispatch(...): Invalid `event`.'
  ) : invariant(!Array.isArray(dispatchListener)));
  var res = dispatchListener ?
    dispatchListener(event, dispatchID) :
    null;
  event._dispatchListeners = null;
  event._dispatchIDs = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {bool} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatch: executeDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,
  injection: injection,
  useTouchEvents: false
};

module.exports = EventPluginUtils;

}).call(this,require('_process'))
},{"./EventConstants":17,"./invariant":128,"_process":2}],22:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPropagators
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");

var accumulateInto = require("./accumulateInto");
var forEachAccumulated = require("./forEachAccumulated");

var PropagationPhases = EventConstants.PropagationPhases;
var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(id, event, propagationPhase) {
  var registrationName =
    event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(id, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(domID, upwards, event) {
  if ("production" !== process.env.NODE_ENV) {
    if (!domID) {
      throw new Error('Dispatching id must not be null');
    }
  }
  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
  var listener = listenerAtPhase(domID, event, phase);
  if (listener) {
    event._dispatchListeners =
      accumulateInto(event._dispatchListeners, listener);
    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We can not perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(
      event.dispatchMarker,
      accumulateDirectionalDispatches,
      event
    );
  }
}


/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(id, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(id, registrationName);
    if (listener) {
      event._dispatchListeners =
        accumulateInto(event._dispatchListeners, listener);
      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event.dispatchMarker, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(
    fromID,
    toID,
    accumulateDispatches,
    leave,
    enter
  );
}


function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}



/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;

}).call(this,require('_process'))
},{"./EventConstants":17,"./EventPluginHub":19,"./accumulateInto":99,"./forEachAccumulated":114,"_process":2}],23:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ExecutionEnvironment
 */

/*jslint evil: true */

"use strict";

var canUseDOM = !!(
  typeof window !== 'undefined' &&
  window.document &&
  window.document.createElement
);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners:
    canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

},{}],24:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule HTMLDOMPropertyConfig
 */

/*jslint bitwise: true*/

"use strict";

var DOMProperty = require("./DOMProperty");
var ExecutionEnvironment = require("./ExecutionEnvironment");

var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE =
  DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE =
  DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var hasSVG;
if (ExecutionEnvironment.canUseDOM) {
  var implementation = document.implementation;
  hasSVG = (
    implementation &&
    implementation.hasFeature &&
    implementation.hasFeature(
      'http://www.w3.org/TR/SVG11/feature#BasicStructure',
      '1.1'
    )
  );
}


var HTMLDOMPropertyConfig = {
  isCustomAttribute: RegExp.prototype.test.bind(
    /^(data|aria)-[a-z_][a-z\d_.\-]*$/
  ),
  Properties: {
    /**
     * Standard Properties
     */
    accept: null,
    acceptCharset: null,
    accessKey: null,
    action: null,
    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    allowTransparency: MUST_USE_ATTRIBUTE,
    alt: null,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: null,
    // autoFocus is polyfilled/normalized by AutoFocusMixin
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    cellPadding: null,
    cellSpacing: null,
    charSet: MUST_USE_ATTRIBUTE,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    classID: MUST_USE_ATTRIBUTE,
    // To set className on SVG elements, it's necessary to use .setAttribute;
    // this works on HTML elements too in all browsers except IE8. Conveniently,
    // IE8 doesn't support SVG and so we can simply use the attribute in
    // browsers that support SVG and the property in browsers that don't,
    // regardless of whether the element is HTML or SVG.
    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: null,
    content: null,
    contentEditable: null,
    contextMenu: MUST_USE_ATTRIBUTE,
    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    coords: null,
    crossOrigin: null,
    data: null, // For `<object />` acts as `src`.
    dateTime: MUST_USE_ATTRIBUTE,
    defer: HAS_BOOLEAN_VALUE,
    dir: null,
    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: null,
    encType: null,
    form: MUST_USE_ATTRIBUTE,
    formNoValidate: HAS_BOOLEAN_VALUE,
    frameBorder: MUST_USE_ATTRIBUTE,
    height: MUST_USE_ATTRIBUTE,
    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    href: null,
    hrefLang: null,
    htmlFor: null,
    httpEquiv: null,
    icon: null,
    id: MUST_USE_PROPERTY,
    label: null,
    lang: null,
    list: MUST_USE_ATTRIBUTE,
    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    manifest: MUST_USE_ATTRIBUTE,
    max: null,
    maxLength: MUST_USE_ATTRIBUTE,
    media: MUST_USE_ATTRIBUTE,
    mediaGroup: null,
    method: null,
    min: null,
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: null,
    noValidate: HAS_BOOLEAN_VALUE,
    open: null,
    pattern: null,
    placeholder: null,
    poster: null,
    preload: null,
    radioGroup: null,
    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    rel: null,
    required: HAS_BOOLEAN_VALUE,
    role: MUST_USE_ATTRIBUTE,
    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: null,
    sandbox: null,
    scope: null,
    scrolling: null,
    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: null,
    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    sizes: MUST_USE_ATTRIBUTE,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: null,
    src: null,
    srcDoc: MUST_USE_PROPERTY,
    srcSet: MUST_USE_ATTRIBUTE,
    start: HAS_NUMERIC_VALUE,
    step: null,
    style: null,
    tabIndex: null,
    target: null,
    title: null,
    type: null,
    useMap: null,
    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
    width: MUST_USE_ATTRIBUTE,
    wmode: MUST_USE_ATTRIBUTE,

    /**
     * Non-standard Properties
     */
    autoCapitalize: null, // Supported in Mobile Safari for keyboard hints
    autoCorrect: null, // Supported in Mobile Safari for keyboard hints
    itemProp: MUST_USE_ATTRIBUTE, // Microdata: http://schema.org/docs/gs.html
    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE, // Microdata: http://schema.org/docs/gs.html
    itemType: MUST_USE_ATTRIBUTE, // Microdata: http://schema.org/docs/gs.html
    property: null // Supports OG in meta tags
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {
    autoCapitalize: 'autocapitalize',
    autoComplete: 'autocomplete',
    autoCorrect: 'autocorrect',
    autoFocus: 'autofocus',
    autoPlay: 'autoplay',
    encType: 'enctype',
    hrefLang: 'hreflang',
    radioGroup: 'radiogroup',
    spellCheck: 'spellcheck',
    srcDoc: 'srcdoc',
    srcSet: 'srcset'
  }
};

module.exports = HTMLDOMPropertyConfig;

},{"./DOMProperty":12,"./ExecutionEnvironment":23}],25:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule LinkedValueUtils
 * @typechecks static-only
 */

"use strict";

var ReactPropTypes = require("./ReactPropTypes");

var invariant = require("./invariant");

var hasReadOnlyValue = {
  'button': true,
  'checkbox': true,
  'image': true,
  'hidden': true,
  'radio': true,
  'reset': true,
  'submit': true
};

function _assertSingleLink(input) {
  ("production" !== process.env.NODE_ENV ? invariant(
    input.props.checkedLink == null || input.props.valueLink == null,
    'Cannot provide a checkedLink and a valueLink. If you want to use ' +
    'checkedLink, you probably don\'t want to use valueLink and vice versa.'
  ) : invariant(input.props.checkedLink == null || input.props.valueLink == null));
}
function _assertValueLink(input) {
  _assertSingleLink(input);
  ("production" !== process.env.NODE_ENV ? invariant(
    input.props.value == null && input.props.onChange == null,
    'Cannot provide a valueLink and a value or onChange event. If you want ' +
    'to use value or onChange, you probably don\'t want to use valueLink.'
  ) : invariant(input.props.value == null && input.props.onChange == null));
}

function _assertCheckedLink(input) {
  _assertSingleLink(input);
  ("production" !== process.env.NODE_ENV ? invariant(
    input.props.checked == null && input.props.onChange == null,
    'Cannot provide a checkedLink and a checked property or onChange event. ' +
    'If you want to use checked or onChange, you probably don\'t want to ' +
    'use checkedLink'
  ) : invariant(input.props.checked == null && input.props.onChange == null));
}

/**
 * @param {SyntheticEvent} e change event to handle
 */
function _handleLinkedValueChange(e) {
  /*jshint validthis:true */
  this.props.valueLink.requestChange(e.target.value);
}

/**
  * @param {SyntheticEvent} e change event to handle
  */
function _handleLinkedCheckChange(e) {
  /*jshint validthis:true */
  this.props.checkedLink.requestChange(e.target.checked);
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils = {
  Mixin: {
    propTypes: {
      value: function(props, propName, componentName) {
        if (!props[propName] ||
            hasReadOnlyValue[props.type] ||
            props.onChange ||
            props.readOnly ||
            props.disabled) {
          return;
        }
        return new Error(
          'You provided a `value` prop to a form field without an ' +
          '`onChange` handler. This will render a read-only field. If ' +
          'the field should be mutable use `defaultValue`. Otherwise, ' +
          'set either `onChange` or `readOnly`.'
        );
      },
      checked: function(props, propName, componentName) {
        if (!props[propName] ||
            props.onChange ||
            props.readOnly ||
            props.disabled) {
          return;
        }
        return new Error(
          'You provided a `checked` prop to a form field without an ' +
          '`onChange` handler. This will render a read-only field. If ' +
          'the field should be mutable use `defaultChecked`. Otherwise, ' +
          'set either `onChange` or `readOnly`.'
        );
      },
      onChange: ReactPropTypes.func
    }
  },

  /**
   * @param {ReactComponent} input Form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function(input) {
    if (input.props.valueLink) {
      _assertValueLink(input);
      return input.props.valueLink.value;
    }
    return input.props.value;
  },

  /**
   * @param {ReactComponent} input Form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function(input) {
    if (input.props.checkedLink) {
      _assertCheckedLink(input);
      return input.props.checkedLink.value;
    }
    return input.props.checked;
  },

  /**
   * @param {ReactComponent} input Form component
   * @return {function} change callback either from onChange prop or link.
   */
  getOnChange: function(input) {
    if (input.props.valueLink) {
      _assertValueLink(input);
      return _handleLinkedValueChange;
    } else if (input.props.checkedLink) {
      _assertCheckedLink(input);
      return _handleLinkedCheckChange;
    }
    return input.props.onChange;
  }
};

module.exports = LinkedValueUtils;

}).call(this,require('_process'))
},{"./ReactPropTypes":74,"./invariant":128,"_process":2}],26:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule LocalEventTrapMixin
 */

"use strict";

var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");

var accumulateInto = require("./accumulateInto");
var forEachAccumulated = require("./forEachAccumulated");
var invariant = require("./invariant");

function remove(event) {
  event.remove();
}

var LocalEventTrapMixin = {
  trapBubbledEvent:function(topLevelType, handlerBaseName) {
    ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'Must be mounted to trap events') : invariant(this.isMounted()));
    var listener = ReactBrowserEventEmitter.trapBubbledEvent(
      topLevelType,
      handlerBaseName,
      this.getDOMNode()
    );
    this._localEventListeners =
      accumulateInto(this._localEventListeners, listener);
  },

  // trapCapturedEvent would look nearly identical. We don't implement that
  // method because it isn't currently needed.

  componentWillUnmount:function() {
    if (this._localEventListeners) {
      forEachAccumulated(this._localEventListeners, remove);
    }
  }
};

module.exports = LocalEventTrapMixin;

}).call(this,require('_process'))
},{"./ReactBrowserEventEmitter":32,"./accumulateInto":99,"./forEachAccumulated":114,"./invariant":128,"_process":2}],27:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule MobileSafariClickEventPlugin
 * @typechecks static-only
 */

"use strict";

var EventConstants = require("./EventConstants");

var emptyFunction = require("./emptyFunction");

var topLevelTypes = EventConstants.topLevelTypes;

/**
 * Mobile Safari does not fire properly bubble click events on non-interactive
 * elements, which means delegated click listeners do not fire. The workaround
 * for this bug involves attaching an empty click listener on the target node.
 *
 * This particular plugin works around the bug by attaching an empty click
 * listener on `touchstart` (which does fire on every element).
 */
var MobileSafariClickEventPlugin = {

  eventTypes: null,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {
    if (topLevelType === topLevelTypes.topTouchStart) {
      var target = nativeEvent.target;
      if (target && !target.onclick) {
        target.onclick = emptyFunction;
      }
    }
  }

};

module.exports = MobileSafariClickEventPlugin;

},{"./EventConstants":17,"./emptyFunction":109}],28:[function(require,module,exports){
/**
 * Copyright 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Object.assign
 */

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign

function assign(target, sources) {
  if (target == null) {
    throw new TypeError('Object.assign target cannot be null or undefined');
  }

  var to = Object(target);
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
    var nextSource = arguments[nextIndex];
    if (nextSource == null) {
      continue;
    }

    var from = Object(nextSource);

    // We don't currently support accessors nor proxies. Therefore this
    // copy cannot throw. If we ever supported this then we must handle
    // exceptions and side-effects. We don't support symbols so they won't
    // be transferred.

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
  }

  return to;
};

module.exports = assign;

},{}],29:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule PooledClass
 */

"use strict";

var invariant = require("./invariant");

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function(copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function(a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function(a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fiveArgumentPooler = function(a1, a2, a3, a4, a5) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4, a5);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4, a5);
  }
};

var standardReleaser = function(instance) {
  var Klass = this;
  ("production" !== process.env.NODE_ENV ? invariant(
    instance instanceof Klass,
    'Trying to release an instance into a pool of a different type.'
  ) : invariant(instance instanceof Klass));
  if (instance.destructor) {
    instance.destructor();
  }
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances (optional).
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function(CopyConstructor, pooler) {
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fiveArgumentPooler: fiveArgumentPooler
};

module.exports = PooledClass;

}).call(this,require('_process'))
},{"./invariant":128,"_process":2}],30:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule React
 */

"use strict";

var DOMPropertyOperations = require("./DOMPropertyOperations");
var EventPluginUtils = require("./EventPluginUtils");
var ReactChildren = require("./ReactChildren");
var ReactComponent = require("./ReactComponent");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactContext = require("./ReactContext");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactElement = require("./ReactElement");
var ReactElementValidator = require("./ReactElementValidator");
var ReactDOM = require("./ReactDOM");
var ReactDOMComponent = require("./ReactDOMComponent");
var ReactDefaultInjection = require("./ReactDefaultInjection");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactLegacyElement = require("./ReactLegacyElement");
var ReactMount = require("./ReactMount");
var ReactMultiChild = require("./ReactMultiChild");
var ReactPerf = require("./ReactPerf");
var ReactPropTypes = require("./ReactPropTypes");
var ReactServerRendering = require("./ReactServerRendering");
var ReactTextComponent = require("./ReactTextComponent");

var assign = require("./Object.assign");
var deprecated = require("./deprecated");
var onlyChild = require("./onlyChild");

ReactDefaultInjection.inject();

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;

if ("production" !== process.env.NODE_ENV) {
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
}

// TODO: Drop legacy elements once classes no longer export these factories
createElement = ReactLegacyElement.wrapCreateElement(
  createElement
);
createFactory = ReactLegacyElement.wrapCreateFactory(
  createFactory
);

var render = ReactPerf.measure('React', 'render', ReactMount.render);

var React = {
  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    only: onlyChild
  },
  DOM: ReactDOM,
  PropTypes: ReactPropTypes,
  initializeTouchEvents: function(shouldUseTouch) {
    EventPluginUtils.useTouchEvents = shouldUseTouch;
  },
  createClass: ReactCompositeComponent.createClass,
  createElement: createElement,
  createFactory: createFactory,
  constructAndRenderComponent: ReactMount.constructAndRenderComponent,
  constructAndRenderComponentByID: ReactMount.constructAndRenderComponentByID,
  render: render,
  renderToString: ReactServerRendering.renderToString,
  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  isValidClass: ReactLegacyElement.isValidClass,
  isValidElement: ReactElement.isValidElement,
  withContext: ReactContext.withContext,

  // Hook for JSX spread, don't use this for anything else.
  __spread: assign,

  // Deprecations (remove for 0.13)
  renderComponent: deprecated(
    'React',
    'renderComponent',
    'render',
    this,
    render
  ),
  renderComponentToString: deprecated(
    'React',
    'renderComponentToString',
    'renderToString',
    this,
    ReactServerRendering.renderToString
  ),
  renderComponentToStaticMarkup: deprecated(
    'React',
    'renderComponentToStaticMarkup',
    'renderToStaticMarkup',
    this,
    ReactServerRendering.renderToStaticMarkup
  ),
  isValidComponent: deprecated(
    'React',
    'isValidComponent',
    'isValidElement',
    this,
    ReactElement.isValidElement
  )
};

// Inject the runtime into a devtools global hook regardless of browser.
// Allows for debugging when the hook is injected on the page.
if (
  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
    Component: ReactComponent,
    CurrentOwner: ReactCurrentOwner,
    DOMComponent: ReactDOMComponent,
    DOMPropertyOperations: DOMPropertyOperations,
    InstanceHandles: ReactInstanceHandles,
    Mount: ReactMount,
    MultiChild: ReactMultiChild,
    TextComponent: ReactTextComponent
  });
}

if ("production" !== process.env.NODE_ENV) {
  var ExecutionEnvironment = require("./ExecutionEnvironment");
  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

    // If we're in Chrome, look for the devtools marker and provide a download
    // link if not installed.
    if (navigator.userAgent.indexOf('Chrome') > -1) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
        console.debug(
          'Download the React DevTools for a better development experience: ' +
          'http://fb.me/react-devtools'
        );
      }
    }

    var expectedFeatures = [
      // shims
      Array.isArray,
      Array.prototype.every,
      Array.prototype.forEach,
      Array.prototype.indexOf,
      Array.prototype.map,
      Date.now,
      Function.prototype.bind,
      Object.keys,
      String.prototype.split,
      String.prototype.trim,

      // shams
      Object.create,
      Object.freeze
    ];

    for (var i = 0; i < expectedFeatures.length; i++) {
      if (!expectedFeatures[i]) {
        console.error(
          'One or more ES5 shim/shams expected by React are not available: ' +
          'http://fb.me/react-warning-polyfills'
        );
        break;
      }
    }
  }
}

// Version exists only in the open-source version of React, not in Facebook's
// internal version.
React.version = '0.12.1';

module.exports = React;

}).call(this,require('_process'))
},{"./DOMPropertyOperations":13,"./EventPluginUtils":21,"./ExecutionEnvironment":23,"./Object.assign":28,"./ReactChildren":33,"./ReactComponent":34,"./ReactCompositeComponent":36,"./ReactContext":37,"./ReactCurrentOwner":38,"./ReactDOM":39,"./ReactDOMComponent":41,"./ReactDefaultInjection":51,"./ReactElement":54,"./ReactElementValidator":55,"./ReactInstanceHandles":62,"./ReactLegacyElement":63,"./ReactMount":65,"./ReactMultiChild":66,"./ReactPerf":70,"./ReactPropTypes":74,"./ReactServerRendering":78,"./ReactTextComponent":80,"./deprecated":108,"./onlyChild":139,"_process":2}],31:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactBrowserComponentMixin
 */

"use strict";

var ReactEmptyComponent = require("./ReactEmptyComponent");
var ReactMount = require("./ReactMount");

var invariant = require("./invariant");

var ReactBrowserComponentMixin = {
  /**
   * Returns the DOM node rendered by this component.
   *
   * @return {DOMElement} The root node of this component.
   * @final
   * @protected
   */
  getDOMNode: function() {
    ("production" !== process.env.NODE_ENV ? invariant(
      this.isMounted(),
      'getDOMNode(): A component must be mounted to have a DOM node.'
    ) : invariant(this.isMounted()));
    if (ReactEmptyComponent.isNullComponentID(this._rootNodeID)) {
      return null;
    }
    return ReactMount.getNode(this._rootNodeID);
  }
};

module.exports = ReactBrowserComponentMixin;

}).call(this,require('_process'))
},{"./ReactEmptyComponent":56,"./ReactMount":65,"./invariant":128,"_process":2}],32:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactBrowserEventEmitter
 * @typechecks static-only
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");
var EventPluginRegistry = require("./EventPluginRegistry");
var ReactEventEmitterMixin = require("./ReactEventEmitterMixin");
var ViewportMetrics = require("./ViewportMetrics");

var assign = require("./Object.assign");
var isEventSupported = require("./isEventSupported");

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topBlur: 'blur',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topScroll: 'scroll',
  topSelectionChange: 'selectionchange',
  topTextInput: 'textInput',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = "_reactListenersID" + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {

  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function(ReactEventListener) {
      ReactEventListener.setHandleTopLevel(
        ReactBrowserEventEmitter.handleTopLevel
      );
      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function(enabled) {
    if (ReactBrowserEventEmitter.ReactEventListener) {
      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function() {
    return !!(
      ReactBrowserEventEmitter.ReactEventListener &&
      ReactBrowserEventEmitter.ReactEventListener.isEnabled()
    );
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function(registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry.
      registrationNameDependencies[registrationName];

    var topLevelTypes = EventConstants.topLevelTypes;
    for (var i = 0, l = dependencies.length; i < l; i++) {
      var dependency = dependencies[i];
      if (!(
            isListening.hasOwnProperty(dependency) &&
            isListening[dependency]
          )) {
        if (dependency === topLevelTypes.topWheel) {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              topLevelTypes.topWheel,
              'wheel',
              mountAt
            );
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              topLevelTypes.topWheel,
              'mousewheel',
              mountAt
            );
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              topLevelTypes.topWheel,
              'DOMMouseScroll',
              mountAt
            );
          }
        } else if (dependency === topLevelTypes.topScroll) {

          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
              topLevelTypes.topScroll,
              'scroll',
              mountAt
            );
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              topLevelTypes.topScroll,
              'scroll',
              ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE
            );
          }
        } else if (dependency === topLevelTypes.topFocus ||
            dependency === topLevelTypes.topBlur) {

          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
              topLevelTypes.topFocus,
              'focus',
              mountAt
            );
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
              topLevelTypes.topBlur,
              'blur',
              mountAt
            );
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              topLevelTypes.topFocus,
              'focusin',
              mountAt
            );
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              topLevelTypes.topBlur,
              'focusout',
              mountAt
            );
          }

          // to make sure blur and focus event listeners are only attached once
          isListening[topLevelTypes.topBlur] = true;
          isListening[topLevelTypes.topFocus] = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
            dependency,
            topEventMapping[dependency],
            mountAt
          );
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
      topLevelType,
      handlerBaseName,
      handle
    );
  },

  trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
      topLevelType,
      handlerBaseName,
      handle
    );
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function(){
    if (!isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  },

  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,

  registrationNameModules: EventPluginHub.registrationNameModules,

  putListener: EventPluginHub.putListener,

  getListener: EventPluginHub.getListener,

  deleteListener: EventPluginHub.deleteListener,

  deleteAllListeners: EventPluginHub.deleteAllListeners

});

module.exports = ReactBrowserEventEmitter;

},{"./EventConstants":17,"./EventPluginHub":19,"./EventPluginRegistry":20,"./Object.assign":28,"./ReactEventEmitterMixin":58,"./ViewportMetrics":98,"./isEventSupported":129}],33:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactChildren
 */

"use strict";

var PooledClass = require("./PooledClass");

var traverseAllChildren = require("./traverseAllChildren");
var warning = require("./warning");

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var threeArgumentPooler = PooledClass.threeArgumentPooler;

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.forEachFunction = forEachFunction;
  this.forEachContext = forEachContext;
}
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(traverseContext, child, name, i) {
  var forEachBookKeeping = traverseContext;
  forEachBookKeeping.forEachFunction.call(
    forEachBookKeeping.forEachContext, child, i);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc.
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }

  var traverseContext =
    ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, mapFunction, mapContext) {
  this.mapResult = mapResult;
  this.mapFunction = mapFunction;
  this.mapContext = mapContext;
}
PooledClass.addPoolingTo(MapBookKeeping, threeArgumentPooler);

function mapSingleChildIntoContext(traverseContext, child, name, i) {
  var mapBookKeeping = traverseContext;
  var mapResult = mapBookKeeping.mapResult;

  var keyUnique = !mapResult.hasOwnProperty(name);
  ("production" !== process.env.NODE_ENV ? warning(
    keyUnique,
    'ReactChildren.map(...): Encountered two children with the same key, ' +
    '`%s`. Child keys must be unique; when two children share a key, only ' +
    'the first child will be used.',
    name
  ) : null);

  if (keyUnique) {
    var mappedChild =
      mapBookKeeping.mapFunction.call(mapBookKeeping.mapContext, child, i);
    mapResult[name] = mappedChild;
  }
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * TODO: This may likely break any calls to `ReactChildren.map` that were
 * previously relying on the fact that we guarded against null children.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} mapFunction.
 * @param {*} mapContext Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var mapResult = {};
  var traverseContext = MapBookKeeping.getPooled(mapResult, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
  return mapResult;
}

function forEachSingleChildDummy(traverseContext, child, name, i) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  count: countChildren
};

module.exports = ReactChildren;

}).call(this,require('_process'))
},{"./PooledClass":29,"./traverseAllChildren":146,"./warning":147,"_process":2}],34:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponent
 */

"use strict";

var ReactElement = require("./ReactElement");
var ReactOwner = require("./ReactOwner");
var ReactUpdates = require("./ReactUpdates");

var assign = require("./Object.assign");
var invariant = require("./invariant");
var keyMirror = require("./keyMirror");

/**
 * Every React component is in one of these life cycles.
 */
var ComponentLifeCycle = keyMirror({
  /**
   * Mounted components have a DOM node representation and are capable of
   * receiving new props.
   */
  MOUNTED: null,
  /**
   * Unmounted components are inactive and cannot receive new props.
   */
  UNMOUNTED: null
});

var injected = false;

/**
 * Optionally injectable environment dependent cleanup hook. (server vs.
 * browser etc). Example: A browser system caches DOM nodes based on component
 * ID and must remove that cache entry when this instance is unmounted.
 *
 * @private
 */
var unmountIDFromEnvironment = null;

/**
 * The "image" of a component tree, is the platform specific (typically
 * serialized) data that represents a tree of lower level UI building blocks.
 * On the web, this "image" is HTML markup which describes a construction of
 * low level `div` and `span` nodes. Other platforms may have different
 * encoding of this "image". This must be injected.
 *
 * @private
 */
var mountImageIntoNode = null;

/**
 * Components are the basic units of composition in React.
 *
 * Every component accepts a set of keyed input parameters known as "props" that
 * are initialized by the constructor. Once a component is mounted, the props
 * can be mutated using `setProps` or `replaceProps`.
 *
 * Every component is capable of the following operations:
 *
 *   `mountComponent`
 *     Initializes the component, renders markup, and registers event listeners.
 *
 *   `receiveComponent`
 *     Updates the rendered DOM nodes to match the given component.
 *
 *   `unmountComponent`
 *     Releases any resources allocated by this component.
 *
 * Components can also be "owned" by other components. Being owned by another
 * component means being constructed by that component. This is different from
 * being the child of a component, which means having a DOM representation that
 * is a child of the DOM representation of that component.
 *
 * @class ReactComponent
 */
var ReactComponent = {

  injection: {
    injectEnvironment: function(ReactComponentEnvironment) {
      ("production" !== process.env.NODE_ENV ? invariant(
        !injected,
        'ReactComponent: injectEnvironment() can only be called once.'
      ) : invariant(!injected));
      mountImageIntoNode = ReactComponentEnvironment.mountImageIntoNode;
      unmountIDFromEnvironment =
        ReactComponentEnvironment.unmountIDFromEnvironment;
      ReactComponent.BackendIDOperations =
        ReactComponentEnvironment.BackendIDOperations;
      injected = true;
    }
  },

  /**
   * @internal
   */
  LifeCycle: ComponentLifeCycle,

  /**
   * Injected module that provides ability to mutate individual properties.
   * Injected into the base class because many different subclasses need access
   * to this.
   *
   * @internal
   */
  BackendIDOperations: null,

  /**
   * Base functionality for every ReactComponent constructor. Mixed into the
   * `ReactComponent` prototype, but exposed statically for easy access.
   *
   * @lends {ReactComponent.prototype}
   */
  Mixin: {

    /**
     * Checks whether or not this component is mounted.
     *
     * @return {boolean} True if mounted, false otherwise.
     * @final
     * @protected
     */
    isMounted: function() {
      return this._lifeCycleState === ComponentLifeCycle.MOUNTED;
    },

    /**
     * Sets a subset of the props.
     *
     * @param {object} partialProps Subset of the next props.
     * @param {?function} callback Called after props are updated.
     * @final
     * @public
     */
    setProps: function(partialProps, callback) {
      // Merge with the pending element if it exists, otherwise with existing
      // element props.
      var element = this._pendingElement || this._currentElement;
      this.replaceProps(
        assign({}, element.props, partialProps),
        callback
      );
    },

    /**
     * Replaces all of the props.
     *
     * @param {object} props New props.
     * @param {?function} callback Called after props are updated.
     * @final
     * @public
     */
    replaceProps: function(props, callback) {
      ("production" !== process.env.NODE_ENV ? invariant(
        this.isMounted(),
        'replaceProps(...): Can only update a mounted component.'
      ) : invariant(this.isMounted()));
      ("production" !== process.env.NODE_ENV ? invariant(
        this._mountDepth === 0,
        'replaceProps(...): You called `setProps` or `replaceProps` on a ' +
        'component with a parent. This is an anti-pattern since props will ' +
        'get reactively updated when rendered. Instead, change the owner\'s ' +
        '`render` method to pass the correct value as props to the component ' +
        'where it is created.'
      ) : invariant(this._mountDepth === 0));
      // This is a deoptimized path. We optimize for always having a element.
      // This creates an extra internal element.
      this._pendingElement = ReactElement.cloneAndReplaceProps(
        this._pendingElement || this._currentElement,
        props
      );
      ReactUpdates.enqueueUpdate(this, callback);
    },

    /**
     * Schedule a partial update to the props. Only used for internal testing.
     *
     * @param {object} partialProps Subset of the next props.
     * @param {?function} callback Called after props are updated.
     * @final
     * @internal
     */
    _setPropsInternal: function(partialProps, callback) {
      // This is a deoptimized path. We optimize for always having a element.
      // This creates an extra internal element.
      var element = this._pendingElement || this._currentElement;
      this._pendingElement = ReactElement.cloneAndReplaceProps(
        element,
        assign({}, element.props, partialProps)
      );
      ReactUpdates.enqueueUpdate(this, callback);
    },

    /**
     * Base constructor for all React components.
     *
     * Subclasses that override this method should make sure to invoke
     * `ReactComponent.Mixin.construct.call(this, ...)`.
     *
     * @param {ReactElement} element
     * @internal
     */
    construct: function(element) {
      // This is the public exposed props object after it has been processed
      // with default props. The element's props represents the true internal
      // state of the props.
      this.props = element.props;
      // Record the component responsible for creating this component.
      // This is accessible through the element but we maintain an extra
      // field for compatibility with devtools and as a way to make an
      // incremental update. TODO: Consider deprecating this field.
      this._owner = element._owner;

      // All components start unmounted.
      this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;

      // See ReactUpdates.
      this._pendingCallbacks = null;

      // We keep the old element and a reference to the pending element
      // to track updates.
      this._currentElement = element;
      this._pendingElement = null;
    },

    /**
     * Initializes the component, renders markup, and registers event listeners.
     *
     * NOTE: This does not insert any nodes into the DOM.
     *
     * Subclasses that override this method should make sure to invoke
     * `ReactComponent.Mixin.mountComponent.call(this, ...)`.
     *
     * @param {string} rootID DOM ID of the root node.
     * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
     * @param {number} mountDepth number of components in the owner hierarchy.
     * @return {?string} Rendered markup to be inserted into the DOM.
     * @internal
     */
    mountComponent: function(rootID, transaction, mountDepth) {
      ("production" !== process.env.NODE_ENV ? invariant(
        !this.isMounted(),
        'mountComponent(%s, ...): Can only mount an unmounted component. ' +
        'Make sure to avoid storing components between renders or reusing a ' +
        'single component instance in multiple places.',
        rootID
      ) : invariant(!this.isMounted()));
      var ref = this._currentElement.ref;
      if (ref != null) {
        var owner = this._currentElement._owner;
        ReactOwner.addComponentAsRefTo(this, ref, owner);
      }
      this._rootNodeID = rootID;
      this._lifeCycleState = ComponentLifeCycle.MOUNTED;
      this._mountDepth = mountDepth;
      // Effectively: return '';
    },

    /**
     * Releases any resources allocated by `mountComponent`.
     *
     * NOTE: This does not remove any nodes from the DOM.
     *
     * Subclasses that override this method should make sure to invoke
     * `ReactComponent.Mixin.unmountComponent.call(this)`.
     *
     * @internal
     */
    unmountComponent: function() {
      ("production" !== process.env.NODE_ENV ? invariant(
        this.isMounted(),
        'unmountComponent(): Can only unmount a mounted component.'
      ) : invariant(this.isMounted()));
      var ref = this._currentElement.ref;
      if (ref != null) {
        ReactOwner.removeComponentAsRefFrom(this, ref, this._owner);
      }
      unmountIDFromEnvironment(this._rootNodeID);
      this._rootNodeID = null;
      this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;
    },

    /**
     * Given a new instance of this component, updates the rendered DOM nodes
     * as if that instance was rendered instead.
     *
     * Subclasses that override this method should make sure to invoke
     * `ReactComponent.Mixin.receiveComponent.call(this, ...)`.
     *
     * @param {object} nextComponent Next set of properties.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    receiveComponent: function(nextElement, transaction) {
      ("production" !== process.env.NODE_ENV ? invariant(
        this.isMounted(),
        'receiveComponent(...): Can only update a mounted component.'
      ) : invariant(this.isMounted()));
      this._pendingElement = nextElement;
      this.performUpdateIfNecessary(transaction);
    },

    /**
     * If `_pendingElement` is set, update the component.
     *
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    performUpdateIfNecessary: function(transaction) {
      if (this._pendingElement == null) {
        return;
      }
      var prevElement = this._currentElement;
      var nextElement = this._pendingElement;
      this._currentElement = nextElement;
      this.props = nextElement.props;
      this._owner = nextElement._owner;
      this._pendingElement = null;
      this.updateComponent(transaction, prevElement);
    },

    /**
     * Updates the component's currently mounted representation.
     *
     * @param {ReactReconcileTransaction} transaction
     * @param {object} prevElement
     * @internal
     */
    updateComponent: function(transaction, prevElement) {
      var nextElement = this._currentElement;

      // If either the owner or a `ref` has changed, make sure the newest owner
      // has stored a reference to `this`, and the previous owner (if different)
      // has forgotten the reference to `this`. We use the element instead
      // of the public this.props because the post processing cannot determine
      // a ref. The ref conceptually lives on the element.

      // TODO: Should this even be possible? The owner cannot change because
      // it's forbidden by shouldUpdateReactComponent. The ref can change
      // if you swap the keys of but not the refs. Reconsider where this check
      // is made. It probably belongs where the key checking and
      // instantiateReactComponent is done.

      if (nextElement._owner !== prevElement._owner ||
          nextElement.ref !== prevElement.ref) {
        if (prevElement.ref != null) {
          ReactOwner.removeComponentAsRefFrom(
            this, prevElement.ref, prevElement._owner
          );
        }
        // Correct, even if the owner is the same, and only the ref has changed.
        if (nextElement.ref != null) {
          ReactOwner.addComponentAsRefTo(
            this,
            nextElement.ref,
            nextElement._owner
          );
        }
      }
    },

    /**
     * Mounts this component and inserts it into the DOM.
     *
     * @param {string} rootID DOM ID of the root node.
     * @param {DOMElement} container DOM element to mount into.
     * @param {boolean} shouldReuseMarkup If true, do not insert markup
     * @final
     * @internal
     * @see {ReactMount.render}
     */
    mountComponentIntoNode: function(rootID, container, shouldReuseMarkup) {
      var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
      transaction.perform(
        this._mountComponentIntoNode,
        this,
        rootID,
        container,
        transaction,
        shouldReuseMarkup
      );
      ReactUpdates.ReactReconcileTransaction.release(transaction);
    },

    /**
     * @param {string} rootID DOM ID of the root node.
     * @param {DOMElement} container DOM element to mount into.
     * @param {ReactReconcileTransaction} transaction
     * @param {boolean} shouldReuseMarkup If true, do not insert markup
     * @final
     * @private
     */
    _mountComponentIntoNode: function(
        rootID,
        container,
        transaction,
        shouldReuseMarkup) {
      var markup = this.mountComponent(rootID, transaction, 0);
      mountImageIntoNode(markup, container, shouldReuseMarkup);
    },

    /**
     * Checks if this component is owned by the supplied `owner` component.
     *
     * @param {ReactComponent} owner Component to check.
     * @return {boolean} True if `owners` owns this component.
     * @final
     * @internal
     */
    isOwnedBy: function(owner) {
      return this._owner === owner;
    },

    /**
     * Gets another component, that shares the same owner as this one, by ref.
     *
     * @param {string} ref of a sibling Component.
     * @return {?ReactComponent} the actual sibling Component.
     * @final
     * @internal
     */
    getSiblingByRef: function(ref) {
      var owner = this._owner;
      if (!owner || !owner.refs) {
        return null;
      }
      return owner.refs[ref];
    }
  }
};

module.exports = ReactComponent;

}).call(this,require('_process'))
},{"./Object.assign":28,"./ReactElement":54,"./ReactOwner":69,"./ReactUpdates":81,"./invariant":128,"./keyMirror":134,"_process":2}],35:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentBrowserEnvironment
 */

/*jslint evil: true */

"use strict";

var ReactDOMIDOperations = require("./ReactDOMIDOperations");
var ReactMarkupChecksum = require("./ReactMarkupChecksum");
var ReactMount = require("./ReactMount");
var ReactPerf = require("./ReactPerf");
var ReactReconcileTransaction = require("./ReactReconcileTransaction");

var getReactRootElementInContainer = require("./getReactRootElementInContainer");
var invariant = require("./invariant");
var setInnerHTML = require("./setInnerHTML");


var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;


/**
 * Abstracts away all functionality of `ReactComponent` requires knowledge of
 * the browser context.
 */
var ReactComponentBrowserEnvironment = {
  ReactReconcileTransaction: ReactReconcileTransaction,

  BackendIDOperations: ReactDOMIDOperations,

  /**
   * If a particular environment requires that some resources be cleaned up,
   * specify this in the injected Mixin. In the DOM, we would likely want to
   * purge any cached node ID lookups.
   *
   * @private
   */
  unmountIDFromEnvironment: function(rootNodeID) {
    ReactMount.purgeID(rootNodeID);
  },

  /**
   * @param {string} markup Markup string to place into the DOM Element.
   * @param {DOMElement} container DOM Element to insert markup into.
   * @param {boolean} shouldReuseMarkup Should reuse the existing markup in the
   * container if possible.
   */
  mountImageIntoNode: ReactPerf.measure(
    'ReactComponentBrowserEnvironment',
    'mountImageIntoNode',
    function(markup, container, shouldReuseMarkup) {
      ("production" !== process.env.NODE_ENV ? invariant(
        container && (
          container.nodeType === ELEMENT_NODE_TYPE ||
            container.nodeType === DOC_NODE_TYPE
        ),
        'mountComponentIntoNode(...): Target container is not valid.'
      ) : invariant(container && (
        container.nodeType === ELEMENT_NODE_TYPE ||
          container.nodeType === DOC_NODE_TYPE
      )));

      if (shouldReuseMarkup) {
        if (ReactMarkupChecksum.canReuseMarkup(
          markup,
          getReactRootElementInContainer(container))) {
          return;
        } else {
          ("production" !== process.env.NODE_ENV ? invariant(
            container.nodeType !== DOC_NODE_TYPE,
            'You\'re trying to render a component to the document using ' +
            'server rendering but the checksum was invalid. This usually ' +
            'means you rendered a different component type or props on ' +
            'the client from the one on the server, or your render() ' +
            'methods are impure. React cannot handle this case due to ' +
            'cross-browser quirks by rendering at the document root. You ' +
            'should look for environment dependent code in your components ' +
            'and ensure the props are the same client and server side.'
          ) : invariant(container.nodeType !== DOC_NODE_TYPE));

          if ("production" !== process.env.NODE_ENV) {
            console.warn(
              'React attempted to use reuse markup in a container but the ' +
              'checksum was invalid. This generally means that you are ' +
              'using server rendering and the markup generated on the ' +
              'server was not what the client was expecting. React injected ' +
              'new markup to compensate which works but you have lost many ' +
              'of the benefits of server rendering. Instead, figure out ' +
              'why the markup being generated is different on the client ' +
              'or server.'
            );
          }
        }
      }

      ("production" !== process.env.NODE_ENV ? invariant(
        container.nodeType !== DOC_NODE_TYPE,
        'You\'re trying to render a component to the document but ' +
          'you didn\'t use server rendering. We can\'t do this ' +
          'without using server rendering due to cross-browser quirks. ' +
          'See renderComponentToString() for server rendering.'
      ) : invariant(container.nodeType !== DOC_NODE_TYPE));

      setInnerHTML(container, markup);
    }
  )
};

module.exports = ReactComponentBrowserEnvironment;

}).call(this,require('_process'))
},{"./ReactDOMIDOperations":43,"./ReactMarkupChecksum":64,"./ReactMount":65,"./ReactPerf":70,"./ReactReconcileTransaction":76,"./getReactRootElementInContainer":122,"./invariant":128,"./setInnerHTML":142,"_process":2}],36:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactCompositeComponent
 */

"use strict";

var ReactComponent = require("./ReactComponent");
var ReactContext = require("./ReactContext");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactElement = require("./ReactElement");
var ReactElementValidator = require("./ReactElementValidator");
var ReactEmptyComponent = require("./ReactEmptyComponent");
var ReactErrorUtils = require("./ReactErrorUtils");
var ReactLegacyElement = require("./ReactLegacyElement");
var ReactOwner = require("./ReactOwner");
var ReactPerf = require("./ReactPerf");
var ReactPropTransferer = require("./ReactPropTransferer");
var ReactPropTypeLocations = require("./ReactPropTypeLocations");
var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");
var ReactUpdates = require("./ReactUpdates");

var assign = require("./Object.assign");
var instantiateReactComponent = require("./instantiateReactComponent");
var invariant = require("./invariant");
var keyMirror = require("./keyMirror");
var keyOf = require("./keyOf");
var monitorCodeUse = require("./monitorCodeUse");
var mapObject = require("./mapObject");
var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
var warning = require("./warning");

var MIXINS_KEY = keyOf({mixins: null});

/**
 * Policies that describe methods in `ReactCompositeComponentInterface`.
 */
var SpecPolicy = keyMirror({
  /**
   * These methods may be defined only once by the class specification or mixin.
   */
  DEFINE_ONCE: null,
  /**
   * These methods may be defined by both the class specification and mixins.
   * Subsequent definitions will be chained. These methods must return void.
   */
  DEFINE_MANY: null,
  /**
   * These methods are overriding the base ReactCompositeComponent class.
   */
  OVERRIDE_BASE: null,
  /**
   * These methods are similar to DEFINE_MANY, except we assume they return
   * objects. We try to merge the keys of the return values of all the mixed in
   * functions. If there is a key conflict we throw.
   */
  DEFINE_MANY_MERGED: null
});


var injectedMixins = [];

/**
 * Composite components are higher-level components that compose other composite
 * or native components.
 *
 * To create a new type of `ReactCompositeComponent`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactCompositeComponentInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will available on the prototype.
 *
 * @interface ReactCompositeComponentInterface
 * @internal
 */
var ReactCompositeComponentInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: SpecPolicy.DEFINE_MANY,

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: SpecPolicy.DEFINE_MANY,

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * @return {object}
   * @optional
   */
  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @nosideeffects
   * @required
   */
  render: SpecPolicy.DEFINE_ONCE,



  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: SpecPolicy.DEFINE_MANY,



  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: SpecPolicy.OVERRIDE_BASE

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function(Constructor, displayName) {
    Constructor.displayName = displayName;
  },
  mixins: function(Constructor, mixins) {
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: function(Constructor, childContextTypes) {
    validateTypeDef(
      Constructor,
      childContextTypes,
      ReactPropTypeLocations.childContext
    );
    Constructor.childContextTypes = assign(
      {},
      Constructor.childContextTypes,
      childContextTypes
    );
  },
  contextTypes: function(Constructor, contextTypes) {
    validateTypeDef(
      Constructor,
      contextTypes,
      ReactPropTypeLocations.context
    );
    Constructor.contextTypes = assign(
      {},
      Constructor.contextTypes,
      contextTypes
    );
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function(Constructor, getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(
        Constructor.getDefaultProps,
        getDefaultProps
      );
    } else {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: function(Constructor, propTypes) {
    validateTypeDef(
      Constructor,
      propTypes,
      ReactPropTypeLocations.prop
    );
    Constructor.propTypes = assign(
      {},
      Constructor.propTypes,
      propTypes
    );
  },
  statics: function(Constructor, statics) {
    mixStaticSpecIntoComponent(Constructor, statics);
  }
};

function getDeclarationErrorAddendum(component) {
  var owner = component._owner || null;
  if (owner && owner.constructor && owner.constructor.displayName) {
    return ' Check the render method of `' + owner.constructor.displayName +
      '`.';
  }
  return '';
}

function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      ("production" !== process.env.NODE_ENV ? invariant(
        typeof typeDef[propName] == 'function',
        '%s: %s type `%s` is invalid; it must be a function, usually from ' +
        'React.PropTypes.',
        Constructor.displayName || 'ReactCompositeComponent',
        ReactPropTypeLocationNames[location],
        propName
      ) : invariant(typeof typeDef[propName] == 'function'));
    }
  }
}

function validateMethodOverride(proto, name) {
  var specPolicy = ReactCompositeComponentInterface.hasOwnProperty(name) ?
    ReactCompositeComponentInterface[name] :
    null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactCompositeComponentMixin.hasOwnProperty(name)) {
    ("production" !== process.env.NODE_ENV ? invariant(
      specPolicy === SpecPolicy.OVERRIDE_BASE,
      'ReactCompositeComponentInterface: You are attempting to override ' +
      '`%s` from your class specification. Ensure that your method names ' +
      'do not overlap with React methods.',
      name
    ) : invariant(specPolicy === SpecPolicy.OVERRIDE_BASE));
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (proto.hasOwnProperty(name)) {
    ("production" !== process.env.NODE_ENV ? invariant(
      specPolicy === SpecPolicy.DEFINE_MANY ||
      specPolicy === SpecPolicy.DEFINE_MANY_MERGED,
      'ReactCompositeComponentInterface: You are attempting to define ' +
      '`%s` on your component more than once. This conflict may be due ' +
      'to a mixin.',
      name
    ) : invariant(specPolicy === SpecPolicy.DEFINE_MANY ||
    specPolicy === SpecPolicy.DEFINE_MANY_MERGED));
  }
}

function validateLifeCycleOnReplaceState(instance) {
  var compositeLifeCycleState = instance._compositeLifeCycleState;
  ("production" !== process.env.NODE_ENV ? invariant(
    instance.isMounted() ||
      compositeLifeCycleState === CompositeLifeCycle.MOUNTING,
    'replaceState(...): Can only update a mounted or mounting component.'
  ) : invariant(instance.isMounted() ||
    compositeLifeCycleState === CompositeLifeCycle.MOUNTING));
  ("production" !== process.env.NODE_ENV ? invariant(
    ReactCurrentOwner.current == null,
    'replaceState(...): Cannot update during an existing state transition ' +
    '(such as within `render`). Render methods should be a pure function ' +
    'of props and state.'
  ) : invariant(ReactCurrentOwner.current == null));
  ("production" !== process.env.NODE_ENV ? invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING,
    'replaceState(...): Cannot update while unmounting component. This ' +
    'usually means you called setState() on an unmounted component.'
  ) : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING));
}

/**
 * Mixin helper which handles policy validation and reserved
 * specification keys when building `ReactCompositeComponent` classses.
 */
function mixSpecIntoComponent(Constructor, spec) {
  if (!spec) {
    return;
  }

  ("production" !== process.env.NODE_ENV ? invariant(
    !ReactLegacyElement.isValidFactory(spec),
    'ReactCompositeComponent: You\'re attempting to ' +
    'use a component class as a mixin. Instead, just use a regular object.'
  ) : invariant(!ReactLegacyElement.isValidFactory(spec)));
  ("production" !== process.env.NODE_ENV ? invariant(
    !ReactElement.isValidElement(spec),
    'ReactCompositeComponent: You\'re attempting to ' +
    'use a component as a mixin. Instead, just use a regular object.'
  ) : invariant(!ReactElement.isValidElement(spec)));

  var proto = Constructor.prototype;

  // By handling mixins before any other properties, we ensure the same
  // chaining order is applied to methods with DEFINE_MANY policy, whether
  // mixins are listed before or after these methods in the spec.
  if (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }

  for (var name in spec) {
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    if (name === MIXINS_KEY) {
      // We have already handled mixins in a special case above
      continue;
    }

    var property = spec[name];
    validateMethodOverride(proto, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactCompositeComponent methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isCompositeComponentMethod =
        ReactCompositeComponentInterface.hasOwnProperty(name);
      var isAlreadyDefined = proto.hasOwnProperty(name);
      var markedDontBind = property && property.__reactDontBind;
      var isFunction = typeof property === 'function';
      var shouldAutoBind =
        isFunction &&
        !isCompositeComponentMethod &&
        !isAlreadyDefined &&
        !markedDontBind;

      if (shouldAutoBind) {
        if (!proto.__reactAutoBindMap) {
          proto.__reactAutoBindMap = {};
        }
        proto.__reactAutoBindMap[name] = property;
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactCompositeComponentInterface[name];

          // These cases should already be caught by validateMethodOverride
          ("production" !== process.env.NODE_ENV ? invariant(
            isCompositeComponentMethod && (
              specPolicy === SpecPolicy.DEFINE_MANY_MERGED ||
              specPolicy === SpecPolicy.DEFINE_MANY
            ),
            'ReactCompositeComponent: Unexpected spec policy %s for key %s ' +
            'when mixing in component specs.',
            specPolicy,
            name
          ) : invariant(isCompositeComponentMethod && (
            specPolicy === SpecPolicy.DEFINE_MANY_MERGED ||
            specPolicy === SpecPolicy.DEFINE_MANY
          )));

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          if ("production" !== process.env.NODE_ENV) {
            // Add verbose displayName to the function, which helps when looking
            // at profiling tools.
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isReserved = name in RESERVED_SPEC_KEYS;
    ("production" !== process.env.NODE_ENV ? invariant(
      !isReserved,
      'ReactCompositeComponent: You are attempting to define a reserved ' +
      'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' +
      'as an instance property instead; it will still be accessible on the ' +
      'constructor.',
      name
    ) : invariant(!isReserved));

    var isInherited = name in Constructor;
    ("production" !== process.env.NODE_ENV ? invariant(
      !isInherited,
      'ReactCompositeComponent: You are attempting to define ' +
      '`%s` on your component more than once. This conflict may be ' +
      'due to a mixin.',
      name
    ) : invariant(!isInherited));
    Constructor[name] = property;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeObjectsWithNoDuplicateKeys(one, two) {
  ("production" !== process.env.NODE_ENV ? invariant(
    one && two && typeof one === 'object' && typeof two === 'object',
    'mergeObjectsWithNoDuplicateKeys(): Cannot merge non-objects'
  ) : invariant(one && two && typeof one === 'object' && typeof two === 'object'));

  mapObject(two, function(value, key) {
    ("production" !== process.env.NODE_ENV ? invariant(
      one[key] === undefined,
      'mergeObjectsWithNoDuplicateKeys(): ' +
      'Tried to merge two objects with the same key: `%s`. This conflict ' +
      'may be due to a mixin; in particular, this may be caused by two ' +
      'getInitialState() or getDefaultProps() methods returning objects ' +
      'with clashing keys.',
      key
    ) : invariant(one[key] === undefined));
    one[key] = value;
  });
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    return mergeObjectsWithNoDuplicateKeys(a, b);
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * `ReactCompositeComponent` maintains an auxiliary life cycle state in
 * `this._compositeLifeCycleState` (which can be null).
 *
 * This is different from the life cycle state maintained by `ReactComponent` in
 * `this._lifeCycleState`. The following diagram shows how the states overlap in
 * time. There are times when the CompositeLifeCycle is null - at those times it
 * is only meaningful to look at ComponentLifeCycle alone.
 *
 * Top Row: ReactComponent.ComponentLifeCycle
 * Low Row: ReactComponent.CompositeLifeCycle
 *
 * +-------+---------------------------------+--------+
 * |  UN   |             MOUNTED             |   UN   |
 * |MOUNTED|                                 | MOUNTED|
 * +-------+---------------------------------+--------+
 * |       ^--------+   +-------+   +--------^        |
 * |       |        |   |       |   |        |        |
 * |    0--|MOUNTING|-0-|RECEIVE|-0-|   UN   |--->0   |
 * |       |        |   |PROPS  |   |MOUNTING|        |
 * |       |        |   |       |   |        |        |
 * |       |        |   |       |   |        |        |
 * |       +--------+   +-------+   +--------+        |
 * |       |                                 |        |
 * +-------+---------------------------------+--------+
 */
var CompositeLifeCycle = keyMirror({
  /**
   * Components in the process of being mounted respond to state changes
   * differently.
   */
  MOUNTING: null,
  /**
   * Components in the process of being unmounted are guarded against state
   * changes.
   */
  UNMOUNTING: null,
  /**
   * Components that are mounted and receiving new props respond to state
   * changes differently.
   */
  RECEIVING_PROPS: null
});

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponentMixin = {

  /**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
  construct: function(element) {
    // Children can be either an array or more than one argument
    ReactComponent.Mixin.construct.apply(this, arguments);
    ReactOwner.Mixin.construct.apply(this, arguments);

    this.state = null;
    this._pendingState = null;

    // This is the public post-processed context. The real context and pending
    // context lives on the element.
    this.context = null;

    this._compositeLifeCycleState = null;
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function() {
    return ReactComponent.Mixin.isMounted.call(this) &&
      this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING;
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {number} mountDepth number of components in the owner hierarchy
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: ReactPerf.measure(
    'ReactCompositeComponent',
    'mountComponent',
    function(rootID, transaction, mountDepth) {
      ReactComponent.Mixin.mountComponent.call(
        this,
        rootID,
        transaction,
        mountDepth
      );
      this._compositeLifeCycleState = CompositeLifeCycle.MOUNTING;

      if (this.__reactAutoBindMap) {
        this._bindAutoBindMethods();
      }

      this.context = this._processContext(this._currentElement._context);
      this.props = this._processProps(this.props);

      this.state = this.getInitialState ? this.getInitialState() : null;
      ("production" !== process.env.NODE_ENV ? invariant(
        typeof this.state === 'object' && !Array.isArray(this.state),
        '%s.getInitialState(): must return an object or null',
        this.constructor.displayName || 'ReactCompositeComponent'
      ) : invariant(typeof this.state === 'object' && !Array.isArray(this.state)));

      this._pendingState = null;
      this._pendingForceUpdate = false;

      if (this.componentWillMount) {
        this.componentWillMount();
        // When mounting, calls to `setState` by `componentWillMount` will set
        // `this._pendingState` without triggering a re-render.
        if (this._pendingState) {
          this.state = this._pendingState;
          this._pendingState = null;
        }
      }

      this._renderedComponent = instantiateReactComponent(
        this._renderValidatedComponent(),
        this._currentElement.type // The wrapping type
      );

      // Done with mounting, `setState` will now trigger UI changes.
      this._compositeLifeCycleState = null;
      var markup = this._renderedComponent.mountComponent(
        rootID,
        transaction,
        mountDepth + 1
      );
      if (this.componentDidMount) {
        transaction.getReactMountReady().enqueue(this.componentDidMount, this);
      }
      return markup;
    }
  ),

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function() {
    this._compositeLifeCycleState = CompositeLifeCycle.UNMOUNTING;
    if (this.componentWillUnmount) {
      this.componentWillUnmount();
    }
    this._compositeLifeCycleState = null;

    this._renderedComponent.unmountComponent();
    this._renderedComponent = null;

    ReactComponent.Mixin.unmountComponent.call(this);

    // Some existing components rely on this.props even after they've been
    // destroyed (in event handlers).
    // TODO: this.props = null;
    // TODO: this.state = null;
  },

  /**
   * Sets a subset of the state. Always use this or `replaceState` to mutate
   * state. You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * There is no guarantee that calls to `setState` will run synchronously,
   * as they may eventually be batched together.  You can provide an optional
   * callback that will be executed when the call to setState is actually
   * completed.
   *
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after state is updated.
   * @final
   * @protected
   */
  setState: function(partialState, callback) {
    ("production" !== process.env.NODE_ENV ? invariant(
      typeof partialState === 'object' || partialState == null,
      'setState(...): takes an object of state variables to update.'
    ) : invariant(typeof partialState === 'object' || partialState == null));
    if ("production" !== process.env.NODE_ENV){
      ("production" !== process.env.NODE_ENV ? warning(
        partialState != null,
        'setState(...): You passed an undefined or null state object; ' +
        'instead, use forceUpdate().'
      ) : null);
    }
    // Merge with `_pendingState` if it exists, otherwise with existing state.
    this.replaceState(
      assign({}, this._pendingState || this.state, partialState),
      callback
    );
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {object} completeState Next state.
   * @param {?function} callback Called after state is updated.
   * @final
   * @protected
   */
  replaceState: function(completeState, callback) {
    validateLifeCycleOnReplaceState(this);
    this._pendingState = completeState;
    if (this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING) {
      // If we're in a componentWillMount handler, don't enqueue a rerender
      // because ReactUpdates assumes we're in a browser context (which is wrong
      // for server rendering) and we're about to do a render anyway.
      // TODO: The callback here is ignored when setState is called from
      // componentWillMount. Either fix it or disallow doing so completely in
      // favor of getInitialState.
      ReactUpdates.enqueueUpdate(this, callback);
    }
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function(context) {
    var maskedContext = null;
    var contextTypes = this.constructor.contextTypes;
    if (contextTypes) {
      maskedContext = {};
      for (var contextName in contextTypes) {
        maskedContext[contextName] = context[contextName];
      }
      if ("production" !== process.env.NODE_ENV) {
        this._checkPropTypes(
          contextTypes,
          maskedContext,
          ReactPropTypeLocations.context
        );
      }
    }
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function(currentContext) {
    var childContext = this.getChildContext && this.getChildContext();
    var displayName = this.constructor.displayName || 'ReactCompositeComponent';
    if (childContext) {
      ("production" !== process.env.NODE_ENV ? invariant(
        typeof this.constructor.childContextTypes === 'object',
        '%s.getChildContext(): childContextTypes must be defined in order to ' +
        'use getChildContext().',
        displayName
      ) : invariant(typeof this.constructor.childContextTypes === 'object'));
      if ("production" !== process.env.NODE_ENV) {
        this._checkPropTypes(
          this.constructor.childContextTypes,
          childContext,
          ReactPropTypeLocations.childContext
        );
      }
      for (var name in childContext) {
        ("production" !== process.env.NODE_ENV ? invariant(
          name in this.constructor.childContextTypes,
          '%s.getChildContext(): key "%s" is not defined in childContextTypes.',
          displayName,
          name
        ) : invariant(name in this.constructor.childContextTypes));
      }
      return assign({}, currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Processes props by setting default values for unspecified props and
   * asserting that the props are valid. Does not mutate its argument; returns
   * a new props object with defaults merged in.
   *
   * @param {object} newProps
   * @return {object}
   * @private
   */
  _processProps: function(newProps) {
    if ("production" !== process.env.NODE_ENV) {
      var propTypes = this.constructor.propTypes;
      if (propTypes) {
        this._checkPropTypes(propTypes, newProps, ReactPropTypeLocations.prop);
      }
    }
    return newProps;
  },

  /**
   * Assert that the props are valid
   *
   * @param {object} propTypes Map of prop name to a ReactPropType
   * @param {object} props
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkPropTypes: function(propTypes, props, location) {
    // TODO: Stop validating prop types here and only use the element
    // validation.
    var componentName = this.constructor.displayName;
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error =
          propTypes[propName](props, propName, componentName, location);
        if (error instanceof Error) {
          // We may want to extend this logic for similar errors in
          // renderComponent calls, so I'm abstracting it away into
          // a function to minimize refactoring in the future
          var addendum = getDeclarationErrorAddendum(this);
          ("production" !== process.env.NODE_ENV ? warning(false, error.message + addendum) : null);
        }
      }
    }
  },

  /**
   * If any of `_pendingElement`, `_pendingState`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function(transaction) {
    var compositeLifeCycleState = this._compositeLifeCycleState;
    // Do not trigger a state transition if we are in the middle of mounting or
    // receiving props because both of those will already be doing this.
    if (compositeLifeCycleState === CompositeLifeCycle.MOUNTING ||
        compositeLifeCycleState === CompositeLifeCycle.RECEIVING_PROPS) {
      return;
    }

    if (this._pendingElement == null &&
        this._pendingState == null &&
        !this._pendingForceUpdate) {
      return;
    }

    var nextContext = this.context;
    var nextProps = this.props;
    var nextElement = this._currentElement;
    if (this._pendingElement != null) {
      nextElement = this._pendingElement;
      nextContext = this._processContext(nextElement._context);
      nextProps = this._processProps(nextElement.props);
      this._pendingElement = null;

      this._compositeLifeCycleState = CompositeLifeCycle.RECEIVING_PROPS;
      if (this.componentWillReceiveProps) {
        this.componentWillReceiveProps(nextProps, nextContext);
      }
    }

    this._compositeLifeCycleState = null;

    var nextState = this._pendingState || this.state;
    this._pendingState = null;

    var shouldUpdate =
      this._pendingForceUpdate ||
      !this.shouldComponentUpdate ||
      this.shouldComponentUpdate(nextProps, nextState, nextContext);

    if ("production" !== process.env.NODE_ENV) {
      if (typeof shouldUpdate === "undefined") {
        console.warn(
          (this.constructor.displayName || 'ReactCompositeComponent') +
          '.shouldComponentUpdate(): Returned undefined instead of a ' +
          'boolean value. Make sure to return true or false.'
        );
      }
    }

    if (shouldUpdate) {
      this._pendingForceUpdate = false;
      // Will set `this.props`, `this.state` and `this.context`.
      this._performComponentUpdate(
        nextElement,
        nextProps,
        nextState,
        nextContext,
        transaction
      );
    } else {
      // If it's determined that a component should not update, we still want
      // to set props and state.
      this._currentElement = nextElement;
      this.props = nextProps;
      this.state = nextState;
      this.context = nextContext;

      // Owner cannot change because shouldUpdateReactComponent doesn't allow
      // it. TODO: Remove this._owner completely.
      this._owner = nextElement._owner;
    }
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactElement} nextElement Next element
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @private
   */
  _performComponentUpdate: function(
    nextElement,
    nextProps,
    nextState,
    nextContext,
    transaction
  ) {
    var prevElement = this._currentElement;
    var prevProps = this.props;
    var prevState = this.state;
    var prevContext = this.context;

    if (this.componentWillUpdate) {
      this.componentWillUpdate(nextProps, nextState, nextContext);
    }

    this._currentElement = nextElement;
    this.props = nextProps;
    this.state = nextState;
    this.context = nextContext;

    // Owner cannot change because shouldUpdateReactComponent doesn't allow
    // it. TODO: Remove this._owner completely.
    this._owner = nextElement._owner;

    this.updateComponent(
      transaction,
      prevElement
    );

    if (this.componentDidUpdate) {
      transaction.getReactMountReady().enqueue(
        this.componentDidUpdate.bind(this, prevProps, prevState, prevContext),
        this
      );
    }
  },

  receiveComponent: function(nextElement, transaction) {
    if (nextElement === this._currentElement &&
        nextElement._owner != null) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for a element created outside a composite to be
      // deeply mutated and reused.
      return;
    }

    ReactComponent.Mixin.receiveComponent.call(
      this,
      nextElement,
      transaction
    );
  },

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @internal
   * @overridable
   */
  updateComponent: ReactPerf.measure(
    'ReactCompositeComponent',
    'updateComponent',
    function(transaction, prevParentElement) {
      ReactComponent.Mixin.updateComponent.call(
        this,
        transaction,
        prevParentElement
      );

      var prevComponentInstance = this._renderedComponent;
      var prevElement = prevComponentInstance._currentElement;
      var nextElement = this._renderValidatedComponent();
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        prevComponentInstance.receiveComponent(nextElement, transaction);
      } else {
        // These two IDs are actually the same! But nothing should rely on that.
        var thisID = this._rootNodeID;
        var prevComponentID = prevComponentInstance._rootNodeID;
        prevComponentInstance.unmountComponent();
        this._renderedComponent = instantiateReactComponent(
          nextElement,
          this._currentElement.type
        );
        var nextMarkup = this._renderedComponent.mountComponent(
          thisID,
          transaction,
          this._mountDepth + 1
        );
        ReactComponent.BackendIDOperations.dangerouslyReplaceNodeWithMarkupByID(
          prevComponentID,
          nextMarkup
        );
      }
    }
  ),

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldUpdateComponent`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {?function} callback Called after update is complete.
   * @final
   * @protected
   */
  forceUpdate: function(callback) {
    var compositeLifeCycleState = this._compositeLifeCycleState;
    ("production" !== process.env.NODE_ENV ? invariant(
      this.isMounted() ||
        compositeLifeCycleState === CompositeLifeCycle.MOUNTING,
      'forceUpdate(...): Can only force an update on mounted or mounting ' +
        'components.'
    ) : invariant(this.isMounted() ||
      compositeLifeCycleState === CompositeLifeCycle.MOUNTING));
    ("production" !== process.env.NODE_ENV ? invariant(
      compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING &&
      ReactCurrentOwner.current == null,
      'forceUpdate(...): Cannot force an update while unmounting component ' +
      'or within a `render` function.'
    ) : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING &&
    ReactCurrentOwner.current == null));
    this._pendingForceUpdate = true;
    ReactUpdates.enqueueUpdate(this, callback);
  },

  /**
   * @private
   */
  _renderValidatedComponent: ReactPerf.measure(
    'ReactCompositeComponent',
    '_renderValidatedComponent',
    function() {
      var renderedComponent;
      var previousContext = ReactContext.current;
      ReactContext.current = this._processChildContext(
        this._currentElement._context
      );
      ReactCurrentOwner.current = this;
      try {
        renderedComponent = this.render();
        if (renderedComponent === null || renderedComponent === false) {
          renderedComponent = ReactEmptyComponent.getEmptyComponent();
          ReactEmptyComponent.registerNullComponentID(this._rootNodeID);
        } else {
          ReactEmptyComponent.deregisterNullComponentID(this._rootNodeID);
        }
      } finally {
        ReactContext.current = previousContext;
        ReactCurrentOwner.current = null;
      }
      ("production" !== process.env.NODE_ENV ? invariant(
        ReactElement.isValidElement(renderedComponent),
        '%s.render(): A valid ReactComponent must be returned. You may have ' +
          'returned undefined, an array or some other invalid object.',
        this.constructor.displayName || 'ReactCompositeComponent'
      ) : invariant(ReactElement.isValidElement(renderedComponent)));
      return renderedComponent;
    }
  ),

  /**
   * @private
   */
  _bindAutoBindMethods: function() {
    for (var autoBindKey in this.__reactAutoBindMap) {
      if (!this.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
        continue;
      }
      var method = this.__reactAutoBindMap[autoBindKey];
      this[autoBindKey] = this._bindAutoBindMethod(ReactErrorUtils.guard(
        method,
        this.constructor.displayName + '.' + autoBindKey
      ));
    }
  },

  /**
   * Binds a method to the component.
   *
   * @param {function} method Method to be bound.
   * @private
   */
  _bindAutoBindMethod: function(method) {
    var component = this;
    var boundMethod = method.bind(component);
    if ("production" !== process.env.NODE_ENV) {
      boundMethod.__reactBoundContext = component;
      boundMethod.__reactBoundMethod = method;
      boundMethod.__reactBoundArguments = null;
      var componentName = component.constructor.displayName;
      var _bind = boundMethod.bind;
      boundMethod.bind = function(newThis ) {for (var args=[],$__0=1,$__1=arguments.length;$__0<$__1;$__0++) args.push(arguments[$__0]);
        // User is trying to bind() an autobound method; we effectively will
        // ignore the value of "this" that the user is trying to use, so
        // let's warn.
        if (newThis !== component && newThis !== null) {
          monitorCodeUse('react_bind_warning', { component: componentName });
          console.warn(
            'bind(): React component methods may only be bound to the ' +
            'component instance. See ' + componentName
          );
        } else if (!args.length) {
          monitorCodeUse('react_bind_warning', { component: componentName });
          console.warn(
            'bind(): You are binding a component method to the component. ' +
            'React does this for you automatically in a high-performance ' +
            'way, so you can safely remove this call. See ' + componentName
          );
          return boundMethod;
        }
        var reboundMethod = _bind.apply(boundMethod, arguments);
        reboundMethod.__reactBoundContext = component;
        reboundMethod.__reactBoundMethod = method;
        reboundMethod.__reactBoundArguments = args;
        return reboundMethod;
      };
    }
    return boundMethod;
  }
};

var ReactCompositeComponentBase = function() {};
assign(
  ReactCompositeComponentBase.prototype,
  ReactComponent.Mixin,
  ReactOwner.Mixin,
  ReactPropTransferer.Mixin,
  ReactCompositeComponentMixin
);

/**
 * Module for creating composite components.
 *
 * @class ReactCompositeComponent
 * @extends ReactComponent
 * @extends ReactOwner
 * @extends ReactPropTransferer
 */
var ReactCompositeComponent = {

  LifeCycle: CompositeLifeCycle,

  Base: ReactCompositeComponentBase,

  /**
   * Creates a composite component class given a class specification.
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function(spec) {
    var Constructor = function(props) {
      // This constructor is overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted. This will later be used
      // by the stand-alone class implementation.
    };
    Constructor.prototype = new ReactCompositeComponentBase();
    Constructor.prototype.constructor = Constructor;

    injectedMixins.forEach(
      mixSpecIntoComponent.bind(null, Constructor)
    );

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    ("production" !== process.env.NODE_ENV ? invariant(
      Constructor.prototype.render,
      'createClass(...): Class specification must implement a `render` method.'
    ) : invariant(Constructor.prototype.render));

    if ("production" !== process.env.NODE_ENV) {
      if (Constructor.prototype.componentShouldUpdate) {
        monitorCodeUse(
          'react_component_should_update_warning',
          { component: spec.displayName }
        );
        console.warn(
          (spec.displayName || 'A component') + ' has a method called ' +
          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +
          'The name is phrased as a question because the function is ' +
          'expected to return a value.'
         );
      }
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactCompositeComponentInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    if ("production" !== process.env.NODE_ENV) {
      return ReactLegacyElement.wrapFactory(
        ReactElementValidator.createFactory(Constructor)
      );
    }
    return ReactLegacyElement.wrapFactory(
      ReactElement.createFactory(Constructor)
    );
  },

  injection: {
    injectMixin: function(mixin) {
      injectedMixins.push(mixin);
    }
  }
};

module.exports = ReactCompositeComponent;

}).call(this,require('_process'))
},{"./Object.assign":28,"./ReactComponent":34,"./ReactContext":37,"./ReactCurrentOwner":38,"./ReactElement":54,"./ReactElementValidator":55,"./ReactEmptyComponent":56,"./ReactErrorUtils":57,"./ReactLegacyElement":63,"./ReactOwner":69,"./ReactPerf":70,"./ReactPropTransferer":71,"./ReactPropTypeLocationNames":72,"./ReactPropTypeLocations":73,"./ReactUpdates":81,"./instantiateReactComponent":127,"./invariant":128,"./keyMirror":134,"./keyOf":135,"./mapObject":136,"./monitorCodeUse":138,"./shouldUpdateReactComponent":144,"./warning":147,"_process":2}],37:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactContext
 */

"use strict";

var assign = require("./Object.assign");

/**
 * Keeps track of the current context.
 *
 * The context is automatically passed down the component ownership hierarchy
 * and is accessible via `this.context` on ReactCompositeComponents.
 */
var ReactContext = {

  /**
   * @internal
   * @type {object}
   */
  current: {},

  /**
   * Temporarily extends the current context while executing scopedCallback.
   *
   * A typical use case might look like
   *
   *  render: function() {
   *    var children = ReactContext.withContext({foo: 'foo'}, () => (
   *
   *    ));
   *    return <div>{children}</div>;
   *  }
   *
   * @param {object} newContext New context to merge into the existing context
   * @param {function} scopedCallback Callback to run with the new context
   * @return {ReactComponent|array<ReactComponent>}
   */
  withContext: function(newContext, scopedCallback) {
    var result;
    var previousContext = ReactContext.current;
    ReactContext.current = assign({}, previousContext, newContext);
    try {
      result = scopedCallback();
    } finally {
      ReactContext.current = previousContext;
    }
    return result;
  }

};

module.exports = ReactContext;

},{"./Object.assign":28}],38:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactCurrentOwner
 */

"use strict";

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 *
 * The depth indicate how many composite components are above this render level.
 */
var ReactCurrentOwner = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

module.exports = ReactCurrentOwner;

},{}],39:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOM
 * @typechecks static-only
 */

"use strict";

var ReactElement = require("./ReactElement");
var ReactElementValidator = require("./ReactElementValidator");
var ReactLegacyElement = require("./ReactLegacyElement");

var mapObject = require("./mapObject");

/**
 * Create a factory that creates HTML tag elements.
 *
 * @param {string} tag Tag name (e.g. `div`).
 * @private
 */
function createDOMFactory(tag) {
  if ("production" !== process.env.NODE_ENV) {
    return ReactLegacyElement.markNonLegacyFactory(
      ReactElementValidator.createFactory(tag)
    );
  }
  return ReactLegacyElement.markNonLegacyFactory(
    ReactElement.createFactory(tag)
  );
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOM = mapObject({
  a: 'a',
  abbr: 'abbr',
  address: 'address',
  area: 'area',
  article: 'article',
  aside: 'aside',
  audio: 'audio',
  b: 'b',
  base: 'base',
  bdi: 'bdi',
  bdo: 'bdo',
  big: 'big',
  blockquote: 'blockquote',
  body: 'body',
  br: 'br',
  button: 'button',
  canvas: 'canvas',
  caption: 'caption',
  cite: 'cite',
  code: 'code',
  col: 'col',
  colgroup: 'colgroup',
  data: 'data',
  datalist: 'datalist',
  dd: 'dd',
  del: 'del',
  details: 'details',
  dfn: 'dfn',
  dialog: 'dialog',
  div: 'div',
  dl: 'dl',
  dt: 'dt',
  em: 'em',
  embed: 'embed',
  fieldset: 'fieldset',
  figcaption: 'figcaption',
  figure: 'figure',
  footer: 'footer',
  form: 'form',
  h1: 'h1',
  h2: 'h2',
  h3: 'h3',
  h4: 'h4',
  h5: 'h5',
  h6: 'h6',
  head: 'head',
  header: 'header',
  hr: 'hr',
  html: 'html',
  i: 'i',
  iframe: 'iframe',
  img: 'img',
  input: 'input',
  ins: 'ins',
  kbd: 'kbd',
  keygen: 'keygen',
  label: 'label',
  legend: 'legend',
  li: 'li',
  link: 'link',
  main: 'main',
  map: 'map',
  mark: 'mark',
  menu: 'menu',
  menuitem: 'menuitem',
  meta: 'meta',
  meter: 'meter',
  nav: 'nav',
  noscript: 'noscript',
  object: 'object',
  ol: 'ol',
  optgroup: 'optgroup',
  option: 'option',
  output: 'output',
  p: 'p',
  param: 'param',
  picture: 'picture',
  pre: 'pre',
  progress: 'progress',
  q: 'q',
  rp: 'rp',
  rt: 'rt',
  ruby: 'ruby',
  s: 's',
  samp: 'samp',
  script: 'script',
  section: 'section',
  select: 'select',
  small: 'small',
  source: 'source',
  span: 'span',
  strong: 'strong',
  style: 'style',
  sub: 'sub',
  summary: 'summary',
  sup: 'sup',
  table: 'table',
  tbody: 'tbody',
  td: 'td',
  textarea: 'textarea',
  tfoot: 'tfoot',
  th: 'th',
  thead: 'thead',
  time: 'time',
  title: 'title',
  tr: 'tr',
  track: 'track',
  u: 'u',
  ul: 'ul',
  'var': 'var',
  video: 'video',
  wbr: 'wbr',

  // SVG
  circle: 'circle',
  defs: 'defs',
  ellipse: 'ellipse',
  g: 'g',
  line: 'line',
  linearGradient: 'linearGradient',
  mask: 'mask',
  path: 'path',
  pattern: 'pattern',
  polygon: 'polygon',
  polyline: 'polyline',
  radialGradient: 'radialGradient',
  rect: 'rect',
  stop: 'stop',
  svg: 'svg',
  text: 'text',
  tspan: 'tspan'

}, createDOMFactory);

module.exports = ReactDOM;

}).call(this,require('_process'))
},{"./ReactElement":54,"./ReactElementValidator":55,"./ReactLegacyElement":63,"./mapObject":136,"_process":2}],40:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMButton
 */

"use strict";

var AutoFocusMixin = require("./AutoFocusMixin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactElement = require("./ReactElement");
var ReactDOM = require("./ReactDOM");

var keyMirror = require("./keyMirror");

// Store a reference to the <button> `ReactDOMComponent`. TODO: use string
var button = ReactElement.createFactory(ReactDOM.button.type);

var mouseListenerNames = keyMirror({
  onClick: true,
  onDoubleClick: true,
  onMouseDown: true,
  onMouseMove: true,
  onMouseUp: true,
  onClickCapture: true,
  onDoubleClickCapture: true,
  onMouseDownCapture: true,
  onMouseMoveCapture: true,
  onMouseUpCapture: true
});

/**
 * Implements a <button> native component that does not receive mouse events
 * when `disabled` is set.
 */
var ReactDOMButton = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMButton',

  mixins: [AutoFocusMixin, ReactBrowserComponentMixin],

  render: function() {
    var props = {};

    // Copy the props; except the mouse listeners if we're disabled
    for (var key in this.props) {
      if (this.props.hasOwnProperty(key) &&
          (!this.props.disabled || !mouseListenerNames[key])) {
        props[key] = this.props[key];
      }
    }

    return button(props, this.props.children);
  }

});

module.exports = ReactDOMButton;

},{"./AutoFocusMixin":3,"./ReactBrowserComponentMixin":31,"./ReactCompositeComponent":36,"./ReactDOM":39,"./ReactElement":54,"./keyMirror":134}],41:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMComponent
 * @typechecks static-only
 */

"use strict";

var CSSPropertyOperations = require("./CSSPropertyOperations");
var DOMProperty = require("./DOMProperty");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactComponent = require("./ReactComponent");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactMount = require("./ReactMount");
var ReactMultiChild = require("./ReactMultiChild");
var ReactPerf = require("./ReactPerf");

var assign = require("./Object.assign");
var escapeTextForBrowser = require("./escapeTextForBrowser");
var invariant = require("./invariant");
var isEventSupported = require("./isEventSupported");
var keyOf = require("./keyOf");
var monitorCodeUse = require("./monitorCodeUse");

var deleteListener = ReactBrowserEventEmitter.deleteListener;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = {'string': true, 'number': true};

var STYLE = keyOf({style: null});

var ELEMENT_NODE_TYPE = 1;

/**
 * @param {?object} props
 */
function assertValidProps(props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  ("production" !== process.env.NODE_ENV ? invariant(
    props.children == null || props.dangerouslySetInnerHTML == null,
    'Can only set one of `children` or `props.dangerouslySetInnerHTML`.'
  ) : invariant(props.children == null || props.dangerouslySetInnerHTML == null));
  if ("production" !== process.env.NODE_ENV) {
    if (props.contentEditable && props.children != null) {
      console.warn(
        'A component is `contentEditable` and contains `children` managed by ' +
        'React. It is now your responsibility to guarantee that none of those '+
        'nodes are unexpectedly modified or duplicated. This is probably not ' +
        'intentional.'
      );
    }
  }
  ("production" !== process.env.NODE_ENV ? invariant(
    props.style == null || typeof props.style === 'object',
    'The `style` prop expects a mapping from style properties to values, ' +
    'not a string.'
  ) : invariant(props.style == null || typeof props.style === 'object'));
}

function putListener(id, registrationName, listener, transaction) {
  if ("production" !== process.env.NODE_ENV) {
    // IE8 has no API for event capturing and the `onScroll` event doesn't
    // bubble.
    if (registrationName === 'onScroll' &&
        !isEventSupported('scroll', true)) {
      monitorCodeUse('react_no_scroll_event');
      console.warn('This browser doesn\'t support the `onScroll` event');
    }
  }
  var container = ReactMount.findReactContainerForID(id);
  if (container) {
    var doc = container.nodeType === ELEMENT_NODE_TYPE ?
      container.ownerDocument :
      container;
    listenTo(registrationName, doc);
  }
  transaction.getPutListenerQueue().enqueuePutListener(
    id,
    registrationName,
    listener
  );
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special cased tags.

var omittedCloseTags = {
  'area': true,
  'base': true,
  'br': true,
  'col': true,
  'embed': true,
  'hr': true,
  'img': true,
  'input': true,
  'keygen': true,
  'link': true,
  'meta': true,
  'param': true,
  'source': true,
  'track': true,
  'wbr': true
  // NOTE: menuitem's close tag should be omitted, but that causes problems.
};

// We accept any tag to be rendered but since this gets injected into abitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
var validatedTagCache = {};
var hasOwnProperty = {}.hasOwnProperty;

function validateDangerousTag(tag) {
  if (!hasOwnProperty.call(validatedTagCache, tag)) {
    ("production" !== process.env.NODE_ENV ? invariant(VALID_TAG_REGEX.test(tag), 'Invalid tag: %s', tag) : invariant(VALID_TAG_REGEX.test(tag)));
    validatedTagCache[tag] = true;
  }
}

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @constructor ReactDOMComponent
 * @extends ReactComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(tag) {
  validateDangerousTag(tag);
  this._tag = tag;
  this.tagName = tag.toUpperCase();
}

ReactDOMComponent.displayName = 'ReactDOMComponent';

ReactDOMComponent.Mixin = {

  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {string} rootID The root DOM ID for this node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {number} mountDepth number of components in the owner hierarchy
   * @return {string} The computed markup.
   */
  mountComponent: ReactPerf.measure(
    'ReactDOMComponent',
    'mountComponent',
    function(rootID, transaction, mountDepth) {
      ReactComponent.Mixin.mountComponent.call(
        this,
        rootID,
        transaction,
        mountDepth
      );
      assertValidProps(this.props);
      var closeTag = omittedCloseTags[this._tag] ? '' : '</' + this._tag + '>';
      return (
        this._createOpenTagMarkupAndPutListeners(transaction) +
        this._createContentMarkup(transaction) +
        closeTag
      );
    }
  ),

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function(transaction) {
    var props = this.props;
    var ret = '<' + this._tag;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        putListener(this._rootNodeID, propKey, propValue, transaction);
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            propValue = props.style = assign({}, props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
        }
        var markup =
          DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret + '>';
    }

    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
    return ret + ' ' + markupForID + '>';
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Content markup.
   */
  _createContentMarkup: function(transaction) {
    // Intentional use of != to avoid catching zero/false.
    var innerHTML = this.props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        return innerHTML.__html;
      }
    } else {
      var contentToUse =
        CONTENT_TYPES[typeof this.props.children] ? this.props.children : null;
      var childrenToUse = contentToUse != null ? null : this.props.children;
      if (contentToUse != null) {
        return escapeTextForBrowser(contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(
          childrenToUse,
          transaction
        );
        return mountImages.join('');
      }
    }
    return '';
  },

  receiveComponent: function(nextElement, transaction) {
    if (nextElement === this._currentElement &&
        nextElement._owner != null) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for a element created outside a composite to be
      // deeply mutated and reused.
      return;
    }

    ReactComponent.Mixin.receiveComponent.call(
      this,
      nextElement,
      transaction
    );
  },

  /**
   * Updates a native DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @internal
   * @overridable
   */
  updateComponent: ReactPerf.measure(
    'ReactDOMComponent',
    'updateComponent',
    function(transaction, prevElement) {
      assertValidProps(this._currentElement.props);
      ReactComponent.Mixin.updateComponent.call(
        this,
        transaction,
        prevElement
      );
      this._updateDOMProperties(prevElement.props, transaction);
      this._updateDOMChildren(prevElement.props, transaction);
    }
  ),

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {ReactReconcileTransaction} transaction
   */
  _updateDOMProperties: function(lastProps, transaction) {
    var nextProps = this.props;
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) ||
         !lastProps.hasOwnProperty(propKey)) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = lastProps[propKey];
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        deleteListener(this._rootNodeID, propKey);
      } else if (
          DOMProperty.isStandardName[propKey] ||
          DOMProperty.isCustomAttribute(propKey)) {
        ReactComponent.BackendIDOperations.deletePropertyByID(
          this._rootNodeID,
          propKey
        );
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = lastProps[propKey];
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          nextProp = nextProps.style = assign({}, nextProp);
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) &&
                (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) &&
                lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        putListener(this._rootNodeID, propKey, nextProp, transaction);
      } else if (
          DOMProperty.isStandardName[propKey] ||
          DOMProperty.isCustomAttribute(propKey)) {
        ReactComponent.BackendIDOperations.updatePropertyByID(
          this._rootNodeID,
          propKey,
          nextProp
        );
      }
    }
    if (styleUpdates) {
      ReactComponent.BackendIDOperations.updateStylesByID(
        this._rootNodeID,
        styleUpdates
      );
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {ReactReconcileTransaction} transaction
   */
  _updateDOMChildren: function(lastProps, transaction) {
    var nextProps = this.props;

    var lastContent =
      CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
    var nextContent =
      CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

    var lastHtml =
      lastProps.dangerouslySetInnerHTML &&
      lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml =
      nextProps.dangerouslySetInnerHTML &&
      nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        ReactComponent.BackendIDOperations.updateInnerHTMLByID(
          this._rootNodeID,
          nextHtml
        );
      }
    } else if (nextChildren != null) {
      this.updateChildren(nextChildren, transaction);
    }
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function() {
    this.unmountChildren();
    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
    ReactComponent.Mixin.unmountComponent.call(this);
  }

};

assign(
  ReactDOMComponent.prototype,
  ReactComponent.Mixin,
  ReactDOMComponent.Mixin,
  ReactMultiChild.Mixin,
  ReactBrowserComponentMixin
);

module.exports = ReactDOMComponent;

}).call(this,require('_process'))
},{"./CSSPropertyOperations":6,"./DOMProperty":12,"./DOMPropertyOperations":13,"./Object.assign":28,"./ReactBrowserComponentMixin":31,"./ReactBrowserEventEmitter":32,"./ReactComponent":34,"./ReactMount":65,"./ReactMultiChild":66,"./ReactPerf":70,"./escapeTextForBrowser":111,"./invariant":128,"./isEventSupported":129,"./keyOf":135,"./monitorCodeUse":138,"_process":2}],42:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMForm
 */

"use strict";

var EventConstants = require("./EventConstants");
var LocalEventTrapMixin = require("./LocalEventTrapMixin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactElement = require("./ReactElement");
var ReactDOM = require("./ReactDOM");

// Store a reference to the <form> `ReactDOMComponent`. TODO: use string
var form = ReactElement.createFactory(ReactDOM.form.type);

/**
 * Since onSubmit doesn't bubble OR capture on the top level in IE8, we need
 * to capture it on the <form> element itself. There are lots of hacks we could
 * do to accomplish this, but the most reliable is to make <form> a
 * composite component and use `componentDidMount` to attach the event handlers.
 */
var ReactDOMForm = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMForm',

  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],

  render: function() {
    // TODO: Instead of using `ReactDOM` directly, we should use JSX. However,
    // `jshint` fails to parse JSX so in order for linting to work in the open
    // source repo, we need to just use `ReactDOM.form`.
    return form(this.props);
  },

  componentDidMount: function() {
    this.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset');
    this.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit');
  }
});

module.exports = ReactDOMForm;

},{"./EventConstants":17,"./LocalEventTrapMixin":26,"./ReactBrowserComponentMixin":31,"./ReactCompositeComponent":36,"./ReactDOM":39,"./ReactElement":54}],43:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMIDOperations
 * @typechecks static-only
 */

/*jslint evil: true */

"use strict";

var CSSPropertyOperations = require("./CSSPropertyOperations");
var DOMChildrenOperations = require("./DOMChildrenOperations");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var ReactMount = require("./ReactMount");
var ReactPerf = require("./ReactPerf");

var invariant = require("./invariant");
var setInnerHTML = require("./setInnerHTML");

/**
 * Errors for properties that should not be updated with `updatePropertyById()`.
 *
 * @type {object}
 * @private
 */
var INVALID_PROPERTY_ERRORS = {
  dangerouslySetInnerHTML:
    '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
  style: '`style` must be set using `updateStylesByID()`.'
};

/**
 * Operations used to process updates to DOM nodes. This is made injectable via
 * `ReactComponent.BackendIDOperations`.
 */
var ReactDOMIDOperations = {

  /**
   * Updates a DOM node with new property values. This should only be used to
   * update DOM properties in `DOMProperty`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} name A valid property name, see `DOMProperty`.
   * @param {*} value New value of the property.
   * @internal
   */
  updatePropertyByID: ReactPerf.measure(
    'ReactDOMIDOperations',
    'updatePropertyByID',
    function(id, name, value) {
      var node = ReactMount.getNode(id);
      ("production" !== process.env.NODE_ENV ? invariant(
        !INVALID_PROPERTY_ERRORS.hasOwnProperty(name),
        'updatePropertyByID(...): %s',
        INVALID_PROPERTY_ERRORS[name]
      ) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));

      // If we're updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertantly setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      if (value != null) {
        DOMPropertyOperations.setValueForProperty(node, name, value);
      } else {
        DOMPropertyOperations.deleteValueForProperty(node, name);
      }
    }
  ),

  /**
   * Updates a DOM node to remove a property. This should only be used to remove
   * DOM properties in `DOMProperty`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} name A property name to remove, see `DOMProperty`.
   * @internal
   */
  deletePropertyByID: ReactPerf.measure(
    'ReactDOMIDOperations',
    'deletePropertyByID',
    function(id, name, value) {
      var node = ReactMount.getNode(id);
      ("production" !== process.env.NODE_ENV ? invariant(
        !INVALID_PROPERTY_ERRORS.hasOwnProperty(name),
        'updatePropertyByID(...): %s',
        INVALID_PROPERTY_ERRORS[name]
      ) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));
      DOMPropertyOperations.deleteValueForProperty(node, name, value);
    }
  ),

  /**
   * Updates a DOM node with new style values. If a value is specified as '',
   * the corresponding style property will be unset.
   *
   * @param {string} id ID of the node to update.
   * @param {object} styles Mapping from styles to values.
   * @internal
   */
  updateStylesByID: ReactPerf.measure(
    'ReactDOMIDOperations',
    'updateStylesByID',
    function(id, styles) {
      var node = ReactMount.getNode(id);
      CSSPropertyOperations.setValueForStyles(node, styles);
    }
  ),

  /**
   * Updates a DOM node's innerHTML.
   *
   * @param {string} id ID of the node to update.
   * @param {string} html An HTML string.
   * @internal
   */
  updateInnerHTMLByID: ReactPerf.measure(
    'ReactDOMIDOperations',
    'updateInnerHTMLByID',
    function(id, html) {
      var node = ReactMount.getNode(id);
      setInnerHTML(node, html);
    }
  ),

  /**
   * Updates a DOM node's text content set by `props.content`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} content Text content.
   * @internal
   */
  updateTextContentByID: ReactPerf.measure(
    'ReactDOMIDOperations',
    'updateTextContentByID',
    function(id, content) {
      var node = ReactMount.getNode(id);
      DOMChildrenOperations.updateTextContent(node, content);
    }
  ),

  /**
   * Replaces a DOM node that exists in the document with markup.
   *
   * @param {string} id ID of child to be replaced.
   * @param {string} markup Dangerous markup to inject in place of child.
   * @internal
   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
   */
  dangerouslyReplaceNodeWithMarkupByID: ReactPerf.measure(
    'ReactDOMIDOperations',
    'dangerouslyReplaceNodeWithMarkupByID',
    function(id, markup) {
      var node = ReactMount.getNode(id);
      DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
    }
  ),

  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @param {array<string>} markup List of markup strings.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: ReactPerf.measure(
    'ReactDOMIDOperations',
    'dangerouslyProcessChildrenUpdates',
    function(updates, markup) {
      for (var i = 0; i < updates.length; i++) {
        updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
      }
      DOMChildrenOperations.processUpdates(updates, markup);
    }
  )
};

module.exports = ReactDOMIDOperations;

}).call(this,require('_process'))
},{"./CSSPropertyOperations":6,"./DOMChildrenOperations":11,"./DOMPropertyOperations":13,"./ReactMount":65,"./ReactPerf":70,"./invariant":128,"./setInnerHTML":142,"_process":2}],44:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMImg
 */

"use strict";

var EventConstants = require("./EventConstants");
var LocalEventTrapMixin = require("./LocalEventTrapMixin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactElement = require("./ReactElement");
var ReactDOM = require("./ReactDOM");

// Store a reference to the <img> `ReactDOMComponent`. TODO: use string
var img = ReactElement.createFactory(ReactDOM.img.type);

/**
 * Since onLoad doesn't bubble OR capture on the top level in IE8, we need to
 * capture it on the <img> element itself. There are lots of hacks we could do
 * to accomplish this, but the most reliable is to make <img> a composite
 * component and use `componentDidMount` to attach the event handlers.
 */
var ReactDOMImg = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMImg',
  tagName: 'IMG',

  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],

  render: function() {
    return img(this.props);
  },

  componentDidMount: function() {
    this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load');
    this.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error');
  }
});

module.exports = ReactDOMImg;

},{"./EventConstants":17,"./LocalEventTrapMixin":26,"./ReactBrowserComponentMixin":31,"./ReactCompositeComponent":36,"./ReactDOM":39,"./ReactElement":54}],45:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMInput
 */

"use strict";

var AutoFocusMixin = require("./AutoFocusMixin");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var LinkedValueUtils = require("./LinkedValueUtils");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactElement = require("./ReactElement");
var ReactDOM = require("./ReactDOM");
var ReactMount = require("./ReactMount");
var ReactUpdates = require("./ReactUpdates");

var assign = require("./Object.assign");
var invariant = require("./invariant");

// Store a reference to the <input> `ReactDOMComponent`. TODO: use string
var input = ReactElement.createFactory(ReactDOM.input.type);

var instancesByReactID = {};

function forceUpdateIfMounted() {
  /*jshint validthis:true */
  if (this.isMounted()) {
    this.forceUpdate();
  }
}

/**
 * Implements an <input> native component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMInput',

  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],

  getInitialState: function() {
    var defaultValue = this.props.defaultValue;
    return {
      initialChecked: this.props.defaultChecked || false,
      initialValue: defaultValue != null ? defaultValue : null
    };
  },

  render: function() {
    // Clone `this.props` so we don't mutate the input.
    var props = assign({}, this.props);

    props.defaultChecked = null;
    props.defaultValue = null;

    var value = LinkedValueUtils.getValue(this);
    props.value = value != null ? value : this.state.initialValue;

    var checked = LinkedValueUtils.getChecked(this);
    props.checked = checked != null ? checked : this.state.initialChecked;

    props.onChange = this._handleChange;

    return input(props, this.props.children);
  },

  componentDidMount: function() {
    var id = ReactMount.getID(this.getDOMNode());
    instancesByReactID[id] = this;
  },

  componentWillUnmount: function() {
    var rootNode = this.getDOMNode();
    var id = ReactMount.getID(rootNode);
    delete instancesByReactID[id];
  },

  componentDidUpdate: function(prevProps, prevState, prevContext) {
    var rootNode = this.getDOMNode();
    if (this.props.checked != null) {
      DOMPropertyOperations.setValueForProperty(
        rootNode,
        'checked',
        this.props.checked || false
      );
    }

    var value = LinkedValueUtils.getValue(this);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
    }
  },

  _handleChange: function(event) {
    var returnValue;
    var onChange = LinkedValueUtils.getOnChange(this);
    if (onChange) {
      returnValue = onChange.call(this, event);
    }
    // Here we use asap to wait until all updates have propagated, which
    // is important when using controlled components within layers:
    // https://github.com/facebook/react/issues/1698
    ReactUpdates.asap(forceUpdateIfMounted, this);

    var name = this.props.name;
    if (this.props.type === 'radio' && name != null) {
      var rootNode = this.getDOMNode();
      var queryRoot = rootNode;

      while (queryRoot.parentNode) {
        queryRoot = queryRoot.parentNode;
      }

      // If `rootNode.form` was non-null, then we could try `form.elements`,
      // but that sometimes behaves strangely in IE8. We could also try using
      // `form.getElementsByName`, but that will only return direct children
      // and won't include inputs that use the HTML5 `form=` attribute. Since
      // the input might not even be in a form, let's just use the global
      // `querySelectorAll` to ensure we don't miss anything.
      var group = queryRoot.querySelectorAll(
        'input[name=' + JSON.stringify('' + name) + '][type="radio"]');

      for (var i = 0, groupLen = group.length; i < groupLen; i++) {
        var otherNode = group[i];
        if (otherNode === rootNode ||
            otherNode.form !== rootNode.form) {
          continue;
        }
        var otherID = ReactMount.getID(otherNode);
        ("production" !== process.env.NODE_ENV ? invariant(
          otherID,
          'ReactDOMInput: Mixing React and non-React radio inputs with the ' +
          'same `name` is not supported.'
        ) : invariant(otherID));
        var otherInstance = instancesByReactID[otherID];
        ("production" !== process.env.NODE_ENV ? invariant(
          otherInstance,
          'ReactDOMInput: Unknown radio button ID %s.',
          otherID
        ) : invariant(otherInstance));
        // If this is a controlled radio button group, forcing the input that
        // was previously checked to update will cause it to be come re-checked
        // as appropriate.
        ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
      }
    }

    return returnValue;
  }

});

module.exports = ReactDOMInput;

}).call(this,require('_process'))
},{"./AutoFocusMixin":3,"./DOMPropertyOperations":13,"./LinkedValueUtils":25,"./Object.assign":28,"./ReactBrowserComponentMixin":31,"./ReactCompositeComponent":36,"./ReactDOM":39,"./ReactElement":54,"./ReactMount":65,"./ReactUpdates":81,"./invariant":128,"_process":2}],46:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMOption
 */

"use strict";

var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactElement = require("./ReactElement");
var ReactDOM = require("./ReactDOM");

var warning = require("./warning");

// Store a reference to the <option> `ReactDOMComponent`. TODO: use string
var option = ReactElement.createFactory(ReactDOM.option.type);

/**
 * Implements an <option> native component that warns when `selected` is set.
 */
var ReactDOMOption = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMOption',

  mixins: [ReactBrowserComponentMixin],

  componentWillMount: function() {
    // TODO (yungsters): Remove support for `selected` in <option>.
    if ("production" !== process.env.NODE_ENV) {
      ("production" !== process.env.NODE_ENV ? warning(
        this.props.selected == null,
        'Use the `defaultValue` or `value` props on <select> instead of ' +
        'setting `selected` on <option>.'
      ) : null);
    }
  },

  render: function() {
    return option(this.props, this.props.children);
  }

});

module.exports = ReactDOMOption;

}).call(this,require('_process'))
},{"./ReactBrowserComponentMixin":31,"./ReactCompositeComponent":36,"./ReactDOM":39,"./ReactElement":54,"./warning":147,"_process":2}],47:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMSelect
 */

"use strict";

var AutoFocusMixin = require("./AutoFocusMixin");
var LinkedValueUtils = require("./LinkedValueUtils");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactElement = require("./ReactElement");
var ReactDOM = require("./ReactDOM");
var ReactUpdates = require("./ReactUpdates");

var assign = require("./Object.assign");

// Store a reference to the <select> `ReactDOMComponent`. TODO: use string
var select = ReactElement.createFactory(ReactDOM.select.type);

function updateWithPendingValueIfMounted() {
  /*jshint validthis:true */
  if (this.isMounted()) {
    this.setState({value: this._pendingValue});
    this._pendingValue = 0;
  }
}

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function selectValueType(props, propName, componentName) {
  if (props[propName] == null) {
    return;
  }
  if (props.multiple) {
    if (!Array.isArray(props[propName])) {
      return new Error(
        ("The `" + propName + "` prop supplied to <select> must be an array if ") +
        ("`multiple` is true.")
      );
    }
  } else {
    if (Array.isArray(props[propName])) {
      return new Error(
        ("The `" + propName + "` prop supplied to <select> must be a scalar ") +
        ("value if `multiple` is false.")
      );
    }
  }
}

/**
 * If `value` is supplied, updates <option> elements on mount and update.
 * @param {ReactComponent} component Instance of ReactDOMSelect
 * @param {?*} propValue For uncontrolled components, null/undefined. For
 * controlled components, a string (or with `multiple`, a list of strings).
 * @private
 */
function updateOptions(component, propValue) {
  var multiple = component.props.multiple;
  var value = propValue != null ? propValue : component.state.value;
  var options = component.getDOMNode().options;
  var selectedValue, i, l;
  if (multiple) {
    selectedValue = {};
    for (i = 0, l = value.length; i < l; ++i) {
      selectedValue['' + value[i]] = true;
    }
  } else {
    selectedValue = '' + value;
  }
  for (i = 0, l = options.length; i < l; i++) {
    var selected = multiple ?
      selectedValue.hasOwnProperty(options[i].value) :
      options[i].value === selectedValue;

    if (selected !== options[i].selected) {
      options[i].selected = selected;
    }
  }
}

/**
 * Implements a <select> native component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * string. If `multiple` is true, the prop must be an array of strings.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMSelect',

  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],

  propTypes: {
    defaultValue: selectValueType,
    value: selectValueType
  },

  getInitialState: function() {
    return {value: this.props.defaultValue || (this.props.multiple ? [] : '')};
  },

  componentWillMount: function() {
    this._pendingValue = null;
  },

  componentWillReceiveProps: function(nextProps) {
    if (!this.props.multiple && nextProps.multiple) {
      this.setState({value: [this.state.value]});
    } else if (this.props.multiple && !nextProps.multiple) {
      this.setState({value: this.state.value[0]});
    }
  },

  render: function() {
    // Clone `this.props` so we don't mutate the input.
    var props = assign({}, this.props);

    props.onChange = this._handleChange;
    props.value = null;

    return select(props, this.props.children);
  },

  componentDidMount: function() {
    updateOptions(this, LinkedValueUtils.getValue(this));
  },

  componentDidUpdate: function(prevProps) {
    var value = LinkedValueUtils.getValue(this);
    var prevMultiple = !!prevProps.multiple;
    var multiple = !!this.props.multiple;
    if (value != null || prevMultiple !== multiple) {
      updateOptions(this, value);
    }
  },

  _handleChange: function(event) {
    var returnValue;
    var onChange = LinkedValueUtils.getOnChange(this);
    if (onChange) {
      returnValue = onChange.call(this, event);
    }

    var selectedValue;
    if (this.props.multiple) {
      selectedValue = [];
      var options = event.target.options;
      for (var i = 0, l = options.length; i < l; i++) {
        if (options[i].selected) {
          selectedValue.push(options[i].value);
        }
      }
    } else {
      selectedValue = event.target.value;
    }

    this._pendingValue = selectedValue;
    ReactUpdates.asap(updateWithPendingValueIfMounted, this);
    return returnValue;
  }

});

module.exports = ReactDOMSelect;

},{"./AutoFocusMixin":3,"./LinkedValueUtils":25,"./Object.assign":28,"./ReactBrowserComponentMixin":31,"./ReactCompositeComponent":36,"./ReactDOM":39,"./ReactElement":54,"./ReactUpdates":81}],48:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMSelection
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

var getNodeForCharacterOffset = require("./getNodeForCharacterOffset");
var getTextContentAccessor = require("./getTextContentAccessor");

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(
    selection.anchorNode,
    selection.anchorOffset,
    selection.focusNode,
    selection.focusOffset
  );

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(
    tempRange.startContainer,
    tempRange.startOffset,
    tempRange.endContainer,
    tempRange.endOffset
  );

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (typeof offsets.end === 'undefined') {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = typeof offsets.end === 'undefined' ?
            start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

var useIEOffsets = ExecutionEnvironment.canUseDOM && document.selection;

var ReactDOMSelection = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

module.exports = ReactDOMSelection;

},{"./ExecutionEnvironment":23,"./getNodeForCharacterOffset":121,"./getTextContentAccessor":123}],49:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMTextarea
 */

"use strict";

var AutoFocusMixin = require("./AutoFocusMixin");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var LinkedValueUtils = require("./LinkedValueUtils");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactElement = require("./ReactElement");
var ReactDOM = require("./ReactDOM");
var ReactUpdates = require("./ReactUpdates");

var assign = require("./Object.assign");
var invariant = require("./invariant");

var warning = require("./warning");

// Store a reference to the <textarea> `ReactDOMComponent`. TODO: use string
var textarea = ReactElement.createFactory(ReactDOM.textarea.type);

function forceUpdateIfMounted() {
  /*jshint validthis:true */
  if (this.isMounted()) {
    this.forceUpdate();
  }
}

/**
 * Implements a <textarea> native component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMTextarea',

  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],

  getInitialState: function() {
    var defaultValue = this.props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = this.props.children;
    if (children != null) {
      if ("production" !== process.env.NODE_ENV) {
        ("production" !== process.env.NODE_ENV ? warning(
          false,
          'Use the `defaultValue` or `value` props instead of setting ' +
          'children on <textarea>.'
        ) : null);
      }
      ("production" !== process.env.NODE_ENV ? invariant(
        defaultValue == null,
        'If you supply `defaultValue` on a <textarea>, do not pass children.'
      ) : invariant(defaultValue == null));
      if (Array.isArray(children)) {
        ("production" !== process.env.NODE_ENV ? invariant(
          children.length <= 1,
          '<textarea> can only have at most one child.'
        ) : invariant(children.length <= 1));
        children = children[0];
      }

      defaultValue = '' + children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    var value = LinkedValueUtils.getValue(this);
    return {
      // We save the initial value so that `ReactDOMComponent` doesn't update
      // `textContent` (unnecessary since we update value).
      // The initial value can be a boolean or object so that's why it's
      // forced to be a string.
      initialValue: '' + (value != null ? value : defaultValue)
    };
  },

  render: function() {
    // Clone `this.props` so we don't mutate the input.
    var props = assign({}, this.props);

    ("production" !== process.env.NODE_ENV ? invariant(
      props.dangerouslySetInnerHTML == null,
      '`dangerouslySetInnerHTML` does not make sense on <textarea>.'
    ) : invariant(props.dangerouslySetInnerHTML == null));

    props.defaultValue = null;
    props.value = null;
    props.onChange = this._handleChange;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.
    return textarea(props, this.state.initialValue);
  },

  componentDidUpdate: function(prevProps, prevState, prevContext) {
    var value = LinkedValueUtils.getValue(this);
    if (value != null) {
      var rootNode = this.getDOMNode();
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
    }
  },

  _handleChange: function(event) {
    var returnValue;
    var onChange = LinkedValueUtils.getOnChange(this);
    if (onChange) {
      returnValue = onChange.call(this, event);
    }
    ReactUpdates.asap(forceUpdateIfMounted, this);
    return returnValue;
  }

});

module.exports = ReactDOMTextarea;

}).call(this,require('_process'))
},{"./AutoFocusMixin":3,"./DOMPropertyOperations":13,"./LinkedValueUtils":25,"./Object.assign":28,"./ReactBrowserComponentMixin":31,"./ReactCompositeComponent":36,"./ReactDOM":39,"./ReactElement":54,"./ReactUpdates":81,"./invariant":128,"./warning":147,"_process":2}],50:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultBatchingStrategy
 */

"use strict";

var ReactUpdates = require("./ReactUpdates");
var Transaction = require("./Transaction");

var assign = require("./Object.assign");
var emptyFunction = require("./emptyFunction");

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function() {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

assign(
  ReactDefaultBatchingStrategyTransaction.prototype,
  Transaction.Mixin,
  {
    getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    }
  }
);

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function(callback, a, b) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      callback(a, b);
    } else {
      transaction.perform(callback, null, a, b);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;

},{"./Object.assign":28,"./ReactUpdates":81,"./Transaction":97,"./emptyFunction":109}],51:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultInjection
 */

"use strict";

var BeforeInputEventPlugin = require("./BeforeInputEventPlugin");
var ChangeEventPlugin = require("./ChangeEventPlugin");
var ClientReactRootIndex = require("./ClientReactRootIndex");
var CompositionEventPlugin = require("./CompositionEventPlugin");
var DefaultEventPluginOrder = require("./DefaultEventPluginOrder");
var EnterLeaveEventPlugin = require("./EnterLeaveEventPlugin");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var HTMLDOMPropertyConfig = require("./HTMLDOMPropertyConfig");
var MobileSafariClickEventPlugin = require("./MobileSafariClickEventPlugin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactComponentBrowserEnvironment =
  require("./ReactComponentBrowserEnvironment");
var ReactDefaultBatchingStrategy = require("./ReactDefaultBatchingStrategy");
var ReactDOMComponent = require("./ReactDOMComponent");
var ReactDOMButton = require("./ReactDOMButton");
var ReactDOMForm = require("./ReactDOMForm");
var ReactDOMImg = require("./ReactDOMImg");
var ReactDOMInput = require("./ReactDOMInput");
var ReactDOMOption = require("./ReactDOMOption");
var ReactDOMSelect = require("./ReactDOMSelect");
var ReactDOMTextarea = require("./ReactDOMTextarea");
var ReactEventListener = require("./ReactEventListener");
var ReactInjection = require("./ReactInjection");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactMount = require("./ReactMount");
var SelectEventPlugin = require("./SelectEventPlugin");
var ServerReactRootIndex = require("./ServerReactRootIndex");
var SimpleEventPlugin = require("./SimpleEventPlugin");
var SVGDOMPropertyConfig = require("./SVGDOMPropertyConfig");

var createFullPageComponent = require("./createFullPageComponent");

function inject() {
  ReactInjection.EventEmitter.injectReactEventListener(
    ReactEventListener
  );

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
  ReactInjection.EventPluginHub.injectMount(ReactMount);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    CompositionEventPlugin: CompositionEventPlugin,
    MobileSafariClickEventPlugin: MobileSafariClickEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.NativeComponent.injectGenericComponentClass(
    ReactDOMComponent
  );

  ReactInjection.NativeComponent.injectComponentClasses({
    'button': ReactDOMButton,
    'form': ReactDOMForm,
    'img': ReactDOMImg,
    'input': ReactDOMInput,
    'option': ReactDOMOption,
    'select': ReactDOMSelect,
    'textarea': ReactDOMTextarea,

    'html': createFullPageComponent('html'),
    'head': createFullPageComponent('head'),
    'body': createFullPageComponent('body')
  });

  // This needs to happen after createFullPageComponent() otherwise the mixin
  // gets double injected.
  ReactInjection.CompositeComponent.injectMixin(ReactBrowserComponentMixin);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');

  ReactInjection.Updates.injectReconcileTransaction(
    ReactComponentBrowserEnvironment.ReactReconcileTransaction
  );
  ReactInjection.Updates.injectBatchingStrategy(
    ReactDefaultBatchingStrategy
  );

  ReactInjection.RootIndex.injectCreateReactRootIndex(
    ExecutionEnvironment.canUseDOM ?
      ClientReactRootIndex.createReactRootIndex :
      ServerReactRootIndex.createReactRootIndex
  );

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);

  if ("production" !== process.env.NODE_ENV) {
    var url = (ExecutionEnvironment.canUseDOM && window.location.href) || '';
    if ((/[?&]react_perf\b/).test(url)) {
      var ReactDefaultPerf = require("./ReactDefaultPerf");
      ReactDefaultPerf.start();
    }
  }
}

module.exports = {
  inject: inject
};

}).call(this,require('_process'))
},{"./BeforeInputEventPlugin":4,"./ChangeEventPlugin":8,"./ClientReactRootIndex":9,"./CompositionEventPlugin":10,"./DefaultEventPluginOrder":15,"./EnterLeaveEventPlugin":16,"./ExecutionEnvironment":23,"./HTMLDOMPropertyConfig":24,"./MobileSafariClickEventPlugin":27,"./ReactBrowserComponentMixin":31,"./ReactComponentBrowserEnvironment":35,"./ReactDOMButton":40,"./ReactDOMComponent":41,"./ReactDOMForm":42,"./ReactDOMImg":44,"./ReactDOMInput":45,"./ReactDOMOption":46,"./ReactDOMSelect":47,"./ReactDOMTextarea":49,"./ReactDefaultBatchingStrategy":50,"./ReactDefaultPerf":52,"./ReactEventListener":59,"./ReactInjection":60,"./ReactInstanceHandles":62,"./ReactMount":65,"./SVGDOMPropertyConfig":82,"./SelectEventPlugin":83,"./ServerReactRootIndex":84,"./SimpleEventPlugin":85,"./createFullPageComponent":105,"_process":2}],52:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultPerf
 * @typechecks static-only
 */

"use strict";

var DOMProperty = require("./DOMProperty");
var ReactDefaultPerfAnalysis = require("./ReactDefaultPerfAnalysis");
var ReactMount = require("./ReactMount");
var ReactPerf = require("./ReactPerf");

var performanceNow = require("./performanceNow");

function roundFloat(val) {
  return Math.floor(val * 100) / 100;
}

function addValue(obj, key, val) {
  obj[key] = (obj[key] || 0) + val;
}

var ReactDefaultPerf = {
  _allMeasurements: [], // last item in the list is the current one
  _mountStack: [0],
  _injected: false,

  start: function() {
    if (!ReactDefaultPerf._injected) {
      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
    }

    ReactDefaultPerf._allMeasurements.length = 0;
    ReactPerf.enableMeasure = true;
  },

  stop: function() {
    ReactPerf.enableMeasure = false;
  },

  getLastMeasurements: function() {
    return ReactDefaultPerf._allMeasurements;
  },

  printExclusive: function(measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
    console.table(summary.map(function(item) {
      return {
        'Component class name': item.componentName,
        'Total inclusive time (ms)': roundFloat(item.inclusive),
        'Exclusive mount time (ms)': roundFloat(item.exclusive),
        'Exclusive render time (ms)': roundFloat(item.render),
        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
        'Render time per instance (ms)': roundFloat(item.render / item.count),
        'Instances': item.count
      };
    }));
    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
    // number.
  },

  printInclusive: function(measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
    console.table(summary.map(function(item) {
      return {
        'Owner > component': item.componentName,
        'Inclusive time (ms)': roundFloat(item.time),
        'Instances': item.count
      };
    }));
    console.log(
      'Total time:',
      ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms'
    );
  },

  getMeasurementsSummaryMap: function(measurements) {
    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(
      measurements,
      true
    );
    return summary.map(function(item) {
      return {
        'Owner > component': item.componentName,
        'Wasted time (ms)': item.time,
        'Instances': item.count
      };
    });
  },

  printWasted: function(measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
    console.log(
      'Total time:',
      ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms'
    );
  },

  printDOM: function(measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
    console.table(summary.map(function(item) {
      var result = {};
      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
      result['type'] = item.type;
      result['args'] = JSON.stringify(item.args);
      return result;
    }));
    console.log(
      'Total time:',
      ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms'
    );
  },

  _recordWrite: function(id, fnName, totalTime, args) {
    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
    var writes =
      ReactDefaultPerf
        ._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1]
        .writes;
    writes[id] = writes[id] || [];
    writes[id].push({
      type: fnName,
      time: totalTime,
      args: args
    });
  },

  measure: function(moduleName, fnName, func) {
    return function() {for (var args=[],$__0=0,$__1=arguments.length;$__0<$__1;$__0++) args.push(arguments[$__0]);
      var totalTime;
      var rv;
      var start;

      if (fnName === '_renderNewRootComponent' ||
          fnName === 'flushBatchedUpdates') {
        // A "measurement" is a set of metrics recorded for each flush. We want
        // to group the metrics for a given flush together so we can look at the
        // components that rendered and the DOM operations that actually
        // happened to determine the amount of "wasted work" performed.
        ReactDefaultPerf._allMeasurements.push({
          exclusive: {},
          inclusive: {},
          render: {},
          counts: {},
          writes: {},
          displayNames: {},
          totalTime: 0
        });
        start = performanceNow();
        rv = func.apply(this, args);
        ReactDefaultPerf._allMeasurements[
          ReactDefaultPerf._allMeasurements.length - 1
        ].totalTime = performanceNow() - start;
        return rv;
      } else if (moduleName === 'ReactDOMIDOperations' ||
        moduleName === 'ReactComponentBrowserEnvironment') {
        start = performanceNow();
        rv = func.apply(this, args);
        totalTime = performanceNow() - start;

        if (fnName === 'mountImageIntoNode') {
          var mountID = ReactMount.getID(args[1]);
          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
          // special format
          args[0].forEach(function(update) {
            var writeArgs = {};
            if (update.fromIndex !== null) {
              writeArgs.fromIndex = update.fromIndex;
            }
            if (update.toIndex !== null) {
              writeArgs.toIndex = update.toIndex;
            }
            if (update.textContent !== null) {
              writeArgs.textContent = update.textContent;
            }
            if (update.markupIndex !== null) {
              writeArgs.markup = args[1][update.markupIndex];
            }
            ReactDefaultPerf._recordWrite(
              update.parentID,
              update.type,
              totalTime,
              writeArgs
            );
          });
        } else {
          // basic format
          ReactDefaultPerf._recordWrite(
            args[0],
            fnName,
            totalTime,
            Array.prototype.slice.call(args, 1)
          );
        }
        return rv;
      } else if (moduleName === 'ReactCompositeComponent' && (
        fnName === 'mountComponent' ||
        fnName === 'updateComponent' || // TODO: receiveComponent()?
        fnName === '_renderValidatedComponent')) {

        var rootNodeID = fnName === 'mountComponent' ?
          args[0] :
          this._rootNodeID;
        var isRender = fnName === '_renderValidatedComponent';
        var isMount = fnName === 'mountComponent';

        var mountStack = ReactDefaultPerf._mountStack;
        var entry = ReactDefaultPerf._allMeasurements[
          ReactDefaultPerf._allMeasurements.length - 1
        ];

        if (isRender) {
          addValue(entry.counts, rootNodeID, 1);
        } else if (isMount) {
          mountStack.push(0);
        }

        start = performanceNow();
        rv = func.apply(this, args);
        totalTime = performanceNow() - start;

        if (isRender) {
          addValue(entry.render, rootNodeID, totalTime);
        } else if (isMount) {
          var subMountTime = mountStack.pop();
          mountStack[mountStack.length - 1] += totalTime;
          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
          addValue(entry.inclusive, rootNodeID, totalTime);
        } else {
          addValue(entry.inclusive, rootNodeID, totalTime);
        }

        entry.displayNames[rootNodeID] = {
          current: this.constructor.displayName,
          owner: this._owner ? this._owner.constructor.displayName : '<root>'
        };

        return rv;
      } else {
        return func.apply(this, args);
      }
    };
  }
};

module.exports = ReactDefaultPerf;

},{"./DOMProperty":12,"./ReactDefaultPerfAnalysis":53,"./ReactMount":65,"./ReactPerf":70,"./performanceNow":141}],53:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultPerfAnalysis
 */

var assign = require("./Object.assign");

// Don't try to save users less than 1.2ms (a number I made up)
var DONT_CARE_THRESHOLD = 1.2;
var DOM_OPERATION_TYPES = {
  'mountImageIntoNode': 'set innerHTML',
  INSERT_MARKUP: 'set innerHTML',
  MOVE_EXISTING: 'move',
  REMOVE_NODE: 'remove',
  TEXT_CONTENT: 'set textContent',
  'updatePropertyByID': 'update attribute',
  'deletePropertyByID': 'delete attribute',
  'updateStylesByID': 'update styles',
  'updateInnerHTMLByID': 'set innerHTML',
  'dangerouslyReplaceNodeWithMarkupByID': 'replace'
};

function getTotalTime(measurements) {
  // TODO: return number of DOM ops? could be misleading.
  // TODO: measure dropped frames after reconcile?
  // TODO: log total time of each reconcile and the top-level component
  // class that triggered it.
  var totalTime = 0;
  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    totalTime += measurement.totalTime;
  }
  return totalTime;
}

function getDOMSummary(measurements) {
  var items = [];
  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var id;

    for (id in measurement.writes) {
      measurement.writes[id].forEach(function(write) {
        items.push({
          id: id,
          type: DOM_OPERATION_TYPES[write.type] || write.type,
          args: write.args
        });
      });
    }
  }
  return items;
}

function getExclusiveSummary(measurements) {
  var candidates = {};
  var displayName;

  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var allIDs = assign(
      {},
      measurement.exclusive,
      measurement.inclusive
    );

    for (var id in allIDs) {
      displayName = measurement.displayNames[id].current;

      candidates[displayName] = candidates[displayName] || {
        componentName: displayName,
        inclusive: 0,
        exclusive: 0,
        render: 0,
        count: 0
      };
      if (measurement.render[id]) {
        candidates[displayName].render += measurement.render[id];
      }
      if (measurement.exclusive[id]) {
        candidates[displayName].exclusive += measurement.exclusive[id];
      }
      if (measurement.inclusive[id]) {
        candidates[displayName].inclusive += measurement.inclusive[id];
      }
      if (measurement.counts[id]) {
        candidates[displayName].count += measurement.counts[id];
      }
    }
  }

  // Now make a sorted array with the results.
  var arr = [];
  for (displayName in candidates) {
    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
      arr.push(candidates[displayName]);
    }
  }

  arr.sort(function(a, b) {
    return b.exclusive - a.exclusive;
  });

  return arr;
}

function getInclusiveSummary(measurements, onlyClean) {
  var candidates = {};
  var inclusiveKey;

  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var allIDs = assign(
      {},
      measurement.exclusive,
      measurement.inclusive
    );
    var cleanComponents;

    if (onlyClean) {
      cleanComponents = getUnchangedComponents(measurement);
    }

    for (var id in allIDs) {
      if (onlyClean && !cleanComponents[id]) {
        continue;
      }

      var displayName = measurement.displayNames[id];

      // Inclusive time is not useful for many components without knowing where
      // they are instantiated. So we aggregate inclusive time with both the
      // owner and current displayName as the key.
      inclusiveKey = displayName.owner + ' > ' + displayName.current;

      candidates[inclusiveKey] = candidates[inclusiveKey] || {
        componentName: inclusiveKey,
        time: 0,
        count: 0
      };

      if (measurement.inclusive[id]) {
        candidates[inclusiveKey].time += measurement.inclusive[id];
      }
      if (measurement.counts[id]) {
        candidates[inclusiveKey].count += measurement.counts[id];
      }
    }
  }

  // Now make a sorted array with the results.
  var arr = [];
  for (inclusiveKey in candidates) {
    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
      arr.push(candidates[inclusiveKey]);
    }
  }

  arr.sort(function(a, b) {
    return b.time - a.time;
  });

  return arr;
}

function getUnchangedComponents(measurement) {
  // For a given reconcile, look at which components did not actually
  // render anything to the DOM and return a mapping of their ID to
  // the amount of time it took to render the entire subtree.
  var cleanComponents = {};
  var dirtyLeafIDs = Object.keys(measurement.writes);
  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

  for (var id in allIDs) {
    var isDirty = false;
    // For each component that rendered, see if a component that triggered
    // a DOM op is in its subtree.
    for (var i = 0; i < dirtyLeafIDs.length; i++) {
      if (dirtyLeafIDs[i].indexOf(id) === 0) {
        isDirty = true;
        break;
      }
    }
    if (!isDirty && measurement.counts[id] > 0) {
      cleanComponents[id] = true;
    }
  }
  return cleanComponents;
}

var ReactDefaultPerfAnalysis = {
  getExclusiveSummary: getExclusiveSummary,
  getInclusiveSummary: getInclusiveSummary,
  getDOMSummary: getDOMSummary,
  getTotalTime: getTotalTime
};

module.exports = ReactDefaultPerfAnalysis;

},{"./Object.assign":28}],54:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactElement
 */

"use strict";

var ReactContext = require("./ReactContext");
var ReactCurrentOwner = require("./ReactCurrentOwner");

var warning = require("./warning");

var RESERVED_PROPS = {
  key: true,
  ref: true
};

/**
 * Warn for mutations.
 *
 * @internal
 * @param {object} object
 * @param {string} key
 */
function defineWarningProperty(object, key) {
  Object.defineProperty(object, key, {

    configurable: false,
    enumerable: true,

    get: function() {
      if (!this._store) {
        return null;
      }
      return this._store[key];
    },

    set: function(value) {
      ("production" !== process.env.NODE_ENV ? warning(
        false,
        'Don\'t set the ' + key + ' property of the component. ' +
        'Mutate the existing props object instead.'
      ) : null);
      this._store[key] = value;
    }

  });
}

/**
 * This is updated to true if the membrane is successfully created.
 */
var useMutationMembrane = false;

/**
 * Warn for mutations.
 *
 * @internal
 * @param {object} element
 */
function defineMutationMembrane(prototype) {
  try {
    var pseudoFrozenProperties = {
      props: true
    };
    for (var key in pseudoFrozenProperties) {
      defineWarningProperty(prototype, key);
    }
    useMutationMembrane = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

/**
 * Base constructor for all React elements. This is only used to make this
 * work with a dynamic instanceof check. Nothing should live on this prototype.
 *
 * @param {*} type
 * @param {string|object} ref
 * @param {*} key
 * @param {*} props
 * @internal
 */
var ReactElement = function(type, key, ref, owner, context, props) {
  // Built-in properties that belong on the element
  this.type = type;
  this.key = key;
  this.ref = ref;

  // Record the component responsible for creating this element.
  this._owner = owner;

  // TODO: Deprecate withContext, and then the context becomes accessible
  // through the owner.
  this._context = context;

  if ("production" !== process.env.NODE_ENV) {
    // The validation flag and props are currently mutative. We put them on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    this._store = { validated: false, props: props };

    // We're not allowed to set props directly on the object so we early
    // return and rely on the prototype membrane to forward to the backing
    // store.
    if (useMutationMembrane) {
      Object.freeze(this);
      return;
    }
  }

  this.props = props;
};

// We intentionally don't expose the function on the constructor property.
// ReactElement should be indistinguishable from a plain object.
ReactElement.prototype = {
  _isReactElement: true
};

if ("production" !== process.env.NODE_ENV) {
  defineMutationMembrane(ReactElement.prototype);
}

ReactElement.createElement = function(type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;

  if (config != null) {
    ref = config.ref === undefined ? null : config.ref;
    if ("production" !== process.env.NODE_ENV) {
      ("production" !== process.env.NODE_ENV ? warning(
        config.key !== null,
        'createElement(...): Encountered component with a `key` of null. In ' +
        'a future version, this will be treated as equivalent to the string ' +
        '\'null\'; instead, provide an explicit key or use undefined.'
      ) : null);
    }
    // TODO: Change this back to `config.key === undefined`
    key = config.key == null ? null : '' + config.key;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (config.hasOwnProperty(propName) &&
          !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (typeof props[propName] === 'undefined') {
        props[propName] = defaultProps[propName];
      }
    }
  }

  return new ReactElement(
    type,
    key,
    ref,
    ReactCurrentOwner.current,
    ReactContext.current,
    props
  );
};

ReactElement.createFactory = function(type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. <Foo />.type === Foo.type.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceProps = function(oldElement, newProps) {
  var newElement = new ReactElement(
    oldElement.type,
    oldElement.key,
    oldElement.ref,
    oldElement._owner,
    oldElement._context,
    newProps
  );

  if ("production" !== process.env.NODE_ENV) {
    // If the key on the original is valid, then the clone is valid
    newElement._store.validated = oldElement._store.validated;
  }
  return newElement;
};

/**
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function(object) {
  // ReactTestUtils is often used outside of beforeEach where as React is
  // within it. This leads to two different instances of React on the same
  // page. To identify a element from a different React instance we use
  // a flag instead of an instanceof check.
  var isElement = !!(object && object._isReactElement);
  // if (isElement && !(object instanceof ReactElement)) {
  // This is an indicator that you're using multiple versions of React at the
  // same time. This will screw with ownership and stuff. Fix it, please.
  // TODO: We could possibly warn here.
  // }
  return isElement;
};

module.exports = ReactElement;

}).call(this,require('_process'))
},{"./ReactContext":37,"./ReactCurrentOwner":38,"./warning":147,"_process":2}],55:[function(require,module,exports){
/**
 * Copyright 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactElementValidator
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

"use strict";

var ReactElement = require("./ReactElement");
var ReactPropTypeLocations = require("./ReactPropTypeLocations");
var ReactCurrentOwner = require("./ReactCurrentOwner");

var monitorCodeUse = require("./monitorCodeUse");

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {
  'react_key_warning': {},
  'react_numeric_key_warning': {}
};
var ownerHasMonitoredObjectMap = {};

var loggedTypeFailures = {};

var NUMERIC_PROPERTY_REGEX = /^\d+$/;

/**
 * Gets the current owner's displayName for use in warnings.
 *
 * @internal
 * @return {?string} Display name or undefined
 */
function getCurrentOwnerDisplayName() {
  var current = ReactCurrentOwner.current;
  return current && current.constructor.displayName || undefined;
}

/**
 * Warn if the component doesn't have an explicit key assigned to it.
 * This component is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it.
 *
 * @internal
 * @param {ReactComponent} component Component that requires a key.
 * @param {*} parentType component's parent's type.
 */
function validateExplicitKey(component, parentType) {
  if (component._store.validated || component.key != null) {
    return;
  }
  component._store.validated = true;

  warnAndMonitorForKeyUse(
    'react_key_warning',
    'Each child in an array should have a unique "key" prop.',
    component,
    parentType
  );
}

/**
 * Warn if the key is being defined as an object property but has an incorrect
 * value.
 *
 * @internal
 * @param {string} name Property name of the key.
 * @param {ReactComponent} component Component that requires a key.
 * @param {*} parentType component's parent's type.
 */
function validatePropertyKey(name, component, parentType) {
  if (!NUMERIC_PROPERTY_REGEX.test(name)) {
    return;
  }
  warnAndMonitorForKeyUse(
    'react_numeric_key_warning',
    'Child objects should have non-numeric keys so ordering is preserved.',
    component,
    parentType
  );
}

/**
 * Shared warning and monitoring code for the key warnings.
 *
 * @internal
 * @param {string} warningID The id used when logging.
 * @param {string} message The base warning that gets output.
 * @param {ReactComponent} component Component that requires a key.
 * @param {*} parentType component's parent's type.
 */
function warnAndMonitorForKeyUse(warningID, message, component, parentType) {
  var ownerName = getCurrentOwnerDisplayName();
  var parentName = parentType.displayName;

  var useName = ownerName || parentName;
  var memoizer = ownerHasKeyUseWarning[warningID];
  if (memoizer.hasOwnProperty(useName)) {
    return;
  }
  memoizer[useName] = true;

  message += ownerName ?
    (" Check the render method of " + ownerName + ".") :
    (" Check the renderComponent call using <" + parentName + ">.");

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwnerName = null;
  if (component._owner && component._owner !== ReactCurrentOwner.current) {
    // Name of the component that originally created this child.
    childOwnerName = component._owner.constructor.displayName;

    message += (" It was passed a child from " + childOwnerName + ".");
  }

  message += ' See http://fb.me/react-warning-keys for more information.';
  monitorCodeUse(warningID, {
    component: useName,
    componentOwner: childOwnerName
  });
  console.warn(message);
}

/**
 * Log that we're using an object map. We're considering deprecating this
 * feature and replace it with proper Map and ImmutableMap data structures.
 *
 * @internal
 */
function monitorUseOfObjectMap() {
  var currentName = getCurrentOwnerDisplayName() || '';
  if (ownerHasMonitoredObjectMap.hasOwnProperty(currentName)) {
    return;
  }
  ownerHasMonitoredObjectMap[currentName] = true;
  monitorCodeUse('react_object_map_children');
}

/**
 * Ensure that every component either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {*} component Statically passed child of any type.
 * @param {*} parentType component's parent's type.
 * @return {boolean}
 */
function validateChildKeys(component, parentType) {
  if (Array.isArray(component)) {
    for (var i = 0; i < component.length; i++) {
      var child = component[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(component)) {
    // This component was passed in a valid location.
    component._store.validated = true;
  } else if (component && typeof component === 'object') {
    monitorUseOfObjectMap();
    for (var name in component) {
      validatePropertyKey(name, component[name], parentType);
    }
  }
}

/**
 * Assert that the props are valid
 *
 * @param {string} componentName Name of the component for error messages.
 * @param {object} propTypes Map of prop name to a ReactPropType
 * @param {object} props
 * @param {string} location e.g. "prop", "context", "child context"
 * @private
 */
function checkPropTypes(componentName, propTypes, props, location) {
  for (var propName in propTypes) {
    if (propTypes.hasOwnProperty(propName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        error = propTypes[propName](props, propName, componentName, location);
      } catch (ex) {
        error = ex;
      }
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;
        // This will soon use the warning module
        monitorCodeUse(
          'react_failed_descriptor_type_check',
          { message: error.message }
        );
      }
    }
  }
}

var ReactElementValidator = {

  createElement: function(type, props, children) {
    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }

    var name = type.displayName;
    if (type.propTypes) {
      checkPropTypes(
        name,
        type.propTypes,
        element.props,
        ReactPropTypeLocations.prop
      );
    }
    if (type.contextTypes) {
      checkPropTypes(
        name,
        type.contextTypes,
        element._context,
        ReactPropTypeLocations.context
      );
    }
    return element;
  },

  createFactory: function(type) {
    var validatedFactory = ReactElementValidator.createElement.bind(
      null,
      type
    );
    validatedFactory.type = type;
    return validatedFactory;
  }

};

module.exports = ReactElementValidator;

},{"./ReactCurrentOwner":38,"./ReactElement":54,"./ReactPropTypeLocations":73,"./monitorCodeUse":138}],56:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEmptyComponent
 */

"use strict";

var ReactElement = require("./ReactElement");

var invariant = require("./invariant");

var component;
// This registry keeps track of the React IDs of the components that rendered to
// `null` (in reality a placeholder such as `noscript`)
var nullComponentIdsRegistry = {};

var ReactEmptyComponentInjection = {
  injectEmptyComponent: function(emptyComponent) {
    component = ReactElement.createFactory(emptyComponent);
  }
};

/**
 * @return {ReactComponent} component The injected empty component.
 */
function getEmptyComponent() {
  ("production" !== process.env.NODE_ENV ? invariant(
    component,
    'Trying to return null from a render, but no null placeholder component ' +
    'was injected.'
  ) : invariant(component));
  return component();
}

/**
 * Mark the component as having rendered to null.
 * @param {string} id Component's `_rootNodeID`.
 */
function registerNullComponentID(id) {
  nullComponentIdsRegistry[id] = true;
}

/**
 * Unmark the component as having rendered to null: it renders to something now.
 * @param {string} id Component's `_rootNodeID`.
 */
function deregisterNullComponentID(id) {
  delete nullComponentIdsRegistry[id];
}

/**
 * @param {string} id Component's `_rootNodeID`.
 * @return {boolean} True if the component is rendered to null.
 */
function isNullComponentID(id) {
  return nullComponentIdsRegistry[id];
}

var ReactEmptyComponent = {
  deregisterNullComponentID: deregisterNullComponentID,
  getEmptyComponent: getEmptyComponent,
  injection: ReactEmptyComponentInjection,
  isNullComponentID: isNullComponentID,
  registerNullComponentID: registerNullComponentID
};

module.exports = ReactEmptyComponent;

}).call(this,require('_process'))
},{"./ReactElement":54,"./invariant":128,"_process":2}],57:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactErrorUtils
 * @typechecks
 */

"use strict";

var ReactErrorUtils = {
  /**
   * Creates a guarded version of a function. This is supposed to make debugging
   * of event handlers easier. To aid debugging with the browser's debugger,
   * this currently simply returns the original function.
   *
   * @param {function} func Function to be executed
   * @param {string} name The name of the guard
   * @return {function}
   */
  guard: function(func, name) {
    return func;
  }
};

module.exports = ReactErrorUtils;

},{}],58:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEventEmitterMixin
 */

"use strict";

var EventPluginHub = require("./EventPluginHub");

function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue();
}

var ReactEventEmitterMixin = {

  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {object} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native environment event.
   */
  handleTopLevel: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {
    var events = EventPluginHub.extractEvents(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent
    );

    runEventQueueInBatch(events);
  }
};

module.exports = ReactEventEmitterMixin;

},{"./EventPluginHub":19}],59:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEventListener
 * @typechecks static-only
 */

"use strict";

var EventListener = require("./EventListener");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var PooledClass = require("./PooledClass");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactMount = require("./ReactMount");
var ReactUpdates = require("./ReactUpdates");

var assign = require("./Object.assign");
var getEventTarget = require("./getEventTarget");
var getUnboundedScrollPosition = require("./getUnboundedScrollPosition");

/**
 * Finds the parent React component of `node`.
 *
 * @param {*} node
 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
 *                           is not nested.
 */
function findParent(node) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  var nodeID = ReactMount.getID(node);
  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
  var container = ReactMount.findReactContainerForID(rootID);
  var parent = ReactMount.getFirstReactDOM(container);
  return parent;
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
assign(TopLevelCallbackBookKeeping.prototype, {
  destructor: function() {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(
  TopLevelCallbackBookKeeping,
  PooledClass.twoArgumentPooler
);

function handleTopLevelImpl(bookKeeping) {
  var topLevelTarget = ReactMount.getFirstReactDOM(
    getEventTarget(bookKeeping.nativeEvent)
  ) || window;

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = topLevelTarget;
  while (ancestor) {
    bookKeeping.ancestors.push(ancestor);
    ancestor = findParent(ancestor);
  }

  for (var i = 0, l = bookKeeping.ancestors.length; i < l; i++) {
    topLevelTarget = bookKeeping.ancestors[i];
    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
    ReactEventListener._handleTopLevel(
      bookKeeping.topLevelType,
      topLevelTarget,
      topLevelTargetID,
      bookKeeping.nativeEvent
    );
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function(handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function(enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function() {
    return ReactEventListener._enabled;
  },


  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return;
    }
    return EventListener.listen(
      element,
      handlerBaseName,
      ReactEventListener.dispatchEvent.bind(null, topLevelType)
    );
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return;
    }
    return EventListener.capture(
      element,
      handlerBaseName,
      ReactEventListener.dispatchEvent.bind(null, topLevelType)
    );
  },

  monitorScrollValue: function(refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
    EventListener.listen(window, 'resize', callback);
  },

  dispatchEvent: function(topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(
      topLevelType,
      nativeEvent
    );
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;

},{"./EventListener":18,"./ExecutionEnvironment":23,"./Object.assign":28,"./PooledClass":29,"./ReactInstanceHandles":62,"./ReactMount":65,"./ReactUpdates":81,"./getEventTarget":119,"./getUnboundedScrollPosition":124}],60:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInjection
 */

"use strict";

var DOMProperty = require("./DOMProperty");
var EventPluginHub = require("./EventPluginHub");
var ReactComponent = require("./ReactComponent");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactEmptyComponent = require("./ReactEmptyComponent");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactNativeComponent = require("./ReactNativeComponent");
var ReactPerf = require("./ReactPerf");
var ReactRootIndex = require("./ReactRootIndex");
var ReactUpdates = require("./ReactUpdates");

var ReactInjection = {
  Component: ReactComponent.injection,
  CompositeComponent: ReactCompositeComponent.injection,
  DOMProperty: DOMProperty.injection,
  EmptyComponent: ReactEmptyComponent.injection,
  EventPluginHub: EventPluginHub.injection,
  EventEmitter: ReactBrowserEventEmitter.injection,
  NativeComponent: ReactNativeComponent.injection,
  Perf: ReactPerf.injection,
  RootIndex: ReactRootIndex.injection,
  Updates: ReactUpdates.injection
};

module.exports = ReactInjection;

},{"./DOMProperty":12,"./EventPluginHub":19,"./ReactBrowserEventEmitter":32,"./ReactComponent":34,"./ReactCompositeComponent":36,"./ReactEmptyComponent":56,"./ReactNativeComponent":68,"./ReactPerf":70,"./ReactRootIndex":77,"./ReactUpdates":81}],61:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInputSelection
 */

"use strict";

var ReactDOMSelection = require("./ReactDOMSelection");

var containsNode = require("./containsNode");
var focusNode = require("./focusNode");
var getActiveElement = require("./getActiveElement");

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection = {

  hasSelectionCapabilities: function(elem) {
    return elem && (
      (elem.nodeName === 'INPUT' && elem.type === 'text') ||
      elem.nodeName === 'TEXTAREA' ||
      elem.contentEditable === 'true'
    );
  },

  getSelectionInformation: function() {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange:
          ReactInputSelection.hasSelectionCapabilities(focusedElem) ?
          ReactInputSelection.getSelection(focusedElem) :
          null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function(priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem &&
        isInDocument(priorFocusedElem)) {
      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection.setSelection(
          priorFocusedElem,
          priorSelectionRange
        );
      }
      focusNode(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function(input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && input.nodeName === 'INPUT') {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || {start: 0, end: 0};
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function(input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (typeof end === 'undefined') {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && input.nodeName === 'INPUT') {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;

},{"./ReactDOMSelection":48,"./containsNode":103,"./focusNode":113,"./getActiveElement":115}],62:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInstanceHandles
 * @typechecks static-only
 */

"use strict";

var ReactRootIndex = require("./ReactRootIndex");

var invariant = require("./invariant");

var SEPARATOR = '.';
var SEPARATOR_LENGTH = SEPARATOR.length;

/**
 * Maximum depth of traversals before we consider the possibility of a bad ID.
 */
var MAX_TREE_DEPTH = 100;

/**
 * Creates a DOM ID prefix to use when mounting React components.
 *
 * @param {number} index A unique integer
 * @return {string} React root ID.
 * @internal
 */
function getReactRootIDString(index) {
  return SEPARATOR + index.toString(36);
}

/**
 * Checks if a character in the supplied ID is a separator or the end.
 *
 * @param {string} id A React DOM ID.
 * @param {number} index Index of the character to check.
 * @return {boolean} True if the character is a separator or end of the ID.
 * @private
 */
function isBoundary(id, index) {
  return id.charAt(index) === SEPARATOR || index === id.length;
}

/**
 * Checks if the supplied string is a valid React DOM ID.
 *
 * @param {string} id A React DOM ID, maybe.
 * @return {boolean} True if the string is a valid React DOM ID.
 * @private
 */
function isValidID(id) {
  return id === '' || (
    id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR
  );
}

/**
 * Checks if the first ID is an ancestor of or equal to the second ID.
 *
 * @param {string} ancestorID
 * @param {string} descendantID
 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
 * @internal
 */
function isAncestorIDOf(ancestorID, descendantID) {
  return (
    descendantID.indexOf(ancestorID) === 0 &&
    isBoundary(descendantID, ancestorID.length)
  );
}

/**
 * Gets the parent ID of the supplied React DOM ID, `id`.
 *
 * @param {string} id ID of a component.
 * @return {string} ID of the parent, or an empty string.
 * @private
 */
function getParentID(id) {
  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
}

/**
 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
 * supplied `destinationID`. If they are equal, the ID is returned.
 *
 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
 * @param {string} destinationID ID of the destination node.
 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
 * @private
 */
function getNextDescendantID(ancestorID, destinationID) {
  ("production" !== process.env.NODE_ENV ? invariant(
    isValidID(ancestorID) && isValidID(destinationID),
    'getNextDescendantID(%s, %s): Received an invalid React DOM ID.',
    ancestorID,
    destinationID
  ) : invariant(isValidID(ancestorID) && isValidID(destinationID)));
  ("production" !== process.env.NODE_ENV ? invariant(
    isAncestorIDOf(ancestorID, destinationID),
    'getNextDescendantID(...): React has made an invalid assumption about ' +
    'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.',
    ancestorID,
    destinationID
  ) : invariant(isAncestorIDOf(ancestorID, destinationID)));
  if (ancestorID === destinationID) {
    return ancestorID;
  }
  // Skip over the ancestor and the immediate separator. Traverse until we hit
  // another separator or we reach the end of `destinationID`.
  var start = ancestorID.length + SEPARATOR_LENGTH;
  for (var i = start; i < destinationID.length; i++) {
    if (isBoundary(destinationID, i)) {
      break;
    }
  }
  return destinationID.substr(0, i);
}

/**
 * Gets the nearest common ancestor ID of two IDs.
 *
 * Using this ID scheme, the nearest common ancestor ID is the longest common
 * prefix of the two IDs that immediately preceded a "marker" in both strings.
 *
 * @param {string} oneID
 * @param {string} twoID
 * @return {string} Nearest common ancestor ID, or the empty string if none.
 * @private
 */
function getFirstCommonAncestorID(oneID, twoID) {
  var minLength = Math.min(oneID.length, twoID.length);
  if (minLength === 0) {
    return '';
  }
  var lastCommonMarkerIndex = 0;
  // Use `<=` to traverse until the "EOL" of the shorter string.
  for (var i = 0; i <= minLength; i++) {
    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
      lastCommonMarkerIndex = i;
    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
      break;
    }
  }
  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
  ("production" !== process.env.NODE_ENV ? invariant(
    isValidID(longestCommonID),
    'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s',
    oneID,
    twoID,
    longestCommonID
  ) : invariant(isValidID(longestCommonID)));
  return longestCommonID;
}

/**
 * Traverses the parent path between two IDs (either up or down). The IDs must
 * not be the same, and there must exist a parent path between them. If the
 * callback returns `false`, traversal is stopped.
 *
 * @param {?string} start ID at which to start traversal.
 * @param {?string} stop ID at which to end traversal.
 * @param {function} cb Callback to invoke each ID with.
 * @param {?boolean} skipFirst Whether or not to skip the first node.
 * @param {?boolean} skipLast Whether or not to skip the last node.
 * @private
 */
function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
  start = start || '';
  stop = stop || '';
  ("production" !== process.env.NODE_ENV ? invariant(
    start !== stop,
    'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.',
    start
  ) : invariant(start !== stop));
  var traverseUp = isAncestorIDOf(stop, start);
  ("production" !== process.env.NODE_ENV ? invariant(
    traverseUp || isAncestorIDOf(start, stop),
    'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' +
    'not have a parent path.',
    start,
    stop
  ) : invariant(traverseUp || isAncestorIDOf(start, stop)));
  // Traverse from `start` to `stop` one depth at a time.
  var depth = 0;
  var traverse = traverseUp ? getParentID : getNextDescendantID;
  for (var id = start; /* until break */; id = traverse(id, stop)) {
    var ret;
    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
      ret = cb(id, traverseUp, arg);
    }
    if (ret === false || id === stop) {
      // Only break //after// visiting `stop`.
      break;
    }
    ("production" !== process.env.NODE_ENV ? invariant(
      depth++ < MAX_TREE_DEPTH,
      'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' +
      'traversing the React DOM ID tree. This may be due to malformed IDs: %s',
      start, stop
    ) : invariant(depth++ < MAX_TREE_DEPTH));
  }
}

/**
 * Manages the IDs assigned to DOM representations of React components. This
 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
 * order to simulate events).
 *
 * @internal
 */
var ReactInstanceHandles = {

  /**
   * Constructs a React root ID
   * @return {string} A React root ID.
   */
  createReactRootID: function() {
    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
  },

  /**
   * Constructs a React ID by joining a root ID with a name.
   *
   * @param {string} rootID Root ID of a parent component.
   * @param {string} name A component's name (as flattened children).
   * @return {string} A React ID.
   * @internal
   */
  createReactID: function(rootID, name) {
    return rootID + name;
  },

  /**
   * Gets the DOM ID of the React component that is the root of the tree that
   * contains the React component with the supplied DOM ID.
   *
   * @param {string} id DOM ID of a React component.
   * @return {?string} DOM ID of the React component that is the root.
   * @internal
   */
  getReactRootIDFromNodeID: function(id) {
    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
      var index = id.indexOf(SEPARATOR, 1);
      return index > -1 ? id.substr(0, index) : id;
    }
    return null;
  },

  /**
   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
   * should would receive a `mouseEnter` or `mouseLeave` event.
   *
   * NOTE: Does not invoke the callback on the nearest common ancestor because
   * nothing "entered" or "left" that element.
   *
   * @param {string} leaveID ID being left.
   * @param {string} enterID ID being entered.
   * @param {function} cb Callback to invoke on each entered/left ID.
   * @param {*} upArg Argument to invoke the callback with on left IDs.
   * @param {*} downArg Argument to invoke the callback with on entered IDs.
   * @internal
   */
  traverseEnterLeave: function(leaveID, enterID, cb, upArg, downArg) {
    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
    if (ancestorID !== leaveID) {
      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
    }
    if (ancestorID !== enterID) {
      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
    }
  },

  /**
   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
   *
   * NOTE: This traversal happens on IDs without touching the DOM.
   *
   * @param {string} targetID ID of the target node.
   * @param {function} cb Callback to invoke.
   * @param {*} arg Argument to invoke the callback with.
   * @internal
   */
  traverseTwoPhase: function(targetID, cb, arg) {
    if (targetID) {
      traverseParentPath('', targetID, cb, arg, true, false);
      traverseParentPath(targetID, '', cb, arg, false, true);
    }
  },

  /**
   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
   * example, passing `.0.$row-0.1` would result in `cb` getting called
   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
   *
   * NOTE: This traversal happens on IDs without touching the DOM.
   *
   * @param {string} targetID ID of the target node.
   * @param {function} cb Callback to invoke.
   * @param {*} arg Argument to invoke the callback with.
   * @internal
   */
  traverseAncestors: function(targetID, cb, arg) {
    traverseParentPath('', targetID, cb, arg, true, false);
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _getFirstCommonAncestorID: getFirstCommonAncestorID,

  /**
   * Exposed for unit testing.
   * @private
   */
  _getNextDescendantID: getNextDescendantID,

  isAncestorIDOf: isAncestorIDOf,

  SEPARATOR: SEPARATOR

};

module.exports = ReactInstanceHandles;

}).call(this,require('_process'))
},{"./ReactRootIndex":77,"./invariant":128,"_process":2}],63:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactLegacyElement
 */

"use strict";

var ReactCurrentOwner = require("./ReactCurrentOwner");

var invariant = require("./invariant");
var monitorCodeUse = require("./monitorCodeUse");
var warning = require("./warning");

var legacyFactoryLogs = {};
function warnForLegacyFactoryCall() {
  if (!ReactLegacyElementFactory._isLegacyCallWarningEnabled) {
    return;
  }
  var owner = ReactCurrentOwner.current;
  var name = owner && owner.constructor ? owner.constructor.displayName : '';
  if (!name) {
    name = 'Something';
  }
  if (legacyFactoryLogs.hasOwnProperty(name)) {
    return;
  }
  legacyFactoryLogs[name] = true;
  ("production" !== process.env.NODE_ENV ? warning(
    false,
    name + ' is calling a React component directly. ' +
    'Use a factory or JSX instead. See: http://fb.me/react-legacyfactory'
  ) : null);
  monitorCodeUse('react_legacy_factory_call', { version: 3, name: name });
}

function warnForPlainFunctionType(type) {
  var isReactClass =
    type.prototype &&
    typeof type.prototype.mountComponent === 'function' &&
    typeof type.prototype.receiveComponent === 'function';
  if (isReactClass) {
    ("production" !== process.env.NODE_ENV ? warning(
      false,
      'Did not expect to get a React class here. Use `Component` instead ' +
      'of `Component.type` or `this.constructor`.'
    ) : null);
  } else {
    if (!type._reactWarnedForThisType) {
      try {
        type._reactWarnedForThisType = true;
      } catch (x) {
        // just incase this is a frozen object or some special object
      }
      monitorCodeUse(
        'react_non_component_in_jsx',
        { version: 3, name: type.name }
      );
    }
    ("production" !== process.env.NODE_ENV ? warning(
      false,
      'This JSX uses a plain function. Only React components are ' +
      'valid in React\'s JSX transform.'
    ) : null);
  }
}

function warnForNonLegacyFactory(type) {
  ("production" !== process.env.NODE_ENV ? warning(
    false,
    'Do not pass React.DOM.' + type.type + ' to JSX or createFactory. ' +
    'Use the string "' + type.type + '" instead.'
  ) : null);
}

/**
 * Transfer static properties from the source to the target. Functions are
 * rebound to have this reflect the original source.
 */
function proxyStaticMethods(target, source) {
  if (typeof source !== 'function') {
    return;
  }
  for (var key in source) {
    if (source.hasOwnProperty(key)) {
      var value = source[key];
      if (typeof value === 'function') {
        var bound = value.bind(source);
        // Copy any properties defined on the function, such as `isRequired` on
        // a PropTypes validator.
        for (var k in value) {
          if (value.hasOwnProperty(k)) {
            bound[k] = value[k];
          }
        }
        target[key] = bound;
      } else {
        target[key] = value;
      }
    }
  }
}

// We use an object instead of a boolean because booleans are ignored by our
// mocking libraries when these factories gets mocked.
var LEGACY_MARKER = {};
var NON_LEGACY_MARKER = {};

var ReactLegacyElementFactory = {};

ReactLegacyElementFactory.wrapCreateFactory = function(createFactory) {
  var legacyCreateFactory = function(type) {
    if (typeof type !== 'function') {
      // Non-function types cannot be legacy factories
      return createFactory(type);
    }

    if (type.isReactNonLegacyFactory) {
      // This is probably a factory created by ReactDOM we unwrap it to get to
      // the underlying string type. It shouldn't have been passed here so we
      // warn.
      if ("production" !== process.env.NODE_ENV) {
        warnForNonLegacyFactory(type);
      }
      return createFactory(type.type);
    }

    if (type.isReactLegacyFactory) {
      // This is probably a legacy factory created by ReactCompositeComponent.
      // We unwrap it to get to the underlying class.
      return createFactory(type.type);
    }

    if ("production" !== process.env.NODE_ENV) {
      warnForPlainFunctionType(type);
    }

    // Unless it's a legacy factory, then this is probably a plain function,
    // that is expecting to be invoked by JSX. We can just return it as is.
    return type;
  };
  return legacyCreateFactory;
};

ReactLegacyElementFactory.wrapCreateElement = function(createElement) {
  var legacyCreateElement = function(type, props, children) {
    if (typeof type !== 'function') {
      // Non-function types cannot be legacy factories
      return createElement.apply(this, arguments);
    }

    var args;

    if (type.isReactNonLegacyFactory) {
      // This is probably a factory created by ReactDOM we unwrap it to get to
      // the underlying string type. It shouldn't have been passed here so we
      // warn.
      if ("production" !== process.env.NODE_ENV) {
        warnForNonLegacyFactory(type);
      }
      args = Array.prototype.slice.call(arguments, 0);
      args[0] = type.type;
      return createElement.apply(this, args);
    }

    if (type.isReactLegacyFactory) {
      // This is probably a legacy factory created by ReactCompositeComponent.
      // We unwrap it to get to the underlying class.
      if (type._isMockFunction) {
        // If this is a mock function, people will expect it to be called. We
        // will actually call the original mock factory function instead. This
        // future proofs unit testing that assume that these are classes.
        type.type._mockedReactClassConstructor = type;
      }
      args = Array.prototype.slice.call(arguments, 0);
      args[0] = type.type;
      return createElement.apply(this, args);
    }

    if ("production" !== process.env.NODE_ENV) {
      warnForPlainFunctionType(type);
    }

    // This is being called with a plain function we should invoke it
    // immediately as if this was used with legacy JSX.
    return type.apply(null, Array.prototype.slice.call(arguments, 1));
  };
  return legacyCreateElement;
};

ReactLegacyElementFactory.wrapFactory = function(factory) {
  ("production" !== process.env.NODE_ENV ? invariant(
    typeof factory === 'function',
    'This is suppose to accept a element factory'
  ) : invariant(typeof factory === 'function'));
  var legacyElementFactory = function(config, children) {
    // This factory should not be called when JSX is used. Use JSX instead.
    if ("production" !== process.env.NODE_ENV) {
      warnForLegacyFactoryCall();
    }
    return factory.apply(this, arguments);
  };
  proxyStaticMethods(legacyElementFactory, factory.type);
  legacyElementFactory.isReactLegacyFactory = LEGACY_MARKER;
  legacyElementFactory.type = factory.type;
  return legacyElementFactory;
};

// This is used to mark a factory that will remain. E.g. we're allowed to call
// it as a function. However, you're not suppose to pass it to createElement
// or createFactory, so it will warn you if you do.
ReactLegacyElementFactory.markNonLegacyFactory = function(factory) {
  factory.isReactNonLegacyFactory = NON_LEGACY_MARKER;
  return factory;
};

// Checks if a factory function is actually a legacy factory pretending to
// be a class.
ReactLegacyElementFactory.isValidFactory = function(factory) {
  // TODO: This will be removed and moved into a class validator or something.
  return typeof factory === 'function' &&
    factory.isReactLegacyFactory === LEGACY_MARKER;
};

ReactLegacyElementFactory.isValidClass = function(factory) {
  if ("production" !== process.env.NODE_ENV) {
    ("production" !== process.env.NODE_ENV ? warning(
      false,
      'isValidClass is deprecated and will be removed in a future release. ' +
      'Use a more specific validator instead.'
    ) : null);
  }
  return ReactLegacyElementFactory.isValidFactory(factory);
};

ReactLegacyElementFactory._isLegacyCallWarningEnabled = true;

module.exports = ReactLegacyElementFactory;

}).call(this,require('_process'))
},{"./ReactCurrentOwner":38,"./invariant":128,"./monitorCodeUse":138,"./warning":147,"_process":2}],64:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMarkupChecksum
 */

"use strict";

var adler32 = require("./adler32");

var ReactMarkupChecksum = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function(markup) {
    var checksum = adler32(markup);
    return markup.replace(
      '>',
      ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '">'
    );
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function(markup, element) {
    var existingChecksum = element.getAttribute(
      ReactMarkupChecksum.CHECKSUM_ATTR_NAME
    );
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

module.exports = ReactMarkupChecksum;

},{"./adler32":100}],65:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMount
 */

"use strict";

var DOMProperty = require("./DOMProperty");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactElement = require("./ReactElement");
var ReactLegacyElement = require("./ReactLegacyElement");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactPerf = require("./ReactPerf");

var containsNode = require("./containsNode");
var deprecated = require("./deprecated");
var getReactRootElementInContainer = require("./getReactRootElementInContainer");
var instantiateReactComponent = require("./instantiateReactComponent");
var invariant = require("./invariant");
var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
var warning = require("./warning");

var createElement = ReactLegacyElement.wrapCreateElement(
  ReactElement.createElement
);

var SEPARATOR = ReactInstanceHandles.SEPARATOR;

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var nodeCache = {};

var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;

/** Mapping from reactRootID to React component instance. */
var instancesByReactRootID = {};

/** Mapping from reactRootID to `container` nodes. */
var containersByReactRootID = {};

if ("production" !== process.env.NODE_ENV) {
  /** __DEV__-only mapping from reactRootID to root elements. */
  var rootElementsByReactRootID = {};
}

// Used to store breadth-first search state in findComponentRoot.
var findComponentRootReusableArray = [];

/**
 * @param {DOMElement} container DOM element that may contain a React component.
 * @return {?string} A "reactRoot" ID, if a React component is rendered.
 */
function getReactRootID(container) {
  var rootElement = getReactRootElementInContainer(container);
  return rootElement && ReactMount.getID(rootElement);
}

/**
 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
 * element can return its control whose name or ID equals ATTR_NAME. All
 * DOM nodes support `getAttributeNode` but this can also get called on
 * other objects so just return '' if we're given something other than a
 * DOM node (such as window).
 *
 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
 * @return {string} ID of the supplied `domNode`.
 */
function getID(node) {
  var id = internalGetID(node);
  if (id) {
    if (nodeCache.hasOwnProperty(id)) {
      var cached = nodeCache[id];
      if (cached !== node) {
        ("production" !== process.env.NODE_ENV ? invariant(
          !isValid(cached, id),
          'ReactMount: Two valid but unequal nodes with the same `%s`: %s',
          ATTR_NAME, id
        ) : invariant(!isValid(cached, id)));

        nodeCache[id] = node;
      }
    } else {
      nodeCache[id] = node;
    }
  }

  return id;
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
}

/**
 * Sets the React-specific ID of the given node.
 *
 * @param {DOMElement} node The DOM node whose ID will be set.
 * @param {string} id The value of the ID attribute.
 */
function setID(node, id) {
  var oldID = internalGetID(node);
  if (oldID !== id) {
    delete nodeCache[oldID];
  }
  node.setAttribute(ATTR_NAME, id);
  nodeCache[id] = node;
}

/**
 * Finds the node with the supplied React-generated DOM ID.
 *
 * @param {string} id A React-generated DOM ID.
 * @return {DOMElement} DOM node with the suppled `id`.
 * @internal
 */
function getNode(id) {
  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
    nodeCache[id] = ReactMount.findReactNodeByID(id);
  }
  return nodeCache[id];
}

/**
 * A node is "valid" if it is contained by a currently mounted container.
 *
 * This means that the node does not have to be contained by a document in
 * order to be considered valid.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @param {string} id The expected ID of the node.
 * @return {boolean} Whether the node is contained by a mounted container.
 */
function isValid(node, id) {
  if (node) {
    ("production" !== process.env.NODE_ENV ? invariant(
      internalGetID(node) === id,
      'ReactMount: Unexpected modification of `%s`',
      ATTR_NAME
    ) : invariant(internalGetID(node) === id));

    var container = ReactMount.findReactContainerForID(id);
    if (container && containsNode(container, node)) {
      return true;
    }
  }

  return false;
}

/**
 * Causes the cache to forget about one React-specific ID.
 *
 * @param {string} id The ID to forget.
 */
function purgeID(id) {
  delete nodeCache[id];
}

var deepestNodeSoFar = null;
function findDeepestCachedAncestorImpl(ancestorID) {
  var ancestor = nodeCache[ancestorID];
  if (ancestor && isValid(ancestor, ancestorID)) {
    deepestNodeSoFar = ancestor;
  } else {
    // This node isn't populated in the cache, so presumably none of its
    // descendants are. Break out of the loop.
    return false;
  }
}

/**
 * Return the deepest cached node whose ID is a prefix of `targetID`.
 */
function findDeepestCachedAncestor(targetID) {
  deepestNodeSoFar = null;
  ReactInstanceHandles.traverseAncestors(
    targetID,
    findDeepestCachedAncestorImpl
  );

  var foundNode = deepestNodeSoFar;
  deepestNodeSoFar = null;
  return foundNode;
}

/**
 * Mounting is the process of initializing a React component by creatings its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.render(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount = {
  /** Exposed for debugging purposes **/
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function(container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactComponent} nextComponent component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function(
      prevComponent,
      nextComponent,
      container,
      callback) {
    var nextProps = nextComponent.props;
    ReactMount.scrollMonitor(container, function() {
      prevComponent.replaceProps(nextProps, callback);
    });

    if ("production" !== process.env.NODE_ENV) {
      // Record the root element in case it later gets transplanted.
      rootElementsByReactRootID[getReactRootID(container)] =
        getReactRootElementInContainer(container);
    }

    return prevComponent;
  },

  /**
   * Register a component into the instance map and starts scroll value
   * monitoring
   * @param {ReactComponent} nextComponent component instance to render
   * @param {DOMElement} container container to render into
   * @return {string} reactRoot ID prefix
   */
  _registerComponent: function(nextComponent, container) {
    ("production" !== process.env.NODE_ENV ? invariant(
      container && (
        container.nodeType === ELEMENT_NODE_TYPE ||
        container.nodeType === DOC_NODE_TYPE
      ),
      '_registerComponent(...): Target container is not a DOM element.'
    ) : invariant(container && (
      container.nodeType === ELEMENT_NODE_TYPE ||
      container.nodeType === DOC_NODE_TYPE
    )));

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();

    var reactRootID = ReactMount.registerContainer(container);
    instancesByReactRootID[reactRootID] = nextComponent;
    return reactRootID;
  },

  /**
   * Render a new component into the DOM.
   * @param {ReactComponent} nextComponent component instance to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: ReactPerf.measure(
    'ReactMount',
    '_renderNewRootComponent',
    function(
        nextComponent,
        container,
        shouldReuseMarkup) {
      // Various parts of our code (such as ReactCompositeComponent's
      // _renderValidatedComponent) assume that calls to render aren't nested;
      // verify that that's the case.
      ("production" !== process.env.NODE_ENV ? warning(
        ReactCurrentOwner.current == null,
        '_renderNewRootComponent(): Render methods should be a pure function ' +
        'of props and state; triggering nested component updates from ' +
        'render is not allowed. If necessary, trigger nested updates in ' +
        'componentDidUpdate.'
      ) : null);

      var componentInstance = instantiateReactComponent(nextComponent, null);
      var reactRootID = ReactMount._registerComponent(
        componentInstance,
        container
      );
      componentInstance.mountComponentIntoNode(
        reactRootID,
        container,
        shouldReuseMarkup
      );

      if ("production" !== process.env.NODE_ENV) {
        // Record the root element in case it later gets transplanted.
        rootElementsByReactRootID[reactRootID] =
          getReactRootElementInContainer(container);
      }

      return componentInstance;
    }
  ),

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  render: function(nextElement, container, callback) {
    ("production" !== process.env.NODE_ENV ? invariant(
      ReactElement.isValidElement(nextElement),
      'renderComponent(): Invalid component element.%s',
      (
        typeof nextElement === 'string' ?
          ' Instead of passing an element string, make sure to instantiate ' +
          'it by passing it to React.createElement.' :
        ReactLegacyElement.isValidFactory(nextElement) ?
          ' Instead of passing a component class, make sure to instantiate ' +
          'it by passing it to React.createElement.' :
        // Check if it quacks like a element
        typeof nextElement.props !== "undefined" ?
          ' This may be caused by unintentionally loading two independent ' +
          'copies of React.' :
          ''
      )
    ) : invariant(ReactElement.isValidElement(nextElement)));

    var prevComponent = instancesByReactRootID[getReactRootID(container)];

    if (prevComponent) {
      var prevElement = prevComponent._currentElement;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        return ReactMount._updateRootComponent(
          prevComponent,
          nextElement,
          container,
          callback
        );
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup =
      reactRootElement && ReactMount.isRenderedByReact(reactRootElement);

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;

    var component = ReactMount._renderNewRootComponent(
      nextElement,
      container,
      shouldReuseMarkup
    );
    callback && callback.call(component);
    return component;
  },

  /**
   * Constructs a component instance of `constructor` with `initialProps` and
   * renders it into the supplied `container`.
   *
   * @param {function} constructor React component constructor.
   * @param {?object} props Initial props of the component instance.
   * @param {DOMElement} container DOM element to render into.
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  constructAndRenderComponent: function(constructor, props, container) {
    var element = createElement(constructor, props);
    return ReactMount.render(element, container);
  },

  /**
   * Constructs a component instance of `constructor` with `initialProps` and
   * renders it into a container node identified by supplied `id`.
   *
   * @param {function} componentConstructor React component constructor
   * @param {?object} props Initial props of the component instance.
   * @param {string} id ID of the DOM element to render into.
   * @return {ReactComponent} Component instance rendered in the container node.
   */
  constructAndRenderComponentByID: function(constructor, props, id) {
    var domNode = document.getElementById(id);
    ("production" !== process.env.NODE_ENV ? invariant(
      domNode,
      'Tried to get element with id of "%s" but it is not present on the page.',
      id
    ) : invariant(domNode));
    return ReactMount.constructAndRenderComponent(constructor, props, domNode);
  },

  /**
   * Registers a container node into which React components will be rendered.
   * This also creates the "reactRoot" ID that will be assigned to the element
   * rendered within.
   *
   * @param {DOMElement} container DOM element to register as a container.
   * @return {string} The "reactRoot" ID of elements rendered within.
   */
  registerContainer: function(container) {
    var reactRootID = getReactRootID(container);
    if (reactRootID) {
      // If one exists, make sure it is a valid "reactRoot" ID.
      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
    }
    if (!reactRootID) {
      // No valid "reactRoot" ID found, create one.
      reactRootID = ReactInstanceHandles.createReactRootID();
    }
    containersByReactRootID[reactRootID] = container;
    return reactRootID;
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function(container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    ("production" !== process.env.NODE_ENV ? warning(
      ReactCurrentOwner.current == null,
      'unmountComponentAtNode(): Render methods should be a pure function of ' +
      'props and state; triggering nested component updates from render is ' +
      'not allowed. If necessary, trigger nested updates in ' +
      'componentDidUpdate.'
    ) : null);

    var reactRootID = getReactRootID(container);
    var component = instancesByReactRootID[reactRootID];
    if (!component) {
      return false;
    }
    ReactMount.unmountComponentFromNode(component, container);
    delete instancesByReactRootID[reactRootID];
    delete containersByReactRootID[reactRootID];
    if ("production" !== process.env.NODE_ENV) {
      delete rootElementsByReactRootID[reactRootID];
    }
    return true;
  },

  /**
   * Unmounts a component and removes it from the DOM.
   *
   * @param {ReactComponent} instance React component instance.
   * @param {DOMElement} container DOM element to unmount from.
   * @final
   * @internal
   * @see {ReactMount.unmountComponentAtNode}
   */
  unmountComponentFromNode: function(instance, container) {
    instance.unmountComponent();

    if (container.nodeType === DOC_NODE_TYPE) {
      container = container.documentElement;
    }

    // http://jsperf.com/emptying-a-node
    while (container.lastChild) {
      container.removeChild(container.lastChild);
    }
  },

  /**
   * Finds the container DOM element that contains React component to which the
   * supplied DOM `id` belongs.
   *
   * @param {string} id The ID of an element rendered by a React component.
   * @return {?DOMElement} DOM element that contains the `id`.
   */
  findReactContainerForID: function(id) {
    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
    var container = containersByReactRootID[reactRootID];

    if ("production" !== process.env.NODE_ENV) {
      var rootElement = rootElementsByReactRootID[reactRootID];
      if (rootElement && rootElement.parentNode !== container) {
        ("production" !== process.env.NODE_ENV ? invariant(
          // Call internalGetID here because getID calls isValid which calls
          // findReactContainerForID (this function).
          internalGetID(rootElement) === reactRootID,
          'ReactMount: Root element ID differed from reactRootID.'
        ) : invariant(// Call internalGetID here because getID calls isValid which calls
        // findReactContainerForID (this function).
        internalGetID(rootElement) === reactRootID));

        var containerChild = container.firstChild;
        if (containerChild &&
            reactRootID === internalGetID(containerChild)) {
          // If the container has a new child with the same ID as the old
          // root element, then rootElementsByReactRootID[reactRootID] is
          // just stale and needs to be updated. The case that deserves a
          // warning is when the container is empty.
          rootElementsByReactRootID[reactRootID] = containerChild;
        } else {
          console.warn(
            'ReactMount: Root element has been removed from its original ' +
            'container. New container:', rootElement.parentNode
          );
        }
      }
    }

    return container;
  },

  /**
   * Finds an element rendered by React with the supplied ID.
   *
   * @param {string} id ID of a DOM node in the React component.
   * @return {DOMElement} Root DOM node of the React component.
   */
  findReactNodeByID: function(id) {
    var reactRoot = ReactMount.findReactContainerForID(id);
    return ReactMount.findComponentRoot(reactRoot, id);
  },

  /**
   * True if the supplied `node` is rendered by React.
   *
   * @param {*} node DOM Element to check.
   * @return {boolean} True if the DOM Element appears to be rendered by React.
   * @internal
   */
  isRenderedByReact: function(node) {
    if (node.nodeType !== 1) {
      // Not a DOMElement, therefore not a React component
      return false;
    }
    var id = ReactMount.getID(node);
    return id ? id.charAt(0) === SEPARATOR : false;
  },

  /**
   * Traverses up the ancestors of the supplied node to find a node that is a
   * DOM representation of a React component.
   *
   * @param {*} node
   * @return {?DOMEventTarget}
   * @internal
   */
  getFirstReactDOM: function(node) {
    var current = node;
    while (current && current.parentNode !== current) {
      if (ReactMount.isRenderedByReact(current)) {
        return current;
      }
      current = current.parentNode;
    }
    return null;
  },

  /**
   * Finds a node with the supplied `targetID` inside of the supplied
   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
   * quickly.
   *
   * @param {DOMEventTarget} ancestorNode Search from this root.
   * @pararm {string} targetID ID of the DOM representation of the component.
   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
   * @internal
   */
  findComponentRoot: function(ancestorNode, targetID) {
    var firstChildren = findComponentRootReusableArray;
    var childIndex = 0;

    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;

    firstChildren[0] = deepestAncestor.firstChild;
    firstChildren.length = 1;

    while (childIndex < firstChildren.length) {
      var child = firstChildren[childIndex++];
      var targetChild;

      while (child) {
        var childID = ReactMount.getID(child);
        if (childID) {
          // Even if we find the node we're looking for, we finish looping
          // through its siblings to ensure they're cached so that we don't have
          // to revisit this node again. Otherwise, we make n^2 calls to getID
          // when visiting the many children of a single node in order.

          if (targetID === childID) {
            targetChild = child;
          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
            // If we find a child whose ID is an ancestor of the given ID,
            // then we can be sure that we only want to search the subtree
            // rooted at this child, so we can throw out the rest of the
            // search state.
            firstChildren.length = childIndex = 0;
            firstChildren.push(child.firstChild);
          }

        } else {
          // If this child had no ID, then there's a chance that it was
          // injected automatically by the browser, as when a `<table>`
          // element sprouts an extra `<tbody>` child as a side effect of
          // `.innerHTML` parsing. Optimistically continue down this
          // branch, but not before examining the other siblings.
          firstChildren.push(child.firstChild);
        }

        child = child.nextSibling;
      }

      if (targetChild) {
        // Emptying firstChildren/findComponentRootReusableArray is
        // not necessary for correctness, but it helps the GC reclaim
        // any nodes that were left at the end of the search.
        firstChildren.length = 0;

        return targetChild;
      }
    }

    firstChildren.length = 0;

    ("production" !== process.env.NODE_ENV ? invariant(
      false,
      'findComponentRoot(..., %s): Unable to find element. This probably ' +
      'means the DOM was unexpectedly mutated (e.g., by the browser), ' +
      'usually due to forgetting a <tbody> when using tables, nesting tags ' +
      'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' +
      'parent. ' +
      'Try inspecting the child nodes of the element with React ID `%s`.',
      targetID,
      ReactMount.getID(ancestorNode)
    ) : invariant(false));
  },


  /**
   * React ID utilities.
   */

  getReactRootID: getReactRootID,

  getID: getID,

  setID: setID,

  getNode: getNode,

  purgeID: purgeID
};

// Deprecations (remove for 0.13)
ReactMount.renderComponent = deprecated(
  'ReactMount',
  'renderComponent',
  'render',
  this,
  ReactMount.render
);

module.exports = ReactMount;

}).call(this,require('_process'))
},{"./DOMProperty":12,"./ReactBrowserEventEmitter":32,"./ReactCurrentOwner":38,"./ReactElement":54,"./ReactInstanceHandles":62,"./ReactLegacyElement":63,"./ReactPerf":70,"./containsNode":103,"./deprecated":108,"./getReactRootElementInContainer":122,"./instantiateReactComponent":127,"./invariant":128,"./shouldUpdateReactComponent":144,"./warning":147,"_process":2}],66:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMultiChild
 * @typechecks static-only
 */

"use strict";

var ReactComponent = require("./ReactComponent");
var ReactMultiChildUpdateTypes = require("./ReactMultiChildUpdateTypes");

var flattenChildren = require("./flattenChildren");
var instantiateReactComponent = require("./instantiateReactComponent");
var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");

/**
 * Updating children of a component may trigger recursive updates. The depth is
 * used to batch recursive updates to render markup more efficiently.
 *
 * @type {number}
 * @private
 */
var updateDepth = 0;

/**
 * Queue of update configuration objects.
 *
 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
 *
 * @type {array<object>}
 * @private
 */
var updateQueue = [];

/**
 * Queue of markup to be rendered.
 *
 * @type {array<string>}
 * @private
 */
var markupQueue = [];

/**
 * Enqueues markup to be rendered and inserted at a supplied index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function enqueueMarkup(parentID, markup, toIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
    markupIndex: markupQueue.push(markup) - 1,
    textContent: null,
    fromIndex: null,
    toIndex: toIndex
  });
}

/**
 * Enqueues moving an existing element to another index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function enqueueMove(parentID, fromIndex, toIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
    markupIndex: null,
    textContent: null,
    fromIndex: fromIndex,
    toIndex: toIndex
  });
}

/**
 * Enqueues removing an element at an index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function enqueueRemove(parentID, fromIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
    markupIndex: null,
    textContent: null,
    fromIndex: fromIndex,
    toIndex: null
  });
}

/**
 * Enqueues setting the text content.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} textContent Text content to set.
 * @private
 */
function enqueueTextContent(parentID, textContent) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
    markupIndex: null,
    textContent: textContent,
    fromIndex: null,
    toIndex: null
  });
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue() {
  if (updateQueue.length) {
    ReactComponent.BackendIDOperations.dangerouslyProcessChildrenUpdates(
      updateQueue,
      markupQueue
    );
    clearQueue();
  }
}

/**
 * Clears any enqueued updates.
 *
 * @private
 */
function clearQueue() {
  updateQueue.length = 0;
  markupQueue.length = 0;
}

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {

  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function(nestedChildren, transaction) {
      var children = flattenChildren(nestedChildren);
      var mountImages = [];
      var index = 0;
      this._renderedChildren = children;
      for (var name in children) {
        var child = children[name];
        if (children.hasOwnProperty(name)) {
          // The rendered children must be turned into instances as they're
          // mounted.
          var childInstance = instantiateReactComponent(child, null);
          children[name] = childInstance;
          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
          var rootID = this._rootNodeID + name;
          var mountImage = childInstance.mountComponent(
            rootID,
            transaction,
            this._mountDepth + 1
          );
          childInstance._mountIndex = index;
          mountImages.push(mountImage);
          index++;
        }
      }
      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function(nextContent) {
      updateDepth++;
      var errorThrown = true;
      try {
        var prevChildren = this._renderedChildren;
        // Remove any rendered children.
        for (var name in prevChildren) {
          if (prevChildren.hasOwnProperty(name)) {
            this._unmountChildByName(prevChildren[name], name);
          }
        }
        // Set new text content.
        this.setTextContent(nextContent);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          errorThrown ? clearQueue() : processQueue();
        }
      }
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildren Nested child maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function(nextNestedChildren, transaction) {
      updateDepth++;
      var errorThrown = true;
      try {
        this._updateChildren(nextNestedChildren, transaction);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          errorThrown ? clearQueue() : processQueue();
        }
      }
    },

    /**
     * Improve performance by isolating this hot code path from the try/catch
     * block in `updateChildren`.
     *
     * @param {?object} nextNestedChildren Nested child maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function(nextNestedChildren, transaction) {
      var nextChildren = flattenChildren(nextNestedChildren);
      var prevChildren = this._renderedChildren;
      if (!nextChildren && !prevChildren) {
        return;
      }
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var lastIndex = 0;
      var nextIndex = 0;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var prevElement = prevChild && prevChild._currentElement;
        var nextElement = nextChildren[name];
        if (shouldUpdateReactComponent(prevElement, nextElement)) {
          this.moveChild(prevChild, nextIndex, lastIndex);
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild.receiveComponent(nextElement, transaction);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            this._unmountChildByName(prevChild, name);
          }
          // The child must be instantiated before it's mounted.
          var nextChildInstance = instantiateReactComponent(
            nextElement,
            null
          );
          this._mountChildByNameAtIndex(
            nextChildInstance, name, nextIndex, transaction
          );
        }
        nextIndex++;
      }
      // Remove children that are no longer present.
      for (name in prevChildren) {
        if (prevChildren.hasOwnProperty(name) &&
            !(nextChildren && nextChildren[name])) {
          this._unmountChildByName(prevChildren[name], name);
        }
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted.
     *
     * @internal
     */
    unmountChildren: function() {
      var renderedChildren = this._renderedChildren;
      for (var name in renderedChildren) {
        var renderedChild = renderedChildren[name];
        // TODO: When is this not true?
        if (renderedChild.unmountComponent) {
          renderedChild.unmountComponent();
        }
      }
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function(child, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function(child, mountImage) {
      enqueueMarkup(this._rootNodeID, mountImage, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function(child) {
      enqueueRemove(this._rootNodeID, child._mountIndex);
    },

    /**
     * Sets this text content string.
     *
     * @param {string} textContent Text content to set.
     * @protected
     */
    setTextContent: function(textContent) {
      enqueueTextContent(this._rootNodeID, textContent);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildByNameAtIndex: function(child, name, index, transaction) {
      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
      var rootID = this._rootNodeID + name;
      var mountImage = child.mountComponent(
        rootID,
        transaction,
        this._mountDepth + 1
      );
      child._mountIndex = index;
      this.createChild(child, mountImage);
      this._renderedChildren = this._renderedChildren || {};
      this._renderedChildren[name] = child;
    },

    /**
     * Unmounts a rendered child by name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @param {string} name Name of the child in `this._renderedChildren`.
     * @private
     */
    _unmountChildByName: function(child, name) {
      this.removeChild(child);
      child._mountIndex = null;
      child.unmountComponent();
      delete this._renderedChildren[name];
    }

  }

};

module.exports = ReactMultiChild;

},{"./ReactComponent":34,"./ReactMultiChildUpdateTypes":67,"./flattenChildren":112,"./instantiateReactComponent":127,"./shouldUpdateReactComponent":144}],67:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMultiChildUpdateTypes
 */

"use strict";

var keyMirror = require("./keyMirror");

/**
 * When a component's children are updated, a series of update configuration
 * objects are created in order to batch and serialize the required changes.
 *
 * Enumerates all the possible types of update configurations.
 *
 * @internal
 */
var ReactMultiChildUpdateTypes = keyMirror({
  INSERT_MARKUP: null,
  MOVE_EXISTING: null,
  REMOVE_NODE: null,
  TEXT_CONTENT: null
});

module.exports = ReactMultiChildUpdateTypes;

},{"./keyMirror":134}],68:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactNativeComponent
 */

"use strict";

var assign = require("./Object.assign");
var invariant = require("./invariant");

var genericComponentClass = null;
// This registry keeps track of wrapper classes around native tags
var tagToComponentClass = {};

var ReactNativeComponentInjection = {
  // This accepts a class that receives the tag string. This is a catch all
  // that can render any kind of tag.
  injectGenericComponentClass: function(componentClass) {
    genericComponentClass = componentClass;
  },
  // This accepts a keyed object with classes as values. Each key represents a
  // tag. That particular tag will use this class instead of the generic one.
  injectComponentClasses: function(componentClasses) {
    assign(tagToComponentClass, componentClasses);
  }
};

/**
 * Create an internal class for a specific tag.
 *
 * @param {string} tag The tag for which to create an internal instance.
 * @param {any} props The props passed to the instance constructor.
 * @return {ReactComponent} component The injected empty component.
 */
function createInstanceForTag(tag, props, parentType) {
  var componentClass = tagToComponentClass[tag];
  if (componentClass == null) {
    ("production" !== process.env.NODE_ENV ? invariant(
      genericComponentClass,
      'There is no registered component for the tag %s',
      tag
    ) : invariant(genericComponentClass));
    return new genericComponentClass(tag, props);
  }
  if (parentType === tag) {
    // Avoid recursion
    ("production" !== process.env.NODE_ENV ? invariant(
      genericComponentClass,
      'There is no registered component for the tag %s',
      tag
    ) : invariant(genericComponentClass));
    return new genericComponentClass(tag, props);
  }
  // Unwrap legacy factories
  return new componentClass.type(props);
}

var ReactNativeComponent = {
  createInstanceForTag: createInstanceForTag,
  injection: ReactNativeComponentInjection,
};

module.exports = ReactNativeComponent;

}).call(this,require('_process'))
},{"./Object.assign":28,"./invariant":128,"_process":2}],69:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactOwner
 */

"use strict";

var emptyObject = require("./emptyObject");
var invariant = require("./invariant");

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner = {

  /**
   * @param {?object} object
   * @return {boolean} True if `object` is a valid owner.
   * @final
   */
  isValidOwner: function(object) {
    return !!(
      object &&
      typeof object.attachRef === 'function' &&
      typeof object.detachRef === 'function'
    );
  },

  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function(component, ref, owner) {
    ("production" !== process.env.NODE_ENV ? invariant(
      ReactOwner.isValidOwner(owner),
      'addComponentAsRefTo(...): Only a ReactOwner can have refs. This ' +
      'usually means that you\'re trying to add a ref to a component that ' +
      'doesn\'t have an owner (that is, was not created inside of another ' +
      'component\'s `render` method). Try rendering this component inside of ' +
      'a new top-level component which will hold the ref.'
    ) : invariant(ReactOwner.isValidOwner(owner)));
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function(component, ref, owner) {
    ("production" !== process.env.NODE_ENV ? invariant(
      ReactOwner.isValidOwner(owner),
      'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. This ' +
      'usually means that you\'re trying to remove a ref to a component that ' +
      'doesn\'t have an owner (that is, was not created inside of another ' +
      'component\'s `render` method). Try rendering this component inside of ' +
      'a new top-level component which will hold the ref.'
    ) : invariant(ReactOwner.isValidOwner(owner)));
    // Check that `component` is still the current ref because we do not want to
    // detach the ref if another component stole it.
    if (owner.refs[ref] === component) {
      owner.detachRef(ref);
    }
  },

  /**
   * A ReactComponent must mix this in to have refs.
   *
   * @lends {ReactOwner.prototype}
   */
  Mixin: {

    construct: function() {
      this.refs = emptyObject;
    },

    /**
     * Lazily allocates the refs object and stores `component` as `ref`.
     *
     * @param {string} ref Reference name.
     * @param {component} component Component to store as `ref`.
     * @final
     * @private
     */
    attachRef: function(ref, component) {
      ("production" !== process.env.NODE_ENV ? invariant(
        component.isOwnedBy(this),
        'attachRef(%s, ...): Only a component\'s owner can store a ref to it.',
        ref
      ) : invariant(component.isOwnedBy(this)));
      var refs = this.refs === emptyObject ? (this.refs = {}) : this.refs;
      refs[ref] = component;
    },

    /**
     * Detaches a reference name.
     *
     * @param {string} ref Name to dereference.
     * @final
     * @private
     */
    detachRef: function(ref) {
      delete this.refs[ref];
    }

  }

};

module.exports = ReactOwner;

}).call(this,require('_process'))
},{"./emptyObject":110,"./invariant":128,"_process":2}],70:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPerf
 * @typechecks static-only
 */

"use strict";

/**
 * ReactPerf is a general AOP system designed to measure performance. This
 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
 */
var ReactPerf = {
  /**
   * Boolean to enable/disable measurement. Set to false by default to prevent
   * accidental logging and perf loss.
   */
  enableMeasure: false,

  /**
   * Holds onto the measure function in use. By default, don't measure
   * anything, but we'll override this if we inject a measure function.
   */
  storedMeasure: _noMeasure,

  /**
   * Use this to wrap methods you want to measure. Zero overhead in production.
   *
   * @param {string} objName
   * @param {string} fnName
   * @param {function} func
   * @return {function}
   */
  measure: function(objName, fnName, func) {
    if ("production" !== process.env.NODE_ENV) {
      var measuredFunc = null;
      var wrapper = function() {
        if (ReactPerf.enableMeasure) {
          if (!measuredFunc) {
            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
          }
          return measuredFunc.apply(this, arguments);
        }
        return func.apply(this, arguments);
      };
      wrapper.displayName = objName + '_' + fnName;
      return wrapper;
    }
    return func;
  },

  injection: {
    /**
     * @param {function} measure
     */
    injectMeasure: function(measure) {
      ReactPerf.storedMeasure = measure;
    }
  }
};

/**
 * Simply passes through the measured function, without measuring it.
 *
 * @param {string} objName
 * @param {string} fnName
 * @param {function} func
 * @return {function}
 */
function _noMeasure(objName, fnName, func) {
  return func;
}

module.exports = ReactPerf;

}).call(this,require('_process'))
},{"_process":2}],71:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTransferer
 */

"use strict";

var assign = require("./Object.assign");
var emptyFunction = require("./emptyFunction");
var invariant = require("./invariant");
var joinClasses = require("./joinClasses");
var warning = require("./warning");

var didWarn = false;

/**
 * Creates a transfer strategy that will merge prop values using the supplied
 * `mergeStrategy`. If a prop was previously unset, this just sets it.
 *
 * @param {function} mergeStrategy
 * @return {function}
 */
function createTransferStrategy(mergeStrategy) {
  return function(props, key, value) {
    if (!props.hasOwnProperty(key)) {
      props[key] = value;
    } else {
      props[key] = mergeStrategy(props[key], value);
    }
  };
}

var transferStrategyMerge = createTransferStrategy(function(a, b) {
  // `merge` overrides the first object's (`props[key]` above) keys using the
  // second object's (`value`) keys. An object's style's existing `propA` would
  // get overridden. Flip the order here.
  return assign({}, b, a);
});

/**
 * Transfer strategies dictate how props are transferred by `transferPropsTo`.
 * NOTE: if you add any more exceptions to this list you should be sure to
 * update `cloneWithProps()` accordingly.
 */
var TransferStrategies = {
  /**
   * Never transfer `children`.
   */
  children: emptyFunction,
  /**
   * Transfer the `className` prop by merging them.
   */
  className: createTransferStrategy(joinClasses),
  /**
   * Transfer the `style` prop (which is an object) by merging them.
   */
  style: transferStrategyMerge
};

/**
 * Mutates the first argument by transferring the properties from the second
 * argument.
 *
 * @param {object} props
 * @param {object} newProps
 * @return {object}
 */
function transferInto(props, newProps) {
  for (var thisKey in newProps) {
    if (!newProps.hasOwnProperty(thisKey)) {
      continue;
    }

    var transferStrategy = TransferStrategies[thisKey];

    if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {
      transferStrategy(props, thisKey, newProps[thisKey]);
    } else if (!props.hasOwnProperty(thisKey)) {
      props[thisKey] = newProps[thisKey];
    }
  }
  return props;
}

/**
 * ReactPropTransferer are capable of transferring props to another component
 * using a `transferPropsTo` method.
 *
 * @class ReactPropTransferer
 */
var ReactPropTransferer = {

  TransferStrategies: TransferStrategies,

  /**
   * Merge two props objects using TransferStrategies.
   *
   * @param {object} oldProps original props (they take precedence)
   * @param {object} newProps new props to merge in
   * @return {object} a new object containing both sets of props merged.
   */
  mergeProps: function(oldProps, newProps) {
    return transferInto(assign({}, oldProps), newProps);
  },

  /**
   * @lends {ReactPropTransferer.prototype}
   */
  Mixin: {

    /**
     * Transfer props from this component to a target component.
     *
     * Props that do not have an explicit transfer strategy will be transferred
     * only if the target component does not already have the prop set.
     *
     * This is usually used to pass down props to a returned root component.
     *
     * @param {ReactElement} element Component receiving the properties.
     * @return {ReactElement} The supplied `component`.
     * @final
     * @protected
     */
    transferPropsTo: function(element) {
      ("production" !== process.env.NODE_ENV ? invariant(
        element._owner === this,
        '%s: You can\'t call transferPropsTo() on a component that you ' +
        'don\'t own, %s. This usually means you are calling ' +
        'transferPropsTo() on a component passed in as props or children.',
        this.constructor.displayName,
        typeof element.type === 'string' ?
        element.type :
        element.type.displayName
      ) : invariant(element._owner === this));

      if ("production" !== process.env.NODE_ENV) {
        if (!didWarn) {
          didWarn = true;
          ("production" !== process.env.NODE_ENV ? warning(
            false,
            'transferPropsTo is deprecated. ' +
            'See http://fb.me/react-transferpropsto for more information.'
          ) : null);
        }
      }

      // Because elements are immutable we have to merge into the existing
      // props object rather than clone it.
      transferInto(element.props, this.props);

      return element;
    }

  }
};

module.exports = ReactPropTransferer;

}).call(this,require('_process'))
},{"./Object.assign":28,"./emptyFunction":109,"./invariant":128,"./joinClasses":133,"./warning":147,"_process":2}],72:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypeLocationNames
 */

"use strict";

var ReactPropTypeLocationNames = {};

if ("production" !== process.env.NODE_ENV) {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;

}).call(this,require('_process'))
},{"_process":2}],73:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypeLocations
 */

"use strict";

var keyMirror = require("./keyMirror");

var ReactPropTypeLocations = keyMirror({
  prop: null,
  context: null,
  childContext: null
});

module.exports = ReactPropTypeLocations;

},{"./keyMirror":134}],74:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypes
 */

"use strict";

var ReactElement = require("./ReactElement");
var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");

var deprecated = require("./deprecated");
var emptyFunction = require("./emptyFunction");

/**
 * Collection of methods that allow declaration and validation of props that are
 * supplied to React components. Example usage:
 *
 *   var Props = require('ReactPropTypes');
 *   var MyArticle = React.createClass({
 *     propTypes: {
 *       // An optional string prop named "description".
 *       description: Props.string,
 *
 *       // A required enum prop named "category".
 *       category: Props.oneOf(['News','Photos']).isRequired,
 *
 *       // A prop named "dialog" that requires an instance of Dialog.
 *       dialog: Props.instanceOf(Dialog).isRequired
 *     },
 *     render: function() { ... }
 *   });
 *
 * A more formal specification of how these methods are used:
 *
 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
 *   decl := ReactPropTypes.{type}(.isRequired)?
 *
 * Each and every declaration produces a function with the same signature. This
 * allows the creation of custom validation functions. For example:
 *
 *  var MyLink = React.createClass({
 *    propTypes: {
 *      // An optional string or URI prop named "href".
 *      href: function(props, propName, componentName) {
 *        var propValue = props[propName];
 *        if (propValue != null && typeof propValue !== 'string' &&
 *            !(propValue instanceof URI)) {
 *          return new Error(
 *            'Expected a string or an URI for ' + propName + ' in ' +
 *            componentName
 *          );
 *        }
 *      }
 *    },
 *    render: function() {...}
 *  });
 *
 * @internal
 */

var ANONYMOUS = '<<anonymous>>';

var elementTypeChecker = createElementTypeChecker();
var nodeTypeChecker = createNodeChecker();

var ReactPropTypes = {
  array: createPrimitiveTypeChecker('array'),
  bool: createPrimitiveTypeChecker('boolean'),
  func: createPrimitiveTypeChecker('function'),
  number: createPrimitiveTypeChecker('number'),
  object: createPrimitiveTypeChecker('object'),
  string: createPrimitiveTypeChecker('string'),

  any: createAnyTypeChecker(),
  arrayOf: createArrayOfTypeChecker,
  element: elementTypeChecker,
  instanceOf: createInstanceTypeChecker,
  node: nodeTypeChecker,
  objectOf: createObjectOfTypeChecker,
  oneOf: createEnumTypeChecker,
  oneOfType: createUnionTypeChecker,
  shape: createShapeTypeChecker,

  component: deprecated(
    'React.PropTypes',
    'component',
    'element',
    this,
    elementTypeChecker
  ),
  renderable: deprecated(
    'React.PropTypes',
    'renderable',
    'node',
    this,
    nodeTypeChecker
  )
};

function createChainableTypeChecker(validate) {
  function checkType(isRequired, props, propName, componentName, location) {
    componentName = componentName || ANONYMOUS;
    if (props[propName] == null) {
      var locationName = ReactPropTypeLocationNames[location];
      if (isRequired) {
        return new Error(
          ("Required " + locationName + " `" + propName + "` was not specified in ")+
          ("`" + componentName + "`.")
        );
      }
    } else {
      return validate(props, propName, componentName, location);
    }
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);

  return chainedCheckType;
}

function createPrimitiveTypeChecker(expectedType) {
  function validate(props, propName, componentName, location) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== expectedType) {
      var locationName = ReactPropTypeLocationNames[location];
      // `propValue` being instance of, say, date/regexp, pass the 'object'
      // check, but we can offer a more precise error message here rather than
      // 'of type `object`'.
      var preciseType = getPreciseType(propValue);

      return new Error(
        ("Invalid " + locationName + " `" + propName + "` of type `" + preciseType + "` ") +
        ("supplied to `" + componentName + "`, expected `" + expectedType + "`.")
      );
    }
  }
  return createChainableTypeChecker(validate);
}

function createAnyTypeChecker() {
  return createChainableTypeChecker(emptyFunction.thatReturns());
}

function createArrayOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location) {
    var propValue = props[propName];
    if (!Array.isArray(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new Error(
        ("Invalid " + locationName + " `" + propName + "` of type ") +
        ("`" + propType + "` supplied to `" + componentName + "`, expected an array.")
      );
    }
    for (var i = 0; i < propValue.length; i++) {
      var error = typeChecker(propValue, i, componentName, location);
      if (error instanceof Error) {
        return error;
      }
    }
  }
  return createChainableTypeChecker(validate);
}

function createElementTypeChecker() {
  function validate(props, propName, componentName, location) {
    if (!ReactElement.isValidElement(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error(
        ("Invalid " + locationName + " `" + propName + "` supplied to ") +
        ("`" + componentName + "`, expected a ReactElement.")
      );
    }
  }
  return createChainableTypeChecker(validate);
}

function createInstanceTypeChecker(expectedClass) {
  function validate(props, propName, componentName, location) {
    if (!(props[propName] instanceof expectedClass)) {
      var locationName = ReactPropTypeLocationNames[location];
      var expectedClassName = expectedClass.name || ANONYMOUS;
      return new Error(
        ("Invalid " + locationName + " `" + propName + "` supplied to ") +
        ("`" + componentName + "`, expected instance of `" + expectedClassName + "`.")
      );
    }
  }
  return createChainableTypeChecker(validate);
}

function createEnumTypeChecker(expectedValues) {
  function validate(props, propName, componentName, location) {
    var propValue = props[propName];
    for (var i = 0; i < expectedValues.length; i++) {
      if (propValue === expectedValues[i]) {
        return;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    var valuesString = JSON.stringify(expectedValues);
    return new Error(
      ("Invalid " + locationName + " `" + propName + "` of value `" + propValue + "` ") +
      ("supplied to `" + componentName + "`, expected one of " + valuesString + ".")
    );
  }
  return createChainableTypeChecker(validate);
}

function createObjectOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error(
        ("Invalid " + locationName + " `" + propName + "` of type ") +
        ("`" + propType + "` supplied to `" + componentName + "`, expected an object.")
      );
    }
    for (var key in propValue) {
      if (propValue.hasOwnProperty(key)) {
        var error = typeChecker(propValue, key, componentName, location);
        if (error instanceof Error) {
          return error;
        }
      }
    }
  }
  return createChainableTypeChecker(validate);
}

function createUnionTypeChecker(arrayOfTypeCheckers) {
  function validate(props, propName, componentName, location) {
    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (checker(props, propName, componentName, location) == null) {
        return;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    return new Error(
      ("Invalid " + locationName + " `" + propName + "` supplied to ") +
      ("`" + componentName + "`.")
    );
  }
  return createChainableTypeChecker(validate);
}

function createNodeChecker() {
  function validate(props, propName, componentName, location) {
    if (!isNode(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error(
        ("Invalid " + locationName + " `" + propName + "` supplied to ") +
        ("`" + componentName + "`, expected a ReactNode.")
      );
    }
  }
  return createChainableTypeChecker(validate);
}

function createShapeTypeChecker(shapeTypes) {
  function validate(props, propName, componentName, location) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error(
        ("Invalid " + locationName + " `" + propName + "` of type `" + propType + "` ") +
        ("supplied to `" + componentName + "`, expected `object`.")
      );
    }
    for (var key in shapeTypes) {
      var checker = shapeTypes[key];
      if (!checker) {
        continue;
      }
      var error = checker(propValue, key, componentName, location);
      if (error) {
        return error;
      }
    }
  }
  return createChainableTypeChecker(validate, 'expected `object`');
}

function isNode(propValue) {
  switch(typeof propValue) {
    case 'number':
    case 'string':
      return true;
    case 'boolean':
      return !propValue;
    case 'object':
      if (Array.isArray(propValue)) {
        return propValue.every(isNode);
      }
      if (ReactElement.isValidElement(propValue)) {
        return true;
      }
      for (var k in propValue) {
        if (!isNode(propValue[k])) {
          return false;
        }
      }
      return true;
    default:
      return false;
  }
}

// Equivalent of `typeof` but with special handling for array and regexp.
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return 'array';
  }
  if (propValue instanceof RegExp) {
    // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return 'object';
  }
  return propType;
}

// This handles more types than `getPropType`. Only used for error messages.
// See `createPrimitiveTypeChecker`.
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === 'object') {
    if (propValue instanceof Date) {
      return 'date';
    } else if (propValue instanceof RegExp) {
      return 'regexp';
    }
  }
  return propType;
}

module.exports = ReactPropTypes;

},{"./ReactElement":54,"./ReactPropTypeLocationNames":72,"./deprecated":108,"./emptyFunction":109}],75:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPutListenerQueue
 */

"use strict";

var PooledClass = require("./PooledClass");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");

var assign = require("./Object.assign");

function ReactPutListenerQueue() {
  this.listenersToPut = [];
}

assign(ReactPutListenerQueue.prototype, {
  enqueuePutListener: function(rootNodeID, propKey, propValue) {
    this.listenersToPut.push({
      rootNodeID: rootNodeID,
      propKey: propKey,
      propValue: propValue
    });
  },

  putListeners: function() {
    for (var i = 0; i < this.listenersToPut.length; i++) {
      var listenerToPut = this.listenersToPut[i];
      ReactBrowserEventEmitter.putListener(
        listenerToPut.rootNodeID,
        listenerToPut.propKey,
        listenerToPut.propValue
      );
    }
  },

  reset: function() {
    this.listenersToPut.length = 0;
  },

  destructor: function() {
    this.reset();
  }
});

PooledClass.addPoolingTo(ReactPutListenerQueue);

module.exports = ReactPutListenerQueue;

},{"./Object.assign":28,"./PooledClass":29,"./ReactBrowserEventEmitter":32}],76:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactReconcileTransaction
 * @typechecks static-only
 */

"use strict";

var CallbackQueue = require("./CallbackQueue");
var PooledClass = require("./PooledClass");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactInputSelection = require("./ReactInputSelection");
var ReactPutListenerQueue = require("./ReactPutListenerQueue");
var Transaction = require("./Transaction");

var assign = require("./Object.assign");

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function() {
    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
    ReactBrowserEventEmitter.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occured. `close`
   *   restores the previous value.
   */
  close: function(previouslyEnabled) {
    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function() {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function() {
    this.reactMountReady.notifyAll();
  }
};

var PUT_LISTENER_QUEUEING = {
  initialize: function() {
    this.putListenerQueue.reset();
  },

  close: function() {
    this.putListenerQueue.putListeners();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [
  PUT_LISTENER_QUEUEING,
  SELECTION_RESTORATION,
  EVENT_SUPPRESSION,
  ON_DOM_READY_QUEUEING
];

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction() {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.putListenerQueue = ReactPutListenerQueue.getPooled();
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap proceedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function() {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function() {
    return this.reactMountReady;
  },

  getPutListenerQueue: function() {
    return this.putListenerQueue;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be resused.
   */
  destructor: function() {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;

    ReactPutListenerQueue.release(this.putListenerQueue);
    this.putListenerQueue = null;
  }
};


assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);

PooledClass.addPoolingTo(ReactReconcileTransaction);

module.exports = ReactReconcileTransaction;

},{"./CallbackQueue":7,"./Object.assign":28,"./PooledClass":29,"./ReactBrowserEventEmitter":32,"./ReactInputSelection":61,"./ReactPutListenerQueue":75,"./Transaction":97}],77:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactRootIndex
 * @typechecks
 */

"use strict";

var ReactRootIndexInjection = {
  /**
   * @param {function} _createReactRootIndex
   */
  injectCreateReactRootIndex: function(_createReactRootIndex) {
    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
  }
};

var ReactRootIndex = {
  createReactRootIndex: null,
  injection: ReactRootIndexInjection
};

module.exports = ReactRootIndex;

},{}],78:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks static-only
 * @providesModule ReactServerRendering
 */
"use strict";

var ReactElement = require("./ReactElement");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactMarkupChecksum = require("./ReactMarkupChecksum");
var ReactServerRenderingTransaction =
  require("./ReactServerRenderingTransaction");

var instantiateReactComponent = require("./instantiateReactComponent");
var invariant = require("./invariant");

/**
 * @param {ReactElement} element
 * @return {string} the HTML markup
 */
function renderToString(element) {
  ("production" !== process.env.NODE_ENV ? invariant(
    ReactElement.isValidElement(element),
    'renderToString(): You must pass a valid ReactElement.'
  ) : invariant(ReactElement.isValidElement(element)));

  var transaction;
  try {
    var id = ReactInstanceHandles.createReactRootID();
    transaction = ReactServerRenderingTransaction.getPooled(false);

    return transaction.perform(function() {
      var componentInstance = instantiateReactComponent(element, null);
      var markup = componentInstance.mountComponent(id, transaction, 0);
      return ReactMarkupChecksum.addChecksumToMarkup(markup);
    }, null);
  } finally {
    ReactServerRenderingTransaction.release(transaction);
  }
}

/**
 * @param {ReactElement} element
 * @return {string} the HTML markup, without the extra React ID and checksum
 * (for generating static pages)
 */
function renderToStaticMarkup(element) {
  ("production" !== process.env.NODE_ENV ? invariant(
    ReactElement.isValidElement(element),
    'renderToStaticMarkup(): You must pass a valid ReactElement.'
  ) : invariant(ReactElement.isValidElement(element)));

  var transaction;
  try {
    var id = ReactInstanceHandles.createReactRootID();
    transaction = ReactServerRenderingTransaction.getPooled(true);

    return transaction.perform(function() {
      var componentInstance = instantiateReactComponent(element, null);
      return componentInstance.mountComponent(id, transaction, 0);
    }, null);
  } finally {
    ReactServerRenderingTransaction.release(transaction);
  }
}

module.exports = {
  renderToString: renderToString,
  renderToStaticMarkup: renderToStaticMarkup
};

}).call(this,require('_process'))
},{"./ReactElement":54,"./ReactInstanceHandles":62,"./ReactMarkupChecksum":64,"./ReactServerRenderingTransaction":79,"./instantiateReactComponent":127,"./invariant":128,"_process":2}],79:[function(require,module,exports){
/**
 * Copyright 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactServerRenderingTransaction
 * @typechecks
 */

"use strict";

var PooledClass = require("./PooledClass");
var CallbackQueue = require("./CallbackQueue");
var ReactPutListenerQueue = require("./ReactPutListenerQueue");
var Transaction = require("./Transaction");

var assign = require("./Object.assign");
var emptyFunction = require("./emptyFunction");

/**
 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
 * during the performing of the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function() {
    this.reactMountReady.reset();
  },

  close: emptyFunction
};

var PUT_LISTENER_QUEUEING = {
  initialize: function() {
    this.putListenerQueue.reset();
  },

  close: emptyFunction
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [
  PUT_LISTENER_QUEUEING,
  ON_DOM_READY_QUEUEING
];

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.putListenerQueue = ReactPutListenerQueue.getPooled();
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap proceedures.
   */
  getTransactionWrappers: function() {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function() {
    return this.reactMountReady;
  },

  getPutListenerQueue: function() {
    return this.putListenerQueue;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be resused.
   */
  destructor: function() {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;

    ReactPutListenerQueue.release(this.putListenerQueue);
    this.putListenerQueue = null;
  }
};


assign(
  ReactServerRenderingTransaction.prototype,
  Transaction.Mixin,
  Mixin
);

PooledClass.addPoolingTo(ReactServerRenderingTransaction);

module.exports = ReactServerRenderingTransaction;

},{"./CallbackQueue":7,"./Object.assign":28,"./PooledClass":29,"./ReactPutListenerQueue":75,"./Transaction":97,"./emptyFunction":109}],80:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactTextComponent
 * @typechecks static-only
 */

"use strict";

var DOMPropertyOperations = require("./DOMPropertyOperations");
var ReactComponent = require("./ReactComponent");
var ReactElement = require("./ReactElement");

var assign = require("./Object.assign");
var escapeTextForBrowser = require("./escapeTextForBrowser");

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings in elements so that they can undergo
 * the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactTextComponent = function(props) {
  // This constructor and it's argument is currently used by mocks.
};

assign(ReactTextComponent.prototype, ReactComponent.Mixin, {

  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {number} mountDepth number of components in the owner hierarchy
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function(rootID, transaction, mountDepth) {
    ReactComponent.Mixin.mountComponent.call(
      this,
      rootID,
      transaction,
      mountDepth
    );

    var escapedText = escapeTextForBrowser(this.props);

    if (transaction.renderToStaticMarkup) {
      // Normally we'd wrap this in a `span` for the reasons stated above, but
      // since this is a situation where React won't take over (static pages),
      // we can simply return the text as it is.
      return escapedText;
    }

    return (
      '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' +
        escapedText +
      '</span>'
    );
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {object} nextComponent Contains the next text content.
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function(nextComponent, transaction) {
    var nextProps = nextComponent.props;
    if (nextProps !== this.props) {
      this.props = nextProps;
      ReactComponent.BackendIDOperations.updateTextContentByID(
        this._rootNodeID,
        nextProps
      );
    }
  }

});

var ReactTextComponentFactory = function(text) {
  // Bypass validation and configuration
  return new ReactElement(ReactTextComponent, null, null, null, null, text);
};

ReactTextComponentFactory.type = ReactTextComponent;

module.exports = ReactTextComponentFactory;

},{"./DOMPropertyOperations":13,"./Object.assign":28,"./ReactComponent":34,"./ReactElement":54,"./escapeTextForBrowser":111}],81:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactUpdates
 */

"use strict";

var CallbackQueue = require("./CallbackQueue");
var PooledClass = require("./PooledClass");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactPerf = require("./ReactPerf");
var Transaction = require("./Transaction");

var assign = require("./Object.assign");
var invariant = require("./invariant");
var warning = require("./warning");

var dirtyComponents = [];
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;

var batchingStrategy = null;

function ensureInjected() {
  ("production" !== process.env.NODE_ENV ? invariant(
    ReactUpdates.ReactReconcileTransaction && batchingStrategy,
    'ReactUpdates: must inject a reconcile transaction class and batching ' +
    'strategy'
  ) : invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy));
}

var NESTED_UPDATES = {
  initialize: function() {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function() {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function() {
    this.callbackQueue.reset();
  },
  close: function() {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled();
  this.reconcileTransaction =
    ReactUpdates.ReactReconcileTransaction.getPooled();
}

assign(
  ReactUpdatesFlushTransaction.prototype,
  Transaction.Mixin, {
  getTransactionWrappers: function() {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function() {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function(method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.Mixin.perform.call(
      this,
      this.reconcileTransaction.perform,
      this.reconcileTransaction,
      method,
      scope,
      a
    );
  }
});

PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b) {
  ensureInjected();
  batchingStrategy.batchedUpdates(callback, a, b);
}

/**
 * Array comparator for ReactComponents by owner depth
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountDepthComparator(c1, c2) {
  return c1._mountDepth - c2._mountDepth;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  ("production" !== process.env.NODE_ENV ? invariant(
    len === dirtyComponents.length,
    'Expected flush transaction\'s stored dirty-components length (%s) to ' +
    'match dirty-components array length (%s).',
    len,
    dirtyComponents.length
  ) : invariant(len === dirtyComponents.length));

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountDepthComparator);

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, ignore them
    // TODO: Queue unmounts in the same list to avoid this happening at all
    var component = dirtyComponents[i];
    if (component.isMounted()) {
      // If performUpdateIfNecessary happens to enqueue any new updates, we
      // shouldn't execute the callbacks until the next render happens, so
      // stash the callbacks first
      var callbacks = component._pendingCallbacks;
      component._pendingCallbacks = null;
      component.performUpdateIfNecessary(transaction.reconcileTransaction);

      if (callbacks) {
        for (var j = 0; j < callbacks.length; j++) {
          transaction.callbackQueue.enqueue(
            callbacks[j],
            component
          );
        }
      }
    }
  }
}

var flushBatchedUpdates = ReactPerf.measure(
  'ReactUpdates',
  'flushBatchedUpdates',
  function() {
    // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
    // array and perform any updates enqueued by mount-ready handlers (i.e.,
    // componentDidUpdate) but we need to check here too in order to catch
    // updates enqueued by setState callbacks and asap calls.
    while (dirtyComponents.length || asapEnqueued) {
      if (dirtyComponents.length) {
        var transaction = ReactUpdatesFlushTransaction.getPooled();
        transaction.perform(runBatchedUpdates, null, transaction);
        ReactUpdatesFlushTransaction.release(transaction);
      }

      if (asapEnqueued) {
        asapEnqueued = false;
        var queue = asapCallbackQueue;
        asapCallbackQueue = CallbackQueue.getPooled();
        queue.notifyAll();
        CallbackQueue.release(queue);
      }
    }
  }
);

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component, callback) {
  ("production" !== process.env.NODE_ENV ? invariant(
    !callback || typeof callback === "function",
    'enqueueUpdate(...): You called `setProps`, `replaceProps`, ' +
    '`setState`, `replaceState`, or `forceUpdate` with a callback that ' +
    'isn\'t callable.'
  ) : invariant(!callback || typeof callback === "function"));
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setProps, setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)
  ("production" !== process.env.NODE_ENV ? warning(
    ReactCurrentOwner.current == null,
    'enqueueUpdate(): Render methods should be a pure function of props ' +
    'and state; triggering nested component updates from render is not ' +
    'allowed. If necessary, trigger nested updates in ' +
    'componentDidUpdate.'
  ) : null);

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component, callback);
    return;
  }

  dirtyComponents.push(component);

  if (callback) {
    if (component._pendingCallbacks) {
      component._pendingCallbacks.push(callback);
    } else {
      component._pendingCallbacks = [callback];
    }
  }
}

/**
 * Enqueue a callback to be run at the end of the current batching cycle. Throws
 * if no updates are currently being performed.
 */
function asap(callback, context) {
  ("production" !== process.env.NODE_ENV ? invariant(
    batchingStrategy.isBatchingUpdates,
    'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' +
    'updates are not being batched.'
  ) : invariant(batchingStrategy.isBatchingUpdates));
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function(ReconcileTransaction) {
    ("production" !== process.env.NODE_ENV ? invariant(
      ReconcileTransaction,
      'ReactUpdates: must provide a reconcile transaction class'
    ) : invariant(ReconcileTransaction));
    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function(_batchingStrategy) {
    ("production" !== process.env.NODE_ENV ? invariant(
      _batchingStrategy,
      'ReactUpdates: must provide a batching strategy'
    ) : invariant(_batchingStrategy));
    ("production" !== process.env.NODE_ENV ? invariant(
      typeof _batchingStrategy.batchedUpdates === 'function',
      'ReactUpdates: must provide a batchedUpdates() function'
    ) : invariant(typeof _batchingStrategy.batchedUpdates === 'function'));
    ("production" !== process.env.NODE_ENV ? invariant(
      typeof _batchingStrategy.isBatchingUpdates === 'boolean',
      'ReactUpdates: must provide an isBatchingUpdates boolean attribute'
    ) : invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean'));
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap
};

module.exports = ReactUpdates;

}).call(this,require('_process'))
},{"./CallbackQueue":7,"./Object.assign":28,"./PooledClass":29,"./ReactCurrentOwner":38,"./ReactPerf":70,"./Transaction":97,"./invariant":128,"./warning":147,"_process":2}],82:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SVGDOMPropertyConfig
 */

/*jslint bitwise: true*/

"use strict";

var DOMProperty = require("./DOMProperty");

var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;

var SVGDOMPropertyConfig = {
  Properties: {
    cx: MUST_USE_ATTRIBUTE,
    cy: MUST_USE_ATTRIBUTE,
    d: MUST_USE_ATTRIBUTE,
    dx: MUST_USE_ATTRIBUTE,
    dy: MUST_USE_ATTRIBUTE,
    fill: MUST_USE_ATTRIBUTE,
    fillOpacity: MUST_USE_ATTRIBUTE,
    fontFamily: MUST_USE_ATTRIBUTE,
    fontSize: MUST_USE_ATTRIBUTE,
    fx: MUST_USE_ATTRIBUTE,
    fy: MUST_USE_ATTRIBUTE,
    gradientTransform: MUST_USE_ATTRIBUTE,
    gradientUnits: MUST_USE_ATTRIBUTE,
    markerEnd: MUST_USE_ATTRIBUTE,
    markerMid: MUST_USE_ATTRIBUTE,
    markerStart: MUST_USE_ATTRIBUTE,
    offset: MUST_USE_ATTRIBUTE,
    opacity: MUST_USE_ATTRIBUTE,
    patternContentUnits: MUST_USE_ATTRIBUTE,
    patternUnits: MUST_USE_ATTRIBUTE,
    points: MUST_USE_ATTRIBUTE,
    preserveAspectRatio: MUST_USE_ATTRIBUTE,
    r: MUST_USE_ATTRIBUTE,
    rx: MUST_USE_ATTRIBUTE,
    ry: MUST_USE_ATTRIBUTE,
    spreadMethod: MUST_USE_ATTRIBUTE,
    stopColor: MUST_USE_ATTRIBUTE,
    stopOpacity: MUST_USE_ATTRIBUTE,
    stroke: MUST_USE_ATTRIBUTE,
    strokeDasharray: MUST_USE_ATTRIBUTE,
    strokeLinecap: MUST_USE_ATTRIBUTE,
    strokeOpacity: MUST_USE_ATTRIBUTE,
    strokeWidth: MUST_USE_ATTRIBUTE,
    textAnchor: MUST_USE_ATTRIBUTE,
    transform: MUST_USE_ATTRIBUTE,
    version: MUST_USE_ATTRIBUTE,
    viewBox: MUST_USE_ATTRIBUTE,
    x1: MUST_USE_ATTRIBUTE,
    x2: MUST_USE_ATTRIBUTE,
    x: MUST_USE_ATTRIBUTE,
    y1: MUST_USE_ATTRIBUTE,
    y2: MUST_USE_ATTRIBUTE,
    y: MUST_USE_ATTRIBUTE
  },
  DOMAttributeNames: {
    fillOpacity: 'fill-opacity',
    fontFamily: 'font-family',
    fontSize: 'font-size',
    gradientTransform: 'gradientTransform',
    gradientUnits: 'gradientUnits',
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    patternContentUnits: 'patternContentUnits',
    patternUnits: 'patternUnits',
    preserveAspectRatio: 'preserveAspectRatio',
    spreadMethod: 'spreadMethod',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strokeDasharray: 'stroke-dasharray',
    strokeLinecap: 'stroke-linecap',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    textAnchor: 'text-anchor',
    viewBox: 'viewBox'
  }
};

module.exports = SVGDOMPropertyConfig;

},{"./DOMProperty":12}],83:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SelectEventPlugin
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPropagators = require("./EventPropagators");
var ReactInputSelection = require("./ReactInputSelection");
var SyntheticEvent = require("./SyntheticEvent");

var getActiveElement = require("./getActiveElement");
var isTextInputElement = require("./isTextInputElement");
var keyOf = require("./keyOf");
var shallowEqual = require("./shallowEqual");

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: keyOf({onSelect: null}),
      captured: keyOf({onSelectCapture: null})
    },
    dependencies: [
      topLevelTypes.topBlur,
      topLevelTypes.topContextMenu,
      topLevelTypes.topFocus,
      topLevelTypes.topKeyDown,
      topLevelTypes.topMouseDown,
      topLevelTypes.topMouseUp,
      topLevelTypes.topSelectionChange
    ]
  }
};

var activeElement = null;
var activeElementID = null;
var lastSelection = null;
var mouseDown = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @param {object}
 */
function getSelection(node) {
  if ('selectionStart' in node &&
      ReactInputSelection.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown ||
      activeElement == null ||
      activeElement != getActiveElement()) {
    return;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(
      eventTypes.select,
      activeElementID,
      nativeEvent
    );

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {

    switch (topLevelType) {
      // Track the input node that has focus.
      case topLevelTypes.topFocus:
        if (isTextInputElement(topLevelTarget) ||
            topLevelTarget.contentEditable === 'true') {
          activeElement = topLevelTarget;
          activeElementID = topLevelTargetID;
          lastSelection = null;
        }
        break;
      case topLevelTypes.topBlur:
        activeElement = null;
        activeElementID = null;
        lastSelection = null;
        break;

      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case topLevelTypes.topMouseDown:
        mouseDown = true;
        break;
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topMouseUp:
        mouseDown = false;
        return constructSelectEvent(nativeEvent);

      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't).
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      case topLevelTypes.topSelectionChange:
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        return constructSelectEvent(nativeEvent);
    }
  }
};

module.exports = SelectEventPlugin;

},{"./EventConstants":17,"./EventPropagators":22,"./ReactInputSelection":61,"./SyntheticEvent":89,"./getActiveElement":115,"./isTextInputElement":131,"./keyOf":135,"./shallowEqual":143}],84:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ServerReactRootIndex
 * @typechecks
 */

"use strict";

/**
 * Size of the reactRoot ID space. We generate random numbers for React root
 * IDs and if there's a collision the events and DOM update system will
 * get confused. In the future we need a way to generate GUIDs but for
 * now this will work on a smaller scale.
 */
var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);

var ServerReactRootIndex = {
  createReactRootIndex: function() {
    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
  }
};

module.exports = ServerReactRootIndex;

},{}],85:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SimpleEventPlugin
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPluginUtils = require("./EventPluginUtils");
var EventPropagators = require("./EventPropagators");
var SyntheticClipboardEvent = require("./SyntheticClipboardEvent");
var SyntheticEvent = require("./SyntheticEvent");
var SyntheticFocusEvent = require("./SyntheticFocusEvent");
var SyntheticKeyboardEvent = require("./SyntheticKeyboardEvent");
var SyntheticMouseEvent = require("./SyntheticMouseEvent");
var SyntheticDragEvent = require("./SyntheticDragEvent");
var SyntheticTouchEvent = require("./SyntheticTouchEvent");
var SyntheticUIEvent = require("./SyntheticUIEvent");
var SyntheticWheelEvent = require("./SyntheticWheelEvent");

var getEventCharCode = require("./getEventCharCode");

var invariant = require("./invariant");
var keyOf = require("./keyOf");
var warning = require("./warning");

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  blur: {
    phasedRegistrationNames: {
      bubbled: keyOf({onBlur: true}),
      captured: keyOf({onBlurCapture: true})
    }
  },
  click: {
    phasedRegistrationNames: {
      bubbled: keyOf({onClick: true}),
      captured: keyOf({onClickCapture: true})
    }
  },
  contextMenu: {
    phasedRegistrationNames: {
      bubbled: keyOf({onContextMenu: true}),
      captured: keyOf({onContextMenuCapture: true})
    }
  },
  copy: {
    phasedRegistrationNames: {
      bubbled: keyOf({onCopy: true}),
      captured: keyOf({onCopyCapture: true})
    }
  },
  cut: {
    phasedRegistrationNames: {
      bubbled: keyOf({onCut: true}),
      captured: keyOf({onCutCapture: true})
    }
  },
  doubleClick: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDoubleClick: true}),
      captured: keyOf({onDoubleClickCapture: true})
    }
  },
  drag: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDrag: true}),
      captured: keyOf({onDragCapture: true})
    }
  },
  dragEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDragEnd: true}),
      captured: keyOf({onDragEndCapture: true})
    }
  },
  dragEnter: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDragEnter: true}),
      captured: keyOf({onDragEnterCapture: true})
    }
  },
  dragExit: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDragExit: true}),
      captured: keyOf({onDragExitCapture: true})
    }
  },
  dragLeave: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDragLeave: true}),
      captured: keyOf({onDragLeaveCapture: true})
    }
  },
  dragOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDragOver: true}),
      captured: keyOf({onDragOverCapture: true})
    }
  },
  dragStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDragStart: true}),
      captured: keyOf({onDragStartCapture: true})
    }
  },
  drop: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDrop: true}),
      captured: keyOf({onDropCapture: true})
    }
  },
  focus: {
    phasedRegistrationNames: {
      bubbled: keyOf({onFocus: true}),
      captured: keyOf({onFocusCapture: true})
    }
  },
  input: {
    phasedRegistrationNames: {
      bubbled: keyOf({onInput: true}),
      captured: keyOf({onInputCapture: true})
    }
  },
  keyDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({onKeyDown: true}),
      captured: keyOf({onKeyDownCapture: true})
    }
  },
  keyPress: {
    phasedRegistrationNames: {
      bubbled: keyOf({onKeyPress: true}),
      captured: keyOf({onKeyPressCapture: true})
    }
  },
  keyUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({onKeyUp: true}),
      captured: keyOf({onKeyUpCapture: true})
    }
  },
  load: {
    phasedRegistrationNames: {
      bubbled: keyOf({onLoad: true}),
      captured: keyOf({onLoadCapture: true})
    }
  },
  error: {
    phasedRegistrationNames: {
      bubbled: keyOf({onError: true}),
      captured: keyOf({onErrorCapture: true})
    }
  },
  // Note: We do not allow listening to mouseOver events. Instead, use the
  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
  mouseDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({onMouseDown: true}),
      captured: keyOf({onMouseDownCapture: true})
    }
  },
  mouseMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({onMouseMove: true}),
      captured: keyOf({onMouseMoveCapture: true})
    }
  },
  mouseOut: {
    phasedRegistrationNames: {
      bubbled: keyOf({onMouseOut: true}),
      captured: keyOf({onMouseOutCapture: true})
    }
  },
  mouseOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({onMouseOver: true}),
      captured: keyOf({onMouseOverCapture: true})
    }
  },
  mouseUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({onMouseUp: true}),
      captured: keyOf({onMouseUpCapture: true})
    }
  },
  paste: {
    phasedRegistrationNames: {
      bubbled: keyOf({onPaste: true}),
      captured: keyOf({onPasteCapture: true})
    }
  },
  reset: {
    phasedRegistrationNames: {
      bubbled: keyOf({onReset: true}),
      captured: keyOf({onResetCapture: true})
    }
  },
  scroll: {
    phasedRegistrationNames: {
      bubbled: keyOf({onScroll: true}),
      captured: keyOf({onScrollCapture: true})
    }
  },
  submit: {
    phasedRegistrationNames: {
      bubbled: keyOf({onSubmit: true}),
      captured: keyOf({onSubmitCapture: true})
    }
  },
  touchCancel: {
    phasedRegistrationNames: {
      bubbled: keyOf({onTouchCancel: true}),
      captured: keyOf({onTouchCancelCapture: true})
    }
  },
  touchEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({onTouchEnd: true}),
      captured: keyOf({onTouchEndCapture: true})
    }
  },
  touchMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({onTouchMove: true}),
      captured: keyOf({onTouchMoveCapture: true})
    }
  },
  touchStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({onTouchStart: true}),
      captured: keyOf({onTouchStartCapture: true})
    }
  },
  wheel: {
    phasedRegistrationNames: {
      bubbled: keyOf({onWheel: true}),
      captured: keyOf({onWheelCapture: true})
    }
  }
};

var topLevelEventsToDispatchConfig = {
  topBlur:        eventTypes.blur,
  topClick:       eventTypes.click,
  topContextMenu: eventTypes.contextMenu,
  topCopy:        eventTypes.copy,
  topCut:         eventTypes.cut,
  topDoubleClick: eventTypes.doubleClick,
  topDrag:        eventTypes.drag,
  topDragEnd:     eventTypes.dragEnd,
  topDragEnter:   eventTypes.dragEnter,
  topDragExit:    eventTypes.dragExit,
  topDragLeave:   eventTypes.dragLeave,
  topDragOver:    eventTypes.dragOver,
  topDragStart:   eventTypes.dragStart,
  topDrop:        eventTypes.drop,
  topError:       eventTypes.error,
  topFocus:       eventTypes.focus,
  topInput:       eventTypes.input,
  topKeyDown:     eventTypes.keyDown,
  topKeyPress:    eventTypes.keyPress,
  topKeyUp:       eventTypes.keyUp,
  topLoad:        eventTypes.load,
  topMouseDown:   eventTypes.mouseDown,
  topMouseMove:   eventTypes.mouseMove,
  topMouseOut:    eventTypes.mouseOut,
  topMouseOver:   eventTypes.mouseOver,
  topMouseUp:     eventTypes.mouseUp,
  topPaste:       eventTypes.paste,
  topReset:       eventTypes.reset,
  topScroll:      eventTypes.scroll,
  topSubmit:      eventTypes.submit,
  topTouchCancel: eventTypes.touchCancel,
  topTouchEnd:    eventTypes.touchEnd,
  topTouchMove:   eventTypes.touchMove,
  topTouchStart:  eventTypes.touchStart,
  topWheel:       eventTypes.wheel
};

for (var topLevelType in topLevelEventsToDispatchConfig) {
  topLevelEventsToDispatchConfig[topLevelType].dependencies = [topLevelType];
}

var SimpleEventPlugin = {

  eventTypes: eventTypes,

  /**
   * Same as the default implementation, except cancels the event when return
   * value is false. This behavior will be disabled in a future release.
   *
   * @param {object} Event to be dispatched.
   * @param {function} Application-level callback.
   * @param {string} domID DOM ID to pass to the callback.
   */
  executeDispatch: function(event, listener, domID) {
    var returnValue = EventPluginUtils.executeDispatch(event, listener, domID);

    ("production" !== process.env.NODE_ENV ? warning(
      typeof returnValue !== 'boolean',
      'Returning `false` from an event handler is deprecated and will be ' +
      'ignored in a future release. Instead, manually call ' +
      'e.stopPropagation() or e.preventDefault(), as appropriate.'
    ) : null);

    if (returnValue === false) {
      event.stopPropagation();
      event.preventDefault();
    }
  },

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case topLevelTypes.topInput:
      case topLevelTypes.topLoad:
      case topLevelTypes.topError:
      case topLevelTypes.topReset:
      case topLevelTypes.topSubmit:
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
      case topLevelTypes.topKeyPress:
        // FireFox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
        /* falls through */
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case topLevelTypes.topBlur:
      case topLevelTypes.topFocus:
        EventConstructor = SyntheticFocusEvent;
        break;
      case topLevelTypes.topClick:
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
        /* falls through */
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topDoubleClick:
      case topLevelTypes.topMouseDown:
      case topLevelTypes.topMouseMove:
      case topLevelTypes.topMouseOut:
      case topLevelTypes.topMouseOver:
      case topLevelTypes.topMouseUp:
        EventConstructor = SyntheticMouseEvent;
        break;
      case topLevelTypes.topDrag:
      case topLevelTypes.topDragEnd:
      case topLevelTypes.topDragEnter:
      case topLevelTypes.topDragExit:
      case topLevelTypes.topDragLeave:
      case topLevelTypes.topDragOver:
      case topLevelTypes.topDragStart:
      case topLevelTypes.topDrop:
        EventConstructor = SyntheticDragEvent;
        break;
      case topLevelTypes.topTouchCancel:
      case topLevelTypes.topTouchEnd:
      case topLevelTypes.topTouchMove:
      case topLevelTypes.topTouchStart:
        EventConstructor = SyntheticTouchEvent;
        break;
      case topLevelTypes.topScroll:
        EventConstructor = SyntheticUIEvent;
        break;
      case topLevelTypes.topWheel:
        EventConstructor = SyntheticWheelEvent;
        break;
      case topLevelTypes.topCopy:
      case topLevelTypes.topCut:
      case topLevelTypes.topPaste:
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    ("production" !== process.env.NODE_ENV ? invariant(
      EventConstructor,
      'SimpleEventPlugin: Unhandled event type, `%s`.',
      topLevelType
    ) : invariant(EventConstructor));
    var event = EventConstructor.getPooled(
      dispatchConfig,
      topLevelTargetID,
      nativeEvent
    );
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }

};

module.exports = SimpleEventPlugin;

}).call(this,require('_process'))
},{"./EventConstants":17,"./EventPluginUtils":21,"./EventPropagators":22,"./SyntheticClipboardEvent":86,"./SyntheticDragEvent":88,"./SyntheticEvent":89,"./SyntheticFocusEvent":90,"./SyntheticKeyboardEvent":92,"./SyntheticMouseEvent":93,"./SyntheticTouchEvent":94,"./SyntheticUIEvent":95,"./SyntheticWheelEvent":96,"./getEventCharCode":116,"./invariant":128,"./keyOf":135,"./warning":147,"_process":2}],86:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticClipboardEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticEvent = require("./SyntheticEvent");

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function(event) {
    return (
      'clipboardData' in event ?
        event.clipboardData :
        window.clipboardData
    );
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

module.exports = SyntheticClipboardEvent;


},{"./SyntheticEvent":89}],87:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticCompositionEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticEvent = require("./SyntheticEvent");

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent(
  dispatchConfig,
  dispatchMarker,
  nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(
  SyntheticCompositionEvent,
  CompositionEventInterface
);

module.exports = SyntheticCompositionEvent;


},{"./SyntheticEvent":89}],88:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticDragEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticMouseEvent = require("./SyntheticMouseEvent");

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

module.exports = SyntheticDragEvent;

},{"./SyntheticMouseEvent":93}],89:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticEvent
 * @typechecks static-only
 */

"use strict";

var PooledClass = require("./PooledClass");

var assign = require("./Object.assign");
var emptyFunction = require("./emptyFunction");
var getEventTarget = require("./getEventTarget");

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: getEventTarget,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function(event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 */
function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  this.dispatchConfig = dispatchConfig;
  this.dispatchMarker = dispatchMarker;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      this[propName] = nativeEvent[propName];
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ?
    nativeEvent.defaultPrevented :
    nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
}

assign(SyntheticEvent.prototype, {

  preventDefault: function() {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    event.preventDefault ? event.preventDefault() : event.returnValue = false;
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function() {
    var event = this.nativeEvent;
    event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;
    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function() {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function() {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      this[propName] = null;
    }
    this.dispatchConfig = null;
    this.dispatchMarker = null;
    this.nativeEvent = null;
  }

});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function(Class, Interface) {
  var Super = this;

  var prototype = Object.create(Super.prototype);
  assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.threeArgumentPooler);
};

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.threeArgumentPooler);

module.exports = SyntheticEvent;

},{"./Object.assign":28,"./PooledClass":29,"./emptyFunction":109,"./getEventTarget":119}],90:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticFocusEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticUIEvent = require("./SyntheticUIEvent");

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

module.exports = SyntheticFocusEvent;

},{"./SyntheticUIEvent":95}],91:[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticInputEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticEvent = require("./SyntheticEvent");

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent(
  dispatchConfig,
  dispatchMarker,
  nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(
  SyntheticInputEvent,
  InputEventInterface
);

module.exports = SyntheticInputEvent;


},{"./SyntheticEvent":89}],92:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticKeyboardEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticUIEvent = require("./SyntheticUIEvent");

var getEventCharCode = require("./getEventCharCode");
var getEventKey = require("./getEventKey");
var getEventModifierState = require("./getEventModifierState");

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function(event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function(event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function(event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

module.exports = SyntheticKeyboardEvent;

},{"./SyntheticUIEvent":95,"./getEventCharCode":116,"./getEventKey":117,"./getEventModifierState":118}],93:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticMouseEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticUIEvent = require("./SyntheticUIEvent");
var ViewportMetrics = require("./ViewportMetrics");

var getEventModifierState = require("./getEventModifierState");

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function(event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function(event) {
    return event.relatedTarget || (
      event.fromElement === event.srcElement ?
        event.toElement :
        event.fromElement
    );
  },
  // "Proprietary" Interface.
  pageX: function(event) {
    return 'pageX' in event ?
      event.pageX :
      event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function(event) {
    return 'pageY' in event ?
      event.pageY :
      event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

module.exports = SyntheticMouseEvent;

},{"./SyntheticUIEvent":95,"./ViewportMetrics":98,"./getEventModifierState":118}],94:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticTouchEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticUIEvent = require("./SyntheticUIEvent");

var getEventModifierState = require("./getEventModifierState");

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

module.exports = SyntheticTouchEvent;

},{"./SyntheticUIEvent":95,"./getEventModifierState":118}],95:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticUIEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticEvent = require("./SyntheticEvent");

var getEventTarget = require("./getEventTarget");

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function(event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target != null && target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function(event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;

},{"./SyntheticEvent":89,"./getEventTarget":119}],96:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticWheelEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticMouseEvent = require("./SyntheticMouseEvent");

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function(event) {
    return (
      'deltaX' in event ? event.deltaX :
      // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
      'wheelDeltaX' in event ? -event.wheelDeltaX : 0
    );
  },
  deltaY: function(event) {
    return (
      'deltaY' in event ? event.deltaY :
      // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
      'wheelDeltaY' in event ? -event.wheelDeltaY :
      // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
      'wheelDelta' in event ? -event.wheelDelta : 0
    );
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

module.exports = SyntheticWheelEvent;

},{"./SyntheticMouseEvent":93}],97:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Transaction
 */

"use strict";

var invariant = require("./invariant");

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM upates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var Mixin = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function() {
    this.transactionWrappers = this.getTransactionWrappers();
    if (!this.wrapperInitData) {
      this.wrapperInitData = [];
    } else {
      this.wrapperInitData.length = 0;
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function() {
    return !!this._isInTransaction;
  },

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} args... Arguments to pass to the method (optional).
   *                           Helps prevent need to bind in many cases.
   * @return Return value from `method`.
   */
  perform: function(method, scope, a, b, c, d, e, f) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !this.isInTransaction(),
      'Transaction.perform(...): Cannot initialize a transaction when there ' +
      'is already an outstanding transaction.'
    ) : invariant(!this.isInTransaction()));
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {
          }
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function(startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ?
          wrapper.initialize.call(this) :
          null;
      } finally {
        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {
          }
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function(startIndex) {
    ("production" !== process.env.NODE_ENV ? invariant(
      this.isInTransaction(),
      'Transaction.closeAll(): Cannot close transaction when none are open.'
    ) : invariant(this.isInTransaction()));
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== Transaction.OBSERVED_ERROR) {
          wrapper.close && wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {
          }
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

var Transaction = {

  Mixin: Mixin,

  /**
   * Token to look for to determine if an error occured.
   */
  OBSERVED_ERROR: {}

};

module.exports = Transaction;

}).call(this,require('_process'))
},{"./invariant":128,"_process":2}],98:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ViewportMetrics
 */

"use strict";

var getUnboundedScrollPosition = require("./getUnboundedScrollPosition");

var ViewportMetrics = {

  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function() {
    var scrollPosition = getUnboundedScrollPosition(window);
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }

};

module.exports = ViewportMetrics;

},{"./getUnboundedScrollPosition":124}],99:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule accumulateInto
 */

"use strict";

var invariant = require("./invariant");

/**
 *
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  ("production" !== process.env.NODE_ENV ? invariant(
    next != null,
    'accumulateInto(...): Accumulated items must not be null or undefined.'
  ) : invariant(next != null));
  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  var currentIsArray = Array.isArray(current);
  var nextIsArray = Array.isArray(next);

  if (currentIsArray && nextIsArray) {
    current.push.apply(current, next);
    return current;
  }

  if (currentIsArray) {
    current.push(next);
    return current;
  }

  if (nextIsArray) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

module.exports = accumulateInto;

}).call(this,require('_process'))
},{"./invariant":128,"_process":2}],100:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule adler32
 */

/* jslint bitwise:true */

"use strict";

var MOD = 65521;

// This is a clean-room implementation of adler32 designed for detecting
// if markup is not what we expect it to be. It does not need to be
// cryptographically strong, only reasonably good at detecting if markup
// generated on the server is different than that on the client.
function adler32(data) {
  var a = 1;
  var b = 0;
  for (var i = 0; i < data.length; i++) {
    a = (a + data.charCodeAt(i)) % MOD;
    b = (b + a) % MOD;
  }
  return a | (b << 16);
}

module.exports = adler32;

},{}],101:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule camelize
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function(_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

},{}],102:[function(require,module,exports){
/**
 * Copyright 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule camelizeStyleName
 * @typechecks
 */

"use strict";

var camelize = require("./camelize");

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

},{"./camelize":101}],103:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule containsNode
 * @typechecks
 */

var isTextNode = require("./isTextNode");

/*jslint bitwise:true */

/**
 * Checks if a given DOM node contains or is another DOM node.
 *
 * @param {?DOMNode} outerNode Outer DOM node.
 * @param {?DOMNode} innerNode Inner DOM node.
 * @return {boolean} True if `outerNode` contains or is `innerNode`.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if (outerNode.contains) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

},{"./isTextNode":132}],104:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createArrayFrom
 * @typechecks
 */

var toArray = require("./toArray");

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return (
    // not null/false
    !!obj &&
    // arrays are objects, NodeLists are functions in Safari
    (typeof obj == 'object' || typeof obj == 'function') &&
    // quacks like an array
    ('length' in obj) &&
    // not window
    !('setInterval' in obj) &&
    // no DOM node should be considered an array-like
    // a 'select' element has 'length' and 'item' properties on IE8
    (typeof obj.nodeType != 'number') &&
    (
      // a real array
      (// HTMLCollection/NodeList
      (Array.isArray(obj) ||
      // arguments
      ('callee' in obj) || 'item' in obj))
    )
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFrom = require('createArrayFrom');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFrom(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFrom(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFrom;

},{"./toArray":145}],105:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createFullPageComponent
 * @typechecks
 */

"use strict";

// Defeat circular references by requiring this directly.
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactElement = require("./ReactElement");

var invariant = require("./invariant");

/**
 * Create a component that will throw an exception when unmounted.
 *
 * Components like <html> <head> and <body> can't be removed or added
 * easily in a cross-browser way, however it's valuable to be able to
 * take advantage of React's reconciliation for styling and <title>
 * management. So we just document it and throw in dangerous cases.
 *
 * @param {string} tag The tag to wrap
 * @return {function} convenience constructor of new component
 */
function createFullPageComponent(tag) {
  var elementFactory = ReactElement.createFactory(tag);

  var FullPageComponent = ReactCompositeComponent.createClass({
    displayName: 'ReactFullPageComponent' + tag,

    componentWillUnmount: function() {
      ("production" !== process.env.NODE_ENV ? invariant(
        false,
        '%s tried to unmount. Because of cross-browser quirks it is ' +
        'impossible to unmount some top-level components (eg <html>, <head>, ' +
        'and <body>) reliably and efficiently. To fix this, have a single ' +
        'top-level component that never unmounts render these elements.',
        this.constructor.displayName
      ) : invariant(false));
    },

    render: function() {
      return elementFactory(this.props);
    }
  });

  return FullPageComponent;
}

module.exports = createFullPageComponent;

}).call(this,require('_process'))
},{"./ReactCompositeComponent":36,"./ReactElement":54,"./invariant":128,"_process":2}],106:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createNodesFromMarkup
 * @typechecks
 */

/*jslint evil: true, sub: true */

var ExecutionEnvironment = require("./ExecutionEnvironment");

var createArrayFrom = require("./createArrayFrom");
var getMarkupWrap = require("./getMarkupWrap");
var invariant = require("./invariant");

/**
 * Dummy container used to render all markup.
 */
var dummyNode =
  ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup(markup, handleScript) {
  var node = dummyNode;
  ("production" !== process.env.NODE_ENV ? invariant(!!dummyNode, 'createNodesFromMarkup dummy not initialized') : invariant(!!dummyNode));
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    ("production" !== process.env.NODE_ENV ? invariant(
      handleScript,
      'createNodesFromMarkup(...): Unexpected <script> element rendered.'
    ) : invariant(handleScript));
    createArrayFrom(scripts).forEach(handleScript);
  }

  var nodes = createArrayFrom(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

module.exports = createNodesFromMarkup;

}).call(this,require('_process'))
},{"./ExecutionEnvironment":23,"./createArrayFrom":104,"./getMarkupWrap":120,"./invariant":128,"_process":2}],107:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule dangerousStyleValue
 * @typechecks static-only
 */

"use strict";

var CSSProperty = require("./CSSProperty");

var isUnitlessNumber = CSSProperty.isUnitlessNumber;

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isNonNumeric || value === 0 ||
      isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    value = value.trim();
  }
  return value + 'px';
}

module.exports = dangerousStyleValue;

},{"./CSSProperty":5}],108:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule deprecated
 */

var assign = require("./Object.assign");
var warning = require("./warning");

/**
 * This will log a single deprecation notice per function and forward the call
 * on to the new API.
 *
 * @param {string} namespace The namespace of the call, eg 'React'
 * @param {string} oldName The old function name, eg 'renderComponent'
 * @param {string} newName The new function name, eg 'render'
 * @param {*} ctx The context this forwarded call should run in
 * @param {function} fn The function to forward on to
 * @return {*} Will be the value as returned from `fn`
 */
function deprecated(namespace, oldName, newName, ctx, fn) {
  var warned = false;
  if ("production" !== process.env.NODE_ENV) {
    var newFn = function() {
      ("production" !== process.env.NODE_ENV ? warning(
        warned,
        (namespace + "." + oldName + " will be deprecated in a future version. ") +
        ("Use " + namespace + "." + newName + " instead.")
      ) : null);
      warned = true;
      return fn.apply(ctx, arguments);
    };
    newFn.displayName = (namespace + "_" + oldName);
    // We need to make sure all properties of the original fn are copied over.
    // In particular, this is needed to support PropTypes
    return assign(newFn, fn);
  }

  return fn;
}

module.exports = deprecated;

}).call(this,require('_process'))
},{"./Object.assign":28,"./warning":147,"_process":2}],109:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule emptyFunction
 */

function makeEmptyFunction(arg) {
  return function() {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
function emptyFunction() {}

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function() { return this; };
emptyFunction.thatReturnsArgument = function(arg) { return arg; };

module.exports = emptyFunction;

},{}],110:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule emptyObject
 */

"use strict";

var emptyObject = {};

if ("production" !== process.env.NODE_ENV) {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;

}).call(this,require('_process'))
},{"_process":2}],111:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule escapeTextForBrowser
 * @typechecks static-only
 */

"use strict";

var ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  "\"": "&quot;",
  "'": "&#x27;"
};

var ESCAPE_REGEX = /[&><"']/g;

function escaper(match) {
  return ESCAPE_LOOKUP[match];
}

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextForBrowser(text) {
  return ('' + text).replace(ESCAPE_REGEX, escaper);
}

module.exports = escapeTextForBrowser;

},{}],112:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule flattenChildren
 */

"use strict";

var ReactTextComponent = require("./ReactTextComponent");

var traverseAllChildren = require("./traverseAllChildren");
var warning = require("./warning");

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 */
function flattenSingleChildIntoContext(traverseContext, child, name) {
  // We found a component instance.
  var result = traverseContext;
  var keyUnique = !result.hasOwnProperty(name);
  ("production" !== process.env.NODE_ENV ? warning(
    keyUnique,
    'flattenChildren(...): Encountered two children with the same key, ' +
    '`%s`. Child keys must be unique; when two children share a key, only ' +
    'the first child will be used.',
    name
  ) : null);
  if (keyUnique && child != null) {
    var type = typeof child;
    var normalizedValue;

    if (type === 'string') {
      normalizedValue = ReactTextComponent(child);
    } else if (type === 'number') {
      normalizedValue = ReactTextComponent('' + child);
    } else {
      normalizedValue = child;
    }

    result[name] = normalizedValue;
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children) {
  if (children == null) {
    return children;
  }
  var result = {};
  traverseAllChildren(children, flattenSingleChildIntoContext, result);
  return result;
}

module.exports = flattenChildren;

}).call(this,require('_process'))
},{"./ReactTextComponent":80,"./traverseAllChildren":146,"./warning":147,"_process":2}],113:[function(require,module,exports){
/**
 * Copyright 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule focusNode
 */

"use strict";

/**
 * @param {DOMElement} node input/textarea to focus
 */
function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch(e) {
  }
}

module.exports = focusNode;

},{}],114:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule forEachAccumulated
 */

"use strict";

/**
 * @param {array} an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */
var forEachAccumulated = function(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
};

module.exports = forEachAccumulated;

},{}],115:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getActiveElement
 * @typechecks
 */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document body is not yet defined.
 */
function getActiveElement() /*?DOMElement*/ {
  try {
    return document.activeElement || document.body;
  } catch (e) {
    return document.body;
  }
}

module.exports = getActiveElement;

},{}],116:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventCharCode
 * @typechecks static-only
 */

"use strict";

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

module.exports = getEventCharCode;

},{}],117:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventKey
 * @typechecks static-only
 */

"use strict";

var getEventCharCode = require("./getEventCharCode");

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  'Esc': 'Escape',
  'Spacebar': ' ',
  'Left': 'ArrowLeft',
  'Up': 'ArrowUp',
  'Right': 'ArrowRight',
  'Down': 'ArrowDown',
  'Del': 'Delete',
  'Win': 'OS',
  'Menu': 'ContextMenu',
  'Apps': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'MozPrintableKey': 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

module.exports = getEventKey;

},{"./getEventCharCode":116}],118:[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventModifierState
 * @typechecks static-only
 */

"use strict";

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  'Alt': 'altKey',
  'Control': 'ctrlKey',
  'Meta': 'metaKey',
  'Shift': 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  /*jshint validthis:true */
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

module.exports = getEventModifierState;

},{}],119:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventTarget
 * @typechecks static-only
 */

"use strict";

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */
function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;
  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;

},{}],120:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getMarkupWrap
 */

var ExecutionEnvironment = require("./ExecutionEnvironment");

var invariant = require("./invariant");

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode =
  ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */
var shouldWrap = {
  // Force wrapping for SVG elements because if they get created inside a <div>,
  // they will be initialized in the wrong namespace (and will not display).
  'circle': true,
  'defs': true,
  'ellipse': true,
  'g': true,
  'line': true,
  'linearGradient': true,
  'path': true,
  'polygon': true,
  'polyline': true,
  'radialGradient': true,
  'rect': true,
  'stop': true,
  'text': true
};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg>', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap,

  'circle': svgWrap,
  'defs': svgWrap,
  'ellipse': svgWrap,
  'g': svgWrap,
  'line': svgWrap,
  'linearGradient': svgWrap,
  'path': svgWrap,
  'polygon': svgWrap,
  'polyline': svgWrap,
  'radialGradient': svgWrap,
  'rect': svgWrap,
  'stop': svgWrap,
  'text': svgWrap
};

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap(nodeName) {
  ("production" !== process.env.NODE_ENV ? invariant(!!dummyNode, 'Markup wrapping node not initialized') : invariant(!!dummyNode));
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode.innerHTML = '<link />';
    } else {
      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}


module.exports = getMarkupWrap;

}).call(this,require('_process'))
},{"./ExecutionEnvironment":23,"./invariant":128,"_process":2}],121:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getNodeForCharacterOffset
 */

"use strict";

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */
function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType == 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

module.exports = getNodeForCharacterOffset;

},{}],122:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getReactRootElementInContainer
 */

"use strict";

var DOC_NODE_TYPE = 9;

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 *                                           a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

module.exports = getReactRootElementInContainer;

},{}],123:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getTextContentAccessor
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ?
      'textContent' :
      'innerText';
  }
  return contentKey;
}

module.exports = getTextContentAccessor;

},{"./ExecutionEnvironment":23}],124:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getUnboundedScrollPosition
 * @typechecks
 */

"use strict";

/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */
function getUnboundedScrollPosition(scrollable) {
  if (scrollable === window) {
    return {
      x: window.pageXOffset || document.documentElement.scrollLeft,
      y: window.pageYOffset || document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;

},{}],125:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule hyphenate
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

},{}],126:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule hyphenateStyleName
 * @typechecks
 */

"use strict";

var hyphenate = require("./hyphenate");

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

},{"./hyphenate":125}],127:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule instantiateReactComponent
 * @typechecks static-only
 */

"use strict";

var warning = require("./warning");

var ReactElement = require("./ReactElement");
var ReactLegacyElement = require("./ReactLegacyElement");
var ReactNativeComponent = require("./ReactNativeComponent");
var ReactEmptyComponent = require("./ReactEmptyComponent");

/**
 * Given an `element` create an instance that will actually be mounted.
 *
 * @param {object} element
 * @param {*} parentCompositeType The composite type that resolved this.
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent(element, parentCompositeType) {
  var instance;

  if ("production" !== process.env.NODE_ENV) {
    ("production" !== process.env.NODE_ENV ? warning(
      element && (typeof element.type === 'function' ||
                     typeof element.type === 'string'),
      'Only functions or strings can be mounted as React components.'
    ) : null);

    // Resolve mock instances
    if (element.type._mockedReactClassConstructor) {
      // If this is a mocked class, we treat the legacy factory as if it was the
      // class constructor for future proofing unit tests. Because this might
      // be mocked as a legacy factory, we ignore any warnings triggerd by
      // this temporary hack.
      ReactLegacyElement._isLegacyCallWarningEnabled = false;
      try {
        instance = new element.type._mockedReactClassConstructor(
          element.props
        );
      } finally {
        ReactLegacyElement._isLegacyCallWarningEnabled = true;
      }

      // If the mock implementation was a legacy factory, then it returns a
      // element. We need to turn this into a real component instance.
      if (ReactElement.isValidElement(instance)) {
        instance = new instance.type(instance.props);
      }

      var render = instance.render;
      if (!render) {
        // For auto-mocked factories, the prototype isn't shimmed and therefore
        // there is no render function on the instance. We replace the whole
        // component with an empty component instance instead.
        element = ReactEmptyComponent.getEmptyComponent();
      } else {
        if (render._isMockFunction && !render._getMockImplementation()) {
          // Auto-mocked components may have a prototype with a mocked render
          // function. For those, we'll need to mock the result of the render
          // since we consider undefined to be invalid results from render.
          render.mockImplementation(
            ReactEmptyComponent.getEmptyComponent
          );
        }
        instance.construct(element);
        return instance;
      }
    }
  }

  // Special case string values
  if (typeof element.type === 'string') {
    instance = ReactNativeComponent.createInstanceForTag(
      element.type,
      element.props,
      parentCompositeType
    );
  } else {
    // Normal case for non-mocks and non-strings
    instance = new element.type(element.props);
  }

  if ("production" !== process.env.NODE_ENV) {
    ("production" !== process.env.NODE_ENV ? warning(
      typeof instance.construct === 'function' &&
      typeof instance.mountComponent === 'function' &&
      typeof instance.receiveComponent === 'function',
      'Only React Components can be mounted.'
    ) : null);
  }

  // This actually sets up the internal instance. This will become decoupled
  // from the public instance in a future diff.
  instance.construct(element);

  return instance;
}

module.exports = instantiateReactComponent;

}).call(this,require('_process'))
},{"./ReactElement":54,"./ReactEmptyComponent":56,"./ReactLegacyElement":63,"./ReactNativeComponent":68,"./warning":147,"_process":2}],128:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

"use strict";

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if ("production" !== process.env.NODE_ENV) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        'Invariant Violation: ' +
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

}).call(this,require('_process'))
},{"_process":2}],129:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isEventSupported
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature =
    document.implementation &&
    document.implementation.hasFeature &&
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM ||
      capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;

},{"./ExecutionEnvironment":23}],130:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isNode
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode(object) {
  return !!(object && (
    typeof Node === 'function' ? object instanceof Node :
      typeof object === 'object' &&
      typeof object.nodeType === 'number' &&
      typeof object.nodeName === 'string'
  ));
}

module.exports = isNode;

},{}],131:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isTextInputElement
 */

"use strict";

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  'color': true,
  'date': true,
  'datetime': true,
  'datetime-local': true,
  'email': true,
  'month': true,
  'number': true,
  'password': true,
  'range': true,
  'search': true,
  'tel': true,
  'text': true,
  'time': true,
  'url': true,
  'week': true
};

function isTextInputElement(elem) {
  return elem && (
    (elem.nodeName === 'INPUT' && supportedInputTypes[elem.type]) ||
    elem.nodeName === 'TEXTAREA'
  );
}

module.exports = isTextInputElement;

},{}],132:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isTextNode
 * @typechecks
 */

var isNode = require("./isNode");

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

},{"./isNode":130}],133:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule joinClasses
 * @typechecks static-only
 */

"use strict";

/**
 * Combines multiple className strings into one.
 * http://jsperf.com/joinclasses-args-vs-array
 *
 * @param {...?string} classes
 * @return {string}
 */
function joinClasses(className/*, ... */) {
  if (!className) {
    className = '';
  }
  var nextClass;
  var argLength = arguments.length;
  if (argLength > 1) {
    for (var ii = 1; ii < argLength; ii++) {
      nextClass = arguments[ii];
      if (nextClass) {
        className = (className ? className + ' ' : '') + nextClass;
      }
    }
  }
  return className;
}

module.exports = joinClasses;

},{}],134:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyMirror
 * @typechecks static-only
 */

"use strict";

var invariant = require("./invariant");

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function(obj) {
  var ret = {};
  var key;
  ("production" !== process.env.NODE_ENV ? invariant(
    obj instanceof Object && !Array.isArray(obj),
    'keyMirror(...): Argument must be an object.'
  ) : invariant(obj instanceof Object && !Array.isArray(obj)));
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;

}).call(this,require('_process'))
},{"./invariant":128,"_process":2}],135:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyOf
 */

/**
 * Allows extraction of a minified key. Let's the build system minify keys
 * without loosing the ability to dynamically use key strings as values
 * themselves. Pass in an object with a single key/val pair and it will return
 * you the string key of that single record. Suppose you want to grab the
 * value for a key 'className' inside of an object. Key/val minification may
 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
 * reuse those resolutions.
 */
var keyOf = function(oneKeyObj) {
  var key;
  for (key in oneKeyObj) {
    if (!oneKeyObj.hasOwnProperty(key)) {
      continue;
    }
    return key;
  }
  return null;
};


module.exports = keyOf;

},{}],136:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule mapObject
 */

'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Executes the provided `callback` once for each enumerable own property in the
 * object and constructs a new object from the results. The `callback` is
 * invoked with three arguments:
 *
 *  - the property value
 *  - the property name
 *  - the object being traversed
 *
 * Properties that are added after the call to `mapObject` will not be visited
 * by `callback`. If the values of existing properties are changed, the value
 * passed to `callback` will be the value at the time `mapObject` visits them.
 * Properties that are deleted before being visited are not visited.
 *
 * @grep function objectMap()
 * @grep function objMap()
 *
 * @param {?object} object
 * @param {function} callback
 * @param {*} context
 * @return {?object}
 */
function mapObject(object, callback, context) {
  if (!object) {
    return null;
  }
  var result = {};
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result[name] = callback.call(context, object[name], name, object);
    }
  }
  return result;
}

module.exports = mapObject;

},{}],137:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule memoizeStringOnly
 * @typechecks static-only
 */

"use strict";

/**
 * Memoizes the return value of a function that accepts one string argument.
 *
 * @param {function} callback
 * @return {function}
 */
function memoizeStringOnly(callback) {
  var cache = {};
  return function(string) {
    if (cache.hasOwnProperty(string)) {
      return cache[string];
    } else {
      return cache[string] = callback.call(this, string);
    }
  };
}

module.exports = memoizeStringOnly;

},{}],138:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule monitorCodeUse
 */

"use strict";

var invariant = require("./invariant");

/**
 * Provides open-source compatible instrumentation for monitoring certain API
 * uses before we're ready to issue a warning or refactor. It accepts an event
 * name which may only contain the characters [a-z0-9_] and an optional data
 * object with further information.
 */

function monitorCodeUse(eventName, data) {
  ("production" !== process.env.NODE_ENV ? invariant(
    eventName && !/[^a-z0-9_]/.test(eventName),
    'You must provide an eventName using only the characters [a-z0-9_]'
  ) : invariant(eventName && !/[^a-z0-9_]/.test(eventName)));
}

module.exports = monitorCodeUse;

}).call(this,require('_process'))
},{"./invariant":128,"_process":2}],139:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule onlyChild
 */
"use strict";

var ReactElement = require("./ReactElement");

var invariant = require("./invariant");

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection. The current implementation of this
 * function assumes that a single child gets passed without a wrapper, but the
 * purpose of this helper function is to abstract away the particular structure
 * of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactComponent} The first and only `ReactComponent` contained in the
 * structure.
 */
function onlyChild(children) {
  ("production" !== process.env.NODE_ENV ? invariant(
    ReactElement.isValidElement(children),
    'onlyChild must be passed a children with exactly one child.'
  ) : invariant(ReactElement.isValidElement(children)));
  return children;
}

module.exports = onlyChild;

}).call(this,require('_process'))
},{"./ReactElement":54,"./invariant":128,"_process":2}],140:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule performance
 * @typechecks
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

var performance;

if (ExecutionEnvironment.canUseDOM) {
  performance =
    window.performance ||
    window.msPerformance ||
    window.webkitPerformance;
}

module.exports = performance || {};

},{"./ExecutionEnvironment":23}],141:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule performanceNow
 * @typechecks
 */

var performance = require("./performance");

/**
 * Detect if we can use `window.performance.now()` and gracefully fallback to
 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
 * because of Facebook's testing infrastructure.
 */
if (!performance || !performance.now) {
  performance = Date;
}

var performanceNow = performance.now.bind(performance);

module.exports = performanceNow;

},{"./performance":140}],142:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule setInnerHTML
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

var WHITESPACE_TEST = /^[ \r\n\t\f]/;
var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = function(node, html) {
  node.innerHTML = html;
};

if (ExecutionEnvironment.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML = function(node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (WHITESPACE_TEST.test(html) ||
          html[0] === '<' && NONVISIBLE_TEST.test(html)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        node.innerHTML = '\uFEFF' + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
}

module.exports = setInnerHTML;

},{"./ExecutionEnvironment":23}],143:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule shallowEqual
 */

"use strict";

/**
 * Performs equality by iterating through keys on an object and returning
 * false when any key has values which are not strictly equal between
 * objA and objB. Returns true when the values of all keys are strictly equal.
 *
 * @return {boolean}
 */
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }
  var key;
  // Test for A's keys different from B.
  for (key in objA) {
    if (objA.hasOwnProperty(key) &&
        (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {
      return false;
    }
  }
  // Test for B's keys missing from A.
  for (key in objB) {
    if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {
      return false;
    }
  }
  return true;
}

module.exports = shallowEqual;

},{}],144:[function(require,module,exports){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule shouldUpdateReactComponent
 * @typechecks static-only
 */

"use strict";

/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */
function shouldUpdateReactComponent(prevElement, nextElement) {
  if (prevElement && nextElement &&
      prevElement.type === nextElement.type &&
      prevElement.key === nextElement.key &&
      prevElement._owner === nextElement._owner) {
    return true;
  }
  return false;
}

module.exports = shouldUpdateReactComponent;

},{}],145:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule toArray
 * @typechecks
 */

var invariant = require("./invariant");

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFrom.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
  // old versions of Safari).
  ("production" !== process.env.NODE_ENV ? invariant(
    !Array.isArray(obj) &&
    (typeof obj === 'object' || typeof obj === 'function'),
    'toArray: Array-like object expected'
  ) : invariant(!Array.isArray(obj) &&
  (typeof obj === 'object' || typeof obj === 'function')));

  ("production" !== process.env.NODE_ENV ? invariant(
    typeof length === 'number',
    'toArray: Object needs a length property'
  ) : invariant(typeof length === 'number'));

  ("production" !== process.env.NODE_ENV ? invariant(
    length === 0 ||
    (length - 1) in obj,
    'toArray: Object should have keys for indices'
  ) : invariant(length === 0 ||
  (length - 1) in obj));

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
      // IE < 9 does not support Array#slice on collections objects
    }
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

module.exports = toArray;

}).call(this,require('_process'))
},{"./invariant":128,"_process":2}],146:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule traverseAllChildren
 */

"use strict";

var ReactElement = require("./ReactElement");
var ReactInstanceHandles = require("./ReactInstanceHandles");

var invariant = require("./invariant");

var SEPARATOR = ReactInstanceHandles.SEPARATOR;
var SUBSEPARATOR = ':';

/**
 * TODO: Test that:
 * 1. `mapChildren` transforms strings and numbers into `ReactTextComponent`.
 * 2. it('should fail when supplied duplicate key', function() {
 * 3. That a single child and an array with one item have the same key pattern.
 * });
 */

var userProvidedKeyEscaperLookup = {
  '=': '=0',
  '.': '=1',
  ':': '=2'
};

var userProvidedKeyEscapeRegex = /[=.:]/g;

function userProvidedKeyEscaper(match) {
  return userProvidedKeyEscaperLookup[match];
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  if (component && component.key != null) {
    // Explicit key
    return wrapUserProvidedKey(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * Escape a component key so that it is safe to use in a reactid.
 *
 * @param {*} key Component key to be escaped.
 * @return {string} An escaped string.
 */
function escapeUserProvidedKey(text) {
  return ('' + text).replace(
    userProvidedKeyEscapeRegex,
    userProvidedKeyEscaper
  );
}

/**
 * Wrap a `key` value explicitly provided by the user to distinguish it from
 * implicitly-generated keys generated by a component's index in its parent.
 *
 * @param {string} key Value of a user-provided `key` attribute
 * @return {string}
 */
function wrapUserProvidedKey(key) {
  return '$' + escapeUserProvidedKey(key);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!number} indexSoFar Number of children encountered until this point.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
var traverseAllChildrenImpl =
  function(children, nameSoFar, indexSoFar, callback, traverseContext) {
    var nextName, nextIndex;
    var subtreeCount = 0;  // Count of children found in the current subtree.
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        nextName = (
          nameSoFar +
          (nameSoFar ? SUBSEPARATOR : SEPARATOR) +
          getComponentKey(child, i)
        );
        nextIndex = indexSoFar + subtreeCount;
        subtreeCount += traverseAllChildrenImpl(
          child,
          nextName,
          nextIndex,
          callback,
          traverseContext
        );
      }
    } else {
      var type = typeof children;
      var isOnlyChild = nameSoFar === '';
      // If it's the only child, treat the name as if it was wrapped in an array
      // so that it's consistent if the number of children grows
      var storageName =
        isOnlyChild ? SEPARATOR + getComponentKey(children, 0) : nameSoFar;
      if (children == null || type === 'boolean') {
        // All of the above are perceived as null.
        callback(traverseContext, null, storageName, indexSoFar);
        subtreeCount = 1;
      } else if (type === 'string' || type === 'number' ||
                 ReactElement.isValidElement(children)) {
        callback(traverseContext, children, storageName, indexSoFar);
        subtreeCount = 1;
      } else if (type === 'object') {
        ("production" !== process.env.NODE_ENV ? invariant(
          !children || children.nodeType !== 1,
          'traverseAllChildren(...): Encountered an invalid child; DOM ' +
          'elements are not valid children of React components.'
        ) : invariant(!children || children.nodeType !== 1));
        for (var key in children) {
          if (children.hasOwnProperty(key)) {
            nextName = (
              nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) +
              wrapUserProvidedKey(key) + SUBSEPARATOR +
              getComponentKey(children[key], 0)
            );
            nextIndex = indexSoFar + subtreeCount;
            subtreeCount += traverseAllChildrenImpl(
              children[key],
              nextName,
              nextIndex,
              callback,
              traverseContext
            );
          }
        }
      }
    }
    return subtreeCount;
  };

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', 0, callback, traverseContext);
}

module.exports = traverseAllChildren;

}).call(this,require('_process'))
},{"./ReactElement":54,"./ReactInstanceHandles":62,"./invariant":128,"_process":2}],147:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule warning
 */

"use strict";

var emptyFunction = require("./emptyFunction");

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if ("production" !== process.env.NODE_ENV) {
  warning = function(condition, format ) {for (var args=[],$__0=2,$__1=arguments.length;$__0<$__1;$__0++) args.push(arguments[$__0]);
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (!condition) {
      var argIndex = 0;
      console.warn('Warning: ' + format.replace(/%s/g, function()  {return args[argIndex++];}));
    }
  };
}

module.exports = warning;

}).call(this,require('_process'))
},{"./emptyFunction":109,"_process":2}],148:[function(require,module,exports){
module.exports = require('./lib/React');

},{"./lib/React":30}],149:[function(require,module,exports){
/**
 * dat.globe Javascript WebGL Globe Toolkit
 * http://dataarts.github.com/dat.globe
 *
 * Copyright 2011 Data Arts Team, Google Creative Lab
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

var THREE = require("../globe/third-party/three.min.js");

var DAT = DAT || {};

DAT.Globe = function(container, opts) {
  opts = opts || {};
  
  var colorFn = opts.colorFn || function(x) {
    var c = new THREE.Color();
    c.setHSL( ( 0.6 - ( x * 0.5 ) ), 1.0, 0.5 );
    return c;
  };
  var imgDir = opts.imgDir || '/globe/';

  var Shaders = {
    'earth' : {
      uniforms: {
        'texture': { type: 't', value: null }
      },
      vertexShader: [
        'varying vec3 vNormal;',
        'varying vec2 vUv;',
        'void main() {',
          'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
          'vNormal = normalize( normalMatrix * normal );',
          'vUv = uv;',
        '}'
      ].join('\n'),
      fragmentShader: [
        'uniform sampler2D texture;',
        'varying vec3 vNormal;',
        'varying vec2 vUv;',
        'void main() {',
          'vec3 diffuse = texture2D( texture, vUv ).xyz;',
          'float intensity = 1.05 - dot( vNormal, vec3( 0.0, 0.0, 1.0 ) );',
          'vec3 atmosphere = vec3( 1.0, 1.0, 1.0 ) * pow( intensity, 3.0 );',
          'gl_FragColor = vec4( diffuse + atmosphere, 1.0 );',
        '}'
      ].join('\n')
    },
    'atmosphere' : {
      uniforms: {},
      vertexShader: [
        'varying vec3 vNormal;',
        'void main() {',
          'vNormal = normalize( normalMatrix * normal );',
          'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
        '}'
      ].join('\n'),
      fragmentShader: [
        'varying vec3 vNormal;',
        'void main() {',
          'float intensity = pow( 0.8 - dot( vNormal, vec3( 0, 0, 1.0 ) ), 12.0 );',
          'gl_FragColor = vec4( 1.0, 1.0, 1.0, 1.0 ) * intensity;',
        '}'
      ].join('\n')
    }
  };

  var camera, scene, renderer, w, h;
  var mesh, atmosphere, point;

  var overRenderer;

  var curZoomSpeed = 0;
  var zoomSpeed = 50;

  var mouse = { x: 0, y: 0 }, mouseOnDown = { x: 0, y: 0 };
  var rotation = { x: 0, y: 0 },
      target = { x: Math.PI*3/2, y: Math.PI / 6.0 },
      targetOnDown = { x: 0, y: 0 };

  var distance = 100000, distanceTarget = 100000;
  var padding = 40;
  var PI_HALF = Math.PI / 2;

  function init() {

    container.style.color = '#fff';
    container.style.font = '13px/20px Arial, sans-serif';

    var shader, uniforms, material;
    w = container.offsetWidth || window.innerWidth;
    h = container.offsetHeight || window.innerHeight;

    camera = new THREE.PerspectiveCamera(30, w / h, 1, 10000);
    camera.position.z = distance;

    scene = new THREE.Scene();

    var geometry = new THREE.SphereGeometry(200, 40, 30);

    shader = Shaders['earth'];
    uniforms = THREE.UniformsUtils.clone(shader.uniforms);

    uniforms['texture'].value = THREE.ImageUtils.loadTexture(imgDir+'world.jpg');

    material = new THREE.ShaderMaterial({

          uniforms: uniforms,
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader

        });

    mesh = new THREE.Mesh(geometry, material);
    mesh.rotation.y = Math.PI;
    scene.add(mesh);

    shader = Shaders['atmosphere'];
    uniforms = THREE.UniformsUtils.clone(shader.uniforms);

    material = new THREE.ShaderMaterial({

          uniforms: uniforms,
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader,
          side: THREE.BackSide,
          blending: THREE.AdditiveBlending,
          transparent: true

        });

    mesh = new THREE.Mesh(geometry, material);
    mesh.scale.set( 1.1, 1.1, 1.1 );
    scene.add(mesh);

    geometry = new THREE.CubeGeometry(0.75, 0.75, 1);
    geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0,0,-0.5));

    point = new THREE.Mesh(geometry);

    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(w, h);

    renderer.domElement.style.position = 'absolute';

    container.appendChild(renderer.domElement);

    container.addEventListener('mousedown', onMouseDown, false);

    container.addEventListener('mousewheel', onMouseWheel, false);

    document.addEventListener('keydown', onDocumentKeyDown, false);

    window.addEventListener('resize', onWindowResize, false);

    container.addEventListener('mouseover', function() {
      overRenderer = true;
    }, false);

    container.addEventListener('mouseout', function() {
      overRenderer = false;
    }, false);
  }

  addData = function(data, opts) {
    var lat, lng, size, color, i, step, colorFnWrapper;

    opts.animated = opts.animated || false;
    this.is_animated = opts.animated;
    opts.format = opts.format || 'magnitude'; // other option is 'legend'
    console.log(opts.format);
    if (opts.format === 'magnitude') {
      step = 3;
      colorFnWrapper = function(data, i) { return colorFn(data[i+2]); }
    } else if (opts.format === 'legend') {
      step = 4;
      colorFnWrapper = function(data, i) { return colorFn(data[i+3]); }
    } else {
      throw('error: format not supported: '+opts.format);
    }

    if (opts.animated) {
      if (this._baseGeometry === undefined) {
        this._baseGeometry = new THREE.Geometry();
        for (i = 0; i < data.length; i += step) {
          lat = data[i];
          lng = data[i + 1];
//        size = data[i + 2];
          color = colorFnWrapper(data,i);
          size = 0;
          addPoint(lat, lng, size, color, this._baseGeometry);
        }
      }
      if(this._morphTargetId === undefined) {
        this._morphTargetId = 0;
      } else {
        this._morphTargetId += 1;
      }
      opts.name = opts.name || 'morphTarget'+this._morphTargetId;
    }
    var subgeo = new THREE.Geometry();
    for (i = 0; i < data.length; i += step) {
      lat = data[i];
      lng = data[i + 1];
      color = colorFnWrapper(data,i);
      size = data[i + 2];
      size = size*200;
      addPoint(lat, lng, size, color, subgeo);
    }
    if (opts.animated) {
      this._baseGeometry.morphTargets.push({'name': opts.name, vertices: subgeo.vertices});
    } else {
      this._baseGeometry = subgeo;
    }

  };

  function createPoints() {
    if (this._baseGeometry !== undefined) {
      if (this.is_animated === false) {
        this.points = new THREE.Mesh(this._baseGeometry, new THREE.MeshBasicMaterial({
              color: 0xffffff,
              vertexColors: THREE.FaceColors,
              morphTargets: false
            }));
      } else {
        if (this._baseGeometry.morphTargets.length < 8) {
          console.log('t l',this._baseGeometry.morphTargets.length);
          var padding = 8-this._baseGeometry.morphTargets.length;
          console.log('padding', padding);
          for(var i=0; i<=padding; i++) {
            console.log('padding',i);
            this._baseGeometry.morphTargets.push({'name': 'morphPadding'+i, vertices: this._baseGeometry.vertices});
          }
        }
        this.points = new THREE.Mesh(this._baseGeometry, new THREE.MeshBasicMaterial({
              color: 0xffffff,
              vertexColors: THREE.FaceColors,
              morphTargets: true
            }));
      }
      scene.add(this.points);
    }
  }

  function addPoint(lat, lng, size, color, subgeo) {

    var phi = (90 - lat) * Math.PI / 180;
    var theta = (180 - lng) * Math.PI / 180;

    point.position.x = 200 * Math.sin(phi) * Math.cos(theta);
    point.position.y = 200 * Math.cos(phi);
    point.position.z = 200 * Math.sin(phi) * Math.sin(theta);

    point.lookAt(mesh.position);

    point.scale.z = Math.max( size, 0.1 ); // avoid non-invertible matrix
    point.updateMatrix();

    for (var i = 0; i < point.geometry.faces.length; i++) {

      point.geometry.faces[i].color = color;

    }

    THREE.GeometryUtils.merge(subgeo, point);
  }

  function onMouseDown(event) {
    event.preventDefault();

    container.addEventListener('mousemove', onMouseMove, false);
    container.addEventListener('mouseup', onMouseUp, false);
    container.addEventListener('mouseout', onMouseOut, false);

    mouseOnDown.x = - event.clientX;
    mouseOnDown.y = event.clientY;

    targetOnDown.x = target.x;
    targetOnDown.y = target.y;

    container.style.cursor = 'move';
  }

  function onMouseMove(event) {
    mouse.x = - event.clientX;
    mouse.y = event.clientY;

    var zoomDamp = distance/1000;

    target.x = targetOnDown.x + (mouse.x - mouseOnDown.x) * 0.005 * zoomDamp;
    target.y = targetOnDown.y + (mouse.y - mouseOnDown.y) * 0.005 * zoomDamp;

    target.y = target.y > PI_HALF ? PI_HALF : target.y;
    target.y = target.y < - PI_HALF ? - PI_HALF : target.y;
  }

  function onMouseUp(event) {
    container.removeEventListener('mousemove', onMouseMove, false);
    container.removeEventListener('mouseup', onMouseUp, false);
    container.removeEventListener('mouseout', onMouseOut, false);
    container.style.cursor = 'auto';
  }

  function onMouseOut(event) {
    container.removeEventListener('mousemove', onMouseMove, false);
    container.removeEventListener('mouseup', onMouseUp, false);
    container.removeEventListener('mouseout', onMouseOut, false);
  }

  function onMouseWheel(event) {
    event.preventDefault();
    if (overRenderer) {
      zoom(event.wheelDeltaY * 0.3);
    }
    return false;
  }

  function onDocumentKeyDown(event) {
    switch (event.keyCode) {
      case 38:
        zoom(100);
        event.preventDefault();
        break;
      case 40:
        zoom(-100);
        event.preventDefault();
        break;
    }
  }

  function onWindowResize( event ) {
    camera.aspect = container.offsetWidth / container.offsetHeight;
    camera.updateProjectionMatrix();
    renderer.setSize( container.offsetWidth, container.offsetHeight );
  }

  function zoom(delta) {
    distanceTarget -= delta;
    distanceTarget = distanceTarget > 1000 ? 1000 : distanceTarget;
    distanceTarget = distanceTarget < 350 ? 350 : distanceTarget;
  }

  function animate() {
    requestAnimationFrame(animate);
    render();
  }

  function render() {
    zoom(curZoomSpeed);

    rotation.x += (target.x - rotation.x) * 0.1;
    rotation.y += (target.y - rotation.y) * 0.1;
    distance += (distanceTarget - distance) * 0.3;

    camera.position.x = distance * Math.sin(rotation.x) * Math.cos(rotation.y);
    camera.position.y = distance * Math.sin(rotation.y);
    camera.position.z = distance * Math.cos(rotation.x) * Math.cos(rotation.y);

    camera.lookAt(mesh.position);

    renderer.render(scene, camera);
  }

  init();
  this.animate = animate;


  this.__defineGetter__('time', function() {
    return this._time || 0;
  });

  this.__defineSetter__('time', function(t) {
    var validMorphs = [];
    var morphDict = this.points.morphTargetDictionary;
    for(var k in morphDict) {
      if(k.indexOf('morphPadding') < 0) {
        validMorphs.push(morphDict[k]);
      }
    }
    validMorphs.sort();
    var l = validMorphs.length-1;
    var scaledt = t*l+1;
    var index = Math.floor(scaledt);
    for (i=0;i<validMorphs.length;i++) {
      this.points.morphTargetInfluences[validMorphs[i]] = 0;
    }
    var lastIndex = index - 1;
    var leftover = scaledt - index;
    if (lastIndex >= 0) {
      this.points.morphTargetInfluences[lastIndex] = 1 - leftover;
    }
    this.points.morphTargetInfluences[index] = leftover;
    this._time = t;
  });

  this.addData = addData;
  this.createPoints = createPoints;
  this.renderer = renderer;
  this.scene = scene;

  return this;

};

module.exports = DAT;

},{"../globe/third-party/three.min.js":152}],150:[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mr.doob / http://mrdoob.com/
 */

Detector = {

  canvas : !! window.CanvasRenderingContext2D,
  webgl : ( function () { try { return !! window.WebGLRenderingContext && !! document.createElement( 'canvas' ).getContext( 'experimental-webgl' ); } catch( e ) { return false; } } )(),
  workers : !! window.Worker,
  fileapi : window.File && window.FileReader && window.FileList && window.Blob,

  getWebGLErrorMessage : function () {

    var domElement = document.createElement( 'div' );

    domElement.style.fontFamily = 'monospace';
    domElement.style.fontSize = '13px';
    domElement.style.textAlign = 'center';
    domElement.style.background = '#eee';
    domElement.style.color = '#000';
    domElement.style.padding = '1em';
    domElement.style.width = '475px';
    domElement.style.margin = '5em auto 0';

    if ( ! this.webgl ) {

      domElement.innerHTML = window.WebGLRenderingContext ? [
        'Sorry, your graphics card doesn\'t support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">WebGL</a>'
      ].join( '\n' ) : [
        'Sorry, your browser doesn\'t support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">WebGL</a><br/>',
        'Please try with',
        '<a href="http://www.google.com/chrome">Chrome</a>, ',
        '<a href="http://www.mozilla.com/en-US/firefox/new/">Firefox 4</a> or',
        '<a href="http://nightly.webkit.org/">Webkit Nightly (Mac)</a>'
      ].join( '\n' );

    }

    return domElement;

  },

  addGetWebGLMessage : function ( parameters ) {

    var parent, id, domElement;

    parameters = parameters || {};

    parent = parameters.parent !== undefined ? parameters.parent : document.body;
    id = parameters.id !== undefined ? parameters.id : 'oldie';

    domElement = Detector.getWebGLErrorMessage();
    domElement.id = id;

    parent.appendChild( domElement );

  }

};

module.exports = Detector;


},{}],151:[function(require,module,exports){
// Tween.js - http://github.com/sole/tween.js
var TWEEN=TWEEN||function(){var a,e,c,d,f=[];return{start:function(g){c=setInterval(this.update,1E3/(g||60))},stop:function(){clearInterval(c)},add:function(g){f.push(g)},remove:function(g){a=f.indexOf(g);a!==-1&&f.splice(a,1)},update:function(){a=0;e=f.length;for(d=(new Date).getTime();a<e;)if(f[a].update(d))a++;else{f.splice(a,1);e--}}}}();
TWEEN.Tween=function(a){var e={},c={},d={},f=1E3,g=0,j=null,n=TWEEN.Easing.Linear.EaseNone,k=null,l=null,m=null;this.to=function(b,h){if(h!==null)f=h;for(var i in b)if(a[i]!==null)d[i]=b[i];return this};this.start=function(){TWEEN.add(this);j=(new Date).getTime()+g;for(var b in d)if(a[b]!==null){e[b]=a[b];c[b]=d[b]-a[b]}return this};this.stop=function(){TWEEN.remove(this);return this};this.delay=function(b){g=b;return this};this.easing=function(b){n=b;return this};this.chain=function(b){k=b};this.onUpdate=
function(b){l=b;return this};this.onComplete=function(b){m=b;return this};this.update=function(b){var h,i;if(b<j)return true;b=(b-j)/f;b=b>1?1:b;i=n(b);for(h in c)a[h]=e[h]+c[h]*i;l!==null&&l.call(a,i);if(b==1){m!==null&&m.call(a);k!==null&&k.start();return false}return true}};TWEEN.Easing={Linear:{},Quadratic:{},Cubic:{},Quartic:{},Quintic:{},Sinusoidal:{},Exponential:{},Circular:{},Elastic:{},Back:{},Bounce:{}};TWEEN.Easing.Linear.EaseNone=function(a){return a};
TWEEN.Easing.Quadratic.EaseIn=function(a){return a*a};TWEEN.Easing.Quadratic.EaseOut=function(a){return-a*(a-2)};TWEEN.Easing.Quadratic.EaseInOut=function(a){if((a*=2)<1)return 0.5*a*a;return-0.5*(--a*(a-2)-1)};TWEEN.Easing.Cubic.EaseIn=function(a){return a*a*a};TWEEN.Easing.Cubic.EaseOut=function(a){return--a*a*a+1};TWEEN.Easing.Cubic.EaseInOut=function(a){if((a*=2)<1)return 0.5*a*a*a;return 0.5*((a-=2)*a*a+2)};TWEEN.Easing.Quartic.EaseIn=function(a){return a*a*a*a};
TWEEN.Easing.Quartic.EaseOut=function(a){return-(--a*a*a*a-1)};TWEEN.Easing.Quartic.EaseInOut=function(a){if((a*=2)<1)return 0.5*a*a*a*a;return-0.5*((a-=2)*a*a*a-2)};TWEEN.Easing.Quintic.EaseIn=function(a){return a*a*a*a*a};TWEEN.Easing.Quintic.EaseOut=function(a){return(a-=1)*a*a*a*a+1};TWEEN.Easing.Quintic.EaseInOut=function(a){if((a*=2)<1)return 0.5*a*a*a*a*a;return 0.5*((a-=2)*a*a*a*a+2)};TWEEN.Easing.Sinusoidal.EaseIn=function(a){return-Math.cos(a*Math.PI/2)+1};
TWEEN.Easing.Sinusoidal.EaseOut=function(a){return Math.sin(a*Math.PI/2)};TWEEN.Easing.Sinusoidal.EaseInOut=function(a){return-0.5*(Math.cos(Math.PI*a)-1)};TWEEN.Easing.Exponential.EaseIn=function(a){return a==0?0:Math.pow(2,10*(a-1))};TWEEN.Easing.Exponential.EaseOut=function(a){return a==1?1:-Math.pow(2,-10*a)+1};TWEEN.Easing.Exponential.EaseInOut=function(a){if(a==0)return 0;if(a==1)return 1;if((a*=2)<1)return 0.5*Math.pow(2,10*(a-1));return 0.5*(-Math.pow(2,-10*(a-1))+2)};
TWEEN.Easing.Circular.EaseIn=function(a){return-(Math.sqrt(1-a*a)-1)};TWEEN.Easing.Circular.EaseOut=function(a){return Math.sqrt(1- --a*a)};TWEEN.Easing.Circular.EaseInOut=function(a){if((a/=0.5)<1)return-0.5*(Math.sqrt(1-a*a)-1);return 0.5*(Math.sqrt(1-(a-=2)*a)+1)};TWEEN.Easing.Elastic.EaseIn=function(a){var e,c=0.1,d=0.4;if(a==0)return 0;if(a==1)return 1;d||(d=0.3);if(!c||c<1){c=1;e=d/4}else e=d/(2*Math.PI)*Math.asin(1/c);return-(c*Math.pow(2,10*(a-=1))*Math.sin((a-e)*2*Math.PI/d))};
TWEEN.Easing.Elastic.EaseOut=function(a){var e,c=0.1,d=0.4;if(a==0)return 0;if(a==1)return 1;d||(d=0.3);if(!c||c<1){c=1;e=d/4}else e=d/(2*Math.PI)*Math.asin(1/c);return c*Math.pow(2,-10*a)*Math.sin((a-e)*2*Math.PI/d)+1};
TWEEN.Easing.Elastic.EaseInOut=function(a){var e,c=0.1,d=0.4;if(a==0)return 0;if(a==1)return 1;d||(d=0.3);if(!c||c<1){c=1;e=d/4}else e=d/(2*Math.PI)*Math.asin(1/c);if((a*=2)<1)return-0.5*c*Math.pow(2,10*(a-=1))*Math.sin((a-e)*2*Math.PI/d);return c*Math.pow(2,-10*(a-=1))*Math.sin((a-e)*2*Math.PI/d)*0.5+1};TWEEN.Easing.Back.EaseIn=function(a){return a*a*(2.70158*a-1.70158)};TWEEN.Easing.Back.EaseOut=function(a){return(a-=1)*a*(2.70158*a+1.70158)+1};
TWEEN.Easing.Back.EaseInOut=function(a){if((a*=2)<1)return 0.5*a*a*(3.5949095*a-2.5949095);return 0.5*((a-=2)*a*(3.5949095*a+2.5949095)+2)};TWEEN.Easing.Bounce.EaseIn=function(a){return 1-TWEEN.Easing.Bounce.EaseOut(1-a)};TWEEN.Easing.Bounce.EaseOut=function(a){return(a/=1)<1/2.75?7.5625*a*a:a<2/2.75?7.5625*(a-=1.5/2.75)*a+0.75:a<2.5/2.75?7.5625*(a-=2.25/2.75)*a+0.9375:7.5625*(a-=2.625/2.75)*a+0.984375};
TWEEN.Easing.Bounce.EaseInOut=function(a){if(a<0.5)return TWEEN.Easing.Bounce.EaseIn(a*2)*0.5;return TWEEN.Easing.Bounce.EaseOut(a*2-1)*0.5+0.5};

module.exports = TWEEN;

},{}],152:[function(require,module,exports){
// three.js - http://github.com/mrdoob/three.js
'use strict';var THREE={REVISION:"62"};self.console=self.console||{info:function(){},log:function(){},debug:function(){},warn:function(){},error:function(){}};String.prototype.trim=String.prototype.trim||function(){return this.replace(/^\s+|\s+$/g,"")};THREE.extend=function(a,b){if(Object.keys)for(var c=Object.keys(b),d=0,e=c.length;d<e;d++){var f=c[d];Object.defineProperty(a,f,Object.getOwnPropertyDescriptor(b,f))}else for(f in c={}.hasOwnProperty,b)c.call(b,f)&&(a[f]=b[f]);return a};
(function(){for(var a=0,b=["ms","moz","webkit","o"],c=0;c<b.length&&!self.requestAnimationFrame;++c)self.requestAnimationFrame=self[b[c]+"RequestAnimationFrame"],self.cancelAnimationFrame=self[b[c]+"CancelAnimationFrame"]||self[b[c]+"CancelRequestAnimationFrame"];void 0===self.requestAnimationFrame&&void 0!==self.setTimeout&&(self.requestAnimationFrame=function(b){var c=Date.now(),f=Math.max(0,16-(c-a)),h=self.setTimeout(function(){b(c+f)},f);a=c+f;return h});void 0===self.cancelAnimationFrame&&void 0!==
self.clearTimeout&&(self.cancelAnimationFrame=function(a){self.clearTimeout(a)})})();THREE.CullFaceNone=0;THREE.CullFaceBack=1;THREE.CullFaceFront=2;THREE.CullFaceFrontBack=3;THREE.FrontFaceDirectionCW=0;THREE.FrontFaceDirectionCCW=1;THREE.BasicShadowMap=0;THREE.PCFShadowMap=1;THREE.PCFSoftShadowMap=2;THREE.FrontSide=0;THREE.BackSide=1;THREE.DoubleSide=2;THREE.NoShading=0;THREE.FlatShading=1;THREE.SmoothShading=2;THREE.NoColors=0;THREE.FaceColors=1;THREE.VertexColors=2;THREE.NoBlending=0;
THREE.NormalBlending=1;THREE.AdditiveBlending=2;THREE.SubtractiveBlending=3;THREE.MultiplyBlending=4;THREE.CustomBlending=5;THREE.AddEquation=100;THREE.SubtractEquation=101;THREE.ReverseSubtractEquation=102;THREE.ZeroFactor=200;THREE.OneFactor=201;THREE.SrcColorFactor=202;THREE.OneMinusSrcColorFactor=203;THREE.SrcAlphaFactor=204;THREE.OneMinusSrcAlphaFactor=205;THREE.DstAlphaFactor=206;THREE.OneMinusDstAlphaFactor=207;THREE.DstColorFactor=208;THREE.OneMinusDstColorFactor=209;
THREE.SrcAlphaSaturateFactor=210;THREE.MultiplyOperation=0;THREE.MixOperation=1;THREE.AddOperation=2;THREE.UVMapping=function(){};THREE.CubeReflectionMapping=function(){};THREE.CubeRefractionMapping=function(){};THREE.SphericalReflectionMapping=function(){};THREE.SphericalRefractionMapping=function(){};THREE.RepeatWrapping=1E3;THREE.ClampToEdgeWrapping=1001;THREE.MirroredRepeatWrapping=1002;THREE.NearestFilter=1003;THREE.NearestMipMapNearestFilter=1004;THREE.NearestMipMapLinearFilter=1005;
THREE.LinearFilter=1006;THREE.LinearMipMapNearestFilter=1007;THREE.LinearMipMapLinearFilter=1008;THREE.UnsignedByteType=1009;THREE.ByteType=1010;THREE.ShortType=1011;THREE.UnsignedShortType=1012;THREE.IntType=1013;THREE.UnsignedIntType=1014;THREE.FloatType=1015;THREE.UnsignedShort4444Type=1016;THREE.UnsignedShort5551Type=1017;THREE.UnsignedShort565Type=1018;THREE.AlphaFormat=1019;THREE.RGBFormat=1020;THREE.RGBAFormat=1021;THREE.LuminanceFormat=1022;THREE.LuminanceAlphaFormat=1023;
THREE.RGB_S3TC_DXT1_Format=2001;THREE.RGBA_S3TC_DXT1_Format=2002;THREE.RGBA_S3TC_DXT3_Format=2003;THREE.RGBA_S3TC_DXT5_Format=2004;THREE.Color=function(a){void 0!==a&&this.set(a);return this};
THREE.Color.prototype={constructor:THREE.Color,r:1,g:1,b:1,set:function(a){a instanceof THREE.Color?this.copy(a):"number"===typeof a?this.setHex(a):"string"===typeof a&&this.setStyle(a);return this},setHex:function(a){a=Math.floor(a);this.r=(a>>16&255)/255;this.g=(a>>8&255)/255;this.b=(a&255)/255;return this},setRGB:function(a,b,c){this.r=a;this.g=b;this.b=c;return this},setHSL:function(a,b,c){if(0===b)this.r=this.g=this.b=c;else{var d=function(a,b,c){0>c&&(c+=1);1<c&&(c-=1);return c<1/6?a+6*(b-a)*
c:0.5>c?b:c<2/3?a+6*(b-a)*(2/3-c):a},b=0.5>=c?c*(1+b):c+b-c*b,c=2*c-b;this.r=d(c,b,a+1/3);this.g=d(c,b,a);this.b=d(c,b,a-1/3)}return this},setStyle:function(a){if(/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(a))return a=/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(a),this.r=Math.min(255,parseInt(a[1],10))/255,this.g=Math.min(255,parseInt(a[2],10))/255,this.b=Math.min(255,parseInt(a[3],10))/255,this;if(/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(a))return a=/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(a),this.r=
Math.min(100,parseInt(a[1],10))/100,this.g=Math.min(100,parseInt(a[2],10))/100,this.b=Math.min(100,parseInt(a[3],10))/100,this;if(/^\#([0-9a-f]{6})$/i.test(a))return a=/^\#([0-9a-f]{6})$/i.exec(a),this.setHex(parseInt(a[1],16)),this;if(/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a))return a=/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a),this.setHex(parseInt(a[1]+a[1]+a[2]+a[2]+a[3]+a[3],16)),this;if(/^(\w+)$/i.test(a))return this.setHex(THREE.ColorKeywords[a]),this},copy:function(a){this.r=a.r;this.g=
a.g;this.b=a.b;return this},copyGammaToLinear:function(a){this.r=a.r*a.r;this.g=a.g*a.g;this.b=a.b*a.b;return this},copyLinearToGamma:function(a){this.r=Math.sqrt(a.r);this.g=Math.sqrt(a.g);this.b=Math.sqrt(a.b);return this},convertGammaToLinear:function(){var a=this.r,b=this.g,c=this.b;this.r=a*a;this.g=b*b;this.b=c*c;return this},convertLinearToGamma:function(){this.r=Math.sqrt(this.r);this.g=Math.sqrt(this.g);this.b=Math.sqrt(this.b);return this},getHex:function(){return 255*this.r<<16^255*this.g<<
8^255*this.b<<0},getHexString:function(){return("000000"+this.getHex().toString(16)).slice(-6)},getHSL:function(){var a={h:0,s:0,l:0};return function(){var b=this.r,c=this.g,d=this.b,e=Math.max(b,c,d),f=Math.min(b,c,d),h,g=(f+e)/2;if(f===e)f=h=0;else{var i=e-f,f=0.5>=g?i/(e+f):i/(2-e-f);switch(e){case b:h=(c-d)/i+(c<d?6:0);break;case c:h=(d-b)/i+2;break;case d:h=(b-c)/i+4}h/=6}a.h=h;a.s=f;a.l=g;return a}}(),getStyle:function(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"},
offsetHSL:function(a,b,c){var d=this.getHSL();d.h+=a;d.s+=b;d.l+=c;this.setHSL(d.h,d.s,d.l);return this},add:function(a){this.r+=a.r;this.g+=a.g;this.b+=a.b;return this},addColors:function(a,b){this.r=a.r+b.r;this.g=a.g+b.g;this.b=a.b+b.b;return this},addScalar:function(a){this.r+=a;this.g+=a;this.b+=a;return this},multiply:function(a){this.r*=a.r;this.g*=a.g;this.b*=a.b;return this},multiplyScalar:function(a){this.r*=a;this.g*=a;this.b*=a;return this},lerp:function(a,b){this.r+=(a.r-this.r)*b;this.g+=
(a.g-this.g)*b;this.b+=(a.b-this.b)*b;return this},equals:function(a){return a.r===this.r&&a.g===this.g&&a.b===this.b},fromArray:function(a){this.r=a[0];this.g=a[1];this.b=a[2];return this},toArray:function(){return[this.r,this.g,this.b]},clone:function(){return(new THREE.Color).setRGB(this.r,this.g,this.b)}};
THREE.ColorKeywords={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,
darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,
grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,
lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,
palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,
tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};THREE.Quaternion=function(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._w=void 0!==d?d:1};
THREE.Quaternion.prototype={constructor:THREE.Quaternion,_x:0,_y:0,_z:0,_w:0,_euler:void 0,_updateEuler:function(){void 0!==this._euler&&this._euler.setFromQuaternion(this,void 0,!1)},get x(){return this._x},set x(a){this._x=a;this._updateEuler()},get y(){return this._y},set y(a){this._y=a;this._updateEuler()},get z(){return this._z},set z(a){this._z=a;this._updateEuler()},get w(){return this._w},set w(a){this._w=a;this._updateEuler()},set:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._w=d;
this._updateEuler();return this},copy:function(a){this._x=a._x;this._y=a._y;this._z=a._z;this._w=a._w;this._updateEuler();return this},setFromEuler:function(a,b){if(!1===a instanceof THREE.Euler)throw Error("ERROR: Quaternion's .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");var c=Math.cos(a._x/2),d=Math.cos(a._y/2),e=Math.cos(a._z/2),f=Math.sin(a._x/2),h=Math.sin(a._y/2),g=Math.sin(a._z/2);"XYZ"===a.order?(this._x=f*d*e+c*h*g,this._y=c*h*
e-f*d*g,this._z=c*d*g+f*h*e,this._w=c*d*e-f*h*g):"YXZ"===a.order?(this._x=f*d*e+c*h*g,this._y=c*h*e-f*d*g,this._z=c*d*g-f*h*e,this._w=c*d*e+f*h*g):"ZXY"===a.order?(this._x=f*d*e-c*h*g,this._y=c*h*e+f*d*g,this._z=c*d*g+f*h*e,this._w=c*d*e-f*h*g):"ZYX"===a.order?(this._x=f*d*e-c*h*g,this._y=c*h*e+f*d*g,this._z=c*d*g-f*h*e,this._w=c*d*e+f*h*g):"YZX"===a.order?(this._x=f*d*e+c*h*g,this._y=c*h*e+f*d*g,this._z=c*d*g-f*h*e,this._w=c*d*e-f*h*g):"XZY"===a.order&&(this._x=f*d*e-c*h*g,this._y=c*h*e-f*d*g,this._z=
c*d*g+f*h*e,this._w=c*d*e+f*h*g);!1!==b&&this._updateEuler();return this},setFromAxisAngle:function(a,b){var c=b/2,d=Math.sin(c);this._x=a.x*d;this._y=a.y*d;this._z=a.z*d;this._w=Math.cos(c);this._updateEuler();return this},setFromRotationMatrix:function(a){var b=a.elements,c=b[0],a=b[4],d=b[8],e=b[1],f=b[5],h=b[9],g=b[2],i=b[6],b=b[10],k=c+f+b;0<k?(c=0.5/Math.sqrt(k+1),this._w=0.25/c,this._x=(i-h)*c,this._y=(d-g)*c,this._z=(e-a)*c):c>f&&c>b?(c=2*Math.sqrt(1+c-f-b),this._w=(i-h)/c,this._x=0.25*c,
this._y=(a+e)/c,this._z=(d+g)/c):f>b?(c=2*Math.sqrt(1+f-c-b),this._w=(d-g)/c,this._x=(a+e)/c,this._y=0.25*c,this._z=(h+i)/c):(c=2*Math.sqrt(1+b-c-f),this._w=(e-a)/c,this._x=(d+g)/c,this._y=(h+i)/c,this._z=0.25*c);this._updateEuler();return this},inverse:function(){this.conjugate().normalize();return this},conjugate:function(){this._x*=-1;this._y*=-1;this._z*=-1;this._updateEuler();return this},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*
this._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){var a=this.length();0===a?(this._z=this._y=this._x=0,this._w=1):(a=1/a,this._x*=a,this._y*=a,this._z*=a,this._w*=a);return this},multiply:function(a,b){return void 0!==b?(console.warn("DEPRECATED: Quaternion's .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(a,b)):this.multiplyQuaternions(this,a)},multiplyQuaternions:function(a,b){var c=a._x,d=a._y,e=a._z,f=
a._w,h=b._x,g=b._y,i=b._z,k=b._w;this._x=c*k+f*h+d*i-e*g;this._y=d*k+f*g+e*h-c*i;this._z=e*k+f*i+c*g-d*h;this._w=f*k-c*h-d*g-e*i;this._updateEuler();return this},multiplyVector3:function(a){console.warn("DEPRECATED: Quaternion's .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");return a.applyQuaternion(this)},slerp:function(a,b){var c=this._x,d=this._y,e=this._z,f=this._w,h=f*a._w+c*a._x+d*a._y+e*a._z;0>h?(this._w=-a._w,this._x=-a._x,this._y=-a._y,this._z=
-a._z,h=-h):this.copy(a);if(1<=h)return this._w=f,this._x=c,this._y=d,this._z=e,this;var g=Math.acos(h),i=Math.sqrt(1-h*h);if(0.001>Math.abs(i))return this._w=0.5*(f+this._w),this._x=0.5*(c+this._x),this._y=0.5*(d+this._y),this._z=0.5*(e+this._z),this;h=Math.sin((1-b)*g)/i;g=Math.sin(b*g)/i;this._w=f*h+this._w*g;this._x=c*h+this._x*g;this._y=d*h+this._y*g;this._z=e*h+this._z*g;this._updateEuler();return this},equals:function(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._w===this._w},
fromArray:function(a){this._x=a[0];this._y=a[1];this._z=a[2];this._w=a[3];this._updateEuler();return this},toArray:function(){return[this._x,this._y,this._z,this._w]},clone:function(){return new THREE.Quaternion(this._x,this._y,this._z,this._w)}};THREE.Quaternion.slerp=function(a,b,c,d){return c.copy(a).slerp(b,d)};THREE.Vector2=function(a,b){this.x=a||0;this.y=b||0};
THREE.Vector2.prototype={constructor:THREE.Vector2,set:function(a,b){this.x=a;this.y=b;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;default:throw Error("index is out of range: "+a);}},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;default:throw Error("index is out of range: "+a);}},copy:function(a){this.x=a.x;this.y=a.y;return this},add:function(a,
b){if(void 0!==b)return console.warn("DEPRECATED: Vector2's .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this},addScalar:function(a){this.x+=a;this.y+=a;return this},sub:function(a,b){if(void 0!==b)return console.warn("DEPRECATED: Vector2's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b);this.x-=a.x;this.y-=
a.y;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;return this},divideScalar:function(a){0!==a?(a=1/a,this.x*=a,this.y*=a):this.y=this.x=0;return this},min:function(a){this.x>a.x&&(this.x=a.x);this.y>a.y&&(this.y=a.y);return this},max:function(a){this.x<a.x&&(this.x=a.x);this.y<a.y&&(this.y=a.y);return this},clamp:function(a,b){this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x);this.y<a.y?this.y=a.y:this.y>b.y&&(this.y=b.y);
return this},negate:function(){return this.multiplyScalar(-1)},dot:function(a){return this.x*a.x+this.y*a.y},lengthSq:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},normalize:function(){return this.divideScalar(this.length())},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x,a=this.y-a.y;return b*b+a*a},setLength:function(a){var b=this.length();0!==b&&a!==b&&this.multiplyScalar(a/
b);return this},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;return this},equals:function(a){return a.x===this.x&&a.y===this.y},fromArray:function(a){this.x=a[0];this.y=a[1];return this},toArray:function(){return[this.x,this.y]},clone:function(){return new THREE.Vector2(this.x,this.y)}};THREE.Vector3=function(a,b,c){this.x=a||0;this.y=b||0;this.z=c||0};
THREE.Vector3.prototype={constructor:THREE.Vector3,set:function(a,b,c){this.x=a;this.y=b;this.z=c;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;default:throw Error("index is out of range: "+a);}},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw Error("index is out of range: "+
a);}},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;return this},add:function(a,b){if(void 0!==b)return console.warn("DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this},sub:function(a,b){if(void 0!==b)return console.warn("DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
this.subVectors(a,b);this.x-=a.x;this.y-=a.y;this.z-=a.z;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this},multiply:function(a,b){if(void 0!==b)return console.warn("DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(a,b);this.x*=a.x;this.y*=a.y;this.z*=a.z;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;return this},multiplyVectors:function(a,b){this.x=a.x*
b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this},applyMatrix3:function(a){var b=this.x,c=this.y,d=this.z,a=a.elements;this.x=a[0]*b+a[3]*c+a[6]*d;this.y=a[1]*b+a[4]*c+a[7]*d;this.z=a[2]*b+a[5]*c+a[8]*d;return this},applyMatrix4:function(a){var b=this.x,c=this.y,d=this.z,a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d+a[12];this.y=a[1]*b+a[5]*c+a[9]*d+a[13];this.z=a[2]*b+a[6]*c+a[10]*d+a[14];return this},applyProjection:function(a){var b=this.x,c=this.y,d=this.z,a=a.elements,e=1/(a[3]*b+a[7]*c+a[11]*d+a[15]);
this.x=(a[0]*b+a[4]*c+a[8]*d+a[12])*e;this.y=(a[1]*b+a[5]*c+a[9]*d+a[13])*e;this.z=(a[2]*b+a[6]*c+a[10]*d+a[14])*e;return this},applyQuaternion:function(a){var b=this.x,c=this.y,d=this.z,e=a.x,f=a.y,h=a.z,a=a.w,g=a*b+f*d-h*c,i=a*c+h*b-e*d,k=a*d+e*c-f*b,b=-e*b-f*c-h*d;this.x=g*a+b*-e+i*-h-k*-f;this.y=i*a+b*-f+k*-e-g*-h;this.z=k*a+b*-h+g*-f-i*-e;return this},transformDirection:function(a){var b=this.x,c=this.y,d=this.z,a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d;this.y=a[1]*b+a[5]*c+a[9]*d;this.z=a[2]*
b+a[6]*c+a[10]*d;this.normalize();return this},divide:function(a){this.x/=a.x;this.y/=a.y;this.z/=a.z;return this},divideScalar:function(a){0!==a?(a=1/a,this.x*=a,this.y*=a,this.z*=a):this.z=this.y=this.x=0;return this},min:function(a){this.x>a.x&&(this.x=a.x);this.y>a.y&&(this.y=a.y);this.z>a.z&&(this.z=a.z);return this},max:function(a){this.x<a.x&&(this.x=a.x);this.y<a.y&&(this.y=a.y);this.z<a.z&&(this.z=a.z);return this},clamp:function(a,b){this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x);this.y<
a.y?this.y=a.y:this.y>b.y&&(this.y=b.y);this.z<a.z?this.z=a.z:this.z>b.z&&(this.z=b.z);return this},negate:function(){return this.multiplyScalar(-1)},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length())},
setLength:function(a){var b=this.length();0!==b&&a!==b&&this.multiplyScalar(a/b);return this},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;return this},cross:function(a,b){if(void 0!==b)return console.warn("DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(a,b);var c=this.x,d=this.y,e=this.z;this.x=d*a.z-e*a.y;this.y=e*a.x-c*a.z;this.z=c*a.y-d*a.x;return this},crossVectors:function(a,b){var c=
a.x,d=a.y,e=a.z,f=b.x,h=b.y,g=b.z;this.x=d*g-e*h;this.y=e*f-c*g;this.z=c*h-d*f;return this},angleTo:function(a){a=this.dot(a)/(this.length()*a.length());return Math.acos(THREE.Math.clamp(a,-1,1))},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x,c=this.y-a.y,a=this.z-a.z;return b*b+c*c+a*a},setEulerFromRotationMatrix:function(){console.error("REMOVED: Vector3's setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.")},
setEulerFromQuaternion:function(){console.error("REMOVED: Vector3's setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.")},getPositionFromMatrix:function(a){this.x=a.elements[12];this.y=a.elements[13];this.z=a.elements[14];return this},getScaleFromMatrix:function(a){var b=this.set(a.elements[0],a.elements[1],a.elements[2]).length(),c=this.set(a.elements[4],a.elements[5],a.elements[6]).length(),a=this.set(a.elements[8],a.elements[9],a.elements[10]).length();
this.x=b;this.y=c;this.z=a;return this},getColumnFromMatrix:function(a,b){var c=4*a,d=b.elements;this.x=d[c];this.y=d[c+1];this.z=d[c+2];return this},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z},fromArray:function(a){this.x=a[0];this.y=a[1];this.z=a[2];return this},toArray:function(){return[this.x,this.y,this.z]},clone:function(){return new THREE.Vector3(this.x,this.y,this.z)}};
THREE.extend(THREE.Vector3.prototype,{applyEuler:function(){var a=new THREE.Quaternion;return function(b){!1===b instanceof THREE.Euler&&console.error("ERROR: Vector3's .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");this.applyQuaternion(a.setFromEuler(b));return this}}(),applyAxisAngle:function(){var a=new THREE.Quaternion;return function(b,c){this.applyQuaternion(a.setFromAxisAngle(b,c));return this}}(),projectOnVector:function(){var a=new THREE.Vector3;
return function(b){a.copy(b).normalize();b=this.dot(a);return this.copy(a).multiplyScalar(b)}}(),projectOnPlane:function(){var a=new THREE.Vector3;return function(b){a.copy(this).projectOnVector(b);return this.sub(a)}}(),reflect:function(){var a=new THREE.Vector3;return function(b){a.copy(this).projectOnVector(b).multiplyScalar(2);return this.subVectors(a,this)}}()});THREE.Vector4=function(a,b,c,d){this.x=a||0;this.y=b||0;this.z=c||0;this.w=void 0!==d?d:1};
THREE.Vector4.prototype={constructor:THREE.Vector4,set:function(a,b,c,d){this.x=a;this.y=b;this.z=c;this.w=d;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setW:function(a){this.w=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;case 3:this.w=b;break;default:throw Error("index is out of range: "+a);}},getComponent:function(a){switch(a){case 0:return this.x;
case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw Error("index is out of range: "+a);}},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;this.w=void 0!==a.w?a.w:1;return this},add:function(a,b){if(void 0!==b)return console.warn("DEPRECATED: Vector4's .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;this.w+=a.w;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;this.w+=a;return this},
addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this},sub:function(a,b){if(void 0!==b)return console.warn("DEPRECATED: Vector4's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b);this.x-=a.x;this.y-=a.y;this.z-=a.z;this.w-=a.w;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;this.w*=a;return this},
applyMatrix4:function(a){var b=this.x,c=this.y,d=this.z,e=this.w,a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d+a[12]*e;this.y=a[1]*b+a[5]*c+a[9]*d+a[13]*e;this.z=a[2]*b+a[6]*c+a[10]*d+a[14]*e;this.w=a[3]*b+a[7]*c+a[11]*d+a[15]*e;return this},divideScalar:function(a){0!==a?(a=1/a,this.x*=a,this.y*=a,this.z*=a,this.w*=a):(this.z=this.y=this.x=0,this.w=1);return this},setAxisAngleFromQuaternion:function(a){this.w=2*Math.acos(a.w);var b=Math.sqrt(1-a.w*a.w);1E-4>b?(this.x=1,this.z=this.y=0):(this.x=a.x/b,
this.y=a.y/b,this.z=a.z/b);return this},setAxisAngleFromRotationMatrix:function(a){var b,c,d,a=a.elements,e=a[0];d=a[4];var f=a[8],h=a[1],g=a[5],i=a[9];c=a[2];b=a[6];var k=a[10];if(0.01>Math.abs(d-h)&&0.01>Math.abs(f-c)&&0.01>Math.abs(i-b)){if(0.1>Math.abs(d+h)&&0.1>Math.abs(f+c)&&0.1>Math.abs(i+b)&&0.1>Math.abs(e+g+k-3))return this.set(1,0,0,0),this;a=Math.PI;e=(e+1)/2;g=(g+1)/2;k=(k+1)/2;d=(d+h)/4;f=(f+c)/4;i=(i+b)/4;e>g&&e>k?0.01>e?(b=0,d=c=0.707106781):(b=Math.sqrt(e),c=d/b,d=f/b):g>k?0.01>g?
(b=0.707106781,c=0,d=0.707106781):(c=Math.sqrt(g),b=d/c,d=i/c):0.01>k?(c=b=0.707106781,d=0):(d=Math.sqrt(k),b=f/d,c=i/d);this.set(b,c,d,a);return this}a=Math.sqrt((b-i)*(b-i)+(f-c)*(f-c)+(h-d)*(h-d));0.001>Math.abs(a)&&(a=1);this.x=(b-i)/a;this.y=(f-c)/a;this.z=(h-d)/a;this.w=Math.acos((e+g+k-1)/2);return this},min:function(a){this.x>a.x&&(this.x=a.x);this.y>a.y&&(this.y=a.y);this.z>a.z&&(this.z=a.z);this.w>a.w&&(this.w=a.w);return this},max:function(a){this.x<a.x&&(this.x=a.x);this.y<a.y&&(this.y=
a.y);this.z<a.z&&(this.z=a.z);this.w<a.w&&(this.w=a.w);return this},clamp:function(a,b){this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x);this.y<a.y?this.y=a.y:this.y>b.y&&(this.y=b.y);this.z<a.z?this.z=a.z:this.z>b.z&&(this.z=b.z);this.w<a.w?this.w=a.w:this.w>b.w&&(this.w=b.w);return this},negate:function(){return this.multiplyScalar(-1)},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z+this.w*a.w},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w},length:function(){return Math.sqrt(this.x*
this.x+this.y*this.y+this.z*this.z+this.w*this.w)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)},normalize:function(){return this.divideScalar(this.length())},setLength:function(a){var b=this.length();0!==b&&a!==b&&this.multiplyScalar(a/b);return this},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;this.w+=(a.w-this.w)*b;return this},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z&&
a.w===this.w},fromArray:function(a){this.x=a[0];this.y=a[1];this.z=a[2];this.w=a[3];return this},toArray:function(){return[this.x,this.y,this.z,this.w]},clone:function(){return new THREE.Vector4(this.x,this.y,this.z,this.w)}};THREE.Euler=function(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._order=d||THREE.Euler.DefaultOrder};THREE.Euler.RotationOrders="XYZ YZX ZXY XZY YXZ ZYX".split(" ");THREE.Euler.DefaultOrder="XYZ";
THREE.Euler.prototype={constructor:THREE.Euler,_x:0,_y:0,_z:0,_order:THREE.Euler.DefaultOrder,_quaternion:void 0,_updateQuaternion:function(){void 0!==this._quaternion&&this._quaternion.setFromEuler(this,!1)},get x(){return this._x},set x(a){this._x=a;this._updateQuaternion()},get y(){return this._y},set y(a){this._y=a;this._updateQuaternion()},get z(){return this._z},set z(a){this._z=a;this._updateQuaternion()},get order(){return this._order},set order(a){this._order=a;this._updateQuaternion()},
set:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._order=d||this._order;this._updateQuaternion();return this},copy:function(a){this._x=a._x;this._y=a._y;this._z=a._z;this._order=a._order;this._updateQuaternion();return this},setFromRotationMatrix:function(a,b){function c(a){return Math.min(Math.max(a,-1),1)}var d=a.elements,e=d[0],f=d[4],h=d[8],g=d[1],i=d[5],k=d[9],m=d[2],l=d[6],d=d[10],b=b||this._order;"XYZ"===b?(this._y=Math.asin(c(h)),0.99999>Math.abs(h)?(this._x=Math.atan2(-k,d),this._z=
Math.atan2(-f,e)):(this._x=Math.atan2(l,i),this._z=0)):"YXZ"===b?(this._x=Math.asin(-c(k)),0.99999>Math.abs(k)?(this._y=Math.atan2(h,d),this._z=Math.atan2(g,i)):(this._y=Math.atan2(-m,e),this._z=0)):"ZXY"===b?(this._x=Math.asin(c(l)),0.99999>Math.abs(l)?(this._y=Math.atan2(-m,d),this._z=Math.atan2(-f,i)):(this._y=0,this._z=Math.atan2(g,e))):"ZYX"===b?(this._y=Math.asin(-c(m)),0.99999>Math.abs(m)?(this._x=Math.atan2(l,d),this._z=Math.atan2(g,e)):(this._x=0,this._z=Math.atan2(-f,i))):"YZX"===b?(this._z=
Math.asin(c(g)),0.99999>Math.abs(g)?(this._x=Math.atan2(-k,i),this._y=Math.atan2(-m,e)):(this._x=0,this._y=Math.atan2(h,d))):"XZY"===b?(this._z=Math.asin(-c(f)),0.99999>Math.abs(f)?(this._x=Math.atan2(l,i),this._y=Math.atan2(h,e)):(this._x=Math.atan2(-k,d),this._y=0)):console.warn("WARNING: Euler.setFromRotationMatrix() given unsupported order: "+b);this._order=b;this._updateQuaternion();return this},setFromQuaternion:function(a,b,c){function d(a){return Math.min(Math.max(a,-1),1)}var e=a.x*a.x,f=
a.y*a.y,h=a.z*a.z,g=a.w*a.w,b=b||this._order;"XYZ"===b?(this._x=Math.atan2(2*(a.x*a.w-a.y*a.z),g-e-f+h),this._y=Math.asin(d(2*(a.x*a.z+a.y*a.w))),this._z=Math.atan2(2*(a.z*a.w-a.x*a.y),g+e-f-h)):"YXZ"===b?(this._x=Math.asin(d(2*(a.x*a.w-a.y*a.z))),this._y=Math.atan2(2*(a.x*a.z+a.y*a.w),g-e-f+h),this._z=Math.atan2(2*(a.x*a.y+a.z*a.w),g-e+f-h)):"ZXY"===b?(this._x=Math.asin(d(2*(a.x*a.w+a.y*a.z))),this._y=Math.atan2(2*(a.y*a.w-a.z*a.x),g-e-f+h),this._z=Math.atan2(2*(a.z*a.w-a.x*a.y),g-e+f-h)):"ZYX"===
b?(this._x=Math.atan2(2*(a.x*a.w+a.z*a.y),g-e-f+h),this._y=Math.asin(d(2*(a.y*a.w-a.x*a.z))),this._z=Math.atan2(2*(a.x*a.y+a.z*a.w),g+e-f-h)):"YZX"===b?(this._x=Math.atan2(2*(a.x*a.w-a.z*a.y),g-e+f-h),this._y=Math.atan2(2*(a.y*a.w-a.x*a.z),g+e-f-h),this._z=Math.asin(d(2*(a.x*a.y+a.z*a.w)))):"XZY"===b?(this._x=Math.atan2(2*(a.x*a.w+a.y*a.z),g-e+f-h),this._y=Math.atan2(2*(a.x*a.z+a.y*a.w),g+e-f-h),this._z=Math.asin(d(2*(a.z*a.w-a.x*a.y)))):console.warn("WARNING: Euler.setFromQuaternion() given unsupported order: "+
b);this._order=b;!1!==c&&this._updateQuaternion();return this},reorder:function(){var a=new THREE.Quaternion;return function(b){a.setFromEuler(this);this.setFromQuaternion(a,b)}}(),fromArray:function(a){this._x=a[0];this._y=a[1];this._z=a[2];void 0!==a[3]&&(this._order=a[3]);this._updateQuaternion();return this},toArray:function(){return[this._x,this._y,this._z,this._order]},equals:function(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._order===this._order},clone:function(){return new THREE.Euler(this._x,
this._y,this._z,this._order)}};THREE.Line3=function(a,b){this.start=void 0!==a?a:new THREE.Vector3;this.end=void 0!==b?b:new THREE.Vector3};
THREE.Line3.prototype={constructor:THREE.Line3,set:function(a,b){this.start.copy(a);this.end.copy(b);return this},copy:function(a){this.start.copy(a.start);this.end.copy(a.end);return this},center:function(a){return(a||new THREE.Vector3).addVectors(this.start,this.end).multiplyScalar(0.5)},delta:function(a){return(a||new THREE.Vector3).subVectors(this.end,this.start)},distanceSq:function(){return this.start.distanceToSquared(this.end)},distance:function(){return this.start.distanceTo(this.end)},at:function(a,
b){var c=b||new THREE.Vector3;return this.delta(c).multiplyScalar(a).add(this.start)},closestPointToPointParameter:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d){a.subVectors(c,this.start);b.subVectors(this.end,this.start);var e=b.dot(b),e=b.dot(a)/e;d&&(e=THREE.Math.clamp(e,0,1));return e}}(),closestPointToPoint:function(a,b,c){a=this.closestPointToPointParameter(a,b);c=c||new THREE.Vector3;return this.delta(c).multiplyScalar(a).add(this.start)},applyMatrix4:function(a){this.start.applyMatrix4(a);
this.end.applyMatrix4(a);return this},equals:function(a){return a.start.equals(this.start)&&a.end.equals(this.end)},clone:function(){return(new THREE.Line3).copy(this)}};THREE.Box2=function(a,b){this.min=void 0!==a?a:new THREE.Vector2(Infinity,Infinity);this.max=void 0!==b?b:new THREE.Vector2(-Infinity,-Infinity)};
THREE.Box2.prototype={constructor:THREE.Box2,set:function(a,b){this.min.copy(a);this.max.copy(b);return this},setFromPoints:function(a){if(0<a.length){var b=a[0];this.min.copy(b);this.max.copy(b);for(var c=1,d=a.length;c<d;c++)b=a[c],b.x<this.min.x?this.min.x=b.x:b.x>this.max.x&&(this.max.x=b.x),b.y<this.min.y?this.min.y=b.y:b.y>this.max.y&&(this.max.y=b.y)}else this.makeEmpty();return this},setFromCenterAndSize:function(){var a=new THREE.Vector2;return function(b,c){var d=a.copy(c).multiplyScalar(0.5);
this.min.copy(b).sub(d);this.max.copy(b).add(d);return this}}(),copy:function(a){this.min.copy(a.min);this.max.copy(a.max);return this},makeEmpty:function(){this.min.x=this.min.y=Infinity;this.max.x=this.max.y=-Infinity;return this},empty:function(){return this.max.x<this.min.x||this.max.y<this.min.y},center:function(a){return(a||new THREE.Vector2).addVectors(this.min,this.max).multiplyScalar(0.5)},size:function(a){return(a||new THREE.Vector2).subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);
this.max.max(a);return this},expandByVector:function(a){this.min.sub(a);this.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);this.max.addScalar(a);return this},containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y?!0:!1},getParameter:function(a){return new THREE.Vector2((a.x-this.min.x)/(this.max.x-this.min.x),
(a.y-this.min.y)/(this.max.y-this.min.y))},isIntersectionBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y?!1:!0},clampPoint:function(a,b){return(b||new THREE.Vector2).copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new THREE.Vector2;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),intersect:function(a){this.min.max(a.min);this.max.min(a.max);return this},union:function(a){this.min.min(a.min);this.max.max(a.max);
return this},translate:function(a){this.min.add(a);this.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&a.max.equals(this.max)},clone:function(){return(new THREE.Box2).copy(this)}};THREE.Box3=function(a,b){this.min=void 0!==a?a:new THREE.Vector3(Infinity,Infinity,Infinity);this.max=void 0!==b?b:new THREE.Vector3(-Infinity,-Infinity,-Infinity)};
THREE.Box3.prototype={constructor:THREE.Box3,set:function(a,b){this.min.copy(a);this.max.copy(b);return this},addPoint:function(a){a.x<this.min.x?this.min.x=a.x:a.x>this.max.x&&(this.max.x=a.x);a.y<this.min.y?this.min.y=a.y:a.y>this.max.y&&(this.max.y=a.y);a.z<this.min.z?this.min.z=a.z:a.z>this.max.z&&(this.max.z=a.z)},setFromPoints:function(a){if(0<a.length){var b=a[0];this.min.copy(b);this.max.copy(b);for(var b=1,c=a.length;b<c;b++)this.addPoint(a[b])}else this.makeEmpty();return this},setFromCenterAndSize:function(){var a=
new THREE.Vector3;return function(b,c){var d=a.copy(c).multiplyScalar(0.5);this.min.copy(b).sub(d);this.max.copy(b).add(d);return this}}(),setFromObject:function(){var a=new THREE.Vector3;return function(b){var c=this;b.updateMatrixWorld(!0);this.makeEmpty();b.traverse(function(b){if(void 0!==b.geometry&&void 0!==b.geometry.vertices)for(var e=b.geometry.vertices,f=0,h=e.length;f<h;f++)a.copy(e[f]),a.applyMatrix4(b.matrixWorld),c.expandByPoint(a)});return this}}(),copy:function(a){this.min.copy(a.min);
this.max.copy(a.max);return this},makeEmpty:function(){this.min.x=this.min.y=this.min.z=Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this},empty:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z},center:function(a){return(a||new THREE.Vector3).addVectors(this.min,this.max).multiplyScalar(0.5)},size:function(a){return(a||new THREE.Vector3).subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);this.max.max(a);return this},expandByVector:function(a){this.min.sub(a);
this.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);this.max.addScalar(a);return this},containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y||a.z<this.min.z||a.z>this.max.z?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y&&this.min.z<=a.min.z&&a.max.z<=this.max.z?!0:!1},getParameter:function(a){return new THREE.Vector3((a.x-this.min.x)/(this.max.x-this.min.x),
(a.y-this.min.y)/(this.max.y-this.min.y),(a.z-this.min.z)/(this.max.z-this.min.z))},isIntersectionBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y||a.max.z<this.min.z||a.min.z>this.max.z?!1:!0},clampPoint:function(a,b){return(b||new THREE.Vector3).copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new THREE.Vector3;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),getBoundingSphere:function(){var a=
new THREE.Vector3;return function(b){b=b||new THREE.Sphere;b.center=this.center();b.radius=0.5*this.size(a).length();return b}}(),intersect:function(a){this.min.max(a.min);this.max.min(a.max);return this},union:function(a){this.min.min(a.min);this.max.max(a.max);return this},applyMatrix4:function(){var a=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3];return function(b){a[0].set(this.min.x,this.min.y,
this.min.z).applyMatrix4(b);a[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(b);a[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(b);a[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(b);a[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(b);a[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(b);a[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(b);a[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(b);this.makeEmpty();this.setFromPoints(a);return this}}(),translate:function(a){this.min.add(a);
this.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&a.max.equals(this.max)},clone:function(){return(new THREE.Box3).copy(this)}};THREE.Matrix3=function(a,b,c,d,e,f,h,g,i){this.elements=new Float32Array(9);this.set(void 0!==a?a:1,b||0,c||0,d||0,void 0!==e?e:1,f||0,h||0,g||0,void 0!==i?i:1)};
THREE.Matrix3.prototype={constructor:THREE.Matrix3,set:function(a,b,c,d,e,f,h,g,i){var k=this.elements;k[0]=a;k[3]=b;k[6]=c;k[1]=d;k[4]=e;k[7]=f;k[2]=h;k[5]=g;k[8]=i;return this},identity:function(){this.set(1,0,0,0,1,0,0,0,1);return this},copy:function(a){a=a.elements;this.set(a[0],a[3],a[6],a[1],a[4],a[7],a[2],a[5],a[8]);return this},multiplyVector3:function(a){console.warn("DEPRECATED: Matrix3's .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");return a.applyMatrix3(this)},
multiplyVector3Array:function(){var a=new THREE.Vector3;return function(b){for(var c=0,d=b.length;c<d;c+=3)a.x=b[c],a.y=b[c+1],a.z=b[c+2],a.applyMatrix3(this),b[c]=a.x,b[c+1]=a.y,b[c+2]=a.z;return b}}(),multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[3]*=a;b[6]*=a;b[1]*=a;b[4]*=a;b[7]*=a;b[2]*=a;b[5]*=a;b[8]*=a;return this},determinant:function(){var a=this.elements,b=a[0],c=a[1],d=a[2],e=a[3],f=a[4],h=a[5],g=a[6],i=a[7],a=a[8];return b*f*a-b*h*i-c*e*a+c*h*g+d*e*i-d*f*g},getInverse:function(a,
b){var c=a.elements,d=this.elements;d[0]=c[10]*c[5]-c[6]*c[9];d[1]=-c[10]*c[1]+c[2]*c[9];d[2]=c[6]*c[1]-c[2]*c[5];d[3]=-c[10]*c[4]+c[6]*c[8];d[4]=c[10]*c[0]-c[2]*c[8];d[5]=-c[6]*c[0]+c[2]*c[4];d[6]=c[9]*c[4]-c[5]*c[8];d[7]=-c[9]*c[0]+c[1]*c[8];d[8]=c[5]*c[0]-c[1]*c[4];c=c[0]*d[0]+c[1]*d[3]+c[2]*d[6];if(0===c){if(b)throw Error("Matrix3.getInverse(): can't invert matrix, determinant is 0");console.warn("Matrix3.getInverse(): can't invert matrix, determinant is 0");this.identity();return this}this.multiplyScalar(1/
c);return this},transpose:function(){var a,b=this.elements;a=b[1];b[1]=b[3];b[3]=a;a=b[2];b[2]=b[6];b[6]=a;a=b[5];b[5]=b[7];b[7]=a;return this},getNormalMatrix:function(a){this.getInverse(a).transpose();return this},transposeIntoArray:function(a){var b=this.elements;a[0]=b[0];a[1]=b[3];a[2]=b[6];a[3]=b[1];a[4]=b[4];a[5]=b[7];a[6]=b[2];a[7]=b[5];a[8]=b[8];return this},clone:function(){var a=this.elements;return new THREE.Matrix3(a[0],a[3],a[6],a[1],a[4],a[7],a[2],a[5],a[8])}};THREE.Matrix4=function(a,b,c,d,e,f,h,g,i,k,m,l,p,s,t,n){var r=this.elements=new Float32Array(16);r[0]=void 0!==a?a:1;r[4]=b||0;r[8]=c||0;r[12]=d||0;r[1]=e||0;r[5]=void 0!==f?f:1;r[9]=h||0;r[13]=g||0;r[2]=i||0;r[6]=k||0;r[10]=void 0!==m?m:1;r[14]=l||0;r[3]=p||0;r[7]=s||0;r[11]=t||0;r[15]=void 0!==n?n:1};
THREE.Matrix4.prototype={constructor:THREE.Matrix4,set:function(a,b,c,d,e,f,h,g,i,k,m,l,p,s,t,n){var r=this.elements;r[0]=a;r[4]=b;r[8]=c;r[12]=d;r[1]=e;r[5]=f;r[9]=h;r[13]=g;r[2]=i;r[6]=k;r[10]=m;r[14]=l;r[3]=p;r[7]=s;r[11]=t;r[15]=n;return this},identity:function(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this},copy:function(a){this.elements.set(a.elements);return this},extractPosition:function(a){console.warn("DEPRECATED: Matrix4's .extractPosition() has been renamed to .copyPosition().");
return this.copyPosition(a)},copyPosition:function(a){var b=this.elements,a=a.elements;b[12]=a[12];b[13]=a[13];b[14]=a[14];return this},extractRotation:function(){var a=new THREE.Vector3;return function(b){var c=this.elements,b=b.elements,d=1/a.set(b[0],b[1],b[2]).length(),e=1/a.set(b[4],b[5],b[6]).length(),f=1/a.set(b[8],b[9],b[10]).length();c[0]=b[0]*d;c[1]=b[1]*d;c[2]=b[2]*d;c[4]=b[4]*e;c[5]=b[5]*e;c[6]=b[6]*e;c[8]=b[8]*f;c[9]=b[9]*f;c[10]=b[10]*f;return this}}(),makeRotationFromEuler:function(a){!1===
a instanceof THREE.Euler&&console.error("ERROR: Matrix's .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");var b=this.elements,c=a.x,d=a.y,e=a.z,f=Math.cos(c),c=Math.sin(c),h=Math.cos(d),d=Math.sin(d),g=Math.cos(e),e=Math.sin(e);if("XYZ"===a.order){var a=f*g,i=f*e,k=c*g,m=c*e;b[0]=h*g;b[4]=-h*e;b[8]=d;b[1]=i+k*d;b[5]=a-m*d;b[9]=-c*h;b[2]=m-a*d;b[6]=k+i*d;b[10]=f*h}else"YXZ"===a.order?(a=h*g,i=h*e,k=d*g,m=d*e,b[0]=a+m*c,b[4]=k*c-i,b[8]=
f*d,b[1]=f*e,b[5]=f*g,b[9]=-c,b[2]=i*c-k,b[6]=m+a*c,b[10]=f*h):"ZXY"===a.order?(a=h*g,i=h*e,k=d*g,m=d*e,b[0]=a-m*c,b[4]=-f*e,b[8]=k+i*c,b[1]=i+k*c,b[5]=f*g,b[9]=m-a*c,b[2]=-f*d,b[6]=c,b[10]=f*h):"ZYX"===a.order?(a=f*g,i=f*e,k=c*g,m=c*e,b[0]=h*g,b[4]=k*d-i,b[8]=a*d+m,b[1]=h*e,b[5]=m*d+a,b[9]=i*d-k,b[2]=-d,b[6]=c*h,b[10]=f*h):"YZX"===a.order?(a=f*h,i=f*d,k=c*h,m=c*d,b[0]=h*g,b[4]=m-a*e,b[8]=k*e+i,b[1]=e,b[5]=f*g,b[9]=-c*g,b[2]=-d*g,b[6]=i*e+k,b[10]=a-m*e):"XZY"===a.order&&(a=f*h,i=f*d,k=c*h,m=c*d,b[0]=
h*g,b[4]=-e,b[8]=d*g,b[1]=a*e+m,b[5]=f*g,b[9]=i*e-k,b[2]=k*e-i,b[6]=c*g,b[10]=m*e+a);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},setRotationFromQuaternion:function(a){console.warn("DEPRECATED: Matrix4's .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.");return this.makeRotationFromQuaternion(a)},makeRotationFromQuaternion:function(a){var b=this.elements,c=a.x,d=a.y,e=a.z,f=a.w,h=c+c,g=d+d,i=e+e,a=c*h,k=c*g,c=
c*i,m=d*g,d=d*i,e=e*i,h=f*h,g=f*g,f=f*i;b[0]=1-(m+e);b[4]=k-f;b[8]=c+g;b[1]=k+f;b[5]=1-(a+e);b[9]=d-h;b[2]=c-g;b[6]=d+h;b[10]=1-(a+m);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},lookAt:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(d,e,f){var h=this.elements;c.subVectors(d,e).normalize();0===c.length()&&(c.z=1);a.crossVectors(f,c).normalize();0===a.length()&&(c.x+=1E-4,a.crossVectors(f,c).normalize());b.crossVectors(c,a);h[0]=a.x;
h[4]=b.x;h[8]=c.x;h[1]=a.y;h[5]=b.y;h[9]=c.y;h[2]=a.z;h[6]=b.z;h[10]=c.z;return this}}(),multiply:function(a,b){return void 0!==b?(console.warn("DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(a,b)):this.multiplyMatrices(this,a)},multiplyMatrices:function(a,b){var c=a.elements,d=b.elements,e=this.elements,f=c[0],h=c[4],g=c[8],i=c[12],k=c[1],m=c[5],l=c[9],p=c[13],s=c[2],t=c[6],n=c[10],r=c[14],q=c[3],u=c[7],w=c[11],c=c[15],
z=d[0],B=d[4],D=d[8],x=d[12],F=d[1],A=d[5],O=d[9],C=d[13],E=d[2],I=d[6],y=d[10],v=d[14],G=d[3],R=d[7],J=d[11],d=d[15];e[0]=f*z+h*F+g*E+i*G;e[4]=f*B+h*A+g*I+i*R;e[8]=f*D+h*O+g*y+i*J;e[12]=f*x+h*C+g*v+i*d;e[1]=k*z+m*F+l*E+p*G;e[5]=k*B+m*A+l*I+p*R;e[9]=k*D+m*O+l*y+p*J;e[13]=k*x+m*C+l*v+p*d;e[2]=s*z+t*F+n*E+r*G;e[6]=s*B+t*A+n*I+r*R;e[10]=s*D+t*O+n*y+r*J;e[14]=s*x+t*C+n*v+r*d;e[3]=q*z+u*F+w*E+c*G;e[7]=q*B+u*A+w*I+c*R;e[11]=q*D+u*O+w*y+c*J;e[15]=q*x+u*C+w*v+c*d;return this},multiplyToArray:function(a,b,
c){var d=this.elements;this.multiplyMatrices(a,b);c[0]=d[0];c[1]=d[1];c[2]=d[2];c[3]=d[3];c[4]=d[4];c[5]=d[5];c[6]=d[6];c[7]=d[7];c[8]=d[8];c[9]=d[9];c[10]=d[10];c[11]=d[11];c[12]=d[12];c[13]=d[13];c[14]=d[14];c[15]=d[15];return this},multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[4]*=a;b[8]*=a;b[12]*=a;b[1]*=a;b[5]*=a;b[9]*=a;b[13]*=a;b[2]*=a;b[6]*=a;b[10]*=a;b[14]*=a;b[3]*=a;b[7]*=a;b[11]*=a;b[15]*=a;return this},multiplyVector3:function(a){console.warn("DEPRECATED: Matrix4's .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.");
return a.applyProjection(this)},multiplyVector4:function(a){console.warn("DEPRECATED: Matrix4's .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");return a.applyMatrix4(this)},multiplyVector3Array:function(){var a=new THREE.Vector3;return function(b){for(var c=0,d=b.length;c<d;c+=3)a.x=b[c],a.y=b[c+1],a.z=b[c+2],a.applyProjection(this),b[c]=a.x,b[c+1]=a.y,b[c+2]=a.z;return b}}(),rotateAxis:function(a){console.warn("DEPRECATED: Matrix4's .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
a.transformDirection(this)},crossVector:function(a){console.warn("DEPRECATED: Matrix4's .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");return a.applyMatrix4(this)},determinant:function(){var a=this.elements,b=a[0],c=a[4],d=a[8],e=a[12],f=a[1],h=a[5],g=a[9],i=a[13],k=a[2],m=a[6],l=a[10],p=a[14];return a[3]*(+e*g*m-d*i*m-e*h*l+c*i*l+d*h*p-c*g*p)+a[7]*(+b*g*p-b*i*l+e*f*l-d*f*p+d*i*k-e*g*k)+a[11]*(+b*i*m-b*h*p-e*f*m+c*f*p+e*h*k-c*i*k)+a[15]*(-d*h*k-b*g*m+b*h*l+d*f*m-c*f*
l+c*g*k)},transpose:function(){var a=this.elements,b;b=a[1];a[1]=a[4];a[4]=b;b=a[2];a[2]=a[8];a[8]=b;b=a[6];a[6]=a[9];a[9]=b;b=a[3];a[3]=a[12];a[12]=b;b=a[7];a[7]=a[13];a[13]=b;b=a[11];a[11]=a[14];a[14]=b;return this},flattenToArray:function(a){var b=this.elements;a[0]=b[0];a[1]=b[1];a[2]=b[2];a[3]=b[3];a[4]=b[4];a[5]=b[5];a[6]=b[6];a[7]=b[7];a[8]=b[8];a[9]=b[9];a[10]=b[10];a[11]=b[11];a[12]=b[12];a[13]=b[13];a[14]=b[14];a[15]=b[15];return a},flattenToArrayOffset:function(a,b){var c=this.elements;
a[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];a[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];a[b+9]=c[9];a[b+10]=c[10];a[b+11]=c[11];a[b+12]=c[12];a[b+13]=c[13];a[b+14]=c[14];a[b+15]=c[15];return a},getPosition:function(){var a=new THREE.Vector3;return function(){console.warn("DEPRECATED: Matrix4's .getPosition() has been removed. Use Vector3.getPositionFromMatrix( matrix ) instead.");var b=this.elements;return a.set(b[12],b[13],b[14])}}(),setPosition:function(a){var b=this.elements;
b[12]=a.x;b[13]=a.y;b[14]=a.z;return this},getInverse:function(a,b){var c=this.elements,d=a.elements,e=d[0],f=d[4],h=d[8],g=d[12],i=d[1],k=d[5],m=d[9],l=d[13],p=d[2],s=d[6],t=d[10],n=d[14],r=d[3],q=d[7],u=d[11],d=d[15];c[0]=m*n*q-l*t*q+l*s*u-k*n*u-m*s*d+k*t*d;c[4]=g*t*q-h*n*q-g*s*u+f*n*u+h*s*d-f*t*d;c[8]=h*l*q-g*m*q+g*k*u-f*l*u-h*k*d+f*m*d;c[12]=g*m*s-h*l*s-g*k*t+f*l*t+h*k*n-f*m*n;c[1]=l*t*r-m*n*r-l*p*u+i*n*u+m*p*d-i*t*d;c[5]=h*n*r-g*t*r+g*p*u-e*n*u-h*p*d+e*t*d;c[9]=g*m*r-h*l*r-g*i*u+e*l*u+h*i*d-
e*m*d;c[13]=h*l*p-g*m*p+g*i*t-e*l*t-h*i*n+e*m*n;c[2]=k*n*r-l*s*r+l*p*q-i*n*q-k*p*d+i*s*d;c[6]=g*s*r-f*n*r-g*p*q+e*n*q+f*p*d-e*s*d;c[10]=f*l*r-g*k*r+g*i*q-e*l*q-f*i*d+e*k*d;c[14]=g*k*p-f*l*p-g*i*s+e*l*s+f*i*n-e*k*n;c[3]=m*s*r-k*t*r-m*p*q+i*t*q+k*p*u-i*s*u;c[7]=f*t*r-h*s*r+h*p*q-e*t*q-f*p*u+e*s*u;c[11]=h*k*r-f*m*r-h*i*q+e*m*q+f*i*u-e*k*u;c[15]=f*m*p-h*k*p+h*i*s-e*m*s-f*i*t+e*k*t;c=e*c[0]+i*c[4]+p*c[8]+r*c[12];if(0==c){if(b)throw Error("Matrix4.getInverse(): can't invert matrix, determinant is 0");console.warn("Matrix4.getInverse(): can't invert matrix, determinant is 0");
this.identity();return this}this.multiplyScalar(1/c);return this},translate:function(){console.warn("DEPRECATED: Matrix4's .translate() has been removed.")},rotateX:function(){console.warn("DEPRECATED: Matrix4's .rotateX() has been removed.")},rotateY:function(){console.warn("DEPRECATED: Matrix4's .rotateY() has been removed.")},rotateZ:function(){console.warn("DEPRECATED: Matrix4's .rotateZ() has been removed.")},rotateByAxis:function(){console.warn("DEPRECATED: Matrix4's .rotateByAxis() has been removed.")},
scale:function(a){var b=this.elements,c=a.x,d=a.y,a=a.z;b[0]*=c;b[4]*=d;b[8]*=a;b[1]*=c;b[5]*=d;b[9]*=a;b[2]*=c;b[6]*=d;b[10]*=a;b[3]*=c;b[7]*=d;b[11]*=a;return this},getMaxScaleOnAxis:function(){var a=this.elements;return Math.sqrt(Math.max(a[0]*a[0]+a[1]*a[1]+a[2]*a[2],Math.max(a[4]*a[4]+a[5]*a[5]+a[6]*a[6],a[8]*a[8]+a[9]*a[9]+a[10]*a[10])))},makeTranslation:function(a,b,c){this.set(1,0,0,a,0,1,0,b,0,0,1,c,0,0,0,1);return this},makeRotationX:function(a){var b=Math.cos(a),a=Math.sin(a);this.set(1,
0,0,0,0,b,-a,0,0,a,b,0,0,0,0,1);return this},makeRotationY:function(a){var b=Math.cos(a),a=Math.sin(a);this.set(b,0,a,0,0,1,0,0,-a,0,b,0,0,0,0,1);return this},makeRotationZ:function(a){var b=Math.cos(a),a=Math.sin(a);this.set(b,-a,0,0,a,b,0,0,0,0,1,0,0,0,0,1);return this},makeRotationAxis:function(a,b){var c=Math.cos(b),d=Math.sin(b),e=1-c,f=a.x,h=a.y,g=a.z,i=e*f,k=e*h;this.set(i*f+c,i*h-d*g,i*g+d*h,0,i*h+d*g,k*h+c,k*g-d*f,0,i*g-d*h,k*g+d*f,e*g*g+c,0,0,0,0,1);return this},makeScale:function(a,b,c){this.set(a,
0,0,0,0,b,0,0,0,0,c,0,0,0,0,1);return this},compose:function(a,b,c){this.makeRotationFromQuaternion(b);this.scale(c);this.setPosition(a);return this},decompose:function(){var a=new THREE.Vector3,b=new THREE.Matrix4;return function(c,d,e){var f=this.elements,h=a.set(f[0],f[1],f[2]).length(),g=a.set(f[4],f[5],f[6]).length(),i=a.set(f[8],f[9],f[10]).length();c.x=f[12];c.y=f[13];c.z=f[14];b.elements.set(this.elements);var c=1/h,f=1/g,k=1/i;b.elements[0]*=c;b.elements[1]*=c;b.elements[2]*=c;b.elements[4]*=
f;b.elements[5]*=f;b.elements[6]*=f;b.elements[8]*=k;b.elements[9]*=k;b.elements[10]*=k;d.setFromRotationMatrix(b);e.x=h;e.y=g;e.z=i;return this}}(),makeFrustum:function(a,b,c,d,e,f){var h=this.elements;h[0]=2*e/(b-a);h[4]=0;h[8]=(b+a)/(b-a);h[12]=0;h[1]=0;h[5]=2*e/(d-c);h[9]=(d+c)/(d-c);h[13]=0;h[2]=0;h[6]=0;h[10]=-(f+e)/(f-e);h[14]=-2*f*e/(f-e);h[3]=0;h[7]=0;h[11]=-1;h[15]=0;return this},makePerspective:function(a,b,c,d){var a=c*Math.tan(THREE.Math.degToRad(0.5*a)),e=-a;return this.makeFrustum(e*
b,a*b,e,a,c,d)},makeOrthographic:function(a,b,c,d,e,f){var h=this.elements,g=b-a,i=c-d,k=f-e;h[0]=2/g;h[4]=0;h[8]=0;h[12]=-((b+a)/g);h[1]=0;h[5]=2/i;h[9]=0;h[13]=-((c+d)/i);h[2]=0;h[6]=0;h[10]=-2/k;h[14]=-((f+e)/k);h[3]=0;h[7]=0;h[11]=0;h[15]=1;return this},fromArray:function(a){this.elements.set(a);return this},toArray:function(){var a=this.elements;return[a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15]]},clone:function(){var a=this.elements;return new THREE.Matrix4(a[0],
a[4],a[8],a[12],a[1],a[5],a[9],a[13],a[2],a[6],a[10],a[14],a[3],a[7],a[11],a[15])}};THREE.Ray=function(a,b){this.origin=void 0!==a?a:new THREE.Vector3;this.direction=void 0!==b?b:new THREE.Vector3};
THREE.Ray.prototype={constructor:THREE.Ray,set:function(a,b){this.origin.copy(a);this.direction.copy(b);return this},copy:function(a){this.origin.copy(a.origin);this.direction.copy(a.direction);return this},at:function(a,b){return(b||new THREE.Vector3).copy(this.direction).multiplyScalar(a).add(this.origin)},recast:function(){var a=new THREE.Vector3;return function(b){this.origin.copy(this.at(b,a));return this}}(),closestPointToPoint:function(a,b){var c=b||new THREE.Vector3;c.subVectors(a,this.origin);
var d=c.dot(this.direction);return 0>d?c.copy(this.origin):c.copy(this.direction).multiplyScalar(d).add(this.origin)},distanceToPoint:function(){var a=new THREE.Vector3;return function(b){var c=a.subVectors(b,this.origin).dot(this.direction);if(0>c)return this.origin.distanceTo(b);a.copy(this.direction).multiplyScalar(c).add(this.origin);return a.distanceTo(b)}}(),distanceSqToSegment:function(a,b,c,d){var e=a.clone().add(b).multiplyScalar(0.5),f=b.clone().sub(a).normalize(),h=0.5*a.distanceTo(b),
g=this.origin.clone().sub(e),a=-this.direction.dot(f),b=g.dot(this.direction),i=-g.dot(f),k=g.lengthSq(),m=Math.abs(1-a*a),l,p;0<=m?(g=a*i-b,l=a*b-i,p=h*m,0<=g?l>=-p?l<=p?(h=1/m,g*=h,l*=h,a=g*(g+a*l+2*b)+l*(a*g+l+2*i)+k):(l=h,g=Math.max(0,-(a*l+b)),a=-g*g+l*(l+2*i)+k):(l=-h,g=Math.max(0,-(a*l+b)),a=-g*g+l*(l+2*i)+k):l<=-p?(g=Math.max(0,-(-a*h+b)),l=0<g?-h:Math.min(Math.max(-h,-i),h),a=-g*g+l*(l+2*i)+k):l<=p?(g=0,l=Math.min(Math.max(-h,-i),h),a=l*(l+2*i)+k):(g=Math.max(0,-(a*h+b)),l=0<g?h:Math.min(Math.max(-h,
-i),h),a=-g*g+l*(l+2*i)+k)):(l=0<a?-h:h,g=Math.max(0,-(a*l+b)),a=-g*g+l*(l+2*i)+k);c&&c.copy(this.direction.clone().multiplyScalar(g).add(this.origin));d&&d.copy(f.clone().multiplyScalar(l).add(e));return a},isIntersectionSphere:function(a){return this.distanceToPoint(a.center)<=a.radius},isIntersectionPlane:function(a){var b=a.distanceToPoint(this.origin);return 0===b||0>a.normal.dot(this.direction)*b?!0:!1},distanceToPlane:function(a){var b=a.normal.dot(this.direction);if(0==b)return 0==a.distanceToPoint(this.origin)?
0:null;a=-(this.origin.dot(a.normal)+a.constant)/b;return 0<=a?a:null},intersectPlane:function(a,b){var c=this.distanceToPlane(a);return null===c?null:this.at(c,b)},isIntersectionBox:function(){var a=new THREE.Vector3;return function(b){return null!==this.intersectBox(b,a)}}(),intersectBox:function(a,b){var c,d,e,f,h;d=1/this.direction.x;f=1/this.direction.y;h=1/this.direction.z;var g=this.origin;0<=d?(c=(a.min.x-g.x)*d,d*=a.max.x-g.x):(c=(a.max.x-g.x)*d,d*=a.min.x-g.x);0<=f?(e=(a.min.y-g.y)*f,f*=
a.max.y-g.y):(e=(a.max.y-g.y)*f,f*=a.min.y-g.y);if(c>f||e>d)return null;if(e>c||c!==c)c=e;if(f<d||d!==d)d=f;0<=h?(e=(a.min.z-g.z)*h,h*=a.max.z-g.z):(e=(a.max.z-g.z)*h,h*=a.min.z-g.z);if(c>h||e>d)return null;if(e>c||c!==c)c=e;if(h<d||d!==d)d=h;return 0>d?null:this.at(0<=c?c:d,b)},intersectTriangle:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3,d=new THREE.Vector3;return function(e,f,h,g,i){b.subVectors(f,e);c.subVectors(h,e);d.crossVectors(b,c);f=this.direction.dot(d);if(0<
f){if(g)return null;g=1}else if(0>f)g=-1,f=-f;else return null;a.subVectors(this.origin,e);e=g*this.direction.dot(c.crossVectors(a,c));if(0>e)return null;h=g*this.direction.dot(b.cross(a));if(0>h||e+h>f)return null;e=-g*a.dot(d);return 0>e?null:this.at(e/f,i)}}(),applyMatrix4:function(a){this.direction.add(this.origin).applyMatrix4(a);this.origin.applyMatrix4(a);this.direction.sub(this.origin);this.direction.normalize();return this},equals:function(a){return a.origin.equals(this.origin)&&a.direction.equals(this.direction)},
clone:function(){return(new THREE.Ray).copy(this)}};THREE.Sphere=function(a,b){this.center=void 0!==a?a:new THREE.Vector3;this.radius=void 0!==b?b:0};
THREE.Sphere.prototype={constructor:THREE.Sphere,set:function(a,b){this.center.copy(a);this.radius=b;return this},setFromPoints:function(){var a=new THREE.Box3;return function(b,c){var d=this.center;void 0!==c?d.copy(c):a.setFromPoints(b).center(d);for(var e=0,f=0,h=b.length;f<h;f++)e=Math.max(e,d.distanceToSquared(b[f]));this.radius=Math.sqrt(e);return this}}(),copy:function(a){this.center.copy(a.center);this.radius=a.radius;return this},empty:function(){return 0>=this.radius},containsPoint:function(a){return a.distanceToSquared(this.center)<=
this.radius*this.radius},distanceToPoint:function(a){return a.distanceTo(this.center)-this.radius},intersectsSphere:function(a){var b=this.radius+a.radius;return a.center.distanceToSquared(this.center)<=b*b},clampPoint:function(a,b){var c=this.center.distanceToSquared(a),d=b||new THREE.Vector3;d.copy(a);c>this.radius*this.radius&&(d.sub(this.center).normalize(),d.multiplyScalar(this.radius).add(this.center));return d},getBoundingBox:function(a){a=a||new THREE.Box3;a.set(this.center,this.center);a.expandByScalar(this.radius);
return a},applyMatrix4:function(a){this.center.applyMatrix4(a);this.radius*=a.getMaxScaleOnAxis();return this},translate:function(a){this.center.add(a);return this},equals:function(a){return a.center.equals(this.center)&&a.radius===this.radius},clone:function(){return(new THREE.Sphere).copy(this)}};THREE.Frustum=function(a,b,c,d,e,f){this.planes=[void 0!==a?a:new THREE.Plane,void 0!==b?b:new THREE.Plane,void 0!==c?c:new THREE.Plane,void 0!==d?d:new THREE.Plane,void 0!==e?e:new THREE.Plane,void 0!==f?f:new THREE.Plane]};
THREE.Frustum.prototype={constructor:THREE.Frustum,set:function(a,b,c,d,e,f){var h=this.planes;h[0].copy(a);h[1].copy(b);h[2].copy(c);h[3].copy(d);h[4].copy(e);h[5].copy(f);return this},copy:function(a){for(var b=this.planes,c=0;6>c;c++)b[c].copy(a.planes[c]);return this},setFromMatrix:function(a){var b=this.planes,c=a.elements,a=c[0],d=c[1],e=c[2],f=c[3],h=c[4],g=c[5],i=c[6],k=c[7],m=c[8],l=c[9],p=c[10],s=c[11],t=c[12],n=c[13],r=c[14],c=c[15];b[0].setComponents(f-a,k-h,s-m,c-t).normalize();b[1].setComponents(f+
a,k+h,s+m,c+t).normalize();b[2].setComponents(f+d,k+g,s+l,c+n).normalize();b[3].setComponents(f-d,k-g,s-l,c-n).normalize();b[4].setComponents(f-e,k-i,s-p,c-r).normalize();b[5].setComponents(f+e,k+i,s+p,c+r).normalize();return this},intersectsObject:function(){var a=new THREE.Sphere;return function(b){var c=b.geometry;null===c.boundingSphere&&c.computeBoundingSphere();a.copy(c.boundingSphere);a.applyMatrix4(b.matrixWorld);return this.intersectsSphere(a)}}(),intersectsSphere:function(a){for(var b=this.planes,
c=a.center,a=-a.radius,d=0;6>d;d++)if(b[d].distanceToPoint(c)<a)return!1;return!0},intersectsBox:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c){for(var d=this.planes,e=0;6>e;e++){var f=d[e];a.x=0<f.normal.x?c.min.x:c.max.x;b.x=0<f.normal.x?c.max.x:c.min.x;a.y=0<f.normal.y?c.min.y:c.max.y;b.y=0<f.normal.y?c.max.y:c.min.y;a.z=0<f.normal.z?c.min.z:c.max.z;b.z=0<f.normal.z?c.max.z:c.min.z;var h=f.distanceToPoint(a),f=f.distanceToPoint(b);if(0>h&&0>f)return!1}return!0}}(),containsPoint:function(a){for(var b=
this.planes,c=0;6>c;c++)if(0>b[c].distanceToPoint(a))return!1;return!0},clone:function(){return(new THREE.Frustum).copy(this)}};THREE.Plane=function(a,b){this.normal=void 0!==a?a:new THREE.Vector3(1,0,0);this.constant=void 0!==b?b:0};
THREE.Plane.prototype={constructor:THREE.Plane,set:function(a,b){this.normal.copy(a);this.constant=b;return this},setComponents:function(a,b,c,d){this.normal.set(a,b,c);this.constant=d;return this},setFromNormalAndCoplanarPoint:function(a,b){this.normal.copy(a);this.constant=-b.dot(this.normal);return this},setFromCoplanarPoints:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d,e){d=a.subVectors(e,d).cross(b.subVectors(c,d)).normalize();this.setFromNormalAndCoplanarPoint(d,
c);return this}}(),copy:function(a){this.normal.copy(a.normal);this.constant=a.constant;return this},normalize:function(){var a=1/this.normal.length();this.normal.multiplyScalar(a);this.constant*=a;return this},negate:function(){this.constant*=-1;this.normal.negate();return this},distanceToPoint:function(a){return this.normal.dot(a)+this.constant},distanceToSphere:function(a){return this.distanceToPoint(a.center)-a.radius},projectPoint:function(a,b){return this.orthoPoint(a,b).sub(a).negate()},orthoPoint:function(a,
b){var c=this.distanceToPoint(a);return(b||new THREE.Vector3).copy(this.normal).multiplyScalar(c)},isIntersectionLine:function(a){var b=this.distanceToPoint(a.start),a=this.distanceToPoint(a.end);return 0>b&&0<a||0>a&&0<b},intersectLine:function(){var a=new THREE.Vector3;return function(b,c){var d=c||new THREE.Vector3,e=b.delta(a),f=this.normal.dot(e);if(0==f){if(0==this.distanceToPoint(b.start))return d.copy(b.start)}else return f=-(b.start.dot(this.normal)+this.constant)/f,0>f||1<f?void 0:d.copy(e).multiplyScalar(f).add(b.start)}}(),
coplanarPoint:function(a){return(a||new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)},applyMatrix4:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d){var d=d||(new THREE.Matrix3).getNormalMatrix(c),e=a.copy(this.normal).applyMatrix3(d),f=this.coplanarPoint(b);f.applyMatrix4(c);this.setFromNormalAndCoplanarPoint(e,f);return this}}(),translate:function(a){this.constant-=a.dot(this.normal);return this},equals:function(a){return a.normal.equals(this.normal)&&
a.constant==this.constant},clone:function(){return(new THREE.Plane).copy(this)}};THREE.Math={PI2:2*Math.PI,generateUUID:function(){var a="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),b=Array(36),c=0,d;return function(){for(var e=0;36>e;e++)8==e||13==e||18==e||23==e?b[e]="-":14==e?b[e]="4":(2>=c&&(c=33554432+16777216*Math.random()|0),d=c&15,c>>=4,b[e]=a[19==e?d&3|8:d]);return b.join("")}}(),clamp:function(a,b,c){return a<b?b:a>c?c:a},clampBottom:function(a,b){return a<b?b:a},mapLinear:function(a,b,c,d,e){return d+(a-b)*(e-d)/(c-b)},smoothstep:function(a,
b,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*(3-2*a)},smootherstep:function(a,b,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*a*(a*(6*a-15)+10)},random16:function(){return(65280*Math.random()+255*Math.random())/65535},randInt:function(a,b){return a+Math.floor(Math.random()*(b-a+1))},randFloat:function(a,b){return a+Math.random()*(b-a)},randFloatSpread:function(a){return a*(0.5-Math.random())},sign:function(a){return 0>a?-1:0<a?1:0},degToRad:function(){var a=Math.PI/
180;return function(b){return b*a}}(),radToDeg:function(){var a=180/Math.PI;return function(b){return b*a}}()};THREE.Spline=function(a){function b(a,b,c,d,e,f,h){a=0.5*(c-a);d=0.5*(d-b);return(2*(b-c)+a+d)*h+(-3*(b-c)-2*a-d)*f+a*e+b}this.points=a;var c=[],d={x:0,y:0,z:0},e,f,h,g,i,k,m,l,p;this.initFromArray=function(a){this.points=[];for(var b=0;b<a.length;b++)this.points[b]={x:a[b][0],y:a[b][1],z:a[b][2]}};this.getPoint=function(a){e=(this.points.length-1)*a;f=Math.floor(e);h=e-f;c[0]=0===f?f:f-1;c[1]=f;c[2]=f>this.points.length-2?this.points.length-1:f+1;c[3]=f>this.points.length-3?this.points.length-1:
f+2;k=this.points[c[0]];m=this.points[c[1]];l=this.points[c[2]];p=this.points[c[3]];g=h*h;i=h*g;d.x=b(k.x,m.x,l.x,p.x,h,g,i);d.y=b(k.y,m.y,l.y,p.y,h,g,i);d.z=b(k.z,m.z,l.z,p.z,h,g,i);return d};this.getControlPointsArray=function(){var a,b,c=this.points.length,d=[];for(a=0;a<c;a++)b=this.points[a],d[a]=[b.x,b.y,b.z];return d};this.getLength=function(a){var b,c,d,e=b=b=0,f=new THREE.Vector3,h=new THREE.Vector3,g=[],i=0;g[0]=0;a||(a=100);c=this.points.length*a;f.copy(this.points[0]);for(a=1;a<c;a++)b=
a/c,d=this.getPoint(b),h.copy(d),i+=h.distanceTo(f),f.copy(d),b*=this.points.length-1,b=Math.floor(b),b!=e&&(g[b]=i,e=b);g[g.length]=i;return{chunks:g,total:i}};this.reparametrizeByArcLength=function(a){var b,c,d,e,f,h,g=[],i=new THREE.Vector3,k=this.getLength();g.push(i.copy(this.points[0]).clone());for(b=1;b<this.points.length;b++){c=k.chunks[b]-k.chunks[b-1];h=Math.ceil(a*c/k.total);e=(b-1)/(this.points.length-1);f=b/(this.points.length-1);for(c=1;c<h-1;c++)d=e+c*(1/h)*(f-e),d=this.getPoint(d),
g.push(i.copy(d).clone());g.push(i.copy(this.points[b]).clone())}this.points=g}};THREE.Triangle=function(a,b,c){this.a=void 0!==a?a:new THREE.Vector3;this.b=void 0!==b?b:new THREE.Vector3;this.c=void 0!==c?c:new THREE.Vector3};THREE.Triangle.normal=function(){var a=new THREE.Vector3;return function(b,c,d,e){e=e||new THREE.Vector3;e.subVectors(d,c);a.subVectors(b,c);e.cross(a);b=e.lengthSq();return 0<b?e.multiplyScalar(1/Math.sqrt(b)):e.set(0,0,0)}}();
THREE.Triangle.barycoordFromPoint=function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(d,e,f,h,g){a.subVectors(h,e);b.subVectors(f,e);c.subVectors(d,e);var d=a.dot(a),e=a.dot(b),f=a.dot(c),i=b.dot(b),h=b.dot(c),k=d*i-e*e,g=g||new THREE.Vector3;if(0==k)return g.set(-2,-1,-1);k=1/k;i=(i*f-e*h)*k;d=(d*h-e*f)*k;return g.set(1-i-d,d,i)}}();
THREE.Triangle.containsPoint=function(){var a=new THREE.Vector3;return function(b,c,d,e){b=THREE.Triangle.barycoordFromPoint(b,c,d,e,a);return 0<=b.x&&0<=b.y&&1>=b.x+b.y}}();
THREE.Triangle.prototype={constructor:THREE.Triangle,set:function(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this},setFromPointsAndIndices:function(a,b,c,d){this.a.copy(a[b]);this.b.copy(a[c]);this.c.copy(a[d]);return this},copy:function(a){this.a.copy(a.a);this.b.copy(a.b);this.c.copy(a.c);return this},area:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(){a.subVectors(this.c,this.b);b.subVectors(this.a,this.b);return 0.5*a.cross(b).length()}}(),midpoint:function(a){return(a||
new THREE.Vector3).addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)},normal:function(a){return THREE.Triangle.normal(this.a,this.b,this.c,a)},plane:function(a){return(a||new THREE.Plane).setFromCoplanarPoints(this.a,this.b,this.c)},barycoordFromPoint:function(a,b){return THREE.Triangle.barycoordFromPoint(a,this.a,this.b,this.c,b)},containsPoint:function(a){return THREE.Triangle.containsPoint(a,this.a,this.b,this.c)},equals:function(a){return a.a.equals(this.a)&&a.b.equals(this.b)&&a.c.equals(this.c)},
clone:function(){return(new THREE.Triangle).copy(this)}};THREE.Vertex=function(a){console.warn("THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.");return a};THREE.UV=function(a,b){console.warn("THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.");return new THREE.Vector2(a,b)};THREE.Clock=function(a){this.autoStart=void 0!==a?a:!0;this.elapsedTime=this.oldTime=this.startTime=0;this.running=!1};
THREE.Clock.prototype={constructor:THREE.Clock,start:function(){this.oldTime=this.startTime=void 0!==self.performance&&void 0!==self.performance.now?self.performance.now():Date.now();this.running=!0},stop:function(){this.getElapsedTime();this.running=!1},getElapsedTime:function(){this.getDelta();return this.elapsedTime},getDelta:function(){var a=0;this.autoStart&&!this.running&&this.start();if(this.running){var b=void 0!==self.performance&&void 0!==self.performance.now?self.performance.now():Date.now(),
a=0.001*(b-this.oldTime);this.oldTime=b;this.elapsedTime+=a}return a}};THREE.EventDispatcher=function(){};
THREE.EventDispatcher.prototype={constructor:THREE.EventDispatcher,apply:function(a){a.addEventListener=THREE.EventDispatcher.prototype.addEventListener;a.hasEventListener=THREE.EventDispatcher.prototype.hasEventListener;a.removeEventListener=THREE.EventDispatcher.prototype.removeEventListener;a.dispatchEvent=THREE.EventDispatcher.prototype.dispatchEvent},addEventListener:function(a,b){void 0===this._listeners&&(this._listeners={});var c=this._listeners;void 0===c[a]&&(c[a]=[]);-1===c[a].indexOf(b)&&
c[a].push(b)},hasEventListener:function(a,b){if(void 0===this._listeners)return!1;var c=this._listeners;return void 0!==c[a]&&-1!==c[a].indexOf(b)?!0:!1},removeEventListener:function(a,b){if(void 0!==this._listeners){var c=this._listeners,d=c[a].indexOf(b);-1!==d&&c[a].splice(d,1)}},dispatchEvent:function(){var a=[];return function(b){if(void 0!==this._listeners){var c=this._listeners[b.type];if(void 0!==c){b.target=this;for(var d=c.length,e=0;e<d;e++)a[e]=c[e];for(e=0;e<d;e++)a[e].call(this,b)}}}}()};(function(a){a.Raycaster=function(b,c,d,e){this.ray=new a.Ray(b,c);this.near=d||0;this.far=e||Infinity};var b=new a.Sphere,c=new a.Ray;new a.Plane;new a.Vector3;var d=new a.Vector3,e=new a.Matrix4,f=function(a,b){return a.distance-b.distance},h=new a.Vector3,g=new a.Vector3,i=new a.Vector3,k=function(f,m,s){if(f instanceof a.Sprite){d.getPositionFromMatrix(f.matrixWorld);var t=m.ray.distanceToPoint(d);if(t>f.scale.x)return s;s.push({distance:t,point:f.position,face:null,object:f})}else if(f instanceof
a.LOD)d.getPositionFromMatrix(f.matrixWorld),t=m.ray.origin.distanceTo(d),k(f.getObjectForDistance(t),m,s);else if(f instanceof a.Mesh){var n=f.geometry;null===n.boundingSphere&&n.computeBoundingSphere();b.copy(n.boundingSphere);b.applyMatrix4(f.matrixWorld);if(!1===m.ray.isIntersectionSphere(b))return s;e.getInverse(f.matrixWorld);c.copy(m.ray).applyMatrix4(e);if(null!==n.boundingBox&&!1===c.isIntersectionBox(n.boundingBox))return s;if(n instanceof a.BufferGeometry){var r=f.material;if(void 0===
r||!1===n.dynamic)return s;var q,u,w=m.precision;if(void 0!==n.attributes.index)for(var z=n.offsets,B=n.attributes.index.array,D=n.attributes.position.array,x=n.offsets.length,F=n.attributes.index.array.length/3,F=0;F<x;++F)for(var t=z[F].start,A=z[F].index,n=t,O=t+z[F].count;n<O;n+=3)t=A+B[n],q=A+B[n+1],u=A+B[n+2],h.set(D[3*t],D[3*t+1],D[3*t+2]),g.set(D[3*q],D[3*q+1],D[3*q+2]),i.set(D[3*u],D[3*u+1],D[3*u+2]),q=r.side===a.BackSide?c.intersectTriangle(i,g,h,!0):c.intersectTriangle(h,g,i,r.side!==a.DoubleSide),
null!==q&&(q.applyMatrix4(f.matrixWorld),t=m.ray.origin.distanceTo(q),t<w||(t<m.near||t>m.far)||s.push({distance:t,point:q,face:null,faceIndex:null,object:f}));else{D=n.attributes.position.array;F=n.attributes.position.array.length;for(n=0;n<F;n+=3)t=n,q=n+1,u=n+2,h.set(D[3*t],D[3*t+1],D[3*t+2]),g.set(D[3*q],D[3*q+1],D[3*q+2]),i.set(D[3*u],D[3*u+1],D[3*u+2]),q=r.side===a.BackSide?c.intersectTriangle(i,g,h,!0):c.intersectTriangle(h,g,i,r.side!==a.DoubleSide),null!==q&&(q.applyMatrix4(f.matrixWorld),
t=m.ray.origin.distanceTo(q),t<w||(t<m.near||t>m.far)||s.push({distance:t,point:q,face:null,faceIndex:null,object:f}))}}else if(n instanceof a.Geometry){B=f.material instanceof a.MeshFaceMaterial;D=!0===B?f.material.materials:null;w=m.precision;z=n.vertices;x=0;for(F=n.faces.length;x<F;x++)A=n.faces[x],r=!0===B?D[A.materialIndex]:f.material,void 0!==r&&(t=z[A.a],q=z[A.b],u=z[A.c],q=r.side===a.BackSide?c.intersectTriangle(u,q,t,!0):c.intersectTriangle(t,q,u,r.side!==a.DoubleSide),null!==q&&(q.applyMatrix4(f.matrixWorld),
t=m.ray.origin.distanceTo(q),t<w||(t<m.near||t>m.far)||s.push({distance:t,point:q,face:A,faceIndex:x,object:f})))}}else if(f instanceof a.Line){w=m.linePrecision;r=w*w;n=f.geometry;null===n.boundingSphere&&n.computeBoundingSphere();b.copy(n.boundingSphere);b.applyMatrix4(f.matrixWorld);if(!1===m.ray.isIntersectionSphere(b))return s;e.getInverse(f.matrixWorld);c.copy(m.ray).applyMatrix4(e);if(n instanceof a.Geometry){z=n.vertices;w=z.length;q=new a.Vector3;u=new a.Vector3;F=f.type===a.LineStrip?1:
2;for(n=0;n<w-1;n+=F)c.distanceSqToSegment(z[n],z[n+1],u,q)>r||(t=c.origin.distanceTo(u),t<m.near||t>m.far||s.push({distance:t,point:q.clone().applyMatrix4(f.matrixWorld),face:null,faceIndex:null,object:f}))}}},m=function(a,b,c){for(var a=a.getDescendants(),d=0,e=a.length;d<e;d++)k(a[d],b,c)};a.Raycaster.prototype.precision=1E-4;a.Raycaster.prototype.linePrecision=1;a.Raycaster.prototype.set=function(a,b){this.ray.set(a,b)};a.Raycaster.prototype.intersectObject=function(a,b){var c=[];!0===b&&m(a,
this,c);k(a,this,c);c.sort(f);return c};a.Raycaster.prototype.intersectObjects=function(a,b){for(var c=[],d=0,e=a.length;d<e;d++)k(a[d],this,c),!0===b&&m(a[d],this,c);c.sort(f);return c}})(THREE);THREE.Object3D=function(){this.id=THREE.Object3DIdCount++;this.uuid=THREE.Math.generateUUID();this.name="";this.parent=void 0;this.children=[];this.up=new THREE.Vector3(0,1,0);this.position=new THREE.Vector3;this.rotation=new THREE.Euler;this.quaternion=new THREE.Quaternion;this.scale=new THREE.Vector3(1,1,1);this.rotation._quaternion=this.quaternion;this.quaternion._euler=this.rotation;this.renderDepth=null;this.rotationAutoUpdate=!0;this.matrix=new THREE.Matrix4;this.matrixWorld=new THREE.Matrix4;
this.visible=this.matrixWorldNeedsUpdate=this.matrixAutoUpdate=!0;this.receiveShadow=this.castShadow=!1;this.frustumCulled=!0;this.userData={}};
THREE.Object3D.prototype={constructor:THREE.Object3D,get eulerOrder(){console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order.");return this.rotation.order},set eulerOrder(a){console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order.");this.rotation.order=a},get useQuaternion(){console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.")},set useQuaternion(a){console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.")},
applyMatrix:function(){var a=new THREE.Matrix4;return function(b){this.matrix.multiplyMatrices(b,this.matrix);this.position.getPositionFromMatrix(this.matrix);this.scale.getScaleFromMatrix(this.matrix);a.extractRotation(this.matrix);this.quaternion.setFromRotationMatrix(a)}}(),setRotationFromAxisAngle:function(a,b){this.quaternion.setFromAxisAngle(a,b)},setRotationFromEuler:function(a){this.quaternion.setFromEuler(a,!0)},setRotationFromMatrix:function(a){this.quaternion.setFromRotationMatrix(a)},
setRotationFromQuaternion:function(a){this.quaternion.copy(a)},rotateOnAxis:function(){var a=new THREE.Quaternion;return function(b,c){a.setFromAxisAngle(b,c);this.quaternion.multiply(a);return this}}(),rotateX:function(){var a=new THREE.Vector3(1,0,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateY:function(){var a=new THREE.Vector3(0,1,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateZ:function(){var a=new THREE.Vector3(0,0,1);return function(b){return this.rotateOnAxis(a,
b)}}(),translateOnAxis:function(){var a=new THREE.Vector3;return function(b,c){a.copy(b);a.applyQuaternion(this.quaternion);this.position.add(a.multiplyScalar(c));return this}}(),translate:function(a,b){console.warn("DEPRECATED: Object3D's .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.");return this.translateOnAxis(b,a)},translateX:function(){var a=new THREE.Vector3(1,0,0);return function(b){return this.translateOnAxis(a,b)}}(),translateY:function(){var a=
new THREE.Vector3(0,1,0);return function(b){return this.translateOnAxis(a,b)}}(),translateZ:function(){var a=new THREE.Vector3(0,0,1);return function(b){return this.translateOnAxis(a,b)}}(),localToWorld:function(a){return a.applyMatrix4(this.matrixWorld)},worldToLocal:function(){var a=new THREE.Matrix4;return function(b){return b.applyMatrix4(a.getInverse(this.matrixWorld))}}(),lookAt:function(){var a=new THREE.Matrix4;return function(b){a.lookAt(b,this.position,this.up);this.quaternion.setFromRotationMatrix(a)}}(),
add:function(a){if(a===this)console.warn("THREE.Object3D.add: An object can't be added as a child of itself.");else if(a instanceof THREE.Object3D){void 0!==a.parent&&a.parent.remove(a);a.parent=this;a.dispatchEvent({type:"added"});this.children.push(a);for(var b=this;void 0!==b.parent;)b=b.parent;void 0!==b&&b instanceof THREE.Scene&&b.__addObject(a)}},remove:function(a){var b=this.children.indexOf(a);if(-1!==b){a.parent=void 0;a.dispatchEvent({type:"removed"});this.children.splice(b,1);for(b=this;void 0!==
b.parent;)b=b.parent;void 0!==b&&b instanceof THREE.Scene&&b.__removeObject(a)}},traverse:function(a){a(this);for(var b=0,c=this.children.length;b<c;b++)this.children[b].traverse(a)},getObjectById:function(a,b){for(var c=0,d=this.children.length;c<d;c++){var e=this.children[c];if(e.id===a||!0===b&&(e=e.getObjectById(a,b),void 0!==e))return e}},getObjectByName:function(a,b){for(var c=0,d=this.children.length;c<d;c++){var e=this.children[c];if(e.name===a||!0===b&&(e=e.getObjectByName(a,b),void 0!==
e))return e}},getChildByName:function(a,b){console.warn("DEPRECATED: Object3D's .getChildByName() has been renamed to .getObjectByName().");return this.getObjectByName(a,b)},getDescendants:function(a){void 0===a&&(a=[]);Array.prototype.push.apply(a,this.children);for(var b=0,c=this.children.length;b<c;b++)this.children[b].getDescendants(a);return a},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(a){!0===
this.matrixAutoUpdate&&this.updateMatrix();if(!0===this.matrixWorldNeedsUpdate||!0===a)void 0===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,a=!0;for(var b=0,c=this.children.length;b<c;b++)this.children[b].updateMatrixWorld(a)},clone:function(a,b){void 0===a&&(a=new THREE.Object3D);void 0===b&&(b=!0);a.name=this.name;a.up.copy(this.up);a.position.copy(this.position);a.quaternion.copy(this.quaternion);
a.scale.copy(this.scale);a.renderDepth=this.renderDepth;a.rotationAutoUpdate=this.rotationAutoUpdate;a.matrix.copy(this.matrix);a.matrixWorld.copy(this.matrixWorld);a.matrixAutoUpdate=this.matrixAutoUpdate;a.matrixWorldNeedsUpdate=this.matrixWorldNeedsUpdate;a.visible=this.visible;a.castShadow=this.castShadow;a.receiveShadow=this.receiveShadow;a.frustumCulled=this.frustumCulled;a.userData=JSON.parse(JSON.stringify(this.userData));if(!0===b)for(var c=0;c<this.children.length;c++)a.add(this.children[c].clone());
return a}};THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);THREE.Object3DIdCount=0;THREE.Projector=function(){function a(){if(i===m){var a=new THREE.RenderableVertex;k.push(a);m++;i++;return a}return k[i++]}function b(a,b){return a.z!==b.z?b.z-a.z:a.id!==b.id?a.id-b.id:0}function c(a,b){var c=0,d=1,e=a.z+a.w,f=b.z+b.w,h=-a.z+a.w,g=-b.z+b.w;if(0<=e&&0<=f&&0<=h&&0<=g)return!0;if(0>e&&0>f||0>h&&0>g)return!1;0>e?c=Math.max(c,e/(e-f)):0>f&&(d=Math.min(d,e/(e-f)));0>h?c=Math.max(c,h/(h-g)):0>g&&(d=Math.min(d,h/(h-g)));if(d<c)return!1;a.lerp(b,c);b.lerp(a,1-d);return!0}var d,e,f=[],h=
0,g,i,k=[],m=0,l,p,s=[],t=0,n,r,q=[],u=0,w,z,B=[],D=0,x={objects:[],sprites:[],lights:[],elements:[]},F=new THREE.Vector3,A=new THREE.Vector4,O=new THREE.Box3(new THREE.Vector3(-1,-1,-1),new THREE.Vector3(1,1,1)),C=new THREE.Box3,E=Array(3),I=new THREE.Matrix4,y=new THREE.Matrix4,v,G=new THREE.Matrix4,R=new THREE.Matrix3,J=new THREE.Matrix3,ba=new THREE.Vector3,oa=new THREE.Frustum,pa=new THREE.Vector4,N=new THREE.Vector4;this.projectVector=function(a,b){b.matrixWorldInverse.getInverse(b.matrixWorld);
y.multiplyMatrices(b.projectionMatrix,b.matrixWorldInverse);return a.applyProjection(y)};this.unprojectVector=function(a,b){b.projectionMatrixInverse.getInverse(b.projectionMatrix);y.multiplyMatrices(b.matrixWorld,b.projectionMatrixInverse);return a.applyProjection(y)};this.pickingRay=function(a,b){a.z=-1;var c=new THREE.Vector3(a.x,a.y,1);this.unprojectVector(a,b);this.unprojectVector(c,b);c.sub(a).normalize();return new THREE.Raycaster(a,c)};var M=function(a){if(e===h){var b=new THREE.RenderableObject;
f.push(b);h++;e++;d=b}else d=f[e++];d.id=a.id;d.object=a;null!==a.renderDepth?d.z=a.renderDepth:(F.getPositionFromMatrix(a.matrixWorld),F.applyProjection(y),d.z=F.z);return d},Q=function(a){if(!1!==a.visible){a instanceof THREE.Light?x.lights.push(a):a instanceof THREE.Mesh||a instanceof THREE.Line?(!1===a.frustumCulled||!0===oa.intersectsObject(a))&&x.objects.push(M(a)):a instanceof THREE.Sprite&&x.sprites.push(M(a));for(var b=0,c=a.children.length;b<c;b++)Q(a.children[b])}};this.projectScene=function(d,
f,h,m){var da=!1,F,M,ea,V,P,Z,U,ka,ta,ia,La,Ga;z=r=p=0;x.elements.length=0;!0===d.autoUpdate&&d.updateMatrixWorld();void 0===f.parent&&f.updateMatrixWorld();I.copy(f.matrixWorldInverse.getInverse(f.matrixWorld));y.multiplyMatrices(f.projectionMatrix,I);J.getNormalMatrix(I);oa.setFromMatrix(y);e=0;x.objects.length=0;x.sprites.length=0;x.lights.length=0;Q(d);!0===h&&x.objects.sort(b);d=0;for(h=x.objects.length;d<h;d++)if(U=x.objects[d].object,v=U.matrixWorld,i=0,U instanceof THREE.Mesh){ka=U.geometry;
ea=ka.vertices;ta=ka.faces;ka=ka.faceVertexUvs;R.getNormalMatrix(v);La=U.material instanceof THREE.MeshFaceMaterial;Ga=!0===La?U.material:null;F=0;for(M=ea.length;F<M;F++){g=a();g.positionWorld.copy(ea[F]).applyMatrix4(v);g.positionScreen.copy(g.positionWorld).applyMatrix4(y);var fa=1/g.positionScreen.w;g.positionScreen.x*=fa;g.positionScreen.y*=fa;g.positionScreen.z*=fa;g.visible=!(-1>g.positionScreen.x||1<g.positionScreen.x||-1>g.positionScreen.y||1<g.positionScreen.y||-1>g.positionScreen.z||1<
g.positionScreen.z)}ea=0;for(F=ta.length;ea<F;ea++)if(M=ta[ea],fa=!0===La?Ga.materials[M.materialIndex]:U.material,void 0!==fa&&(Z=fa.side,V=k[M.a],P=k[M.b],ia=k[M.c],E[0]=V.positionScreen,E[1]=P.positionScreen,E[2]=ia.positionScreen,!0===V.visible||!0===P.visible||!0===ia.visible||O.isIntersectionBox(C.setFromPoints(E))))if(da=0>(ia.positionScreen.x-V.positionScreen.x)*(P.positionScreen.y-V.positionScreen.y)-(ia.positionScreen.y-V.positionScreen.y)*(P.positionScreen.x-V.positionScreen.x),Z===THREE.DoubleSide||
da===(Z===THREE.FrontSide)){if(p===t){var Da=new THREE.RenderableFace3;s.push(Da);t++;p++;l=Da}else l=s[p++];l.id=U.id;l.v1.copy(V);l.v2.copy(P);l.v3.copy(ia);l.normalModel.copy(M.normal);!1===da&&(Z===THREE.BackSide||Z===THREE.DoubleSide)&&l.normalModel.negate();l.normalModel.applyMatrix3(R).normalize();l.normalModelView.copy(l.normalModel).applyMatrix3(J);l.centroidModel.copy(M.centroid).applyMatrix4(v);ia=M.vertexNormals;V=0;for(P=Math.min(ia.length,3);V<P;V++)Da=l.vertexNormalsModel[V],Da.copy(ia[V]),
!1===da&&(Z===THREE.BackSide||Z===THREE.DoubleSide)&&Da.negate(),Da.applyMatrix3(R).normalize(),l.vertexNormalsModelView[V].copy(Da).applyMatrix3(J);l.vertexNormalsLength=ia.length;da=0;for(V=Math.min(ka.length,3);da<V;da++)if(ia=ka[da][ea],void 0!==ia){P=0;for(Z=ia.length;P<Z;P++)l.uvs[da][P]=ia[P]}l.color=M.color;l.material=fa;ba.copy(l.centroidModel).applyProjection(y);l.z=ba.z;x.elements.push(l)}}else if(U instanceof THREE.Line){G.multiplyMatrices(y,v);ea=U.geometry.vertices;V=a();V.positionScreen.copy(ea[0]).applyMatrix4(G);
ta=U.type===THREE.LinePieces?2:1;F=1;for(M=ea.length;F<M;F++)V=a(),V.positionScreen.copy(ea[F]).applyMatrix4(G),0<(F+1)%ta||(P=k[i-2],pa.copy(V.positionScreen),N.copy(P.positionScreen),!0===c(pa,N)&&(pa.multiplyScalar(1/pa.w),N.multiplyScalar(1/N.w),r===u?(ka=new THREE.RenderableLine,q.push(ka),u++,r++,n=ka):n=q[r++],n.id=U.id,n.v1.positionScreen.copy(pa),n.v2.positionScreen.copy(N),n.z=Math.max(pa.z,N.z),n.material=U.material,U.material.vertexColors===THREE.VertexColors&&(n.vertexColors[0].copy(U.geometry.colors[F]),
n.vertexColors[1].copy(U.geometry.colors[F-1])),x.elements.push(n)))}d=0;for(h=x.sprites.length;d<h;d++)U=x.sprites[d].object,v=U.matrixWorld,U instanceof THREE.Sprite&&(A.set(v.elements[12],v.elements[13],v.elements[14],1),A.applyMatrix4(y),fa=1/A.w,A.z*=fa,-1<A.z&&1>A.z&&(z===D?(ta=new THREE.RenderableSprite,B.push(ta),D++,z++,w=ta):w=B[z++],w.id=U.id,w.x=A.x*fa,w.y=A.y*fa,w.z=A.z,w.object=U,w.rotation=U.rotation,w.scale.x=U.scale.x*Math.abs(w.x-(A.x+f.projectionMatrix.elements[0])/(A.w+f.projectionMatrix.elements[12])),
w.scale.y=U.scale.y*Math.abs(w.y-(A.y+f.projectionMatrix.elements[5])/(A.w+f.projectionMatrix.elements[13])),w.material=U.material,x.elements.push(w)));!0===m&&x.elements.sort(b);return x}};THREE.Face3=function(a,b,c,d,e,f){this.a=a;this.b=b;this.c=c;this.normal=d instanceof THREE.Vector3?d:new THREE.Vector3;this.vertexNormals=d instanceof Array?d:[];this.color=e instanceof THREE.Color?e:new THREE.Color;this.vertexColors=e instanceof Array?e:[];this.vertexTangents=[];this.materialIndex=void 0!==f?f:0;this.centroid=new THREE.Vector3};
THREE.Face3.prototype={constructor:THREE.Face3,clone:function(){var a=new THREE.Face3(this.a,this.b,this.c);a.normal.copy(this.normal);a.color.copy(this.color);a.centroid.copy(this.centroid);a.materialIndex=this.materialIndex;var b,c;b=0;for(c=this.vertexNormals.length;b<c;b++)a.vertexNormals[b]=this.vertexNormals[b].clone();b=0;for(c=this.vertexColors.length;b<c;b++)a.vertexColors[b]=this.vertexColors[b].clone();b=0;for(c=this.vertexTangents.length;b<c;b++)a.vertexTangents[b]=this.vertexTangents[b].clone();
return a}};THREE.Face4=function(a,b,c,d,e,f,h){console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");return new THREE.Face3(a,b,c,e,f,h)};THREE.Geometry=function(){this.id=THREE.GeometryIdCount++;this.uuid=THREE.Math.generateUUID();this.name="";this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphColors=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingSphere=this.boundingBox=null;this.hasTangents=!1;this.dynamic=!0;this.buffersNeedUpdate=this.lineDistancesNeedUpdate=this.colorsNeedUpdate=this.tangentsNeedUpdate=this.normalsNeedUpdate=this.uvsNeedUpdate=
this.elementsNeedUpdate=this.verticesNeedUpdate=!1};
THREE.Geometry.prototype={constructor:THREE.Geometry,applyMatrix:function(a){for(var b=(new THREE.Matrix3).getNormalMatrix(a),c=0,d=this.vertices.length;c<d;c++)this.vertices[c].applyMatrix4(a);c=0;for(d=this.faces.length;c<d;c++){var e=this.faces[c];e.normal.applyMatrix3(b).normalize();for(var f=0,h=e.vertexNormals.length;f<h;f++)e.vertexNormals[f].applyMatrix3(b).normalize();e.centroid.applyMatrix4(a)}this.boundingBox instanceof THREE.Box3&&this.computeBoundingBox();this.boundingSphere instanceof
THREE.Sphere&&this.computeBoundingSphere()},computeCentroids:function(){var a,b,c;a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],c.centroid.set(0,0,0),c.centroid.add(this.vertices[c.a]),c.centroid.add(this.vertices[c.b]),c.centroid.add(this.vertices[c.c]),c.centroid.divideScalar(3)},computeFaceNormals:function(){for(var a=new THREE.Vector3,b=new THREE.Vector3,c=0,d=this.faces.length;c<d;c++){var e=this.faces[c],f=this.vertices[e.a],h=this.vertices[e.b];a.subVectors(this.vertices[e.c],h);b.subVectors(f,
h);a.cross(b);a.normalize();e.normal.copy(a)}},computeVertexNormals:function(a){var b,c,d,e;if(void 0===this.__tmpVertices){e=this.__tmpVertices=Array(this.vertices.length);b=0;for(c=this.vertices.length;b<c;b++)e[b]=new THREE.Vector3;b=0;for(c=this.faces.length;b<c;b++)d=this.faces[b],d.vertexNormals=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3]}else{e=this.__tmpVertices;b=0;for(c=this.vertices.length;b<c;b++)e[b].set(0,0,0)}if(a){var f,h,g=new THREE.Vector3,i=new THREE.Vector3;new THREE.Vector3;
new THREE.Vector3;new THREE.Vector3;b=0;for(c=this.faces.length;b<c;b++)d=this.faces[b],a=this.vertices[d.a],f=this.vertices[d.b],h=this.vertices[d.c],g.subVectors(h,f),i.subVectors(a,f),g.cross(i),e[d.a].add(g),e[d.b].add(g),e[d.c].add(g)}else{b=0;for(c=this.faces.length;b<c;b++)d=this.faces[b],e[d.a].add(d.normal),e[d.b].add(d.normal),e[d.c].add(d.normal)}b=0;for(c=this.vertices.length;b<c;b++)e[b].normalize();b=0;for(c=this.faces.length;b<c;b++)d=this.faces[b],d.vertexNormals[0].copy(e[d.a]),d.vertexNormals[1].copy(e[d.b]),
d.vertexNormals[2].copy(e[d.c])},computeMorphNormals:function(){var a,b,c,d,e;c=0;for(d=this.faces.length;c<d;c++){e=this.faces[c];e.__originalFaceNormal?e.__originalFaceNormal.copy(e.normal):e.__originalFaceNormal=e.normal.clone();e.__originalVertexNormals||(e.__originalVertexNormals=[]);a=0;for(b=e.vertexNormals.length;a<b;a++)e.__originalVertexNormals[a]?e.__originalVertexNormals[a].copy(e.vertexNormals[a]):e.__originalVertexNormals[a]=e.vertexNormals[a].clone()}var f=new THREE.Geometry;f.faces=
this.faces;a=0;for(b=this.morphTargets.length;a<b;a++){if(!this.morphNormals[a]){this.morphNormals[a]={};this.morphNormals[a].faceNormals=[];this.morphNormals[a].vertexNormals=[];e=this.morphNormals[a].faceNormals;var h=this.morphNormals[a].vertexNormals,g,i;c=0;for(d=this.faces.length;c<d;c++)g=new THREE.Vector3,i={a:new THREE.Vector3,b:new THREE.Vector3,c:new THREE.Vector3},e.push(g),h.push(i)}h=this.morphNormals[a];f.vertices=this.morphTargets[a].vertices;f.computeFaceNormals();f.computeVertexNormals();
c=0;for(d=this.faces.length;c<d;c++)e=this.faces[c],g=h.faceNormals[c],i=h.vertexNormals[c],g.copy(e.normal),i.a.copy(e.vertexNormals[0]),i.b.copy(e.vertexNormals[1]),i.c.copy(e.vertexNormals[2])}c=0;for(d=this.faces.length;c<d;c++)e=this.faces[c],e.normal=e.__originalFaceNormal,e.vertexNormals=e.__originalVertexNormals},computeTangents:function(){var a,b,c,d,e,f,h,g,i,k,m,l,p,s,t,n,r,q=[],u=[];c=new THREE.Vector3;var w=new THREE.Vector3,z=new THREE.Vector3,B=new THREE.Vector3,D=new THREE.Vector3;
a=0;for(b=this.vertices.length;a<b;a++)q[a]=new THREE.Vector3,u[a]=new THREE.Vector3;a=0;for(b=this.faces.length;a<b;a++)e=this.faces[a],f=this.faceVertexUvs[0][a],d=e.a,r=e.b,e=e.c,h=this.vertices[d],g=this.vertices[r],i=this.vertices[e],k=f[0],m=f[1],l=f[2],f=g.x-h.x,p=i.x-h.x,s=g.y-h.y,t=i.y-h.y,g=g.z-h.z,h=i.z-h.z,i=m.x-k.x,n=l.x-k.x,m=m.y-k.y,k=l.y-k.y,l=1/(i*k-n*m),c.set((k*f-m*p)*l,(k*s-m*t)*l,(k*g-m*h)*l),w.set((i*p-n*f)*l,(i*t-n*s)*l,(i*h-n*g)*l),q[d].add(c),q[r].add(c),q[e].add(c),u[d].add(w),
u[r].add(w),u[e].add(w);w=["a","b","c","d"];a=0;for(b=this.faces.length;a<b;a++){e=this.faces[a];for(c=0;c<Math.min(e.vertexNormals.length,3);c++)D.copy(e.vertexNormals[c]),d=e[w[c]],r=q[d],z.copy(r),z.sub(D.multiplyScalar(D.dot(r))).normalize(),B.crossVectors(e.vertexNormals[c],r),d=B.dot(u[d]),d=0>d?-1:1,e.vertexTangents[c]=new THREE.Vector4(z.x,z.y,z.z,d)}this.hasTangents=!0},computeLineDistances:function(){for(var a=0,b=this.vertices,c=0,d=b.length;c<d;c++)0<c&&(a+=b[c].distanceTo(b[c-1])),this.lineDistances[c]=
a},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new THREE.Box3);this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new THREE.Sphere);this.boundingSphere.setFromPoints(this.vertices)},mergeVertices:function(){var a={},b=[],c=[],d,e=Math.pow(10,4),f,h;this.__tmpVertices=void 0;f=0;for(h=this.vertices.length;f<h;f++)d=this.vertices[f],d=Math.round(d.x*e)+"_"+Math.round(d.y*e)+"_"+Math.round(d.z*
e),void 0===a[d]?(a[d]=f,b.push(this.vertices[f]),c[f]=b.length-1):c[f]=c[a[d]];a=[];f=0;for(h=this.faces.length;f<h;f++){e=this.faces[f];e.a=c[e.a];e.b=c[e.b];e.c=c[e.c];e=[e.a,e.b,e.c];for(d=0;3>d;d++)if(e[d]==e[(d+1)%3]){a.push(f);break}}for(f=a.length-1;0<=f;f--){e=a[f];this.faces.splice(e,1);c=0;for(h=this.faceVertexUvs.length;c<h;c++)this.faceVertexUvs[c].splice(e,1)}f=this.vertices.length-b.length;this.vertices=b;return f},clone:function(){for(var a=new THREE.Geometry,b=this.vertices,c=0,d=
b.length;c<d;c++)a.vertices.push(b[c].clone());b=this.faces;c=0;for(d=b.length;c<d;c++)a.faces.push(b[c].clone());b=this.faceVertexUvs[0];c=0;for(d=b.length;c<d;c++){for(var e=b[c],f=[],h=0,g=e.length;h<g;h++)f.push(new THREE.Vector2(e[h].x,e[h].y));a.faceVertexUvs[0].push(f)}return a},dispose:function(){this.dispatchEvent({type:"dispose"})}};THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);THREE.GeometryIdCount=0;THREE.BufferGeometry=function(){this.id=THREE.GeometryIdCount++;this.uuid=THREE.Math.generateUUID();this.name="";this.attributes={};this.dynamic=!0;this.offsets=[];this.boundingSphere=this.boundingBox=null;this.hasTangents=!1;this.morphTargets=[]};
THREE.BufferGeometry.prototype={constructor:THREE.BufferGeometry,addAttribute:function(a,b,c,d){this.attributes[a]={itemSize:d,array:new b(c*d)}},applyMatrix:function(a){var b,c;this.attributes.position&&(b=this.attributes.position.array);this.attributes.normal&&(c=this.attributes.normal.array);void 0!==b&&(a.multiplyVector3Array(b),this.verticesNeedUpdate=!0);void 0!==c&&((new THREE.Matrix3).getNormalMatrix(a).multiplyVector3Array(c),this.normalizeNormals(),this.normalsNeedUpdate=!0)},computeBoundingBox:function(){null===
this.boundingBox&&(this.boundingBox=new THREE.Box3);var a=this.attributes.position.array;if(a){var b=this.boundingBox,c,d,e;3<=a.length&&(b.min.x=b.max.x=a[0],b.min.y=b.max.y=a[1],b.min.z=b.max.z=a[2]);for(var f=3,h=a.length;f<h;f+=3)c=a[f],d=a[f+1],e=a[f+2],c<b.min.x?b.min.x=c:c>b.max.x&&(b.max.x=c),d<b.min.y?b.min.y=d:d>b.max.y&&(b.max.y=d),e<b.min.z?b.min.z=e:e>b.max.z&&(b.max.z=e)}if(void 0===a||0===a.length)this.boundingBox.min.set(0,0,0),this.boundingBox.max.set(0,0,0)},computeBoundingSphere:function(){var a=
new THREE.Box3,b=new THREE.Vector3;return function(){null===this.boundingSphere&&(this.boundingSphere=new THREE.Sphere);var c=this.attributes.position.array;if(c){for(var d=this.boundingSphere.center,e=0,f=c.length;e<f;e+=3)b.set(c[e],c[e+1],c[e+2]),a.addPoint(b);a.center(d);for(var h=0,e=0,f=c.length;e<f;e+=3)b.set(c[e],c[e+1],c[e+2]),h=Math.max(h,d.distanceToSquared(b));this.boundingSphere.radius=Math.sqrt(h)}}}(),computeVertexNormals:function(){if(this.attributes.position){var a,b,c,d;a=this.attributes.position.array.length;
if(void 0===this.attributes.normal)this.attributes.normal={itemSize:3,array:new Float32Array(a)};else{a=0;for(b=this.attributes.normal.array.length;a<b;a++)this.attributes.normal.array[a]=0}var e=this.attributes.position.array,f=this.attributes.normal.array,h,g,i,k,m,l,p=new THREE.Vector3,s=new THREE.Vector3,t=new THREE.Vector3,n=new THREE.Vector3,r=new THREE.Vector3;if(this.attributes.index){var q=this.attributes.index.array,u=this.offsets;c=0;for(d=u.length;c<d;++c){b=u[c].start;h=u[c].count;var w=
u[c].index;a=b;for(b+=h;a<b;a+=3)h=w+q[a],g=w+q[a+1],i=w+q[a+2],k=e[3*h],m=e[3*h+1],l=e[3*h+2],p.set(k,m,l),k=e[3*g],m=e[3*g+1],l=e[3*g+2],s.set(k,m,l),k=e[3*i],m=e[3*i+1],l=e[3*i+2],t.set(k,m,l),n.subVectors(t,s),r.subVectors(p,s),n.cross(r),f[3*h]+=n.x,f[3*h+1]+=n.y,f[3*h+2]+=n.z,f[3*g]+=n.x,f[3*g+1]+=n.y,f[3*g+2]+=n.z,f[3*i]+=n.x,f[3*i+1]+=n.y,f[3*i+2]+=n.z}}else{a=0;for(b=e.length;a<b;a+=9)k=e[a],m=e[a+1],l=e[a+2],p.set(k,m,l),k=e[a+3],m=e[a+4],l=e[a+5],s.set(k,m,l),k=e[a+6],m=e[a+7],l=e[a+8],
t.set(k,m,l),n.subVectors(t,s),r.subVectors(p,s),n.cross(r),f[a]=n.x,f[a+1]=n.y,f[a+2]=n.z,f[a+3]=n.x,f[a+4]=n.y,f[a+5]=n.z,f[a+6]=n.x,f[a+7]=n.y,f[a+8]=n.z}this.normalizeNormals();this.normalsNeedUpdate=!0}},normalizeNormals:function(){for(var a=this.attributes.normal.array,b,c,d,e=0,f=a.length;e<f;e+=3)b=a[e],c=a[e+1],d=a[e+2],b=1/Math.sqrt(b*b+c*c+d*d),a[e]*=b,a[e+1]*=b,a[e+2]*=b},computeTangents:function(){function a(a){oa.x=d[3*a];oa.y=d[3*a+1];oa.z=d[3*a+2];pa.copy(oa);M=g[a];J.copy(M);J.sub(oa.multiplyScalar(oa.dot(M))).normalize();
ba.crossVectors(pa,M);Q=ba.dot(i[a]);N=0>Q?-1:1;h[4*a]=J.x;h[4*a+1]=J.y;h[4*a+2]=J.z;h[4*a+3]=N}if(void 0===this.attributes.index||void 0===this.attributes.position||void 0===this.attributes.normal||void 0===this.attributes.uv)console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");else{var b=this.attributes.index.array,c=this.attributes.position.array,d=this.attributes.normal.array,e=this.attributes.uv.array,f=c.length/3;void 0===this.attributes.tangent&&
(this.attributes.tangent={itemSize:4,array:new Float32Array(4*f)});for(var h=this.attributes.tangent.array,g=[],i=[],k=0;k<f;k++)g[k]=new THREE.Vector3,i[k]=new THREE.Vector3;var m,l,p,s,t,n,r,q,u,w,z,B,D,x,F,f=new THREE.Vector3,k=new THREE.Vector3,A,O,C,E,I,y,v,G=this.offsets;C=0;for(E=G.length;C<E;++C){O=G[C].start;I=G[C].count;var R=G[C].index;A=O;for(O+=I;A<O;A+=3)I=R+b[A],y=R+b[A+1],v=R+b[A+2],m=c[3*I],l=c[3*I+1],p=c[3*I+2],s=c[3*y],t=c[3*y+1],n=c[3*y+2],r=c[3*v],q=c[3*v+1],u=c[3*v+2],w=e[2*
I],z=e[2*I+1],B=e[2*y],D=e[2*y+1],x=e[2*v],F=e[2*v+1],s-=m,m=r-m,t-=l,l=q-l,n-=p,p=u-p,B-=w,w=x-w,D-=z,z=F-z,F=1/(B*z-w*D),f.set((z*s-D*m)*F,(z*t-D*l)*F,(z*n-D*p)*F),k.set((B*m-w*s)*F,(B*l-w*t)*F,(B*p-w*n)*F),g[I].add(f),g[y].add(f),g[v].add(f),i[I].add(k),i[y].add(k),i[v].add(k)}var J=new THREE.Vector3,ba=new THREE.Vector3,oa=new THREE.Vector3,pa=new THREE.Vector3,N,M,Q;C=0;for(E=G.length;C<E;++C){O=G[C].start;I=G[C].count;R=G[C].index;A=O;for(O+=I;A<O;A+=3)I=R+b[A],y=R+b[A+1],v=R+b[A+2],a(I),a(y),
a(v)}this.tangentsNeedUpdate=this.hasTangents=!0}},clone:function(){var a=new THREE.BufferGeometry,b=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],c;for(c in this.attributes){for(var d=this.attributes[c],e=d.array,f={itemSize:d.itemSize,numItems:d.numItems,array:null},d=0,h=b.length;d<h;d++){var g=b[d];if(e instanceof g){f.array=new g(e);break}}a.attributes[c]=f}d=0;for(h=this.offsets.length;d<h;d++)b=this.offsets[d],a.offsets.push({start:b.start,
index:b.index,count:b.count});return a},dispose:function(){this.dispatchEvent({type:"dispose"})}};THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);THREE.Camera=function(){THREE.Object3D.call(this);this.matrixWorldInverse=new THREE.Matrix4;this.projectionMatrix=new THREE.Matrix4;this.projectionMatrixInverse=new THREE.Matrix4};THREE.Camera.prototype=Object.create(THREE.Object3D.prototype);THREE.Camera.prototype.lookAt=function(){var a=new THREE.Matrix4;return function(b){a.lookAt(this.position,b,this.up);this.quaternion.setFromRotationMatrix(a)}}();
THREE.Camera.prototype.clone=function(a){void 0===a&&(a=new THREE.Camera);THREE.Object3D.prototype.clone.call(this,a);a.matrixWorldInverse.copy(this.matrixWorldInverse);a.projectionMatrix.copy(this.projectionMatrix);a.projectionMatrixInverse.copy(this.projectionMatrixInverse);return a};THREE.OrthographicCamera=function(a,b,c,d,e,f){THREE.Camera.call(this);this.left=a;this.right=b;this.top=c;this.bottom=d;this.near=void 0!==e?e:0.1;this.far=void 0!==f?f:2E3;this.updateProjectionMatrix()};THREE.OrthographicCamera.prototype=Object.create(THREE.Camera.prototype);THREE.OrthographicCamera.prototype.updateProjectionMatrix=function(){this.projectionMatrix.makeOrthographic(this.left,this.right,this.top,this.bottom,this.near,this.far)};
THREE.OrthographicCamera.prototype.clone=function(){var a=new THREE.OrthographicCamera;THREE.Camera.prototype.clone.call(this,a);a.left=this.left;a.right=this.right;a.top=this.top;a.bottom=this.bottom;a.near=this.near;a.far=this.far;return a};THREE.PerspectiveCamera=function(a,b,c,d){THREE.Camera.call(this);this.fov=void 0!==a?a:50;this.aspect=void 0!==b?b:1;this.near=void 0!==c?c:0.1;this.far=void 0!==d?d:2E3;this.updateProjectionMatrix()};THREE.PerspectiveCamera.prototype=Object.create(THREE.Camera.prototype);THREE.PerspectiveCamera.prototype.setLens=function(a,b){void 0===b&&(b=24);this.fov=2*THREE.Math.radToDeg(Math.atan(b/(2*a)));this.updateProjectionMatrix()};
THREE.PerspectiveCamera.prototype.setViewOffset=function(a,b,c,d,e,f){this.fullWidth=a;this.fullHeight=b;this.x=c;this.y=d;this.width=e;this.height=f;this.updateProjectionMatrix()};
THREE.PerspectiveCamera.prototype.updateProjectionMatrix=function(){if(this.fullWidth){var a=this.fullWidth/this.fullHeight,b=Math.tan(THREE.Math.degToRad(0.5*this.fov))*this.near,c=-b,d=a*c,a=Math.abs(a*b-d),c=Math.abs(b-c);this.projectionMatrix.makeFrustum(d+this.x*a/this.fullWidth,d+(this.x+this.width)*a/this.fullWidth,b-(this.y+this.height)*c/this.fullHeight,b-this.y*c/this.fullHeight,this.near,this.far)}else this.projectionMatrix.makePerspective(this.fov,this.aspect,this.near,this.far)};
THREE.PerspectiveCamera.prototype.clone=function(){var a=new THREE.PerspectiveCamera;THREE.Camera.prototype.clone.call(this,a);a.fov=this.fov;a.aspect=this.aspect;a.near=this.near;a.far=this.far;return a};THREE.Light=function(a){THREE.Object3D.call(this);this.color=new THREE.Color(a)};THREE.Light.prototype=Object.create(THREE.Object3D.prototype);THREE.Light.prototype.clone=function(a){void 0===a&&(a=new THREE.Light);THREE.Object3D.prototype.clone.call(this,a);a.color.copy(this.color);return a};THREE.AmbientLight=function(a){THREE.Light.call(this,a)};THREE.AmbientLight.prototype=Object.create(THREE.Light.prototype);THREE.AmbientLight.prototype.clone=function(){var a=new THREE.AmbientLight;THREE.Light.prototype.clone.call(this,a);return a};THREE.AreaLight=function(a,b){THREE.Light.call(this,a);this.normal=new THREE.Vector3(0,-1,0);this.right=new THREE.Vector3(1,0,0);this.intensity=void 0!==b?b:1;this.height=this.width=1;this.constantAttenuation=1.5;this.linearAttenuation=0.5;this.quadraticAttenuation=0.1};THREE.AreaLight.prototype=Object.create(THREE.Light.prototype);THREE.DirectionalLight=function(a,b){THREE.Light.call(this,a);this.position.set(0,1,0);this.target=new THREE.Object3D;this.intensity=void 0!==b?b:1;this.onlyShadow=this.castShadow=!1;this.shadowCameraNear=50;this.shadowCameraFar=5E3;this.shadowCameraLeft=-500;this.shadowCameraTop=this.shadowCameraRight=500;this.shadowCameraBottom=-500;this.shadowCameraVisible=!1;this.shadowBias=0;this.shadowDarkness=0.5;this.shadowMapHeight=this.shadowMapWidth=512;this.shadowCascade=!1;this.shadowCascadeOffset=new THREE.Vector3(0,
0,-1E3);this.shadowCascadeCount=2;this.shadowCascadeBias=[0,0,0];this.shadowCascadeWidth=[512,512,512];this.shadowCascadeHeight=[512,512,512];this.shadowCascadeNearZ=[-1,0.99,0.998];this.shadowCascadeFarZ=[0.99,0.998,1];this.shadowCascadeArray=[];this.shadowMatrix=this.shadowCamera=this.shadowMapSize=this.shadowMap=null};THREE.DirectionalLight.prototype=Object.create(THREE.Light.prototype);
THREE.DirectionalLight.prototype.clone=function(){var a=new THREE.DirectionalLight;THREE.Light.prototype.clone.call(this,a);a.target=this.target.clone();a.intensity=this.intensity;a.castShadow=this.castShadow;a.onlyShadow=this.onlyShadow;return a};THREE.HemisphereLight=function(a,b,c){THREE.Light.call(this,a);this.position.set(0,100,0);this.groundColor=new THREE.Color(b);this.intensity=void 0!==c?c:1};THREE.HemisphereLight.prototype=Object.create(THREE.Light.prototype);THREE.HemisphereLight.prototype.clone=function(){var a=new THREE.HemisphereLight;THREE.Light.prototype.clone.call(this,a);a.groundColor.copy(this.groundColor);a.intensity=this.intensity;return a};THREE.PointLight=function(a,b,c){THREE.Light.call(this,a);this.intensity=void 0!==b?b:1;this.distance=void 0!==c?c:0};THREE.PointLight.prototype=Object.create(THREE.Light.prototype);THREE.PointLight.prototype.clone=function(){var a=new THREE.PointLight;THREE.Light.prototype.clone.call(this,a);a.intensity=this.intensity;a.distance=this.distance;return a};THREE.SpotLight=function(a,b,c,d,e){THREE.Light.call(this,a);this.position.set(0,1,0);this.target=new THREE.Object3D;this.intensity=void 0!==b?b:1;this.distance=void 0!==c?c:0;this.angle=void 0!==d?d:Math.PI/3;this.exponent=void 0!==e?e:10;this.onlyShadow=this.castShadow=!1;this.shadowCameraNear=50;this.shadowCameraFar=5E3;this.shadowCameraFov=50;this.shadowCameraVisible=!1;this.shadowBias=0;this.shadowDarkness=0.5;this.shadowMapHeight=this.shadowMapWidth=512;this.shadowMatrix=this.shadowCamera=this.shadowMapSize=
this.shadowMap=null};THREE.SpotLight.prototype=Object.create(THREE.Light.prototype);THREE.SpotLight.prototype.clone=function(){var a=new THREE.SpotLight;THREE.Light.prototype.clone.call(this,a);a.target=this.target.clone();a.intensity=this.intensity;a.distance=this.distance;a.angle=this.angle;a.exponent=this.exponent;a.castShadow=this.castShadow;a.onlyShadow=this.onlyShadow;return a};THREE.Loader=function(a){this.statusDomElement=(this.showStatus=a)?THREE.Loader.prototype.addStatusElement():null;this.onLoadStart=function(){};this.onLoadProgress=function(){};this.onLoadComplete=function(){}};
THREE.Loader.prototype={constructor:THREE.Loader,crossOrigin:"anonymous",addStatusElement:function(){var a=document.createElement("div");a.style.position="absolute";a.style.right="0px";a.style.top="0px";a.style.fontSize="0.8em";a.style.textAlign="left";a.style.background="rgba(0,0,0,0.25)";a.style.color="#fff";a.style.width="120px";a.style.padding="0.5em 0.5em 0.5em 0.5em";a.style.zIndex=1E3;a.innerHTML="Loading ...";return a},updateProgress:function(a){var b="Loaded ",b=a.total?b+((100*a.loaded/
a.total).toFixed(0)+"%"):b+((a.loaded/1E3).toFixed(2)+" KB");this.statusDomElement.innerHTML=b},extractUrlBase:function(a){a=a.split("/");a.pop();return(1>a.length?".":a.join("/"))+"/"},initMaterials:function(a,b){for(var c=[],d=0;d<a.length;++d)c[d]=THREE.Loader.prototype.createMaterial(a[d],b);return c},needsTangents:function(a){for(var b=0,c=a.length;b<c;b++)if(a[b]instanceof THREE.ShaderMaterial)return!0;return!1},createMaterial:function(a,b){function c(a){a=Math.log(a)/Math.LN2;return Math.floor(a)==
a}function d(a){a=Math.log(a)/Math.LN2;return Math.pow(2,Math.round(a))}function e(a,e,f,g,i,k,r){var q=/\.dds$/i.test(f),u=b+"/"+f;if(q){var w=THREE.ImageUtils.loadCompressedTexture(u);a[e]=w}else w=document.createElement("canvas"),a[e]=new THREE.Texture(w);a[e].sourceFile=f;g&&(a[e].repeat.set(g[0],g[1]),1!==g[0]&&(a[e].wrapS=THREE.RepeatWrapping),1!==g[1]&&(a[e].wrapT=THREE.RepeatWrapping));i&&a[e].offset.set(i[0],i[1]);k&&(f={repeat:THREE.RepeatWrapping,mirror:THREE.MirroredRepeatWrapping},void 0!==
f[k[0]]&&(a[e].wrapS=f[k[0]]),void 0!==f[k[1]]&&(a[e].wrapT=f[k[1]]));r&&(a[e].anisotropy=r);if(!q){var z=a[e],a=new Image;a.onload=function(){if(!c(this.width)||!c(this.height)){var a=d(this.width),b=d(this.height);z.image.width=a;z.image.height=b;z.image.getContext("2d").drawImage(this,0,0,a,b)}else z.image=this;z.needsUpdate=!0};a.crossOrigin=h.crossOrigin;a.src=u}}function f(a){return(255*a[0]<<16)+(255*a[1]<<8)+255*a[2]}var h=this,g="MeshLambertMaterial",i={color:15658734,opacity:1,map:null,
lightMap:null,normalMap:null,bumpMap:null,wireframe:!1};if(a.shading){var k=a.shading.toLowerCase();"phong"===k?g="MeshPhongMaterial":"basic"===k&&(g="MeshBasicMaterial")}void 0!==a.blending&&void 0!==THREE[a.blending]&&(i.blending=THREE[a.blending]);if(void 0!==a.transparent||1>a.opacity)i.transparent=a.transparent;void 0!==a.depthTest&&(i.depthTest=a.depthTest);void 0!==a.depthWrite&&(i.depthWrite=a.depthWrite);void 0!==a.visible&&(i.visible=a.visible);void 0!==a.flipSided&&(i.side=THREE.BackSide);
void 0!==a.doubleSided&&(i.side=THREE.DoubleSide);void 0!==a.wireframe&&(i.wireframe=a.wireframe);void 0!==a.vertexColors&&("face"===a.vertexColors?i.vertexColors=THREE.FaceColors:a.vertexColors&&(i.vertexColors=THREE.VertexColors));a.colorDiffuse?i.color=f(a.colorDiffuse):a.DbgColor&&(i.color=a.DbgColor);a.colorSpecular&&(i.specular=f(a.colorSpecular));a.colorAmbient&&(i.ambient=f(a.colorAmbient));a.transparency&&(i.opacity=a.transparency);a.specularCoef&&(i.shininess=a.specularCoef);a.mapDiffuse&&
b&&e(i,"map",a.mapDiffuse,a.mapDiffuseRepeat,a.mapDiffuseOffset,a.mapDiffuseWrap,a.mapDiffuseAnisotropy);a.mapLight&&b&&e(i,"lightMap",a.mapLight,a.mapLightRepeat,a.mapLightOffset,a.mapLightWrap,a.mapLightAnisotropy);a.mapBump&&b&&e(i,"bumpMap",a.mapBump,a.mapBumpRepeat,a.mapBumpOffset,a.mapBumpWrap,a.mapBumpAnisotropy);a.mapNormal&&b&&e(i,"normalMap",a.mapNormal,a.mapNormalRepeat,a.mapNormalOffset,a.mapNormalWrap,a.mapNormalAnisotropy);a.mapSpecular&&b&&e(i,"specularMap",a.mapSpecular,a.mapSpecularRepeat,
a.mapSpecularOffset,a.mapSpecularWrap,a.mapSpecularAnisotropy);a.mapBumpScale&&(i.bumpScale=a.mapBumpScale);a.mapNormal?(g=THREE.ShaderLib.normalmap,k=THREE.UniformsUtils.clone(g.uniforms),k.tNormal.value=i.normalMap,a.mapNormalFactor&&k.uNormalScale.value.set(a.mapNormalFactor,a.mapNormalFactor),i.map&&(k.tDiffuse.value=i.map,k.enableDiffuse.value=!0),i.specularMap&&(k.tSpecular.value=i.specularMap,k.enableSpecular.value=!0),i.lightMap&&(k.tAO.value=i.lightMap,k.enableAO.value=!0),k.uDiffuseColor.value.setHex(i.color),
k.uSpecularColor.value.setHex(i.specular),k.uAmbientColor.value.setHex(i.ambient),k.uShininess.value=i.shininess,void 0!==i.opacity&&(k.uOpacity.value=i.opacity),g=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:k,lights:!0,fog:!0}),i.transparent&&(g.transparent=!0)):g=new THREE[g](i);void 0!==a.DbgName&&(g.name=a.DbgName);return g}};THREE.XHRLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};
THREE.XHRLoader.prototype={constructor:THREE.XHRLoader,load:function(a,b,c,d){var e=this,f=new XMLHttpRequest;void 0!==b&&f.addEventListener("load",function(c){b(c.target.responseText);e.manager.itemEnd(a)},!1);void 0!==c&&f.addEventListener("progress",function(a){c(a)},!1);void 0!==d&&f.addEventListener("error",function(a){d(a)},!1);void 0!==this.crossOrigin&&(f.crossOrigin=this.crossOrigin);f.open("GET",a,!0);f.send(null);e.manager.itemStart(a)},setCrossOrigin:function(a){this.crossOrigin=a}};THREE.ImageLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};
THREE.ImageLoader.prototype={constructor:THREE.ImageLoader,load:function(a,b,c,d){var e=this,f=document.createElement("img");void 0!==b&&f.addEventListener("load",function(){e.manager.itemEnd(a);b(this)},!1);void 0!==c&&f.addEventListener("progress",function(a){c(a)},!1);void 0!==d&&f.addEventListener("error",function(a){d(a)},!1);void 0!==this.crossOrigin&&(f.crossOrigin=this.crossOrigin);f.src=a;e.manager.itemStart(a);return f},setCrossOrigin:function(a){this.crossOrigin=a}};THREE.JSONLoader=function(a){THREE.Loader.call(this,a);this.withCredentials=!1};THREE.JSONLoader.prototype=Object.create(THREE.Loader.prototype);THREE.JSONLoader.prototype.load=function(a,b,c){c=c&&"string"===typeof c?c:this.extractUrlBase(a);this.onLoadStart();this.loadAjaxJSON(this,a,b,c)};
THREE.JSONLoader.prototype.loadAjaxJSON=function(a,b,c,d,e){var f=new XMLHttpRequest,h=0;f.onreadystatechange=function(){if(f.readyState===f.DONE)if(200===f.status||0===f.status){if(f.responseText){var g=JSON.parse(f.responseText),g=a.parse(g,d);c(g.geometry,g.materials)}else console.warn("THREE.JSONLoader: ["+b+"] seems to be unreachable or file there is empty");a.onLoadComplete()}else console.error("THREE.JSONLoader: Couldn't load ["+b+"] ["+f.status+"]");else f.readyState===f.LOADING?e&&(0===h&&
(h=f.getResponseHeader("Content-Length")),e({total:h,loaded:f.responseText.length})):f.readyState===f.HEADERS_RECEIVED&&void 0!==e&&(h=f.getResponseHeader("Content-Length"))};f.open("GET",b,!0);f.withCredentials=this.withCredentials;f.send(null)};
THREE.JSONLoader.prototype.parse=function(a,b){var c=new THREE.Geometry,d=void 0!==a.scale?1/a.scale:1,e,f,h,g,i,k,m,l,p,s,t,n,r,q,u=a.faces;p=a.vertices;var w=a.normals,z=a.colors,B=0;if(void 0!==a.uvs){for(e=0;e<a.uvs.length;e++)a.uvs[e].length&&B++;for(e=0;e<B;e++)c.faceVertexUvs[e]=[]}g=0;for(i=p.length;g<i;)k=new THREE.Vector3,k.x=p[g++]*d,k.y=p[g++]*d,k.z=p[g++]*d,c.vertices.push(k);g=0;for(i=u.length;g<i;)if(p=u[g++],s=p&1,h=p&2,e=p&8,m=p&16,t=p&32,k=p&64,p&=128,s){s=new THREE.Face3;s.a=u[g];
s.b=u[g+1];s.c=u[g+3];n=new THREE.Face3;n.a=u[g+1];n.b=u[g+2];n.c=u[g+3];g+=4;h&&(h=u[g++],s.materialIndex=h,n.materialIndex=h);h=c.faces.length;if(e)for(e=0;e<B;e++){r=a.uvs[e];c.faceVertexUvs[e][h]=[];c.faceVertexUvs[e][h+1]=[];for(f=0;4>f;f++)l=u[g++],q=r[2*l],l=r[2*l+1],q=new THREE.Vector2(q,l),2!==f&&c.faceVertexUvs[e][h].push(q),0!==f&&c.faceVertexUvs[e][h+1].push(q)}m&&(m=3*u[g++],s.normal.set(w[m++],w[m++],w[m]),n.normal.copy(s.normal));if(t)for(e=0;4>e;e++)m=3*u[g++],t=new THREE.Vector3(w[m++],
w[m++],w[m]),2!==e&&s.vertexNormals.push(t),0!==e&&n.vertexNormals.push(t);k&&(k=u[g++],k=z[k],s.color.setHex(k),n.color.setHex(k));if(p)for(e=0;4>e;e++)k=u[g++],k=z[k],2!==e&&s.vertexColors.push(new THREE.Color(k)),0!==e&&n.vertexColors.push(new THREE.Color(k));c.faces.push(s);c.faces.push(n)}else{s=new THREE.Face3;s.a=u[g++];s.b=u[g++];s.c=u[g++];h&&(h=u[g++],s.materialIndex=h);h=c.faces.length;if(e)for(e=0;e<B;e++){r=a.uvs[e];c.faceVertexUvs[e][h]=[];for(f=0;3>f;f++)l=u[g++],q=r[2*l],l=r[2*l+1],
q=new THREE.Vector2(q,l),c.faceVertexUvs[e][h].push(q)}m&&(m=3*u[g++],s.normal.set(w[m++],w[m++],w[m]));if(t)for(e=0;3>e;e++)m=3*u[g++],t=new THREE.Vector3(w[m++],w[m++],w[m]),s.vertexNormals.push(t);k&&(k=u[g++],s.color.setHex(z[k]));if(p)for(e=0;3>e;e++)k=u[g++],s.vertexColors.push(new THREE.Color(z[k]));c.faces.push(s)}if(a.skinWeights){g=0;for(i=a.skinWeights.length;g<i;g+=2)u=a.skinWeights[g],w=a.skinWeights[g+1],c.skinWeights.push(new THREE.Vector4(u,w,0,0))}if(a.skinIndices){g=0;for(i=a.skinIndices.length;g<
i;g+=2)u=a.skinIndices[g],w=a.skinIndices[g+1],c.skinIndices.push(new THREE.Vector4(u,w,0,0))}c.bones=a.bones;c.animation=a.animation;c.animations=a.animations;if(void 0!==a.morphTargets){g=0;for(i=a.morphTargets.length;g<i;g++){c.morphTargets[g]={};c.morphTargets[g].name=a.morphTargets[g].name;c.morphTargets[g].vertices=[];z=c.morphTargets[g].vertices;B=a.morphTargets[g].vertices;u=0;for(w=B.length;u<w;u+=3)p=new THREE.Vector3,p.x=B[u]*d,p.y=B[u+1]*d,p.z=B[u+2]*d,z.push(p)}}if(void 0!==a.morphColors){g=
0;for(i=a.morphColors.length;g<i;g++){c.morphColors[g]={};c.morphColors[g].name=a.morphColors[g].name;c.morphColors[g].colors=[];w=c.morphColors[g].colors;z=a.morphColors[g].colors;d=0;for(u=z.length;d<u;d+=3)B=new THREE.Color(16755200),B.setRGB(z[d],z[d+1],z[d+2]),w.push(B)}}c.computeCentroids();c.computeFaceNormals();c.computeBoundingSphere();if(void 0===a.materials)return{geometry:c};d=this.initMaterials(a.materials,b);this.needsTangents(d)&&c.computeTangents();return{geometry:c,materials:d}};THREE.LoadingManager=function(a,b,c){var d=this,e=0,f=0;this.onLoad=a;this.onProgress=b;this.onError=c;this.itemStart=function(){f++};this.itemEnd=function(a){e++;if(void 0!==d.onProgress)d.onProgress(a,e,f);if(e===f&&void 0!==d.onLoad)d.onLoad()}};THREE.DefaultLoadingManager=new THREE.LoadingManager;THREE.BufferGeometryLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};
THREE.BufferGeometryLoader.prototype={constructor:THREE.BufferGeometryLoader,load:function(a,b){var c=this,d=new THREE.XHRLoader;d.setCrossOrigin(this.crossOrigin);d.load(a,function(a){b(c.parse(JSON.parse(a)))})},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(a){var b=new THREE.BufferGeometry,c=a.attributes,d=a.offsets,a=a.boundingSphere,e;for(e in c){var f=c[e];b.attributes[e]={itemSize:f.itemSize,array:new self[f.type](f.array)}}void 0!==d&&(b.offsets=JSON.parse(JSON.stringify(d)));
void 0!==a&&(b.boundingSphere=new THREE.Sphere((new THREE.Vector3).fromArray(void 0!==a.center?a.center:[0,0,0]),a.radius));return b}};THREE.GeometryLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};THREE.GeometryLoader.prototype={constructor:THREE.GeometryLoader,load:function(a,b){var c=this,d=new THREE.XHRLoader;d.setCrossOrigin(this.crossOrigin);d.load(a,function(a){b(c.parse(JSON.parse(a)))})},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(){}};THREE.MaterialLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};
THREE.MaterialLoader.prototype={constructor:THREE.MaterialLoader,load:function(a,b){var c=this,d=new THREE.XHRLoader;d.setCrossOrigin(this.crossOrigin);d.load(a,function(a){b(c.parse(JSON.parse(a)))})},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(a){var b=new THREE[a.type];void 0!==a.color&&b.color.setHex(a.color);void 0!==a.ambient&&b.ambient.setHex(a.ambient);void 0!==a.emissive&&b.emissive.setHex(a.emissive);void 0!==a.specular&&b.specular.setHex(a.specular);void 0!==a.shininess&&
(b.shininess=a.shininess);void 0!==a.vertexColors&&(b.vertexColors=a.vertexColors);void 0!==a.blending&&(b.blending=a.blending);void 0!==a.opacity&&(b.opacity=a.opacity);void 0!==a.transparent&&(b.transparent=a.transparent);void 0!==a.wireframe&&(b.wireframe=a.wireframe);if(void 0!==a.materials)for(var c=0,d=a.materials.length;c<d;c++)b.materials.push(this.parse(a.materials[c]));return b}};THREE.ObjectLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};
THREE.ObjectLoader.prototype={constructor:THREE.ObjectLoader,load:function(a,b){var c=this,d=new THREE.XHRLoader(c.manager);d.setCrossOrigin(this.crossOrigin);d.load(a,function(a){b(c.parse(JSON.parse(a)))})},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(a){var b=this.parseGeometries(a.geometries),c=this.parseMaterials(a.materials);return this.parseObject(a.object,b,c)},parseGeometries:function(a){var b={};if(void 0!==a)for(var c=new THREE.JSONLoader,d=new THREE.BufferGeometryLoader,
e=0,f=a.length;e<f;e++){var h,g=a[e];switch(g.type){case "PlaneGeometry":h=new THREE.PlaneGeometry(g.width,g.height,g.widthSegments,g.heightSegments);break;case "CircleGeometry":h=new THREE.CircleGeometry(g.radius,g.segments);break;case "CubeGeometry":h=new THREE.CubeGeometry(g.width,g.height,g.depth,g.widthSegments,g.heightSegments,g.depthSegments);break;case "CylinderGeometry":h=new THREE.CylinderGeometry(g.radiusTop,g.radiusBottom,g.height,g.radiusSegments,g.heightSegments,g.openEnded);break;case "SphereGeometry":h=
new THREE.SphereGeometry(g.radius,g.widthSegments,g.heightSegments,g.phiStart,g.phiLength,g.thetaStart,g.thetaLength);break;case "IcosahedronGeometry":h=new THREE.IcosahedronGeometry(g.radius,g.detail);break;case "TorusGeometry":h=new THREE.TorusGeometry(g.radius,g.tube,g.radialSegments,g.tubularSegments,g.arc);break;case "TorusKnotGeometry":h=new THREE.TorusKnotGeometry(g.radius,g.tube,g.radialSegments,g.tubularSegments,g.p,g.q,g.heightScale);break;case "BufferGeometry":h=d.parse(g.data);break;case "Geometry":h=
c.parse(g.data).geometry}h.uuid=g.uuid;void 0!==g.name&&(h.name=g.name);b[g.uuid]=h}return b},parseMaterials:function(a){var b={};if(void 0!==a)for(var c=new THREE.MaterialLoader,d=0,e=a.length;d<e;d++){var f=a[d],h=c.parse(f);h.uuid=f.uuid;void 0!==f.name&&(h.name=f.name);b[f.uuid]=h}return b},parseObject:function(){var a=new THREE.Matrix4;return function(b,c,d){var e;switch(b.type){case "Scene":e=new THREE.Scene;break;case "PerspectiveCamera":e=new THREE.PerspectiveCamera(b.fov,b.aspect,b.near,
b.far);break;case "OrthographicCamera":e=new THREE.OrthographicCamera(b.left,b.right,b.top,b.bottom,b.near,b.far);break;case "AmbientLight":e=new THREE.AmbientLight(b.color);break;case "DirectionalLight":e=new THREE.DirectionalLight(b.color,b.intensity);break;case "PointLight":e=new THREE.PointLight(b.color,b.intensity,b.distance);break;case "SpotLight":e=new THREE.SpotLight(b.color,b.intensity,b.distance,b.angle,b.exponent);break;case "HemisphereLight":e=new THREE.HemisphereLight(b.color,b.groundColor,
b.intensity);break;case "Mesh":e=c[b.geometry];var f=d[b.material];void 0===e&&console.error("THREE.ObjectLoader: Undefined geometry "+b.geometry);void 0===f&&console.error("THREE.ObjectLoader: Undefined material "+b.material);e=new THREE.Mesh(e,f);break;default:e=new THREE.Object3D}e.uuid=b.uuid;void 0!==b.name&&(e.name=b.name);void 0!==b.matrix?(a.fromArray(b.matrix),a.decompose(e.position,e.quaternion,e.scale)):(void 0!==b.position&&e.position.fromArray(b.position),void 0!==b.rotation&&e.rotation.fromArray(b.rotation),
void 0!==b.scale&&e.scale.fromArray(b.scale));void 0!==b.visible&&(e.visible=b.visible);void 0!==b.userData&&(e.userData=b.userData);if(void 0!==b.children)for(var h in b.children)e.add(this.parseObject(b.children[h],c,d));return e}}()};THREE.SceneLoader=function(){this.onLoadStart=function(){};this.onLoadProgress=function(){};this.onLoadComplete=function(){};this.callbackSync=function(){};this.callbackProgress=function(){};this.geometryHandlers={};this.hierarchyHandlers={};this.addGeometryHandler("ascii",THREE.JSONLoader)};
THREE.SceneLoader.prototype={constructor:THREE.SceneLoader,load:function(a,b){var c=this,d=new THREE.XHRLoader(c.manager);d.setCrossOrigin(this.crossOrigin);d.load(a,function(d){c.parse(JSON.parse(d),b,a)})},setCrossOrigin:function(a){this.crossOrigin=a},addGeometryHandler:function(a,b){this.geometryHandlers[a]={loaderClass:b}},addHierarchyHandler:function(a,b){this.hierarchyHandlers[a]={loaderClass:b}},parse:function(a,b,c){function d(a,b){return"relativeToHTML"==b?a:p+"/"+a}function e(){f(A.scene,
C.objects)}function f(a,b){var c,e,h,i,k,m,p;for(p in b){var r=A.objects[p],q=b[p];if(void 0===r){if(q.type&&q.type in l.hierarchyHandlers){if(void 0===q.loading){e={type:1,url:1,material:1,position:1,rotation:1,scale:1,visible:1,children:1,userData:1,skin:1,morph:1,mirroredLoop:1,duration:1};h={};for(var B in q)B in e||(h[B]=q[B]);t=A.materials[q.material];q.loading=!0;e=l.hierarchyHandlers[q.type].loaderObject;e.options?e.load(d(q.url,C.urlBaseType),g(p,a,t,q)):e.load(d(q.url,C.urlBaseType),g(p,
a,t,q),h)}}else if(void 0!==q.geometry){if(s=A.geometries[q.geometry]){r=!1;t=A.materials[q.material];r=t instanceof THREE.ShaderMaterial;h=q.position;i=q.rotation;k=q.scale;c=q.matrix;m=q.quaternion;q.material||(t=new THREE.MeshFaceMaterial(A.face_materials[q.geometry]));t instanceof THREE.MeshFaceMaterial&&0===t.materials.length&&(t=new THREE.MeshFaceMaterial(A.face_materials[q.geometry]));if(t instanceof THREE.MeshFaceMaterial)for(e=0;e<t.materials.length;e++)r=r||t.materials[e]instanceof THREE.ShaderMaterial;
r&&s.computeTangents();q.skin?r=new THREE.SkinnedMesh(s,t):q.morph?(r=new THREE.MorphAnimMesh(s,t),void 0!==q.duration&&(r.duration=q.duration),void 0!==q.time&&(r.time=q.time),void 0!==q.mirroredLoop&&(r.mirroredLoop=q.mirroredLoop),t.morphNormals&&s.computeMorphNormals()):r=new THREE.Mesh(s,t);r.name=p;c?(r.matrixAutoUpdate=!1,r.matrix.set(c[0],c[1],c[2],c[3],c[4],c[5],c[6],c[7],c[8],c[9],c[10],c[11],c[12],c[13],c[14],c[15])):(r.position.fromArray(h),m?r.quaternion.fromArray(m):r.rotation.fromArray(i),
r.scale.fromArray(k));r.visible=q.visible;r.castShadow=q.castShadow;r.receiveShadow=q.receiveShadow;a.add(r);A.objects[p]=r}}else"DirectionalLight"===q.type||"PointLight"===q.type||"AmbientLight"===q.type?(w=void 0!==q.color?q.color:16777215,z=void 0!==q.intensity?q.intensity:1,"DirectionalLight"===q.type?(h=q.direction,u=new THREE.DirectionalLight(w,z),u.position.fromArray(h),q.target&&(O.push({object:u,targetName:q.target}),u.target=null)):"PointLight"===q.type?(h=q.position,e=q.distance,u=new THREE.PointLight(w,
z,e),u.position.fromArray(h)):"AmbientLight"===q.type&&(u=new THREE.AmbientLight(w)),a.add(u),u.name=p,A.lights[p]=u,A.objects[p]=u):"PerspectiveCamera"===q.type||"OrthographicCamera"===q.type?(h=q.position,i=q.rotation,m=q.quaternion,"PerspectiveCamera"===q.type?n=new THREE.PerspectiveCamera(q.fov,q.aspect,q.near,q.far):"OrthographicCamera"===q.type&&(n=new THREE.OrthographicCamera(q.left,q.right,q.top,q.bottom,q.near,q.far)),n.name=p,n.position.fromArray(h),void 0!==m?n.quaternion.fromArray(m):
void 0!==i&&n.rotation.fromArray(i),a.add(n),A.cameras[p]=n,A.objects[p]=n):(h=q.position,i=q.rotation,k=q.scale,m=q.quaternion,r=new THREE.Object3D,r.name=p,r.position.fromArray(h),m?r.quaternion.fromArray(m):r.rotation.fromArray(i),r.scale.fromArray(k),r.visible=void 0!==q.visible?q.visible:!1,a.add(r),A.objects[p]=r,A.empties[p]=r);if(r){if(void 0!==q.userData)for(var D in q.userData)r.userData[D]=q.userData[D];if(void 0!==q.groups)for(e=0;e<q.groups.length;e++)h=q.groups[e],void 0===A.groups[h]&&
(A.groups[h]=[]),A.groups[h].push(p)}}void 0!==r&&void 0!==q.children&&f(r,q.children)}}function h(a){return function(b,c){b.name=a;A.geometries[a]=b;A.face_materials[a]=c;e();B-=1;l.onLoadComplete();k()}}function g(a,b,c,d){return function(f){var f=f.content?f.content:f.dae?f.scene:f,h=d.rotation,g=d.quaternion,i=d.scale;f.position.fromArray(d.position);g?f.quaternion.fromArray(g):f.rotation.fromArray(h);f.scale.fromArray(i);c&&f.traverse(function(a){a.material=c});var m=void 0!==d.visible?d.visible:
!0;f.traverse(function(a){a.visible=m});b.add(f);f.name=a;A.objects[a]=f;e();B-=1;l.onLoadComplete();k()}}function i(a){return function(b,c){b.name=a;A.geometries[a]=b;A.face_materials[a]=c}}function k(){l.callbackProgress({totalModels:x,totalTextures:F,loadedModels:x-B,loadedTextures:F-D},A);l.onLoadProgress();if(0===B&&0===D){for(var a=0;a<O.length;a++){var c=O[a],d=A.objects[c.targetName];d?c.object.target=d:(c.object.target=new THREE.Object3D,A.scene.add(c.object.target));c.object.target.userData.targetInverse=
c.object}b(A)}}function m(a,b){b(a);if(void 0!==a.children)for(var c in a.children)m(a.children[c],b)}var l=this,p=THREE.Loader.prototype.extractUrlBase(c),s,t,n,r,q,u,w,z,B,D,x,F,A,O=[],C=a,E;for(E in this.geometryHandlers)a=this.geometryHandlers[E].loaderClass,this.geometryHandlers[E].loaderObject=new a;for(E in this.hierarchyHandlers)a=this.hierarchyHandlers[E].loaderClass,this.hierarchyHandlers[E].loaderObject=new a;D=B=0;A={scene:new THREE.Scene,geometries:{},face_materials:{},materials:{},textures:{},
objects:{},cameras:{},lights:{},fogs:{},empties:{},groups:{}};if(C.transform&&(E=C.transform.position,a=C.transform.rotation,c=C.transform.scale,E&&A.scene.position.fromArray(E),a&&A.scene.rotation.fromArray(a),c&&A.scene.scale.fromArray(c),E||a||c))A.scene.updateMatrix(),A.scene.updateMatrixWorld();E=function(a){return function(){D-=a;k();l.onLoadComplete()}};for(var I in C.fogs)a=C.fogs[I],"linear"===a.type?r=new THREE.Fog(0,a.near,a.far):"exp2"===a.type&&(r=new THREE.FogExp2(0,a.density)),a=a.color,
r.color.setRGB(a[0],a[1],a[2]),A.fogs[I]=r;for(var y in C.geometries)r=C.geometries[y],r.type in this.geometryHandlers&&(B+=1,l.onLoadStart());for(var v in C.objects)m(C.objects[v],function(a){a.type&&a.type in l.hierarchyHandlers&&(B+=1,l.onLoadStart())});x=B;for(y in C.geometries)if(r=C.geometries[y],"cube"===r.type)s=new THREE.CubeGeometry(r.width,r.height,r.depth,r.widthSegments,r.heightSegments,r.depthSegments),s.name=y,A.geometries[y]=s;else if("plane"===r.type)s=new THREE.PlaneGeometry(r.width,
r.height,r.widthSegments,r.heightSegments),s.name=y,A.geometries[y]=s;else if("sphere"===r.type)s=new THREE.SphereGeometry(r.radius,r.widthSegments,r.heightSegments),s.name=y,A.geometries[y]=s;else if("cylinder"===r.type)s=new THREE.CylinderGeometry(r.topRad,r.botRad,r.height,r.radSegs,r.heightSegs),s.name=y,A.geometries[y]=s;else if("torus"===r.type)s=new THREE.TorusGeometry(r.radius,r.tube,r.segmentsR,r.segmentsT),s.name=y,A.geometries[y]=s;else if("icosahedron"===r.type)s=new THREE.IcosahedronGeometry(r.radius,
r.subdivisions),s.name=y,A.geometries[y]=s;else if(r.type in this.geometryHandlers){v={};for(q in r)"type"!==q&&"url"!==q&&(v[q]=r[q]);this.geometryHandlers[r.type].loaderObject.load(d(r.url,C.urlBaseType),h(y),v)}else"embedded"===r.type&&(v=C.embeds[r.id],v.metadata=C.metadata,v&&(v=this.geometryHandlers.ascii.loaderObject.parse(v,""),i(y)(v.geometry,v.materials)));for(var G in C.textures)if(y=C.textures[G],y.url instanceof Array){D+=y.url.length;for(q=0;q<y.url.length;q++)l.onLoadStart()}else D+=
1,l.onLoadStart();F=D;for(G in C.textures){y=C.textures[G];void 0!==y.mapping&&void 0!==THREE[y.mapping]&&(y.mapping=new THREE[y.mapping]);if(y.url instanceof Array){v=y.url.length;r=[];for(q=0;q<v;q++)r[q]=d(y.url[q],C.urlBaseType);q=(q=/\.dds$/i.test(r[0]))?THREE.ImageUtils.loadCompressedTextureCube(r,y.mapping,E(v)):THREE.ImageUtils.loadTextureCube(r,y.mapping,E(v))}else q=/\.dds$/i.test(y.url),v=d(y.url,C.urlBaseType),r=E(1),q=q?THREE.ImageUtils.loadCompressedTexture(v,y.mapping,r):THREE.ImageUtils.loadTexture(v,
y.mapping,r),void 0!==THREE[y.minFilter]&&(q.minFilter=THREE[y.minFilter]),void 0!==THREE[y.magFilter]&&(q.magFilter=THREE[y.magFilter]),y.anisotropy&&(q.anisotropy=y.anisotropy),y.repeat&&(q.repeat.set(y.repeat[0],y.repeat[1]),1!==y.repeat[0]&&(q.wrapS=THREE.RepeatWrapping),1!==y.repeat[1]&&(q.wrapT=THREE.RepeatWrapping)),y.offset&&q.offset.set(y.offset[0],y.offset[1]),y.wrap&&(v={repeat:THREE.RepeatWrapping,mirror:THREE.MirroredRepeatWrapping},void 0!==v[y.wrap[0]]&&(q.wrapS=v[y.wrap[0]]),void 0!==
v[y.wrap[1]]&&(q.wrapT=v[y.wrap[1]]));A.textures[G]=q}var R,J;for(R in C.materials){G=C.materials[R];for(J in G.parameters)"envMap"===J||"map"===J||"lightMap"===J||"bumpMap"===J?G.parameters[J]=A.textures[G.parameters[J]]:"shading"===J?G.parameters[J]="flat"===G.parameters[J]?THREE.FlatShading:THREE.SmoothShading:"side"===J?G.parameters[J]="double"==G.parameters[J]?THREE.DoubleSide:"back"==G.parameters[J]?THREE.BackSide:THREE.FrontSide:"blending"===J?G.parameters[J]=G.parameters[J]in THREE?THREE[G.parameters[J]]:
THREE.NormalBlending:"combine"===J?G.parameters[J]=G.parameters[J]in THREE?THREE[G.parameters[J]]:THREE.MultiplyOperation:"vertexColors"===J?"face"==G.parameters[J]?G.parameters[J]=THREE.FaceColors:G.parameters[J]&&(G.parameters[J]=THREE.VertexColors):"wrapRGB"===J&&(E=G.parameters[J],G.parameters[J]=new THREE.Vector3(E[0],E[1],E[2]));void 0!==G.parameters.opacity&&1>G.parameters.opacity&&(G.parameters.transparent=!0);G.parameters.normalMap?(E=THREE.ShaderLib.normalmap,y=THREE.UniformsUtils.clone(E.uniforms),
q=G.parameters.color,v=G.parameters.specular,r=G.parameters.ambient,I=G.parameters.shininess,y.tNormal.value=A.textures[G.parameters.normalMap],G.parameters.normalScale&&y.uNormalScale.value.set(G.parameters.normalScale[0],G.parameters.normalScale[1]),G.parameters.map&&(y.tDiffuse.value=G.parameters.map,y.enableDiffuse.value=!0),G.parameters.envMap&&(y.tCube.value=G.parameters.envMap,y.enableReflection.value=!0,y.uReflectivity.value=G.parameters.reflectivity),G.parameters.lightMap&&(y.tAO.value=G.parameters.lightMap,
y.enableAO.value=!0),G.parameters.specularMap&&(y.tSpecular.value=A.textures[G.parameters.specularMap],y.enableSpecular.value=!0),G.parameters.displacementMap&&(y.tDisplacement.value=A.textures[G.parameters.displacementMap],y.enableDisplacement.value=!0,y.uDisplacementBias.value=G.parameters.displacementBias,y.uDisplacementScale.value=G.parameters.displacementScale),y.uDiffuseColor.value.setHex(q),y.uSpecularColor.value.setHex(v),y.uAmbientColor.value.setHex(r),y.uShininess.value=I,G.parameters.opacity&&
(y.uOpacity.value=G.parameters.opacity),t=new THREE.ShaderMaterial({fragmentShader:E.fragmentShader,vertexShader:E.vertexShader,uniforms:y,lights:!0,fog:!0})):t=new THREE[G.type](G.parameters);t.name=R;A.materials[R]=t}for(R in C.materials)if(G=C.materials[R],G.parameters.materials){J=[];for(q=0;q<G.parameters.materials.length;q++)J.push(A.materials[G.parameters.materials[q]]);A.materials[R].materials=J}e();A.cameras&&C.defaults.camera&&(A.currentCamera=A.cameras[C.defaults.camera]);A.fogs&&C.defaults.fog&&
(A.scene.fog=A.fogs[C.defaults.fog]);l.callbackSync(A);k()}};THREE.TextureLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};THREE.TextureLoader.prototype={constructor:THREE.TextureLoader,load:function(a,b){var c=new THREE.ImageLoader(this.manager);c.setCrossOrigin(this.crossOrigin);c.load(a,function(a){a=new THREE.Texture(a);a.needsUpdate=!0;void 0!==b&&b(a)})},setCrossOrigin:function(a){this.crossOrigin=a}};THREE.Material=function(){this.id=THREE.MaterialIdCount++;this.uuid=THREE.Math.generateUUID();this.name="";this.side=THREE.FrontSide;this.opacity=1;this.transparent=!1;this.blending=THREE.NormalBlending;this.blendSrc=THREE.SrcAlphaFactor;this.blendDst=THREE.OneMinusSrcAlphaFactor;this.blendEquation=THREE.AddEquation;this.depthWrite=this.depthTest=!0;this.polygonOffset=!1;this.overdraw=this.alphaTest=this.polygonOffsetUnits=this.polygonOffsetFactor=0;this.needsUpdate=this.visible=!0};
THREE.Material.prototype={constructor:THREE.Material,setValues:function(a){if(void 0!==a)for(var b in a){var c=a[b];if(void 0===c)console.warn("THREE.Material: '"+b+"' parameter is undefined.");else if(b in this){var d=this[b];d instanceof THREE.Color?d.set(c):d instanceof THREE.Vector3&&c instanceof THREE.Vector3?d.copy(c):this[b]="overdraw"==b?Number(c):c}}},clone:function(a){void 0===a&&(a=new THREE.Material);a.name=this.name;a.side=this.side;a.opacity=this.opacity;a.transparent=this.transparent;
a.blending=this.blending;a.blendSrc=this.blendSrc;a.blendDst=this.blendDst;a.blendEquation=this.blendEquation;a.depthTest=this.depthTest;a.depthWrite=this.depthWrite;a.polygonOffset=this.polygonOffset;a.polygonOffsetFactor=this.polygonOffsetFactor;a.polygonOffsetUnits=this.polygonOffsetUnits;a.alphaTest=this.alphaTest;a.overdraw=this.overdraw;a.visible=this.visible;return a},dispose:function(){this.dispatchEvent({type:"dispose"})}};THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
THREE.MaterialIdCount=0;THREE.LineBasicMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.linewidth=1;this.linejoin=this.linecap="round";this.vertexColors=!1;this.fog=!0;this.setValues(a)};THREE.LineBasicMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.LineBasicMaterial.prototype.clone=function(){var a=new THREE.LineBasicMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.linewidth=this.linewidth;a.linecap=this.linecap;a.linejoin=this.linejoin;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};THREE.LineDashedMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.scale=this.linewidth=1;this.dashSize=3;this.gapSize=1;this.vertexColors=!1;this.fog=!0;this.setValues(a)};THREE.LineDashedMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.LineDashedMaterial.prototype.clone=function(){var a=new THREE.LineDashedMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.linewidth=this.linewidth;a.scale=this.scale;a.dashSize=this.dashSize;a.gapSize=this.gapSize;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};THREE.MeshBasicMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.envMap=this.specularMap=this.lightMap=this.map=null;this.combine=THREE.MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.vertexColors=THREE.NoColors;this.morphTargets=this.skinning=!1;this.setValues(a)};
THREE.MeshBasicMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.MeshBasicMaterial.prototype.clone=function(){var a=new THREE.MeshBasicMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.map=this.map;a.lightMap=this.lightMap;a.specularMap=this.specularMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=
this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;return a};THREE.MeshLambertMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.ambient=new THREE.Color(16777215);this.emissive=new THREE.Color(0);this.wrapAround=!1;this.wrapRGB=new THREE.Vector3(1,1,1);this.envMap=this.specularMap=this.lightMap=this.map=null;this.combine=THREE.MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap=
"round";this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)};THREE.MeshLambertMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.MeshLambertMaterial.prototype.clone=function(){var a=new THREE.MeshLambertMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.ambient.copy(this.ambient);a.emissive.copy(this.emissive);a.wrapAround=this.wrapAround;a.wrapRGB.copy(this.wrapRGB);a.map=this.map;a.lightMap=this.lightMap;a.specularMap=this.specularMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;
a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;a.morphNormals=this.morphNormals;return a};THREE.MeshPhongMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.ambient=new THREE.Color(16777215);this.emissive=new THREE.Color(0);this.specular=new THREE.Color(1118481);this.shininess=30;this.metal=!1;this.perPixel=!0;this.wrapAround=!1;this.wrapRGB=new THREE.Vector3(1,1,1);this.bumpMap=this.lightMap=this.map=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new THREE.Vector2(1,1);this.envMap=this.specularMap=null;this.combine=THREE.MultiplyOperation;
this.reflectivity=1;this.refractionRatio=0.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)};THREE.MeshPhongMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.MeshPhongMaterial.prototype.clone=function(){var a=new THREE.MeshPhongMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.ambient.copy(this.ambient);a.emissive.copy(this.emissive);a.specular.copy(this.specular);a.shininess=this.shininess;a.metal=this.metal;a.perPixel=this.perPixel;a.wrapAround=this.wrapAround;a.wrapRGB.copy(this.wrapRGB);a.map=this.map;a.lightMap=this.lightMap;a.bumpMap=this.bumpMap;a.bumpScale=this.bumpScale;a.normalMap=this.normalMap;a.normalScale.copy(this.normalScale);
a.specularMap=this.specularMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;a.morphNormals=this.morphNormals;return a};THREE.MeshDepthMaterial=function(a){THREE.Material.call(this);this.wireframe=!1;this.wireframeLinewidth=1;this.setValues(a)};THREE.MeshDepthMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshDepthMaterial.prototype.clone=function(){var a=new THREE.MeshDepthMaterial;THREE.Material.prototype.clone.call(this,a);a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;return a};THREE.MeshNormalMaterial=function(a){THREE.Material.call(this,a);this.shading=THREE.FlatShading;this.wireframe=!1;this.wireframeLinewidth=1;this.morphTargets=!1;this.setValues(a)};THREE.MeshNormalMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshNormalMaterial.prototype.clone=function(){var a=new THREE.MeshNormalMaterial;THREE.Material.prototype.clone.call(this,a);a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;return a};THREE.MeshFaceMaterial=function(a){this.materials=a instanceof Array?a:[]};THREE.MeshFaceMaterial.prototype.clone=function(){for(var a=new THREE.MeshFaceMaterial,b=0;b<this.materials.length;b++)a.materials.push(this.materials[b].clone());return a};THREE.ParticleSystemMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.map=null;this.size=1;this.sizeAttenuation=!0;this.vertexColors=!1;this.fog=!0;this.setValues(a)};THREE.ParticleSystemMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.ParticleSystemMaterial.prototype.clone=function(){var a=new THREE.ParticleSystemMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.map=this.map;a.size=this.size;a.sizeAttenuation=this.sizeAttenuation;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};THREE.ParticleBasicMaterial=THREE.ParticleSystemMaterial;THREE.ShaderMaterial=function(a){THREE.Material.call(this);this.vertexShader=this.fragmentShader="void main() {}";this.uniforms={};this.defines={};this.attributes=null;this.shading=THREE.SmoothShading;this.linewidth=1;this.wireframe=!1;this.wireframeLinewidth=1;this.lights=this.fog=!1;this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]};this.index0AttributeName="position";this.setValues(a)};
THREE.ShaderMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.ShaderMaterial.prototype.clone=function(){var a=new THREE.ShaderMaterial;THREE.Material.prototype.clone.call(this,a);a.fragmentShader=this.fragmentShader;a.vertexShader=this.vertexShader;a.uniforms=THREE.UniformsUtils.clone(this.uniforms);a.attributes=this.attributes;a.defines=this.defines;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.fog=this.fog;a.lights=this.lights;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=
this.morphTargets;a.morphNormals=this.morphNormals;return a};THREE.SpriteMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.map=new THREE.Texture;this.useScreenCoordinates=!0;this.depthTest=!this.useScreenCoordinates;this.sizeAttenuation=!this.useScreenCoordinates;this.alignment=THREE.SpriteAlignment.center.clone();this.fog=!1;this.uvOffset=new THREE.Vector2(0,0);this.uvScale=new THREE.Vector2(1,1);this.setValues(a);a=a||{};void 0===a.depthTest&&(this.depthTest=!this.useScreenCoordinates);void 0===a.sizeAttenuation&&(this.sizeAttenuation=
!this.useScreenCoordinates)};THREE.SpriteMaterial.prototype=Object.create(THREE.Material.prototype);THREE.SpriteMaterial.prototype.clone=function(){var a=new THREE.SpriteMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.map=this.map;a.useScreenCoordinates=this.useScreenCoordinates;a.sizeAttenuation=this.sizeAttenuation;a.alignment.copy(this.alignment);a.uvOffset.copy(this.uvOffset);a.uvScale.copy(this.uvScale);a.fog=this.fog;return a};THREE.SpriteAlignment={};
THREE.SpriteAlignment.topLeft=new THREE.Vector2(0.5,-0.5);THREE.SpriteAlignment.topCenter=new THREE.Vector2(0,-0.5);THREE.SpriteAlignment.topRight=new THREE.Vector2(-0.5,-0.5);THREE.SpriteAlignment.centerLeft=new THREE.Vector2(0.5,0);THREE.SpriteAlignment.center=new THREE.Vector2(0,0);THREE.SpriteAlignment.centerRight=new THREE.Vector2(-0.5,0);THREE.SpriteAlignment.bottomLeft=new THREE.Vector2(0.5,0.5);THREE.SpriteAlignment.bottomCenter=new THREE.Vector2(0,0.5);
THREE.SpriteAlignment.bottomRight=new THREE.Vector2(-0.5,0.5);THREE.SpriteCanvasMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.program=function(){};this.setValues(a)};THREE.SpriteCanvasMaterial.prototype=Object.create(THREE.Material.prototype);THREE.SpriteCanvasMaterial.prototype.clone=function(){var a=new THREE.SpriteCanvasMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.program=this.program;return a};THREE.ParticleCanvasMaterial=THREE.SpriteCanvasMaterial;THREE.Texture=function(a,b,c,d,e,f,h,g,i){this.id=THREE.TextureIdCount++;this.uuid=THREE.Math.generateUUID();this.name="";this.image=a;this.mipmaps=[];this.mapping=void 0!==b?b:new THREE.UVMapping;this.wrapS=void 0!==c?c:THREE.ClampToEdgeWrapping;this.wrapT=void 0!==d?d:THREE.ClampToEdgeWrapping;this.magFilter=void 0!==e?e:THREE.LinearFilter;this.minFilter=void 0!==f?f:THREE.LinearMipMapLinearFilter;this.anisotropy=void 0!==i?i:1;this.format=void 0!==h?h:THREE.RGBAFormat;this.type=void 0!==g?g:THREE.UnsignedByteType;
this.offset=new THREE.Vector2(0,0);this.repeat=new THREE.Vector2(1,1);this.generateMipmaps=!0;this.premultiplyAlpha=!1;this.flipY=!0;this.unpackAlignment=4;this.needsUpdate=!1;this.onUpdate=null};
THREE.Texture.prototype={constructor:THREE.Texture,clone:function(a){void 0===a&&(a=new THREE.Texture);a.image=this.image;a.mipmaps=this.mipmaps.slice(0);a.mapping=this.mapping;a.wrapS=this.wrapS;a.wrapT=this.wrapT;a.magFilter=this.magFilter;a.minFilter=this.minFilter;a.anisotropy=this.anisotropy;a.format=this.format;a.type=this.type;a.offset.copy(this.offset);a.repeat.copy(this.repeat);a.generateMipmaps=this.generateMipmaps;a.premultiplyAlpha=this.premultiplyAlpha;a.flipY=this.flipY;a.unpackAlignment=
this.unpackAlignment;return a},dispose:function(){this.dispatchEvent({type:"dispose"})}};THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);THREE.TextureIdCount=0;THREE.CompressedTexture=function(a,b,c,d,e,f,h,g,i,k,m){THREE.Texture.call(this,null,f,h,g,i,k,d,e,m);this.image={width:b,height:c};this.mipmaps=a;this.generateMipmaps=!1};THREE.CompressedTexture.prototype=Object.create(THREE.Texture.prototype);THREE.CompressedTexture.prototype.clone=function(){var a=new THREE.CompressedTexture;THREE.Texture.prototype.clone.call(this,a);return a};THREE.DataTexture=function(a,b,c,d,e,f,h,g,i,k,m){THREE.Texture.call(this,null,f,h,g,i,k,d,e,m);this.image={data:a,width:b,height:c}};THREE.DataTexture.prototype=Object.create(THREE.Texture.prototype);THREE.DataTexture.prototype.clone=function(){var a=new THREE.DataTexture;THREE.Texture.prototype.clone.call(this,a);return a};THREE.ParticleSystem=function(a,b){THREE.Object3D.call(this);this.geometry=void 0!==a?a:new THREE.Geometry;this.material=void 0!==b?b:new THREE.ParticleSystemMaterial({color:16777215*Math.random()});this.frustumCulled=this.sortParticles=!1};THREE.ParticleSystem.prototype=Object.create(THREE.Object3D.prototype);
THREE.ParticleSystem.prototype.clone=function(a){void 0===a&&(a=new THREE.ParticleSystem(this.geometry,this.material));a.sortParticles=this.sortParticles;THREE.Object3D.prototype.clone.call(this,a);return a};THREE.Line=function(a,b,c){THREE.Object3D.call(this);this.geometry=void 0!==a?a:new THREE.Geometry;this.material=void 0!==b?b:new THREE.LineBasicMaterial({color:16777215*Math.random()});this.type=void 0!==c?c:THREE.LineStrip};THREE.LineStrip=0;THREE.LinePieces=1;THREE.Line.prototype=Object.create(THREE.Object3D.prototype);THREE.Line.prototype.clone=function(a){void 0===a&&(a=new THREE.Line(this.geometry,this.material,this.type));THREE.Object3D.prototype.clone.call(this,a);return a};THREE.Mesh=function(a,b){THREE.Object3D.call(this);this.geometry=void 0!==a?a:new THREE.Geometry;this.material=void 0!==b?b:new THREE.MeshBasicMaterial({color:16777215*Math.random()});this.updateMorphTargets()};THREE.Mesh.prototype=Object.create(THREE.Object3D.prototype);
THREE.Mesh.prototype.updateMorphTargets=function(){if(0<this.geometry.morphTargets.length){this.morphTargetBase=-1;this.morphTargetForcedOrder=[];this.morphTargetInfluences=[];this.morphTargetDictionary={};for(var a=0,b=this.geometry.morphTargets.length;a<b;a++)this.morphTargetInfluences.push(0),this.morphTargetDictionary[this.geometry.morphTargets[a].name]=a}};
THREE.Mesh.prototype.getMorphTargetIndexByName=function(a){if(void 0!==this.morphTargetDictionary[a])return this.morphTargetDictionary[a];console.log("THREE.Mesh.getMorphTargetIndexByName: morph target "+a+" does not exist. Returning 0.");return 0};THREE.Mesh.prototype.clone=function(a){void 0===a&&(a=new THREE.Mesh(this.geometry,this.material));THREE.Object3D.prototype.clone.call(this,a);return a};THREE.Bone=function(a){THREE.Object3D.call(this);this.skin=a;this.skinMatrix=new THREE.Matrix4};THREE.Bone.prototype=Object.create(THREE.Object3D.prototype);THREE.Bone.prototype.update=function(a,b){this.matrixAutoUpdate&&(b|=this.updateMatrix());if(b||this.matrixWorldNeedsUpdate)a?this.skinMatrix.multiplyMatrices(a,this.matrix):this.skinMatrix.copy(this.matrix),this.matrixWorldNeedsUpdate=!1,b=!0;var c,d=this.children.length;for(c=0;c<d;c++)this.children[c].update(this.skinMatrix,b)};THREE.SkinnedMesh=function(a,b,c){THREE.Mesh.call(this,a,b);this.useVertexTexture=void 0!==c?c:!0;this.identityMatrix=new THREE.Matrix4;this.bones=[];this.boneMatrices=[];var d,e,f;if(this.geometry&&void 0!==this.geometry.bones){for(a=0;a<this.geometry.bones.length;a++)c=this.geometry.bones[a],d=c.pos,e=c.rotq,f=c.scl,b=this.addBone(),b.name=c.name,b.position.set(d[0],d[1],d[2]),b.quaternion.set(e[0],e[1],e[2],e[3]),void 0!==f?b.scale.set(f[0],f[1],f[2]):b.scale.set(1,1,1);for(a=0;a<this.bones.length;a++)c=
this.geometry.bones[a],b=this.bones[a],-1===c.parent?this.add(b):this.bones[c.parent].add(b);a=this.bones.length;this.useVertexTexture?(this.boneTextureHeight=this.boneTextureWidth=a=256<a?64:64<a?32:16<a?16:8,this.boneMatrices=new Float32Array(4*this.boneTextureWidth*this.boneTextureHeight),this.boneTexture=new THREE.DataTexture(this.boneMatrices,this.boneTextureWidth,this.boneTextureHeight,THREE.RGBAFormat,THREE.FloatType),this.boneTexture.minFilter=THREE.NearestFilter,this.boneTexture.magFilter=
THREE.NearestFilter,this.boneTexture.generateMipmaps=!1,this.boneTexture.flipY=!1):this.boneMatrices=new Float32Array(16*a);this.pose()}};THREE.SkinnedMesh.prototype=Object.create(THREE.Mesh.prototype);THREE.SkinnedMesh.prototype.addBone=function(a){void 0===a&&(a=new THREE.Bone(this));this.bones.push(a);return a};
THREE.SkinnedMesh.prototype.updateMatrixWorld=function(){var a=new THREE.Matrix4;return function(b){this.matrixAutoUpdate&&this.updateMatrix();if(this.matrixWorldNeedsUpdate||b)this.parent?this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix):this.matrixWorld.copy(this.matrix),this.matrixWorldNeedsUpdate=!1;for(var b=0,c=this.children.length;b<c;b++){var d=this.children[b];d instanceof THREE.Bone?d.update(this.identityMatrix,!1):d.updateMatrixWorld(!0)}if(void 0==this.boneInverses){this.boneInverses=
[];b=0;for(c=this.bones.length;b<c;b++)d=new THREE.Matrix4,d.getInverse(this.bones[b].skinMatrix),this.boneInverses.push(d)}b=0;for(c=this.bones.length;b<c;b++)a.multiplyMatrices(this.bones[b].skinMatrix,this.boneInverses[b]),a.flattenToArrayOffset(this.boneMatrices,16*b);this.useVertexTexture&&(this.boneTexture.needsUpdate=!0)}}();THREE.SkinnedMesh.prototype.pose=function(){this.updateMatrixWorld(!0);this.normalizeSkinWeights()};
THREE.SkinnedMesh.prototype.normalizeSkinWeights=function(){if(this.geometry instanceof THREE.Geometry)for(var a=0;a<this.geometry.skinIndices.length;a++){var b=this.geometry.skinWeights[a],c=1/b.lengthManhattan();Infinity!==c?b.multiplyScalar(c):b.set(1)}};THREE.SkinnedMesh.prototype.clone=function(a){void 0===a&&(a=new THREE.SkinnedMesh(this.geometry,this.material,this.useVertexTexture));THREE.Mesh.prototype.clone.call(this,a);return a};THREE.MorphAnimMesh=function(a,b){THREE.Mesh.call(this,a,b);this.duration=1E3;this.mirroredLoop=!1;this.currentKeyframe=this.lastKeyframe=this.time=0;this.direction=1;this.directionBackwards=!1;this.setFrameRange(0,this.geometry.morphTargets.length-1)};THREE.MorphAnimMesh.prototype=Object.create(THREE.Mesh.prototype);THREE.MorphAnimMesh.prototype.setFrameRange=function(a,b){this.startKeyframe=a;this.endKeyframe=b;this.length=this.endKeyframe-this.startKeyframe+1};
THREE.MorphAnimMesh.prototype.setDirectionForward=function(){this.direction=1;this.directionBackwards=!1};THREE.MorphAnimMesh.prototype.setDirectionBackward=function(){this.direction=-1;this.directionBackwards=!0};
THREE.MorphAnimMesh.prototype.parseAnimations=function(){var a=this.geometry;a.animations||(a.animations={});for(var b,c=a.animations,d=/([a-z]+)(\d+)/,e=0,f=a.morphTargets.length;e<f;e++){var h=a.morphTargets[e].name.match(d);if(h&&1<h.length){h=h[1];c[h]||(c[h]={start:Infinity,end:-Infinity});var g=c[h];e<g.start&&(g.start=e);e>g.end&&(g.end=e);b||(b=h)}}a.firstAnimation=b};
THREE.MorphAnimMesh.prototype.setAnimationLabel=function(a,b,c){this.geometry.animations||(this.geometry.animations={});this.geometry.animations[a]={start:b,end:c}};THREE.MorphAnimMesh.prototype.playAnimation=function(a,b){var c=this.geometry.animations[a];c?(this.setFrameRange(c.start,c.end),this.duration=1E3*((c.end-c.start)/b),this.time=0):console.warn("animation["+a+"] undefined")};
THREE.MorphAnimMesh.prototype.updateAnimation=function(a){var b=this.duration/this.length;this.time+=this.direction*a;if(this.mirroredLoop){if(this.time>this.duration||0>this.time)this.direction*=-1,this.time>this.duration&&(this.time=this.duration,this.directionBackwards=!0),0>this.time&&(this.time=0,this.directionBackwards=!1)}else this.time%=this.duration,0>this.time&&(this.time+=this.duration);a=this.startKeyframe+THREE.Math.clamp(Math.floor(this.time/b),0,this.length-1);a!==this.currentKeyframe&&
(this.morphTargetInfluences[this.lastKeyframe]=0,this.morphTargetInfluences[this.currentKeyframe]=1,this.morphTargetInfluences[a]=0,this.lastKeyframe=this.currentKeyframe,this.currentKeyframe=a);b=this.time%b/b;this.directionBackwards&&(b=1-b);this.morphTargetInfluences[this.currentKeyframe]=b;this.morphTargetInfluences[this.lastKeyframe]=1-b};
THREE.MorphAnimMesh.prototype.clone=function(a){void 0===a&&(a=new THREE.MorphAnimMesh(this.geometry,this.material));a.duration=this.duration;a.mirroredLoop=this.mirroredLoop;a.time=this.time;a.lastKeyframe=this.lastKeyframe;a.currentKeyframe=this.currentKeyframe;a.direction=this.direction;a.directionBackwards=this.directionBackwards;THREE.Mesh.prototype.clone.call(this,a);return a};THREE.LOD=function(){THREE.Object3D.call(this);this.objects=[]};THREE.LOD.prototype=Object.create(THREE.Object3D.prototype);THREE.LOD.prototype.addLevel=function(a,b){void 0===b&&(b=0);for(var b=Math.abs(b),c=0;c<this.objects.length&&!(b<this.objects[c].distance);c++);this.objects.splice(c,0,{distance:b,object:a});this.add(a)};THREE.LOD.prototype.getObjectForDistance=function(a){for(var b=1,c=this.objects.length;b<c&&!(a<this.objects[b].distance);b++);return this.objects[b-1].object};
THREE.LOD.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c){if(1<this.objects.length){a.getPositionFromMatrix(c.matrixWorld);b.getPositionFromMatrix(this.matrixWorld);c=a.distanceTo(b);this.objects[0].object.visible=!0;for(var d=1,e=this.objects.length;d<e;d++)if(c>=this.objects[d].distance)this.objects[d-1].object.visible=!1,this.objects[d].object.visible=!0;else break;for(;d<e;d++)this.objects[d].object.visible=!1}}}();THREE.LOD.prototype.clone=function(){};THREE.Sprite=function(a){THREE.Object3D.call(this);this.material=void 0!==a?a:new THREE.SpriteMaterial;this.rotation=0};THREE.Sprite.prototype=Object.create(THREE.Object3D.prototype);THREE.Sprite.prototype.updateMatrix=function(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=!0};THREE.Sprite.prototype.clone=function(a){void 0===a&&(a=new THREE.Sprite(this.material));THREE.Object3D.prototype.clone.call(this,a);return a};THREE.Particle=THREE.Sprite;THREE.Scene=function(){THREE.Object3D.call(this);this.overrideMaterial=this.fog=null;this.autoUpdate=!0;this.matrixAutoUpdate=!1;this.__lights=[];this.__objectsAdded=[];this.__objectsRemoved=[]};THREE.Scene.prototype=Object.create(THREE.Object3D.prototype);
THREE.Scene.prototype.__addObject=function(a){if(a instanceof THREE.Light)-1===this.__lights.indexOf(a)&&this.__lights.push(a),a.target&&void 0===a.target.parent&&this.add(a.target);else if(!(a instanceof THREE.Camera||a instanceof THREE.Bone)){this.__objectsAdded.push(a);var b=this.__objectsRemoved.indexOf(a);-1!==b&&this.__objectsRemoved.splice(b,1)}for(b=0;b<a.children.length;b++)this.__addObject(a.children[b])};
THREE.Scene.prototype.__removeObject=function(a){if(a instanceof THREE.Light){var b=this.__lights.indexOf(a);-1!==b&&this.__lights.splice(b,1);if(a.shadowCascadeArray)for(b=0;b<a.shadowCascadeArray.length;b++)this.__removeObject(a.shadowCascadeArray[b])}else a instanceof THREE.Camera||(this.__objectsRemoved.push(a),b=this.__objectsAdded.indexOf(a),-1!==b&&this.__objectsAdded.splice(b,1));for(b=0;b<a.children.length;b++)this.__removeObject(a.children[b])};
THREE.Scene.prototype.clone=function(a){void 0===a&&(a=new THREE.Scene);THREE.Object3D.prototype.clone.call(this,a);null!==this.fog&&(a.fog=this.fog.clone());null!==this.overrideMaterial&&(a.overrideMaterial=this.overrideMaterial.clone());a.autoUpdate=this.autoUpdate;a.matrixAutoUpdate=this.matrixAutoUpdate;return a};THREE.Fog=function(a,b,c){this.name="";this.color=new THREE.Color(a);this.near=void 0!==b?b:1;this.far=void 0!==c?c:1E3};THREE.Fog.prototype.clone=function(){return new THREE.Fog(this.color.getHex(),this.near,this.far)};THREE.FogExp2=function(a,b){this.name="";this.color=new THREE.Color(a);this.density=void 0!==b?b:2.5E-4};THREE.FogExp2.prototype.clone=function(){return new THREE.FogExp2(this.color.getHex(),this.density)};THREE.CanvasRenderer=function(a){function b(a,b,c){for(var d=0,e=z.length;d<e;d++){var f=z[d];La.copy(f.color);if(f instanceof THREE.DirectionalLight){var h=ua.getPositionFromMatrix(f.matrixWorld).normalize(),g=b.dot(h);0>=g||(g*=f.intensity,c.add(La.multiplyScalar(g)))}else f instanceof THREE.PointLight&&(h=ua.getPositionFromMatrix(f.matrixWorld),g=b.dot(ua.subVectors(h,a).normalize()),0>=g||(g*=0==f.distance?1:1-Math.min(a.distanceTo(h)/f.distance,1),0!=g&&(g*=f.intensity,c.add(La.multiplyScalar(g)))))}}
function c(a,b,c,d){m(b);l(c);p(d);s(a.getStyle());C.stroke();ra.expandByScalar(2*b)}function d(a){t(a.getStyle());C.fill()}function e(a,b,c,e,f,h,g,j,i,k,m,l,p){if(!(p instanceof THREE.DataTexture||void 0===p.image||0==p.image.width)){if(!0===p.needsUpdate){var n=p.wrapS==THREE.RepeatWrapping,r=p.wrapT==THREE.RepeatWrapping;Ga[p.id]=C.createPattern(p.image,!0===n&&!0===r?"repeat":!0===n&&!1===r?"repeat-x":!1===n&&!0===r?"repeat-y":"no-repeat");p.needsUpdate=!1}void 0===Ga[p.id]?t("rgba(0,0,0,1)"):
t(Ga[p.id]);var n=p.offset.x/p.repeat.x,r=p.offset.y/p.repeat.y,s=p.image.width*p.repeat.x,q=p.image.height*p.repeat.y,g=(g+n)*s,j=(1-j+r)*q,c=c-a,e=e-b,f=f-a,h=h-b,i=(i+n)*s-g,k=(1-k+r)*q-j,m=(m+n)*s-g,l=(1-l+r)*q-j,n=i*l-m*k;0===n?(void 0===fa[p.id]&&(b=document.createElement("canvas"),b.width=p.image.width,b.height=p.image.height,b=b.getContext("2d"),b.drawImage(p.image,0,0),fa[p.id]=b.getImageData(0,0,p.image.width,p.image.height).data),b=fa[p.id],g=4*(Math.floor(g)+Math.floor(j)*p.image.width),
V.setRGB(b[g]/255,b[g+1]/255,b[g+2]/255),d(V)):(n=1/n,p=(l*c-k*f)*n,k=(l*e-k*h)*n,c=(i*f-m*c)*n,e=(i*h-m*e)*n,a=a-p*g-c*j,g=b-k*g-e*j,C.save(),C.transform(p,k,c,e,a,g),C.fill(),C.restore())}}function f(a,b,c,d,e,f,h,g,j,i,k,m,l){var p,n;p=l.width-1;n=l.height-1;h*=p;g*=n;c-=a;d-=b;e-=a;f-=b;j=j*p-h;i=i*n-g;k=k*p-h;m=m*n-g;n=1/(j*m-k*i);p=(m*c-i*e)*n;i=(m*d-i*f)*n;c=(j*e-k*c)*n;d=(j*f-k*d)*n;a=a-p*h-c*g;b=b-i*h-d*g;C.save();C.transform(p,i,c,d,a,b);C.clip();C.drawImage(l,0,0);C.restore()}function h(a,
b,c,d){va[0]=255*a.r|0;va[1]=255*a.g|0;va[2]=255*a.b|0;va[4]=255*b.r|0;va[5]=255*b.g|0;va[6]=255*b.b|0;va[8]=255*c.r|0;va[9]=255*c.g|0;va[10]=255*c.b|0;va[12]=255*d.r|0;va[13]=255*d.g|0;va[14]=255*d.b|0;j.putImageData(Oa,0,0);Ea.drawImage(Pa,0,0);return wa}function g(a,b,c){var d=b.x-a.x,e=b.y-a.y,f=d*d+e*e;0!==f&&(c/=Math.sqrt(f),d*=c,e*=c,b.x+=d,b.y+=e,a.x-=d,a.y-=e)}function i(a){y!==a&&(y=C.globalAlpha=a)}function k(a){v!==a&&(a===THREE.NormalBlending?C.globalCompositeOperation="source-over":
a===THREE.AdditiveBlending?C.globalCompositeOperation="lighter":a===THREE.SubtractiveBlending&&(C.globalCompositeOperation="darker"),v=a)}function m(a){J!==a&&(J=C.lineWidth=a)}function l(a){ba!==a&&(ba=C.lineCap=a)}function p(a){oa!==a&&(oa=C.lineJoin=a)}function s(a){G!==a&&(G=C.strokeStyle=a)}function t(a){R!==a&&(R=C.fillStyle=a)}function n(a,b){if(pa!==a||N!==b)C.setLineDash([a,b]),pa=a,N=b}console.log("THREE.CanvasRenderer",THREE.REVISION);var r=THREE.Math.smoothstep,a=a||{},q=this,u,w,z,B=
new THREE.Projector,D=void 0!==a.canvas?a.canvas:document.createElement("canvas"),x=D.width,F=D.height,A=Math.floor(x/2),O=Math.floor(F/2),C=D.getContext("2d"),E=new THREE.Color(0),I=0,y=1,v=0,G=null,R=null,J=null,ba=null,oa=null,pa=null,N=0,M,Q,K,ca;new THREE.RenderableVertex;new THREE.RenderableVertex;var Fa,Ba,da,Aa,$,ea,V=new THREE.Color,P=new THREE.Color,Z=new THREE.Color,U=new THREE.Color,ka=new THREE.Color,ta=new THREE.Color,ia=new THREE.Color,La=new THREE.Color,Ga={},fa={},Da,Ua,Qa,xa,bb,
cb,Ma,fb,sb,pb,Ha=new THREE.Box2,la=new THREE.Box2,ra=new THREE.Box2,gb=new THREE.Color,sa=new THREE.Color,ga=new THREE.Color,ua=new THREE.Vector3,Pa,j,Oa,va,wa,Ea,Ra=16;Pa=document.createElement("canvas");Pa.width=Pa.height=2;j=Pa.getContext("2d");j.fillStyle="rgba(0,0,0,1)";j.fillRect(0,0,2,2);Oa=j.getImageData(0,0,2,2);va=Oa.data;wa=document.createElement("canvas");wa.width=wa.height=Ra;Ea=wa.getContext("2d");Ea.translate(-Ra/2,-Ra/2);Ea.scale(Ra,Ra);Ra--;void 0===C.setLineDash&&(C.setLineDash=
void 0!==C.mozDash?function(a){C.mozDash=null!==a[0]?a:null}:function(){});this.domElement=D;this.devicePixelRatio=void 0!==a.devicePixelRatio?a.devicePixelRatio:void 0!==self.devicePixelRatio?self.devicePixelRatio:1;this.sortElements=this.sortObjects=this.autoClear=!0;this.info={render:{vertices:0,faces:0}};this.supportsVertexTextures=function(){};this.setFaceCulling=function(){};this.setSize=function(a,b,c){x=a*this.devicePixelRatio;F=b*this.devicePixelRatio;A=Math.floor(x/2);O=Math.floor(F/2);
D.width=x;D.height=F;1!==this.devicePixelRatio&&!1!==c&&(D.style.width=a+"px",D.style.height=b+"px");Ha.set(new THREE.Vector2(-A,-O),new THREE.Vector2(A,O));la.set(new THREE.Vector2(-A,-O),new THREE.Vector2(A,O));y=1;v=0;oa=ba=J=R=G=null};this.setClearColor=function(a,b){E.set(a);I=void 0!==b?b:1;la.set(new THREE.Vector2(-A,-O),new THREE.Vector2(A,O))};this.setClearColorHex=function(a,b){console.warn("DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.");this.setClearColor(a,
b)};this.getMaxAnisotropy=function(){return 0};this.clear=function(){C.setTransform(1,0,0,-1,A,O);!1===la.empty()&&(la.intersect(Ha),la.expandByScalar(2),1>I&&C.clearRect(la.min.x|0,la.min.y|0,la.max.x-la.min.x|0,la.max.y-la.min.y|0),0<I&&(k(THREE.NormalBlending),i(1),t("rgba("+Math.floor(255*E.r)+","+Math.floor(255*E.g)+","+Math.floor(255*E.b)+","+I+")"),C.fillRect(la.min.x|0,la.min.y|0,la.max.x-la.min.x|0,la.max.y-la.min.y|0)),la.makeEmpty())};this.render=function(a,j){if(!1===j instanceof THREE.Camera)console.error("THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.");
else{!0===this.autoClear&&this.clear();C.setTransform(1,0,0,-1,A,O);q.info.render.vertices=0;q.info.render.faces=0;u=B.projectScene(a,j,this.sortObjects,this.sortElements);w=u.elements;z=u.lights;M=j;gb.setRGB(0,0,0);sa.setRGB(0,0,0);ga.setRGB(0,0,0);for(var D=0,G=z.length;D<G;D++){var y=z[D],F=y.color;y instanceof THREE.AmbientLight?gb.add(F):y instanceof THREE.DirectionalLight?sa.add(F):y instanceof THREE.PointLight&&ga.add(F)}D=0;for(G=w.length;D<G;D++){var x=w[D],v=x.material;if(!(void 0===v||
!1===v.visible)){ra.makeEmpty();if(x instanceof THREE.RenderableSprite){Q=x;Q.x*=A;Q.y*=O;var y=Q,F=x,J=v;i(J.opacity);k(J.blending);var N=v=x=void 0,E=void 0,I=void 0,R=void 0,ba=void 0;J instanceof THREE.SpriteMaterial||J instanceof THREE.ParticleSystemMaterial?void 0!==J.map.image?(I=J.map.image,R=I.width>>1,ba=I.height>>1,N=F.scale.x*A,E=F.scale.y*O,x=N*R,v=E*ba,ra.min.set(y.x-x,y.y-v),ra.max.set(y.x+x,y.y+v),!1===Ha.isIntersectionBox(ra)?ra.makeEmpty():(C.save(),C.translate(y.x,y.y),C.rotate(-F.rotation),
C.scale(N,-E),C.translate(-R,-ba),C.drawImage(I,0,0),C.restore())):(N=F.object.scale.x,E=F.object.scale.y,N*=F.scale.x*A,E*=F.scale.y*O,ra.min.set(y.x-N,y.y-E),ra.max.set(y.x+N,y.y+E),!1===Ha.isIntersectionBox(ra)?ra.makeEmpty():(t(J.color.getStyle()),C.save(),C.translate(y.x,y.y),C.rotate(-F.rotation),C.scale(N,E),C.fillRect(-1,-1,2,2),C.restore())):J instanceof THREE.SpriteCanvasMaterial&&(x=F.scale.x*A,v=F.scale.y*O,ra.min.set(y.x-x,y.y-v),ra.max.set(y.x+x,y.y+v),!1===Ha.isIntersectionBox(ra)?
ra.makeEmpty():(s(J.color.getStyle()),t(J.color.getStyle()),C.save(),C.translate(y.x,y.y),C.rotate(-F.rotation),C.scale(x,v),J.program(C),C.restore()))}else if(x instanceof THREE.RenderableLine){if(Q=x.v1,K=x.v2,Q.positionScreen.x*=A,Q.positionScreen.y*=O,K.positionScreen.x*=A,K.positionScreen.y*=O,ra.setFromPoints([Q.positionScreen,K.positionScreen]),!0===Ha.isIntersectionBox(ra))if(y=Q,F=K,J=x,x=v,i(x.opacity),k(x.blending),C.beginPath(),C.moveTo(y.positionScreen.x,y.positionScreen.y),C.lineTo(F.positionScreen.x,
F.positionScreen.y),x instanceof THREE.LineBasicMaterial){m(x.linewidth);l(x.linecap);p(x.linejoin);if(x.vertexColors!==THREE.VertexColors)s(x.color.getStyle());else if(v=J.vertexColors[0].getStyle(),J=J.vertexColors[1].getStyle(),v===J)s(v);else{try{var fa=C.createLinearGradient(y.positionScreen.x,y.positionScreen.y,F.positionScreen.x,F.positionScreen.y);fa.addColorStop(0,v);fa.addColorStop(1,J)}catch(oa){fa=v}s(fa)}C.stroke();ra.expandByScalar(2*x.linewidth)}else x instanceof THREE.LineDashedMaterial&&
(m(x.linewidth),l(x.linecap),p(x.linejoin),s(x.color.getStyle()),n(x.dashSize,x.gapSize),C.stroke(),ra.expandByScalar(2*x.linewidth),n(null,null))}else if(x instanceof THREE.RenderableFace3){Q=x.v1;K=x.v2;ca=x.v3;if(-1>Q.positionScreen.z||1<Q.positionScreen.z)continue;if(-1>K.positionScreen.z||1<K.positionScreen.z)continue;if(-1>ca.positionScreen.z||1<ca.positionScreen.z)continue;Q.positionScreen.x*=A;Q.positionScreen.y*=O;K.positionScreen.x*=A;K.positionScreen.y*=O;ca.positionScreen.x*=A;ca.positionScreen.y*=
O;0<v.overdraw&&(g(Q.positionScreen,K.positionScreen,v.overdraw),g(K.positionScreen,ca.positionScreen,v.overdraw),g(ca.positionScreen,Q.positionScreen,v.overdraw));ra.setFromPoints([Q.positionScreen,K.positionScreen,ca.positionScreen]);if(!0===Ha.isIntersectionBox(ra)){y=Q;F=K;J=ca;q.info.render.vertices+=3;q.info.render.faces++;i(v.opacity);k(v.blending);Fa=y.positionScreen.x;Ba=y.positionScreen.y;da=F.positionScreen.x;Aa=F.positionScreen.y;$=J.positionScreen.x;ea=J.positionScreen.y;var N=Fa,E=Ba,
I=da,R=Aa,ba=$,pa=ea;C.beginPath();C.moveTo(N,E);C.lineTo(I,R);C.lineTo(ba,pa);C.closePath();(v instanceof THREE.MeshLambertMaterial||v instanceof THREE.MeshPhongMaterial)&&null===v.map?(ta.copy(v.color),ia.copy(v.emissive),v.vertexColors===THREE.FaceColors&&ta.multiply(x.color),!1===v.wireframe&&v.shading==THREE.SmoothShading&&3==x.vertexNormalsLength?(P.copy(gb),Z.copy(gb),U.copy(gb),b(x.v1.positionWorld,x.vertexNormalsModel[0],P),b(x.v2.positionWorld,x.vertexNormalsModel[1],Z),b(x.v3.positionWorld,
x.vertexNormalsModel[2],U),P.multiply(ta).add(ia),Z.multiply(ta).add(ia),U.multiply(ta).add(ia),ka.addColors(Z,U).multiplyScalar(0.5),Qa=h(P,Z,U,ka),f(Fa,Ba,da,Aa,$,ea,0,0,1,0,0,1,Qa)):(V.copy(gb),b(x.centroidModel,x.normalModel,V),V.multiply(ta).add(ia),!0===v.wireframe?c(V,v.wireframeLinewidth,v.wireframeLinecap,v.wireframeLinejoin):d(V))):v instanceof THREE.MeshBasicMaterial||v instanceof THREE.MeshLambertMaterial||v instanceof THREE.MeshPhongMaterial?null!==v.map?v.map.mapping instanceof THREE.UVMapping&&
(xa=x.uvs[0],e(Fa,Ba,da,Aa,$,ea,xa[0].x,xa[0].y,xa[1].x,xa[1].y,xa[2].x,xa[2].y,v.map)):null!==v.envMap?v.envMap.mapping instanceof THREE.SphericalReflectionMapping&&(ua.copy(x.vertexNormalsModelView[0]),bb=0.5*ua.x+0.5,cb=0.5*ua.y+0.5,ua.copy(x.vertexNormalsModelView[1]),Ma=0.5*ua.x+0.5,fb=0.5*ua.y+0.5,ua.copy(x.vertexNormalsModelView[2]),sb=0.5*ua.x+0.5,pb=0.5*ua.y+0.5,e(Fa,Ba,da,Aa,$,ea,bb,cb,Ma,fb,sb,pb,v.envMap)):(V.copy(v.color),v.vertexColors===THREE.FaceColors&&V.multiply(x.color),!0===v.wireframe?
c(V,v.wireframeLinewidth,v.wireframeLinecap,v.wireframeLinejoin):d(V)):v instanceof THREE.MeshDepthMaterial?(Da=M.near,Ua=M.far,P.r=P.g=P.b=1-r(y.positionScreen.z*y.positionScreen.w,Da,Ua),Z.r=Z.g=Z.b=1-r(F.positionScreen.z*F.positionScreen.w,Da,Ua),U.r=U.g=U.b=1-r(J.positionScreen.z*J.positionScreen.w,Da,Ua),ka.addColors(Z,U).multiplyScalar(0.5),Qa=h(P,Z,U,ka),f(Fa,Ba,da,Aa,$,ea,0,0,1,0,0,1,Qa)):v instanceof THREE.MeshNormalMaterial&&(y=void 0,v.shading==THREE.FlatShading?(y=x.normalModelView,V.setRGB(y.x,
y.y,y.z).multiplyScalar(0.5).addScalar(0.5),!0===v.wireframe?c(V,v.wireframeLinewidth,v.wireframeLinecap,v.wireframeLinejoin):d(V)):v.shading==THREE.SmoothShading&&(y=x.vertexNormalsModelView[0],P.setRGB(y.x,y.y,y.z).multiplyScalar(0.5).addScalar(0.5),y=x.vertexNormalsModelView[1],Z.setRGB(y.x,y.y,y.z).multiplyScalar(0.5).addScalar(0.5),y=x.vertexNormalsModelView[2],U.setRGB(y.x,y.y,y.z).multiplyScalar(0.5).addScalar(0.5),ka.addColors(Z,U).multiplyScalar(0.5),Qa=h(P,Z,U,ka),f(Fa,Ba,da,Aa,$,ea,0,0,
1,0,0,1,Qa)))}}la.union(ra)}}C.setTransform(1,0,0,1,0,0)}}};THREE.ShaderChunk={fog_pars_fragment:"#ifdef USE_FOG\nuniform vec3 fogColor;\n#ifdef FOG_EXP2\nuniform float fogDensity;\n#else\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#endif",fog_fragment:"#ifdef USE_FOG\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n#ifdef FOG_EXP2\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n#else\nfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n#endif\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n#endif",
envmap_pars_fragment:"#ifdef USE_ENVMAP\nuniform float reflectivity;\nuniform samplerCube envMap;\nuniform float flipEnvMap;\nuniform int combine;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nuniform bool useRefract;\nuniform float refractionRatio;\n#else\nvarying vec3 vReflect;\n#endif\n#endif",envmap_fragment:"#ifdef USE_ENVMAP\nvec3 reflectVec;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nreflectVec = refract( cameraToVertex, normal, refractionRatio );\n} else { \nreflectVec = reflect( cameraToVertex, normal );\n}\n#else\nreflectVec = vReflect;\n#endif\n#ifdef DOUBLE_SIDED\nfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\nvec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n#else\nvec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n#endif\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\nif ( combine == 1 ) {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n} else if ( combine == 2 ) {\ngl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n} else {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n}\n#endif",
envmap_pars_vertex:"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvarying vec3 vReflect;\nuniform float refractionRatio;\nuniform bool useRefract;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n#ifdef USE_SKINNING\nvec4 worldPosition = modelMatrix * skinned;\n#endif\n#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n#endif\n#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n#endif\n#endif",
envmap_vertex:"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\nworldNormal = normalize( worldNormal );\nvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, worldNormal );\n}\n#endif",map_particle_pars_fragment:"#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
map_particle_fragment:"#ifdef USE_MAP\ngl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n#endif",map_pars_vertex:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\nuniform vec4 offsetRepeat;\n#endif",map_pars_fragment:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
map_vertex:"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",map_fragment:"#ifdef USE_MAP\nvec4 texelColor = texture2D( map, vUv );\n#ifdef GAMMA_INPUT\ntexelColor.xyz *= texelColor.xyz;\n#endif\ngl_FragColor = gl_FragColor * texelColor;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\nuniform sampler2D lightMap;\n#endif",lightmap_pars_vertex:"#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\n#endif",
lightmap_fragment:"#ifdef USE_LIGHTMAP\ngl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n#endif",lightmap_vertex:"#ifdef USE_LIGHTMAP\nvUv2 = uv2;\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;\nuniform float bumpScale;\nvec2 dHdxy_fwd() {\nvec2 dSTdx = dFdx( vUv );\nvec2 dSTdy = dFdy( vUv );\nfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\nfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\nfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\nreturn vec2( dBx, dBy );\n}\nvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\nvec3 vSigmaX = dFdx( surf_pos );\nvec3 vSigmaY = dFdy( surf_pos );\nvec3 vN = surf_norm;\nvec3 R1 = cross( vSigmaY, vN );\nvec3 R2 = cross( vN, vSigmaX );\nfloat fDet = dot( vSigmaX, R1 );\nvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\nreturn normalize( abs( fDet ) * surf_norm - vGrad );\n}\n#endif",
normalmap_pars_fragment:"#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;\nuniform vec2 normalScale;\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\nvec3 q0 = dFdx( eye_pos.xyz );\nvec3 q1 = dFdy( eye_pos.xyz );\nvec2 st0 = dFdx( vUv.st );\nvec2 st1 = dFdy( vUv.st );\nvec3 S = normalize(  q0 * st1.t - q1 * st0.t );\nvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\nvec3 N = normalize( surf_norm );\nvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\nmapN.xy = normalScale * mapN.xy;\nmat3 tsn = mat3( S, T, N );\nreturn normalize( tsn * mapN );\n}\n#endif",
specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\nuniform sampler2D specularMap;\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\nvec4 texelSpecular = texture2D( specularMap, vUv );\nspecularStrength = texelSpecular.r;\n#else\nspecularStrength = 1.0;\n#endif",lights_lambert_pars_vertex:"uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif",
lights_lambert_vertex:"vLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\nvLightBack = vec3( 0.0 );\n#endif\ntransformedNormal = normalize( transformedNormal );\n#if MAX_DIR_LIGHTS > 0\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, dirVector );\nvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\ndirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\ndirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n#ifdef DOUBLE_SIDED\nvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n#endif\n}\n#endif\n#if MAX_POINT_LIGHTS > 0\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\npointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\npointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n#ifdef DOUBLE_SIDED\nvLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n#endif\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\nspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\nspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n#ifdef DOUBLE_SIDED\nvLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n#endif\n}\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\nvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n#ifdef DOUBLE_SIDED\nvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n#endif\n}\n#endif\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n#ifdef DOUBLE_SIDED\nvLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n#endif",
lights_phong_pars_vertex:"#ifndef PHONG_PER_PIXEL\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\nvarying vec4 vPointLight[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\nvarying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\n#endif\n#endif\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvarying vec3 vWorldPosition;\n#endif",
lights_phong_vertex:"#ifndef PHONG_PER_PIXEL\n#if MAX_POINT_LIGHTS > 0\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nvPointLight[ i ] = vec4( lVector, lDistance );\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nvSpotLight[ i ] = vec4( lVector, lDistance );\n}\n#endif\n#endif\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvWorldPosition = worldPosition.xyz;\n#endif",
lights_phong_pars_fragment:"uniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n#ifdef PHONG_PER_PIXEL\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#else\nvarying vec4 vPointLight[ MAX_POINT_LIGHTS ];\n#endif\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n#ifdef PHONG_PER_PIXEL\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#else\nvarying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\n#endif\n#endif\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvarying vec3 vWorldPosition;\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;",
lights_phong_fragment:"vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#ifdef DOUBLE_SIDED\nnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#endif\n#ifdef USE_NORMALMAP\nnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\nnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse  = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n#ifdef PHONG_PER_PIXEL\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\n#else\nvec3 lVector = normalize( vPointLight[ i ].xyz );\nfloat lDistance = vPointLight[ i ].w;\n#endif\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n#endif\npointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\nvec3 pointHalfVector = normalize( lVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n#else\npointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;\n#endif\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse  = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n#ifdef PHONG_PER_PIXEL\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\n#else\nvec3 lVector = normalize( vSpotLight[ i ].xyz );\nfloat lDistance = vSpotLight[ i ].w;\n#endif\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n#endif\nspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\nvec3 spotHalfVector = normalize( lVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n#else\nspotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;\n#endif\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse  = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, dirVector );\n#ifdef WRAP_AROUND\nfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n#endif\ndirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n#else\ndirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;\n#endif\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += diffuse * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n#else\nhemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\n#endif\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif",
color_pars_fragment:"#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",color_fragment:"#ifdef USE_COLOR\ngl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n#endif",color_pars_vertex:"#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",color_vertex:"#ifdef USE_COLOR\n#ifdef GAMMA_INPUT\nvColor = color * color;\n#else\nvColor = color;\n#endif\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n#ifdef BONE_TEXTURE\nuniform sampler2D boneTexture;\nuniform int boneTextureWidth;\nuniform int boneTextureHeight;\nmat4 getBoneMatrix( const in float i ) {\nfloat j = i * 4.0;\nfloat x = mod( j, float( boneTextureWidth ) );\nfloat y = floor( j / float( boneTextureWidth ) );\nfloat dx = 1.0 / float( boneTextureWidth );\nfloat dy = 1.0 / float( boneTextureHeight );\ny = dy * ( y + 0.5 );\nvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\nvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\nvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\nvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\nmat4 bone = mat4( v1, v2, v3, v4 );\nreturn bone;\n}\n#else\nuniform mat4 boneGlobalMatrices[ MAX_BONES ];\nmat4 getBoneMatrix( const in float i ) {\nmat4 bone = boneGlobalMatrices[ int(i) ];\nreturn bone;\n}\n#endif\n#endif",
skinbase_vertex:"#ifdef USE_SKINNING\nmat4 boneMatX = getBoneMatrix( skinIndex.x );\nmat4 boneMatY = getBoneMatrix( skinIndex.y );\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n#ifdef USE_MORPHTARGETS\nvec4 skinVertex = vec4( morphed, 1.0 );\n#else\nvec4 skinVertex = vec4( position, 1.0 );\n#endif\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned \t  += boneMatY * skinVertex * skinWeight.y;\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n#ifndef USE_MORPHNORMALS\nuniform float morphTargetInfluences[ 8 ];\n#else\nuniform float morphTargetInfluences[ 4 ];\n#endif\n#endif",
morphtarget_vertex:"#ifdef USE_MORPHTARGETS\nvec3 morphed = vec3( 0.0 );\nmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\nmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\nmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\nmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n#ifndef USE_MORPHNORMALS\nmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\nmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\nmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\nmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n#endif\nmorphed += position;\n#endif",
default_vertex:"vec4 mvPosition;\n#ifdef USE_SKINNING\nmvPosition = modelViewMatrix * skinned;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( position, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\nvec3 morphedNormal = vec3( 0.0 );\nmorphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\nmorphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\nmorphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\nmorphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\nmorphedNormal += normal;\n#endif",
skinnormal_vertex:"#ifdef USE_SKINNING\nmat4 skinMatrix = skinWeight.x * boneMatX;\nskinMatrix \t+= skinWeight.y * boneMatY;\n#ifdef USE_MORPHNORMALS\nvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n#else\nvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n#endif\n#endif",defaultnormal_vertex:"vec3 objectNormal;\n#ifdef USE_SKINNING\nobjectNormal = skinnedNormal.xyz;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\nobjectNormal = morphedNormal;\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\nobjectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\nobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;",
shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\nuniform sampler2D shadowMap[ MAX_SHADOWS ];\nuniform vec2 shadowMapSize[ MAX_SHADOWS ];\nuniform float shadowDarkness[ MAX_SHADOWS ];\nuniform float shadowBias[ MAX_SHADOWS ];\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nfloat unpackDepth( const in vec4 rgba_depth ) {\nconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\nfloat depth = dot( rgba_depth, bit_shift );\nreturn depth;\n}\n#endif",shadowmap_fragment:"#ifdef USE_SHADOWMAP\n#ifdef SHADOWMAP_DEBUG\nvec3 frustumColors[3];\nfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\nfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\nfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n#endif\n#ifdef SHADOWMAP_CASCADE\nint inFrustumCount = 0;\n#endif\nfloat fDepth;\nvec3 shadowColor = vec3( 1.0 );\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\nbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\nbool inFrustum = all( inFrustumVec );\n#ifdef SHADOWMAP_CASCADE\ninFrustumCount += int( inFrustum );\nbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n#else\nbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n#endif\nbool frustumTest = all( frustumTestVec );\nif ( frustumTest ) {\nshadowCoord.z += shadowBias[ i ];\n#if defined( SHADOWMAP_TYPE_PCF )\nfloat shadow = 0.0;\nconst float shadowDelta = 1.0 / 9.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.25 * xPixelOffset;\nfloat dy0 = -1.25 * yPixelOffset;\nfloat dx1 = 1.25 * xPixelOffset;\nfloat dy1 = 1.25 * yPixelOffset;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\nfloat shadow = 0.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.0 * xPixelOffset;\nfloat dy0 = -1.0 * yPixelOffset;\nfloat dx1 = 1.0 * xPixelOffset;\nfloat dy1 = 1.0 * yPixelOffset;\nmat3 shadowKernel;\nmat3 depthKernel;\ndepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\ndepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\ndepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\ndepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\ndepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\ndepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\ndepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\ndepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\ndepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nvec3 shadowZ = vec3( shadowCoord.z );\nshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\nshadowKernel[0] *= vec3(0.25);\nshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\nshadowKernel[1] *= vec3(0.25);\nshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\nshadowKernel[2] *= vec3(0.25);\nvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\nshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\nshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\nvec4 shadowValues;\nshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\nshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\nshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\nshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\nshadow = dot( shadowValues, vec4( 1.0 ) );\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#else\nvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\nfloat fDepth = unpackDepth( rgbaDepth );\nif ( fDepth < shadowCoord.z )\nshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n#endif\n}\n#ifdef SHADOWMAP_DEBUG\n#ifdef SHADOWMAP_CASCADE\nif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n#else\nif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n#endif\n#endif\n}\n#ifdef GAMMA_OUTPUT\nshadowColor *= shadowColor;\n#endif\ngl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n#endif",
shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif",alphatest_fragment:"#ifdef ALPHATEST\nif ( gl_FragColor.a < ALPHATEST ) discard;\n#endif",linear_to_gamma_fragment:"#ifdef GAMMA_OUTPUT\ngl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n#endif"};
THREE.UniformsUtils={merge:function(a){var b,c,d,e={};for(b=0;b<a.length;b++)for(c in d=this.clone(a[b]),d)e[c]=d[c];return e},clone:function(a){var b,c,d,e={};for(b in a)for(c in e[b]={},a[b])d=a[b][c],e[b][c]=d instanceof THREE.Color||d instanceof THREE.Vector2||d instanceof THREE.Vector3||d instanceof THREE.Vector4||d instanceof THREE.Matrix4||d instanceof THREE.Texture?d.clone():d instanceof Array?d.slice():d;return e}};
THREE.UniformsLib={common:{diffuse:{type:"c",value:new THREE.Color(15658734)},opacity:{type:"f",value:1},map:{type:"t",value:null},offsetRepeat:{type:"v4",value:new THREE.Vector4(0,0,1,1)},lightMap:{type:"t",value:null},specularMap:{type:"t",value:null},envMap:{type:"t",value:null},flipEnvMap:{type:"f",value:-1},useRefract:{type:"i",value:0},reflectivity:{type:"f",value:1},refractionRatio:{type:"f",value:0.98},combine:{type:"i",value:0},morphTargetInfluences:{type:"f",value:0}},bump:{bumpMap:{type:"t",
value:null},bumpScale:{type:"f",value:1}},normalmap:{normalMap:{type:"t",value:null},normalScale:{type:"v2",value:new THREE.Vector2(1,1)}},fog:{fogDensity:{type:"f",value:2.5E-4},fogNear:{type:"f",value:1},fogFar:{type:"f",value:2E3},fogColor:{type:"c",value:new THREE.Color(16777215)}},lights:{ambientLightColor:{type:"fv",value:[]},directionalLightDirection:{type:"fv",value:[]},directionalLightColor:{type:"fv",value:[]},hemisphereLightDirection:{type:"fv",value:[]},hemisphereLightSkyColor:{type:"fv",
value:[]},hemisphereLightGroundColor:{type:"fv",value:[]},pointLightColor:{type:"fv",value:[]},pointLightPosition:{type:"fv",value:[]},pointLightDistance:{type:"fv1",value:[]},spotLightColor:{type:"fv",value:[]},spotLightPosition:{type:"fv",value:[]},spotLightDirection:{type:"fv",value:[]},spotLightDistance:{type:"fv1",value:[]},spotLightAngleCos:{type:"fv1",value:[]},spotLightExponent:{type:"fv1",value:[]}},particle:{psColor:{type:"c",value:new THREE.Color(15658734)},opacity:{type:"f",value:1},size:{type:"f",
value:1},scale:{type:"f",value:1},map:{type:"t",value:null},fogDensity:{type:"f",value:2.5E-4},fogNear:{type:"f",value:1},fogFar:{type:"f",value:2E3},fogColor:{type:"c",value:new THREE.Color(16777215)}},shadowmap:{shadowMap:{type:"tv",value:[]},shadowMapSize:{type:"v2v",value:[]},shadowBias:{type:"fv1",value:[]},shadowDarkness:{type:"fv1",value:[]},shadowMatrix:{type:"m4v",value:[]}}};
THREE.ShaderLib={basic:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,THREE.UniformsLib.shadowmap]),vertexShader:[THREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,"void main() {",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,
THREE.ShaderChunk.skinbase_vertex,"#ifdef USE_ENVMAP",THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,"#endif",THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,THREE.ShaderChunk.shadowmap_vertex,"}"].join("\n"),fragmentShader:["uniform vec3 diffuse;\nuniform float opacity;",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,
THREE.ShaderChunk.lightmap_pars_fragment,THREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.specularmap_pars_fragment,"void main() {\ngl_FragColor = vec4( diffuse, opacity );",THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,THREE.ShaderChunk.lightmap_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,
THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n")},lambert:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{ambient:{type:"c",value:new THREE.Color(16777215)},emissive:{type:"c",value:new THREE.Color(0)},wrapRGB:{type:"v3",value:new THREE.Vector3(1,1,1)}}]),vertexShader:["#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif",
THREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.lights_lambert_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,"void main() {",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,
THREE.ShaderChunk.defaultnormal_vertex,THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,THREE.ShaderChunk.lights_lambert_vertex,THREE.ShaderChunk.shadowmap_vertex,"}"].join("\n"),fragmentShader:["uniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,THREE.ShaderChunk.lightmap_pars_fragment,
THREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.specularmap_pars_fragment,"void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );",THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,"#ifdef DOUBLE_SIDED\nif ( gl_FrontFacing )\ngl_FragColor.xyz *= vLightFront;\nelse\ngl_FragColor.xyz *= vLightBack;\n#else\ngl_FragColor.xyz *= vLightFront;\n#endif",THREE.ShaderChunk.lightmap_fragment,
THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n")},phong:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.bump,THREE.UniformsLib.normalmap,THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{ambient:{type:"c",value:new THREE.Color(16777215)},emissive:{type:"c",value:new THREE.Color(0)},specular:{type:"c",
value:new THREE.Color(1118481)},shininess:{type:"f",value:30},wrapRGB:{type:"v3",value:new THREE.Vector3(1,1,1)}}]),vertexShader:["#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;",THREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.lights_phong_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,
"void main() {",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,"vNormal = normalize( transformedNormal );",THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,"vViewPosition = -mvPosition.xyz;",THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,
THREE.ShaderChunk.lights_phong_vertex,THREE.ShaderChunk.shadowmap_vertex,"}"].join("\n"),fragmentShader:["uniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,THREE.ShaderChunk.lightmap_pars_fragment,THREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.lights_phong_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,
THREE.ShaderChunk.bumpmap_pars_fragment,THREE.ShaderChunk.normalmap_pars_fragment,THREE.ShaderChunk.specularmap_pars_fragment,"void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );",THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,THREE.ShaderChunk.lights_phong_fragment,THREE.ShaderChunk.lightmap_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,
THREE.ShaderChunk.fog_fragment,"}"].join("\n")},particle_basic:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.particle,THREE.UniformsLib.shadowmap]),vertexShader:["uniform float size;\nuniform float scale;",THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,"void main() {",THREE.ShaderChunk.color_vertex,"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n#ifdef USE_SIZEATTENUATION\ngl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n#else\ngl_PointSize = size;\n#endif\ngl_Position = projectionMatrix * mvPosition;",
THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.shadowmap_vertex,"}"].join("\n"),fragmentShader:["uniform vec3 psColor;\nuniform float opacity;",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_particle_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,"void main() {\ngl_FragColor = vec4( psColor, opacity );",THREE.ShaderChunk.map_particle_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.shadowmap_fragment,
THREE.ShaderChunk.fog_fragment,"}"].join("\n")},dashed:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,{scale:{type:"f",value:1},dashSize:{type:"f",value:1},totalSize:{type:"f",value:2}}]),vertexShader:["uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;",THREE.ShaderChunk.color_pars_vertex,"void main() {",THREE.ShaderChunk.color_vertex,"vLineDistance = scale * lineDistance;\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n}"].join("\n"),
fragmentShader:["uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,"void main() {\nif ( mod( vLineDistance, totalSize ) > dashSize ) {\ndiscard;\n}\ngl_FragColor = vec4( diffuse, opacity );",THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n")},depth:{uniforms:{mNear:{type:"f",value:1},mFar:{type:"f",value:2E3},opacity:{type:"f",
value:1}},vertexShader:"void main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform float mNear;\nuniform float mFar;\nuniform float opacity;\nvoid main() {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat color = 1.0 - smoothstep( mNear, mFar, depth );\ngl_FragColor = vec4( vec3( color ), opacity );\n}"},normal:{uniforms:{opacity:{type:"f",value:1}},vertexShader:["varying vec3 vNormal;",THREE.ShaderChunk.morphtarget_pars_vertex,"void main() {\nvNormal = normalize( normalMatrix * normal );",
THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.default_vertex,"}"].join("\n"),fragmentShader:"uniform float opacity;\nvarying vec3 vNormal;\nvoid main() {\ngl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\n}"},normalmap:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{enableAO:{type:"i",value:0},enableDiffuse:{type:"i",value:0},enableSpecular:{type:"i",value:0},enableReflection:{type:"i",value:0},enableDisplacement:{type:"i",
value:0},tDisplacement:{type:"t",value:null},tDiffuse:{type:"t",value:null},tCube:{type:"t",value:null},tNormal:{type:"t",value:null},tSpecular:{type:"t",value:null},tAO:{type:"t",value:null},uNormalScale:{type:"v2",value:new THREE.Vector2(1,1)},uDisplacementBias:{type:"f",value:0},uDisplacementScale:{type:"f",value:1},uDiffuseColor:{type:"c",value:new THREE.Color(16777215)},uSpecularColor:{type:"c",value:new THREE.Color(1118481)},uAmbientColor:{type:"c",value:new THREE.Color(16777215)},uShininess:{type:"f",
value:30},uOpacity:{type:"f",value:1},useRefract:{type:"i",value:0},uRefractionRatio:{type:"f",value:0.98},uReflectivity:{type:"f",value:0.5},uOffset:{type:"v2",value:new THREE.Vector2(0,0)},uRepeat:{type:"v2",value:new THREE.Vector2(1,1)},wrapRGB:{type:"v3",value:new THREE.Vector3(1,1,1)}}]),fragmentShader:["uniform vec3 uAmbientColor;\nuniform vec3 uDiffuseColor;\nuniform vec3 uSpecularColor;\nuniform float uShininess;\nuniform float uOpacity;\nuniform bool enableDiffuse;\nuniform bool enableSpecular;\nuniform bool enableAO;\nuniform bool enableReflection;\nuniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tSpecular;\nuniform sampler2D tAO;\nuniform samplerCube tCube;\nuniform vec2 uNormalScale;\nuniform bool useRefract;\nuniform float uRefractionRatio;\nuniform float uReflectivity;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;",
THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,"void main() {\ngl_FragColor = vec4( vec3( 1.0 ), uOpacity );\nvec3 specularTex = vec3( 1.0 );\nvec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\nnormalTex.xy *= uNormalScale;\nnormalTex = normalize( normalTex );\nif( enableDiffuse ) {\n#ifdef GAMMA_INPUT\nvec4 texelColor = texture2D( tDiffuse, vUv );\ntexelColor.xyz *= texelColor.xyz;\ngl_FragColor = gl_FragColor * texelColor;\n#else\ngl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\n#endif\n}\nif( enableAO ) {\n#ifdef GAMMA_INPUT\nvec4 aoColor = texture2D( tAO, vUv );\naoColor.xyz *= aoColor.xyz;\ngl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\n#endif\n}\nif( enableSpecular )\nspecularTex = texture2D( tSpecular, vUv ).xyz;\nmat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\nvec3 finalNormal = tsb * normalTex;\n#ifdef FLIP_SIDED\nfinalNormal = -finalNormal;\n#endif\nvec3 normal = normalize( finalNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 pointVector = lPosition.xyz + vViewPosition.xyz;\nfloat pointDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\npointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\npointVector = normalize( pointVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\n#endif\npointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;\nvec3 pointHalfVector = normalize( pointVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat specularNormalization = ( uShininess + 2.0001 ) / 8.0;\nvec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\n#else\npointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;\n#endif\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 spotVector = lPosition.xyz + vViewPosition.xyz;\nfloat spotDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nspotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\nspotVector = normalize( spotVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\n#endif\nspotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;\nvec3 spotHalfVector = normalize( spotVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat specularNormalization = ( uShininess + 2.0001 ) / 8.0;\nvec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\n#else\nspotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;\n#endif\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\n#ifdef WRAP_AROUND\nfloat directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\nfloat directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\n#endif\ndirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat specularNormalization = ( uShininess + 2.0001 ) / 8.0;\nvec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n#else\ndirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;\n#endif\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += uDiffuseColor * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );\n#ifdef PHYSICALLY_BASED_SHADING\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( uShininess + 2.0001 ) / 8.0;\nvec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\nvec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n#else\nhemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;\n#endif\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;\n#endif\nif ( enableReflection ) {\nvec3 vReflect;\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, normal, uRefractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, normal );\n}\nvec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );\n}",
THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n"),vertexShader:["attribute vec4 tangent;\nuniform vec2 uOffset;\nuniform vec2 uRepeat;\nuniform bool enableDisplacement;\n#ifdef VERTEX_TEXTURES\nuniform sampler2D tDisplacement;\nuniform float uDisplacementScale;\nuniform float uDisplacementBias;\n#endif\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;",
THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,"void main() {",THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,"#ifdef USE_SKINNING\nvNormal = normalize( normalMatrix * skinnedNormal.xyz );\nvec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\nvTangent = normalize( normalMatrix * skinnedTangent.xyz );\n#else\nvNormal = normalize( normalMatrix * normal );\nvTangent = normalize( normalMatrix * tangent.xyz );\n#endif\nvBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\nvUv = uv * uRepeat + uOffset;\nvec3 displacedPosition;\n#ifdef VERTEX_TEXTURES\nif ( enableDisplacement ) {\nvec3 dv = texture2D( tDisplacement, uv ).xyz;\nfloat df = uDisplacementScale * dv.x + uDisplacementBias;\ndisplacedPosition = position + normalize( normal ) * df;\n} else {\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned \t  += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n}\n#else\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned \t  += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n#endif\nvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\nvec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\nvWorldPosition = worldPosition.xyz;\nvViewPosition = -mvPosition.xyz;\n#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif\n}"].join("\n")},
cube:{uniforms:{tCube:{type:"t",value:null},tFlip:{type:"f",value:-1}},vertexShader:"varying vec3 vWorldPosition;\nvoid main() {\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\nvWorldPosition = worldPosition.xyz;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",fragmentShader:"uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\nvoid main() {\ngl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n}"},
depthRGBA:{uniforms:{},vertexShader:[THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,"void main() {",THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,"}"].join("\n"),fragmentShader:"vec4 pack_depth( const in float depth ) {\nconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\nconst vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\nvec4 res = fract( depth * bit_shift );\nres -= res.xxyz * bit_mask;\nreturn res;\n}\nvoid main() {\ngl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n}"}};THREE.WebGLRenderer=function(a){function b(a,b){var c=a.vertices.length,d=b.material;if(d.attributes){void 0===a.__webglCustomAttributesList&&(a.__webglCustomAttributesList=[]);for(var e in d.attributes){var f=d.attributes[e];if(!f.__webglInitialized||f.createUniqueBuffers){f.__webglInitialized=!0;var h=1;"v2"===f.type?h=2:"v3"===f.type?h=3:"v4"===f.type?h=4:"c"===f.type&&(h=3);f.size=h;f.array=new Float32Array(c*h);f.buffer=j.createBuffer();f.buffer.belongsToAttribute=e;f.needsUpdate=!0}a.__webglCustomAttributesList.push(f)}}}
function c(a,b){var c=b.geometry,h=a.faces3,g=3*h.length,i=1*h.length,k=3*h.length,h=d(b,a),m=f(h),l=e(h),p=h.vertexColors?h.vertexColors:!1;a.__vertexArray=new Float32Array(3*g);l&&(a.__normalArray=new Float32Array(3*g));c.hasTangents&&(a.__tangentArray=new Float32Array(4*g));p&&(a.__colorArray=new Float32Array(3*g));m&&(0<c.faceVertexUvs.length&&(a.__uvArray=new Float32Array(2*g)),1<c.faceVertexUvs.length&&(a.__uv2Array=new Float32Array(2*g)));b.geometry.skinWeights.length&&b.geometry.skinIndices.length&&
(a.__skinIndexArray=new Float32Array(4*g),a.__skinWeightArray=new Float32Array(4*g));a.__faceArray=new Uint16Array(3*i);a.__lineArray=new Uint16Array(2*k);if(a.numMorphTargets){a.__morphTargetsArrays=[];c=0;for(m=a.numMorphTargets;c<m;c++)a.__morphTargetsArrays.push(new Float32Array(3*g))}if(a.numMorphNormals){a.__morphNormalsArrays=[];c=0;for(m=a.numMorphNormals;c<m;c++)a.__morphNormalsArrays.push(new Float32Array(3*g))}a.__webglFaceCount=3*i;a.__webglLineCount=2*k;if(h.attributes){void 0===a.__webglCustomAttributesList&&
(a.__webglCustomAttributesList=[]);for(var n in h.attributes){var i=h.attributes[n],k={},r;for(r in i)k[r]=i[r];if(!k.__webglInitialized||k.createUniqueBuffers)k.__webglInitialized=!0,c=1,"v2"===k.type?c=2:"v3"===k.type?c=3:"v4"===k.type?c=4:"c"===k.type&&(c=3),k.size=c,k.array=new Float32Array(g*c),k.buffer=j.createBuffer(),k.buffer.belongsToAttribute=n,i.needsUpdate=!0,k.__original=i;a.__webglCustomAttributesList.push(k)}}a.__inittedArrays=!0}function d(a,b){return a.material instanceof THREE.MeshFaceMaterial?
a.material.materials[b.materialIndex]:a.material}function e(a){return a instanceof THREE.MeshBasicMaterial&&!a.envMap||a instanceof THREE.MeshDepthMaterial?!1:a&&void 0!==a.shading&&a.shading===THREE.SmoothShading?THREE.SmoothShading:THREE.FlatShading}function f(a){return a.map||a.lightMap||a.bumpMap||a.normalMap||a.specularMap||a instanceof THREE.ShaderMaterial?!0:!1}function h(a){Ha[a]||(j.enableVertexAttribArray(a),Ha[a]=!0)}function g(){for(var a in Ha)Ha[a]&&(j.disableVertexAttribArray(a),Ha[a]=
!1)}function i(a,b){return a.z!==b.z?b.z-a.z:a.id-b.id}function k(a,b){return b[0]-a[0]}function m(a,b,c){if(a.length)for(var d=0,e=a.length;d<e;d++)ea=Ba=null,Aa=$=U=Z=fa=Ga=ka=-1,ua=!0,a[d].render(b,c,sb,pb),ea=Ba=null,Aa=$=U=Z=fa=Ga=ka=-1,ua=!0}function l(a,b,c,d,e,f,h,g){var j,i,k,m;b?(i=a.length-1,m=b=-1):(i=0,b=a.length,m=1);for(var l=i;l!==b;l+=m)if(j=a[l],j.render){i=j.object;k=j.buffer;if(g)j=g;else{j=j[c];if(!j)continue;h&&K.setBlending(j.blending,j.blendEquation,j.blendSrc,j.blendDst);
K.setDepthTest(j.depthTest);K.setDepthWrite(j.depthWrite);A(j.polygonOffset,j.polygonOffsetFactor,j.polygonOffsetUnits)}K.setMaterialFaces(j);k instanceof THREE.BufferGeometry?K.renderBufferDirect(d,e,f,j,k,i):K.renderBuffer(d,e,f,j,k,i)}}function p(a,b,c,d,e,f,h){for(var g,j,i=0,k=a.length;i<k;i++)if(g=a[i],j=g.object,j.visible){if(h)g=h;else{g=g[b];if(!g)continue;f&&K.setBlending(g.blending,g.blendEquation,g.blendSrc,g.blendDst);K.setDepthTest(g.depthTest);K.setDepthWrite(g.depthWrite);A(g.polygonOffset,
g.polygonOffsetFactor,g.polygonOffsetUnits)}K.renderImmediateObject(c,d,e,g,j)}}function s(a,d){var e,f,h,g;if(void 0===a.__webglInit&&(a.__webglInit=!0,a._modelViewMatrix=new THREE.Matrix4,a._normalMatrix=new THREE.Matrix3,void 0!==a.geometry&&void 0===a.geometry.__webglInit&&(a.geometry.__webglInit=!0,a.geometry.addEventListener("dispose",Cb)),f=a.geometry,void 0!==f))if(f instanceof THREE.BufferGeometry){var i,k;for(i in f.attributes)k="index"===i?j.ELEMENT_ARRAY_BUFFER:j.ARRAY_BUFFER,g=f.attributes[i],
void 0===g.numItems&&(g.numItems=g.array.length),g.buffer=j.createBuffer(),j.bindBuffer(k,g.buffer),j.bufferData(k,g.array,j.STATIC_DRAW)}else if(a instanceof THREE.Mesh){h=a.material;if(void 0===f.geometryGroups){i=f;var m,l,p;k={};var n=i.morphTargets.length,r=i.morphNormals.length,s=h instanceof THREE.MeshFaceMaterial;i.geometryGroups={};h=0;for(m=i.faces.length;h<m;h++)l=i.faces[h],l=s?l.materialIndex:0,void 0===k[l]&&(k[l]={hash:l,counter:0}),p=k[l].hash+"_"+k[l].counter,void 0===i.geometryGroups[p]&&
(i.geometryGroups[p]={faces3:[],materialIndex:l,vertices:0,numMorphTargets:n,numMorphNormals:r}),65535<i.geometryGroups[p].vertices+3&&(k[l].counter+=1,p=k[l].hash+"_"+k[l].counter,void 0===i.geometryGroups[p]&&(i.geometryGroups[p]={faces3:[],materialIndex:l,vertices:0,numMorphTargets:n,numMorphNormals:r})),i.geometryGroups[p].faces3.push(h),i.geometryGroups[p].vertices+=3;i.geometryGroupsList=[];for(g in i.geometryGroups)i.geometryGroups[g].id=V++,i.geometryGroupsList.push(i.geometryGroups[g])}for(e in f.geometryGroups)if(g=
f.geometryGroups[e],!g.__webglVertexBuffer){i=g;i.__webglVertexBuffer=j.createBuffer();i.__webglNormalBuffer=j.createBuffer();i.__webglTangentBuffer=j.createBuffer();i.__webglColorBuffer=j.createBuffer();i.__webglUVBuffer=j.createBuffer();i.__webglUV2Buffer=j.createBuffer();i.__webglSkinIndicesBuffer=j.createBuffer();i.__webglSkinWeightsBuffer=j.createBuffer();i.__webglFaceBuffer=j.createBuffer();i.__webglLineBuffer=j.createBuffer();n=k=void 0;if(i.numMorphTargets){i.__webglMorphTargetsBuffers=[];
k=0;for(n=i.numMorphTargets;k<n;k++)i.__webglMorphTargetsBuffers.push(j.createBuffer())}if(i.numMorphNormals){i.__webglMorphNormalsBuffers=[];k=0;for(n=i.numMorphNormals;k<n;k++)i.__webglMorphNormalsBuffers.push(j.createBuffer())}K.info.memory.geometries++;c(g,a);f.verticesNeedUpdate=!0;f.morphTargetsNeedUpdate=!0;f.elementsNeedUpdate=!0;f.uvsNeedUpdate=!0;f.normalsNeedUpdate=!0;f.tangentsNeedUpdate=!0;f.colorsNeedUpdate=!0}}else a instanceof THREE.Line?f.__webglVertexBuffer||(g=f,g.__webglVertexBuffer=
j.createBuffer(),g.__webglColorBuffer=j.createBuffer(),g.__webglLineDistanceBuffer=j.createBuffer(),K.info.memory.geometries++,g=f,i=g.vertices.length,g.__vertexArray=new Float32Array(3*i),g.__colorArray=new Float32Array(3*i),g.__lineDistanceArray=new Float32Array(1*i),g.__webglLineCount=i,b(g,a),f.verticesNeedUpdate=!0,f.colorsNeedUpdate=!0,f.lineDistancesNeedUpdate=!0):a instanceof THREE.ParticleSystem&&!f.__webglVertexBuffer&&(g=f,g.__webglVertexBuffer=j.createBuffer(),g.__webglColorBuffer=j.createBuffer(),
K.info.memory.geometries++,g=f,i=g.vertices.length,g.__vertexArray=new Float32Array(3*i),g.__colorArray=new Float32Array(3*i),g.__sortArray=[],g.__webglParticleCount=i,b(g,a),f.verticesNeedUpdate=!0,f.colorsNeedUpdate=!0);if(void 0===a.__webglActive){if(a instanceof THREE.Mesh)if(f=a.geometry,f instanceof THREE.BufferGeometry)t(d.__webglObjects,f,a);else{if(f instanceof THREE.Geometry)for(e in f.geometryGroups)g=f.geometryGroups[e],t(d.__webglObjects,g,a)}else a instanceof THREE.Line||a instanceof
THREE.ParticleSystem?(f=a.geometry,t(d.__webglObjects,f,a)):a instanceof THREE.ImmediateRenderObject||a.immediateRenderCallback?d.__webglObjectsImmediate.push({id:null,object:a,opaque:null,transparent:null,z:0}):a instanceof THREE.Sprite?d.__webglSprites.push(a):a instanceof THREE.LensFlare&&d.__webglFlares.push(a);a.__webglActive=!0}}function t(a,b,c){a.push({id:null,buffer:b,object:c,opaque:null,transparent:null,z:0})}function n(a){for(var b in a.attributes)if(a.attributes[b].needsUpdate)return!0;
return!1}function r(a){for(var b in a.attributes)a.attributes[b].needsUpdate=!1}function q(a,b){a instanceof THREE.Mesh||a instanceof THREE.ParticleSystem||a instanceof THREE.Line?u(b.__webglObjects,a):a instanceof THREE.Sprite?w(b.__webglSprites,a):a instanceof THREE.LensFlare?w(b.__webglFlares,a):(a instanceof THREE.ImmediateRenderObject||a.immediateRenderCallback)&&u(b.__webglObjectsImmediate,a);delete a.__webglActive}function u(a,b){for(var c=a.length-1;0<=c;c--)a[c].object===b&&a.splice(c,1)}
function w(a,b){for(var c=a.length-1;0<=c;c--)a[c]===b&&a.splice(c,1)}function z(a,b,c,d,e){P=0;d.needsUpdate&&(d.program&&Gb(d),K.initMaterial(d,b,c,e),d.needsUpdate=!1);d.morphTargets&&!e.__webglMorphTargetInfluences&&(e.__webglMorphTargetInfluences=new Float32Array(K.maxMorphTargets));var f=!1,g=d.program,h=g.uniforms,i=d.uniforms;g!==Ba&&(j.useProgram(g),Ba=g,f=!0);d.id!==Aa&&(Aa=d.id,f=!0);if(f||a!==ea)j.uniformMatrix4fv(h.projectionMatrix,!1,a.projectionMatrix.elements),a!==ea&&(ea=a);if(d.skinning)if(yb&&
e.useVertexTexture){if(null!==h.boneTexture){var k=B();j.uniform1i(h.boneTexture,k);K.setTexture(e.boneTexture,k)}null!==h.boneTextureWidth&&j.uniform1i(h.boneTextureWidth,e.boneTextureWidth);null!==h.boneTextureHeight&&j.uniform1i(h.boneTextureHeight,e.boneTextureHeight)}else null!==h.boneGlobalMatrices&&j.uniformMatrix4fv(h.boneGlobalMatrices,!1,e.boneMatrices);if(f){c&&d.fog&&(i.fogColor.value=c.color,c instanceof THREE.Fog?(i.fogNear.value=c.near,i.fogFar.value=c.far):c instanceof THREE.FogExp2&&
(i.fogDensity.value=c.density));if(d instanceof THREE.MeshPhongMaterial||d instanceof THREE.MeshLambertMaterial||d.lights){if(ua){for(var m,l=k=0,p=0,n,r,s,q=Pa,t=q.directional.colors,u=q.directional.positions,w=q.point.colors,z=q.point.positions,y=q.point.distances,A=q.spot.colors,C=q.spot.positions,F=q.spot.distances,J=q.spot.directions,N=q.spot.anglesCos,O=q.spot.exponents,I=q.hemi.skyColors,V=q.hemi.groundColors,R=q.hemi.positions,M=0,U=0,da=0,Z=0,Fa=0,dc=0,X=0,W=0,Q=m=0,c=s=Q=0,f=b.length;c<
f;c++)m=b[c],m.onlyShadow||(n=m.color,r=m.intensity,s=m.distance,m instanceof THREE.AmbientLight?m.visible&&(K.gammaInput?(k+=n.r*n.r,l+=n.g*n.g,p+=n.b*n.b):(k+=n.r,l+=n.g,p+=n.b)):m instanceof THREE.DirectionalLight?(Fa+=1,m.visible&&(ga.getPositionFromMatrix(m.matrixWorld),sa.getPositionFromMatrix(m.target.matrixWorld),ga.sub(sa),ga.normalize(),0===ga.x&&0===ga.y&&0===ga.z||(m=3*M,u[m]=ga.x,u[m+1]=ga.y,u[m+2]=ga.z,K.gammaInput?D(t,m,n,r*r):x(t,m,n,r),M+=1))):m instanceof THREE.PointLight?(dc+=1,
m.visible&&(Q=3*U,K.gammaInput?D(w,Q,n,r*r):x(w,Q,n,r),sa.getPositionFromMatrix(m.matrixWorld),z[Q]=sa.x,z[Q+1]=sa.y,z[Q+2]=sa.z,y[U]=s,U+=1)):m instanceof THREE.SpotLight?(X+=1,m.visible&&(Q=3*da,K.gammaInput?D(A,Q,n,r*r):x(A,Q,n,r),sa.getPositionFromMatrix(m.matrixWorld),C[Q]=sa.x,C[Q+1]=sa.y,C[Q+2]=sa.z,F[da]=s,ga.copy(sa),sa.getPositionFromMatrix(m.target.matrixWorld),ga.sub(sa),ga.normalize(),J[Q]=ga.x,J[Q+1]=ga.y,J[Q+2]=ga.z,N[da]=Math.cos(m.angle),O[da]=m.exponent,da+=1)):m instanceof THREE.HemisphereLight&&
(W+=1,m.visible&&(ga.getPositionFromMatrix(m.matrixWorld),ga.normalize(),0===ga.x&&0===ga.y&&0===ga.z||(s=3*Z,R[s]=ga.x,R[s+1]=ga.y,R[s+2]=ga.z,n=m.color,m=m.groundColor,K.gammaInput?(r*=r,D(I,s,n,r),D(V,s,m,r)):(x(I,s,n,r),x(V,s,m,r)),Z+=1))));c=3*M;for(f=Math.max(t.length,3*Fa);c<f;c++)t[c]=0;c=3*U;for(f=Math.max(w.length,3*dc);c<f;c++)w[c]=0;c=3*da;for(f=Math.max(A.length,3*X);c<f;c++)A[c]=0;c=3*Z;for(f=Math.max(I.length,3*W);c<f;c++)I[c]=0;c=3*Z;for(f=Math.max(V.length,3*W);c<f;c++)V[c]=0;q.directional.length=
M;q.point.length=U;q.spot.length=da;q.hemi.length=Z;q.ambient[0]=k;q.ambient[1]=l;q.ambient[2]=p;ua=!1}c=Pa;i.ambientLightColor.value=c.ambient;i.directionalLightColor.value=c.directional.colors;i.directionalLightDirection.value=c.directional.positions;i.pointLightColor.value=c.point.colors;i.pointLightPosition.value=c.point.positions;i.pointLightDistance.value=c.point.distances;i.spotLightColor.value=c.spot.colors;i.spotLightPosition.value=c.spot.positions;i.spotLightDistance.value=c.spot.distances;
i.spotLightDirection.value=c.spot.directions;i.spotLightAngleCos.value=c.spot.anglesCos;i.spotLightExponent.value=c.spot.exponents;i.hemisphereLightSkyColor.value=c.hemi.skyColors;i.hemisphereLightGroundColor.value=c.hemi.groundColors;i.hemisphereLightDirection.value=c.hemi.positions}if(d instanceof THREE.MeshBasicMaterial||d instanceof THREE.MeshLambertMaterial||d instanceof THREE.MeshPhongMaterial){i.opacity.value=d.opacity;K.gammaInput?i.diffuse.value.copyGammaToLinear(d.color):i.diffuse.value=
d.color;i.map.value=d.map;i.lightMap.value=d.lightMap;i.specularMap.value=d.specularMap;d.bumpMap&&(i.bumpMap.value=d.bumpMap,i.bumpScale.value=d.bumpScale);d.normalMap&&(i.normalMap.value=d.normalMap,i.normalScale.value.copy(d.normalScale));var $;d.map?$=d.map:d.specularMap?$=d.specularMap:d.normalMap?$=d.normalMap:d.bumpMap&&($=d.bumpMap);void 0!==$&&(c=$.offset,$=$.repeat,i.offsetRepeat.value.set(c.x,c.y,$.x,$.y));i.envMap.value=d.envMap;i.flipEnvMap.value=d.envMap instanceof THREE.WebGLRenderTargetCube?
1:-1;i.reflectivity.value=d.reflectivity;i.refractionRatio.value=d.refractionRatio;i.combine.value=d.combine;i.useRefract.value=d.envMap&&d.envMap.mapping instanceof THREE.CubeRefractionMapping}d instanceof THREE.LineBasicMaterial?(i.diffuse.value=d.color,i.opacity.value=d.opacity):d instanceof THREE.LineDashedMaterial?(i.diffuse.value=d.color,i.opacity.value=d.opacity,i.dashSize.value=d.dashSize,i.totalSize.value=d.dashSize+d.gapSize,i.scale.value=d.scale):d instanceof THREE.ParticleSystemMaterial?
(i.psColor.value=d.color,i.opacity.value=d.opacity,i.size.value=d.size,i.scale.value=G.height/2,i.map.value=d.map):d instanceof THREE.MeshPhongMaterial?(i.shininess.value=d.shininess,K.gammaInput?(i.ambient.value.copyGammaToLinear(d.ambient),i.emissive.value.copyGammaToLinear(d.emissive),i.specular.value.copyGammaToLinear(d.specular)):(i.ambient.value=d.ambient,i.emissive.value=d.emissive,i.specular.value=d.specular),d.wrapAround&&i.wrapRGB.value.copy(d.wrapRGB)):d instanceof THREE.MeshLambertMaterial?
(K.gammaInput?(i.ambient.value.copyGammaToLinear(d.ambient),i.emissive.value.copyGammaToLinear(d.emissive)):(i.ambient.value=d.ambient,i.emissive.value=d.emissive),d.wrapAround&&i.wrapRGB.value.copy(d.wrapRGB)):d instanceof THREE.MeshDepthMaterial?(i.mNear.value=a.near,i.mFar.value=a.far,i.opacity.value=d.opacity):d instanceof THREE.MeshNormalMaterial&&(i.opacity.value=d.opacity);if(e.receiveShadow&&!d._shadowPass&&i.shadowMatrix){c=$=0;for(f=b.length;c<f;c++)if(k=b[c],k.castShadow&&(k instanceof
THREE.SpotLight||k instanceof THREE.DirectionalLight&&!k.shadowCascade))i.shadowMap.value[$]=k.shadowMap,i.shadowMapSize.value[$]=k.shadowMapSize,i.shadowMatrix.value[$]=k.shadowMatrix,i.shadowDarkness.value[$]=k.shadowDarkness,i.shadowBias.value[$]=k.shadowBias,$++}b=d.uniformsList;i=0;for($=b.length;i<$;i++)if(f=g.uniforms[b[i][1]])if(c=b[i][0],l=c.type,k=c.value,"i"===l)j.uniform1i(f,k);else if("f"===l)j.uniform1f(f,k);else if("v2"===l)j.uniform2f(f,k.x,k.y);else if("v3"===l)j.uniform3f(f,k.x,
k.y,k.z);else if("v4"===l)j.uniform4f(f,k.x,k.y,k.z,k.w);else if("c"===l)j.uniform3f(f,k.r,k.g,k.b);else if("iv1"===l)j.uniform1iv(f,k);else if("iv"===l)j.uniform3iv(f,k);else if("fv1"===l)j.uniform1fv(f,k);else if("fv"===l)j.uniform3fv(f,k);else if("v2v"===l){void 0===c._array&&(c._array=new Float32Array(2*k.length));l=0;for(p=k.length;l<p;l++)q=2*l,c._array[q]=k[l].x,c._array[q+1]=k[l].y;j.uniform2fv(f,c._array)}else if("v3v"===l){void 0===c._array&&(c._array=new Float32Array(3*k.length));l=0;for(p=
k.length;l<p;l++)q=3*l,c._array[q]=k[l].x,c._array[q+1]=k[l].y,c._array[q+2]=k[l].z;j.uniform3fv(f,c._array)}else if("v4v"===l){void 0===c._array&&(c._array=new Float32Array(4*k.length));l=0;for(p=k.length;l<p;l++)q=4*l,c._array[q]=k[l].x,c._array[q+1]=k[l].y,c._array[q+2]=k[l].z,c._array[q+3]=k[l].w;j.uniform4fv(f,c._array)}else if("m4"===l)void 0===c._array&&(c._array=new Float32Array(16)),k.flattenToArray(c._array),j.uniformMatrix4fv(f,!1,c._array);else if("m4v"===l){void 0===c._array&&(c._array=
new Float32Array(16*k.length));l=0;for(p=k.length;l<p;l++)k[l].flattenToArrayOffset(c._array,16*l);j.uniformMatrix4fv(f,!1,c._array)}else if("t"===l){if(q=k,k=B(),j.uniform1i(f,k),q)if(q.image instanceof Array&&6===q.image.length){if(c=q,f=k,6===c.image.length)if(c.needsUpdate){c.image.__webglTextureCube||(c.addEventListener("dispose",Db),c.image.__webglTextureCube=j.createTexture(),K.info.memory.textures++);j.activeTexture(j.TEXTURE0+f);j.bindTexture(j.TEXTURE_CUBE_MAP,c.image.__webglTextureCube);
j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL,c.flipY);f=c instanceof THREE.CompressedTexture;k=[];for(l=0;6>l;l++)K.autoScaleCubemaps&&!f?(p=k,q=l,t=c.image[l],w=ac,t.width<=w&&t.height<=w||(z=Math.max(t.width,t.height),u=Math.floor(t.width*w/z),w=Math.floor(t.height*w/z),z=document.createElement("canvas"),z.width=u,z.height=w,z.getContext("2d").drawImage(t,0,0,t.width,t.height,0,0,u,w),t=z),p[q]=t):k[l]=c.image[l];l=k[0];p=0===(l.width&l.width-1)&&0===(l.height&l.height-1);q=v(c.format);t=v(c.type);E(j.TEXTURE_CUBE_MAP,
c,p);for(l=0;6>l;l++)if(f){w=k[l].mipmaps;z=0;for(y=w.length;z<y;z++)u=w[z],c.format!==THREE.RGBAFormat?j.compressedTexImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X+l,z,q,u.width,u.height,0,u.data):j.texImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X+l,z,q,u.width,u.height,0,q,t,u.data)}else j.texImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X+l,0,q,q,t,k[l]);c.generateMipmaps&&p&&j.generateMipmap(j.TEXTURE_CUBE_MAP);c.needsUpdate=!1;if(c.onUpdate)c.onUpdate()}else j.activeTexture(j.TEXTURE0+f),j.bindTexture(j.TEXTURE_CUBE_MAP,
c.image.__webglTextureCube)}else q instanceof THREE.WebGLRenderTargetCube?(c=q,j.activeTexture(j.TEXTURE0+k),j.bindTexture(j.TEXTURE_CUBE_MAP,c.__webglTexture)):K.setTexture(q,k)}else if("tv"===l){void 0===c._array&&(c._array=[]);l=0;for(p=c.value.length;l<p;l++)c._array[l]=B();j.uniform1iv(f,c._array);l=0;for(p=c.value.length;l<p;l++)q=c.value[l],k=c._array[l],q&&K.setTexture(q,k)}else console.warn("THREE.WebGLRenderer: Unknown uniform type: "+l);if((d instanceof THREE.ShaderMaterial||d instanceof
THREE.MeshPhongMaterial||d.envMap)&&null!==h.cameraPosition)sa.getPositionFromMatrix(a.matrixWorld),j.uniform3f(h.cameraPosition,sa.x,sa.y,sa.z);(d instanceof THREE.MeshPhongMaterial||d instanceof THREE.MeshLambertMaterial||d instanceof THREE.ShaderMaterial||d.skinning)&&null!==h.viewMatrix&&j.uniformMatrix4fv(h.viewMatrix,!1,a.matrixWorldInverse.elements)}j.uniformMatrix4fv(h.modelViewMatrix,!1,e._modelViewMatrix.elements);h.normalMatrix&&j.uniformMatrix3fv(h.normalMatrix,!1,e._normalMatrix.elements);
null!==h.modelMatrix&&j.uniformMatrix4fv(h.modelMatrix,!1,e.matrixWorld.elements);return g}function B(){var a=P;a>=Mb&&console.warn("WebGLRenderer: trying to use "+a+" texture units while this GPU supports only "+Mb);P+=1;return a}function D(a,b,c,d){a[b]=c.r*c.r*d;a[b+1]=c.g*c.g*d;a[b+2]=c.b*c.b*d}function x(a,b,c,d){a[b]=c.r*d;a[b+1]=c.g*d;a[b+2]=c.b*d}function F(a){a!==xa&&(j.lineWidth(a),xa=a)}function A(a,b,c){Da!==a&&(a?j.enable(j.POLYGON_OFFSET_FILL):j.disable(j.POLYGON_OFFSET_FILL),Da=a);
if(a&&(Ua!==b||Qa!==c))j.polygonOffset(b,c),Ua=b,Qa=c}function O(a){for(var a=a.split("\n"),b=0,c=a.length;b<c;b++)a[b]=b+1+": "+a[b];return a.join("\n")}function C(a,b){var c;"fragment"===a?c=j.createShader(j.FRAGMENT_SHADER):"vertex"===a&&(c=j.createShader(j.VERTEX_SHADER));j.shaderSource(c,b);j.compileShader(c);return!j.getShaderParameter(c,j.COMPILE_STATUS)?(console.error(j.getShaderInfoLog(c)),console.error(O(b)),null):c}function E(a,b,c){c?(j.texParameteri(a,j.TEXTURE_WRAP_S,v(b.wrapS)),j.texParameteri(a,
j.TEXTURE_WRAP_T,v(b.wrapT)),j.texParameteri(a,j.TEXTURE_MAG_FILTER,v(b.magFilter)),j.texParameteri(a,j.TEXTURE_MIN_FILTER,v(b.minFilter))):(j.texParameteri(a,j.TEXTURE_WRAP_S,j.CLAMP_TO_EDGE),j.texParameteri(a,j.TEXTURE_WRAP_T,j.CLAMP_TO_EDGE),j.texParameteri(a,j.TEXTURE_MAG_FILTER,y(b.magFilter)),j.texParameteri(a,j.TEXTURE_MIN_FILTER,y(b.minFilter)));if(wa&&b.type!==THREE.FloatType&&(1<b.anisotropy||b.__oldAnisotropy))j.texParameterf(a,wa.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(b.anisotropy,Nb)),b.__oldAnisotropy=
b.anisotropy}function I(a,b){j.bindRenderbuffer(j.RENDERBUFFER,a);b.depthBuffer&&!b.stencilBuffer?(j.renderbufferStorage(j.RENDERBUFFER,j.DEPTH_COMPONENT16,b.width,b.height),j.framebufferRenderbuffer(j.FRAMEBUFFER,j.DEPTH_ATTACHMENT,j.RENDERBUFFER,a)):b.depthBuffer&&b.stencilBuffer?(j.renderbufferStorage(j.RENDERBUFFER,j.DEPTH_STENCIL,b.width,b.height),j.framebufferRenderbuffer(j.FRAMEBUFFER,j.DEPTH_STENCIL_ATTACHMENT,j.RENDERBUFFER,a)):j.renderbufferStorage(j.RENDERBUFFER,j.RGBA4,b.width,b.height)}
function y(a){return a===THREE.NearestFilter||a===THREE.NearestMipMapNearestFilter||a===THREE.NearestMipMapLinearFilter?j.NEAREST:j.LINEAR}function v(a){if(a===THREE.RepeatWrapping)return j.REPEAT;if(a===THREE.ClampToEdgeWrapping)return j.CLAMP_TO_EDGE;if(a===THREE.MirroredRepeatWrapping)return j.MIRRORED_REPEAT;if(a===THREE.NearestFilter)return j.NEAREST;if(a===THREE.NearestMipMapNearestFilter)return j.NEAREST_MIPMAP_NEAREST;if(a===THREE.NearestMipMapLinearFilter)return j.NEAREST_MIPMAP_LINEAR;if(a===
THREE.LinearFilter)return j.LINEAR;if(a===THREE.LinearMipMapNearestFilter)return j.LINEAR_MIPMAP_NEAREST;if(a===THREE.LinearMipMapLinearFilter)return j.LINEAR_MIPMAP_LINEAR;if(a===THREE.UnsignedByteType)return j.UNSIGNED_BYTE;if(a===THREE.UnsignedShort4444Type)return j.UNSIGNED_SHORT_4_4_4_4;if(a===THREE.UnsignedShort5551Type)return j.UNSIGNED_SHORT_5_5_5_1;if(a===THREE.UnsignedShort565Type)return j.UNSIGNED_SHORT_5_6_5;if(a===THREE.ByteType)return j.BYTE;if(a===THREE.ShortType)return j.SHORT;if(a===
THREE.UnsignedShortType)return j.UNSIGNED_SHORT;if(a===THREE.IntType)return j.INT;if(a===THREE.UnsignedIntType)return j.UNSIGNED_INT;if(a===THREE.FloatType)return j.FLOAT;if(a===THREE.AlphaFormat)return j.ALPHA;if(a===THREE.RGBFormat)return j.RGB;if(a===THREE.RGBAFormat)return j.RGBA;if(a===THREE.LuminanceFormat)return j.LUMINANCE;if(a===THREE.LuminanceAlphaFormat)return j.LUMINANCE_ALPHA;if(a===THREE.AddEquation)return j.FUNC_ADD;if(a===THREE.SubtractEquation)return j.FUNC_SUBTRACT;if(a===THREE.ReverseSubtractEquation)return j.FUNC_REVERSE_SUBTRACT;
if(a===THREE.ZeroFactor)return j.ZERO;if(a===THREE.OneFactor)return j.ONE;if(a===THREE.SrcColorFactor)return j.SRC_COLOR;if(a===THREE.OneMinusSrcColorFactor)return j.ONE_MINUS_SRC_COLOR;if(a===THREE.SrcAlphaFactor)return j.SRC_ALPHA;if(a===THREE.OneMinusSrcAlphaFactor)return j.ONE_MINUS_SRC_ALPHA;if(a===THREE.DstAlphaFactor)return j.DST_ALPHA;if(a===THREE.OneMinusDstAlphaFactor)return j.ONE_MINUS_DST_ALPHA;if(a===THREE.DstColorFactor)return j.DST_COLOR;if(a===THREE.OneMinusDstColorFactor)return j.ONE_MINUS_DST_COLOR;
if(a===THREE.SrcAlphaSaturateFactor)return j.SRC_ALPHA_SATURATE;if(void 0!==Ea){if(a===THREE.RGB_S3TC_DXT1_Format)return Ea.COMPRESSED_RGB_S3TC_DXT1_EXT;if(a===THREE.RGBA_S3TC_DXT1_Format)return Ea.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(a===THREE.RGBA_S3TC_DXT3_Format)return Ea.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(a===THREE.RGBA_S3TC_DXT5_Format)return Ea.COMPRESSED_RGBA_S3TC_DXT5_EXT}return 0}console.log("THREE.WebGLRenderer",THREE.REVISION);var a=a||{},G=void 0!==a.canvas?a.canvas:document.createElement("canvas"),
R=void 0!==a.precision?a.precision:"highp",J=void 0!==a.alpha?a.alpha:!0,ba=void 0!==a.premultipliedAlpha?a.premultipliedAlpha:!0,oa=void 0!==a.antialias?a.antialias:!1,pa=void 0!==a.stencil?a.stencil:!0,N=void 0!==a.preserveDrawingBuffer?a.preserveDrawingBuffer:!1,M=new THREE.Color(0),Q=0;this.domElement=G;this.context=null;this.devicePixelRatio=void 0!==a.devicePixelRatio?a.devicePixelRatio:void 0!==self.devicePixelRatio?self.devicePixelRatio:1;this.autoUpdateObjects=this.sortObjects=this.autoClearStencil=
this.autoClearDepth=this.autoClearColor=this.autoClear=!0;this.shadowMapEnabled=this.physicallyBasedShading=this.gammaOutput=this.gammaInput=!1;this.shadowMapAutoUpdate=!0;this.shadowMapType=THREE.PCFShadowMap;this.shadowMapCullFace=THREE.CullFaceFront;this.shadowMapCascade=this.shadowMapDebug=!1;this.maxMorphTargets=8;this.maxMorphNormals=4;this.autoScaleCubemaps=!0;this.renderPluginsPre=[];this.renderPluginsPost=[];this.info={memory:{programs:0,geometries:0,textures:0},render:{calls:0,vertices:0,
faces:0,points:0}};var K=this,ca=[],Fa=0,Ba=null,da=null,Aa=-1,$=null,ea=null,V=0,P=0,Z=-1,U=-1,ka=-1,ta=-1,ia=-1,La=-1,Ga=-1,fa=-1,Da=null,Ua=null,Qa=null,xa=null,bb=0,cb=0,Ma=G.width,fb=G.height,sb=0,pb=0,Ha={},la=new THREE.Frustum,ra=new THREE.Matrix4,gb=new THREE.Matrix4,sa=new THREE.Vector3,ga=new THREE.Vector3,ua=!0,Pa={ambient:[0,0,0],directional:{length:0,colors:[],positions:[]},point:{length:0,colors:[],positions:[],distances:[]},spot:{length:0,colors:[],positions:[],distances:[],directions:[],
anglesCos:[],exponents:[]},hemi:{length:0,skyColors:[],groundColors:[],positions:[]}},j,Oa,va,wa,Ea;try{var Ra={alpha:J,premultipliedAlpha:ba,antialias:oa,stencil:pa,preserveDrawingBuffer:N};j=G.getContext("webgl",Ra)||G.getContext("experimental-webgl",Ra);if(null===j)throw"Error creating WebGL context.";}catch(Zb){console.error(Zb)}Oa=j.getExtension("OES_texture_float");j.getExtension("OES_texture_float_linear");va=j.getExtension("OES_standard_derivatives");wa=j.getExtension("EXT_texture_filter_anisotropic")||
j.getExtension("MOZ_EXT_texture_filter_anisotropic")||j.getExtension("WEBKIT_EXT_texture_filter_anisotropic");Ea=j.getExtension("WEBGL_compressed_texture_s3tc")||j.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||j.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");Oa||console.log("THREE.WebGLRenderer: Float textures not supported.");va||console.log("THREE.WebGLRenderer: Standard derivatives not supported.");wa||console.log("THREE.WebGLRenderer: Anisotropic texture filtering not supported.");
Ea||console.log("THREE.WebGLRenderer: S3TC compressed textures not supported.");void 0===j.getShaderPrecisionFormat&&(j.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}});j.clearColor(0,0,0,1);j.clearDepth(1);j.clearStencil(0);j.enable(j.DEPTH_TEST);j.depthFunc(j.LEQUAL);j.frontFace(j.CCW);j.cullFace(j.BACK);j.enable(j.CULL_FACE);j.enable(j.BLEND);j.blendEquation(j.FUNC_ADD);j.blendFunc(j.SRC_ALPHA,j.ONE_MINUS_SRC_ALPHA);j.viewport(bb,cb,Ma,fb);j.clearColor(M.r,M.g,M.b,
Q);this.context=j;var Mb=j.getParameter(j.MAX_TEXTURE_IMAGE_UNITS),$b=j.getParameter(j.MAX_VERTEX_TEXTURE_IMAGE_UNITS);j.getParameter(j.MAX_TEXTURE_SIZE);var ac=j.getParameter(j.MAX_CUBE_MAP_TEXTURE_SIZE),Nb=wa?j.getParameter(wa.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,Bb=0<$b,yb=Bb&&Oa;Ea&&j.getParameter(j.COMPRESSED_TEXTURE_FORMATS);var bc=j.getShaderPrecisionFormat(j.VERTEX_SHADER,j.HIGH_FLOAT),cc=j.getShaderPrecisionFormat(j.VERTEX_SHADER,j.MEDIUM_FLOAT);j.getShaderPrecisionFormat(j.VERTEX_SHADER,j.LOW_FLOAT);
var qc=j.getShaderPrecisionFormat(j.FRAGMENT_SHADER,j.HIGH_FLOAT),rc=j.getShaderPrecisionFormat(j.FRAGMENT_SHADER,j.MEDIUM_FLOAT);j.getShaderPrecisionFormat(j.FRAGMENT_SHADER,j.LOW_FLOAT);j.getShaderPrecisionFormat(j.VERTEX_SHADER,j.HIGH_INT);j.getShaderPrecisionFormat(j.VERTEX_SHADER,j.MEDIUM_INT);j.getShaderPrecisionFormat(j.VERTEX_SHADER,j.LOW_INT);j.getShaderPrecisionFormat(j.FRAGMENT_SHADER,j.HIGH_INT);j.getShaderPrecisionFormat(j.FRAGMENT_SHADER,j.MEDIUM_INT);j.getShaderPrecisionFormat(j.FRAGMENT_SHADER,
j.LOW_INT);var sc=0<bc.precision&&0<qc.precision,Ob=0<cc.precision&&0<rc.precision;"highp"===R&&!sc&&(Ob?(R="mediump",console.warn("WebGLRenderer: highp not supported, using mediump")):(R="lowp",console.warn("WebGLRenderer: highp and mediump not supported, using lowp")));"mediump"===R&&!Ob&&(R="lowp",console.warn("WebGLRenderer: mediump not supported, using lowp"));this.getContext=function(){return j};this.supportsVertexTextures=function(){return Bb};this.supportsFloatTextures=function(){return Oa};
this.supportsStandardDerivatives=function(){return va};this.supportsCompressedTextureS3TC=function(){return Ea};this.getMaxAnisotropy=function(){return Nb};this.getPrecision=function(){return R};this.setSize=function(a,b,c){G.width=a*this.devicePixelRatio;G.height=b*this.devicePixelRatio;1!==this.devicePixelRatio&&!1!==c&&(G.style.width=a+"px",G.style.height=b+"px");this.setViewport(0,0,G.width,G.height)};this.setViewport=function(a,b,c,d){bb=void 0!==a?a:0;cb=void 0!==b?b:0;Ma=void 0!==c?c:G.width;
fb=void 0!==d?d:G.height;j.viewport(bb,cb,Ma,fb)};this.setScissor=function(a,b,c,d){j.scissor(a,b,c,d)};this.enableScissorTest=function(a){a?j.enable(j.SCISSOR_TEST):j.disable(j.SCISSOR_TEST)};this.setClearColor=function(a,b){M.set(a);Q=void 0!==b?b:1;j.clearColor(M.r,M.g,M.b,Q)};this.setClearColorHex=function(a,b){console.warn("DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.");this.setClearColor(a,b)};this.getClearColor=function(){return M};this.getClearAlpha=function(){return Q};
this.clear=function(a,b,c){var d=0;if(void 0===a||a)d|=j.COLOR_BUFFER_BIT;if(void 0===b||b)d|=j.DEPTH_BUFFER_BIT;if(void 0===c||c)d|=j.STENCIL_BUFFER_BIT;j.clear(d)};this.clearTarget=function(a,b,c,d){this.setRenderTarget(a);this.clear(b,c,d)};this.addPostPlugin=function(a){a.init(this);this.renderPluginsPost.push(a)};this.addPrePlugin=function(a){a.init(this);this.renderPluginsPre.push(a)};this.updateShadowMap=function(a,b){Ba=null;Aa=$=fa=Ga=ka=-1;ua=!0;U=Z=-1;this.shadowMapPlugin.update(a,b)};
var Cb=function(a){a=a.target;a.removeEventListener("dispose",Cb);a.__webglInit=void 0;if(a instanceof THREE.BufferGeometry){var b=a.attributes,c;for(c in b)void 0!==b[c].buffer&&j.deleteBuffer(b[c].buffer);K.info.memory.geometries--}else if(void 0!==a.geometryGroups)for(b in a.geometryGroups){c=a.geometryGroups[b];if(void 0!==c.numMorphTargets)for(var d=0,e=c.numMorphTargets;d<e;d++)j.deleteBuffer(c.__webglMorphTargetsBuffers[d]);if(void 0!==c.numMorphNormals){d=0;for(e=c.numMorphNormals;d<e;d++)j.deleteBuffer(c.__webglMorphNormalsBuffers[d])}Hb(c)}else Hb(a)},
Db=function(a){a=a.target;a.removeEventListener("dispose",Db);a.image&&a.image.__webglTextureCube?j.deleteTexture(a.image.__webglTextureCube):a.__webglInit&&(a.__webglInit=!1,j.deleteTexture(a.__webglTexture));K.info.memory.textures--},Eb=function(a){a=a.target;a.removeEventListener("dispose",Eb);if(a&&a.__webglTexture)if(j.deleteTexture(a.__webglTexture),a instanceof THREE.WebGLRenderTargetCube)for(var b=0;6>b;b++)j.deleteFramebuffer(a.__webglFramebuffer[b]),j.deleteRenderbuffer(a.__webglRenderbuffer[b]);
else j.deleteFramebuffer(a.__webglFramebuffer),j.deleteRenderbuffer(a.__webglRenderbuffer);K.info.memory.textures--},Fb=function(a){a=a.target;a.removeEventListener("dispose",Fb);Gb(a)},Hb=function(a){void 0!==a.__webglVertexBuffer&&j.deleteBuffer(a.__webglVertexBuffer);void 0!==a.__webglNormalBuffer&&j.deleteBuffer(a.__webglNormalBuffer);void 0!==a.__webglTangentBuffer&&j.deleteBuffer(a.__webglTangentBuffer);void 0!==a.__webglColorBuffer&&j.deleteBuffer(a.__webglColorBuffer);void 0!==a.__webglUVBuffer&&
j.deleteBuffer(a.__webglUVBuffer);void 0!==a.__webglUV2Buffer&&j.deleteBuffer(a.__webglUV2Buffer);void 0!==a.__webglSkinIndicesBuffer&&j.deleteBuffer(a.__webglSkinIndicesBuffer);void 0!==a.__webglSkinWeightsBuffer&&j.deleteBuffer(a.__webglSkinWeightsBuffer);void 0!==a.__webglFaceBuffer&&j.deleteBuffer(a.__webglFaceBuffer);void 0!==a.__webglLineBuffer&&j.deleteBuffer(a.__webglLineBuffer);void 0!==a.__webglLineDistanceBuffer&&j.deleteBuffer(a.__webglLineDistanceBuffer);if(void 0!==a.__webglCustomAttributesList)for(var b in a.__webglCustomAttributesList)j.deleteBuffer(a.__webglCustomAttributesList[b].buffer);
K.info.memory.geometries--},Gb=function(a){var b=a.program;if(void 0!==b){a.program=void 0;var c,d,e=!1,a=0;for(c=ca.length;a<c;a++)if(d=ca[a],d.program===b){d.usedTimes--;0===d.usedTimes&&(e=!0);break}if(!0===e){e=[];a=0;for(c=ca.length;a<c;a++)d=ca[a],d.program!==b&&e.push(d);ca=e;j.deleteProgram(b);K.info.memory.programs--}}};this.renderBufferImmediate=function(a,b,c){a.hasPositions&&!a.__webglVertexBuffer&&(a.__webglVertexBuffer=j.createBuffer());a.hasNormals&&!a.__webglNormalBuffer&&(a.__webglNormalBuffer=
j.createBuffer());a.hasUvs&&!a.__webglUvBuffer&&(a.__webglUvBuffer=j.createBuffer());a.hasColors&&!a.__webglColorBuffer&&(a.__webglColorBuffer=j.createBuffer());a.hasPositions&&(j.bindBuffer(j.ARRAY_BUFFER,a.__webglVertexBuffer),j.bufferData(j.ARRAY_BUFFER,a.positionArray,j.DYNAMIC_DRAW),j.enableVertexAttribArray(b.attributes.position),j.vertexAttribPointer(b.attributes.position,3,j.FLOAT,!1,0,0));if(a.hasNormals){j.bindBuffer(j.ARRAY_BUFFER,a.__webglNormalBuffer);if(c.shading===THREE.FlatShading){var d,
e,f,h,g,i,k,l,m,p,n,q=3*a.count;for(n=0;n<q;n+=9)p=a.normalArray,d=p[n],e=p[n+1],f=p[n+2],h=p[n+3],i=p[n+4],l=p[n+5],g=p[n+6],k=p[n+7],m=p[n+8],d=(d+h+g)/3,e=(e+i+k)/3,f=(f+l+m)/3,p[n]=d,p[n+1]=e,p[n+2]=f,p[n+3]=d,p[n+4]=e,p[n+5]=f,p[n+6]=d,p[n+7]=e,p[n+8]=f}j.bufferData(j.ARRAY_BUFFER,a.normalArray,j.DYNAMIC_DRAW);j.enableVertexAttribArray(b.attributes.normal);j.vertexAttribPointer(b.attributes.normal,3,j.FLOAT,!1,0,0)}a.hasUvs&&c.map&&(j.bindBuffer(j.ARRAY_BUFFER,a.__webglUvBuffer),j.bufferData(j.ARRAY_BUFFER,
a.uvArray,j.DYNAMIC_DRAW),j.enableVertexAttribArray(b.attributes.uv),j.vertexAttribPointer(b.attributes.uv,2,j.FLOAT,!1,0,0));a.hasColors&&c.vertexColors!==THREE.NoColors&&(j.bindBuffer(j.ARRAY_BUFFER,a.__webglColorBuffer),j.bufferData(j.ARRAY_BUFFER,a.colorArray,j.DYNAMIC_DRAW),j.enableVertexAttribArray(b.attributes.color),j.vertexAttribPointer(b.attributes.color,3,j.FLOAT,!1,0,0));j.drawArrays(j.TRIANGLES,0,a.count);a.count=0};this.renderBufferDirect=function(a,b,c,d,e,f){if(!1!==d.visible){var i,
k,l,m;i=z(a,b,c,d,f);b=i.attributes;a=e.attributes;c=!1;i=16777215*e.id+2*i.id+(d.wireframe?1:0);i!==$&&($=i,c=!0);c&&g();if(f instanceof THREE.Mesh)if(f=a.index){e=e.offsets;1<e.length&&(c=!0);for(var p=0,n=e.length;p<n;p++){var q=e[p].index;if(c){for(k in b)l=b[k],i=a[k],0<=l&&(i?(m=i.itemSize,j.bindBuffer(j.ARRAY_BUFFER,i.buffer),h(l),j.vertexAttribPointer(l,m,j.FLOAT,!1,0,4*q*m)):d.defaultAttributeValues&&(2===d.defaultAttributeValues[k].length?j.vertexAttrib2fv(l,d.defaultAttributeValues[k]):
3===d.defaultAttributeValues[k].length&&j.vertexAttrib3fv(l,d.defaultAttributeValues[k])));j.bindBuffer(j.ELEMENT_ARRAY_BUFFER,f.buffer)}j.drawElements(j.TRIANGLES,e[p].count,j.UNSIGNED_SHORT,2*e[p].start);K.info.render.calls++;K.info.render.vertices+=e[p].count;K.info.render.faces+=e[p].count/3}}else{if(c)for(k in b)"index"!==k&&(l=b[k],i=a[k],0<=l&&(i?(m=i.itemSize,j.bindBuffer(j.ARRAY_BUFFER,i.buffer),h(l),j.vertexAttribPointer(l,m,j.FLOAT,!1,0,0)):d.defaultAttributeValues&&d.defaultAttributeValues[k]&&
(2===d.defaultAttributeValues[k].length?j.vertexAttrib2fv(l,d.defaultAttributeValues[k]):3===d.defaultAttributeValues[k].length&&j.vertexAttrib3fv(l,d.defaultAttributeValues[k]))));d=e.attributes.position;j.drawArrays(j.TRIANGLES,0,d.numItems/3);K.info.render.calls++;K.info.render.vertices+=d.numItems/3;K.info.render.faces+=d.numItems/3/3}else if(f instanceof THREE.ParticleSystem){if(c){for(k in b)l=b[k],i=a[k],0<=l&&(i?(m=i.itemSize,j.bindBuffer(j.ARRAY_BUFFER,i.buffer),h(l),j.vertexAttribPointer(l,
m,j.FLOAT,!1,0,0)):d.defaultAttributeValues&&d.defaultAttributeValues[k]&&(2===d.defaultAttributeValues[k].length?j.vertexAttrib2fv(l,d.defaultAttributeValues[k]):3===d.defaultAttributeValues[k].length&&j.vertexAttrib3fv(l,d.defaultAttributeValues[k])));d=a.position;j.drawArrays(j.POINTS,0,d.numItems/3);K.info.render.calls++;K.info.render.points+=d.numItems/3}}else if(f instanceof THREE.Line&&c){for(k in b)l=b[k],i=a[k],0<=l&&(i?(m=i.itemSize,j.bindBuffer(j.ARRAY_BUFFER,i.buffer),h(l),j.vertexAttribPointer(l,
m,j.FLOAT,!1,0,0)):d.defaultAttributeValues&&d.defaultAttributeValues[k]&&(2===d.defaultAttributeValues[k].length?j.vertexAttrib2fv(l,d.defaultAttributeValues[k]):3===d.defaultAttributeValues[k].length&&j.vertexAttrib3fv(l,d.defaultAttributeValues[k])));k=f.type===THREE.LineStrip?j.LINE_STRIP:j.LINES;F(d.linewidth);d=a.position;j.drawArrays(k,0,d.numItems/3);K.info.render.calls++;K.info.render.points+=d.numItems}}};this.renderBuffer=function(a,b,c,d,e,f){if(!1!==d.visible){var i,l,c=z(a,b,c,d,f),
a=c.attributes,b=!1,c=16777215*e.id+2*c.id+(d.wireframe?1:0);c!==$&&($=c,b=!0);b&&g();if(!d.morphTargets&&0<=a.position)b&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglVertexBuffer),h(a.position),j.vertexAttribPointer(a.position,3,j.FLOAT,!1,0,0));else if(f.morphTargetBase){c=d.program.attributes;-1!==f.morphTargetBase&&0<=c.position?(j.bindBuffer(j.ARRAY_BUFFER,e.__webglMorphTargetsBuffers[f.morphTargetBase]),h(c.position),j.vertexAttribPointer(c.position,3,j.FLOAT,!1,0,0)):0<=c.position&&(j.bindBuffer(j.ARRAY_BUFFER,
e.__webglVertexBuffer),h(c.position),j.vertexAttribPointer(c.position,3,j.FLOAT,!1,0,0));if(f.morphTargetForcedOrder.length){var m=0;l=f.morphTargetForcedOrder;for(i=f.morphTargetInfluences;m<d.numSupportedMorphTargets&&m<l.length;)0<=c["morphTarget"+m]&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglMorphTargetsBuffers[l[m]]),h(c["morphTarget"+m]),j.vertexAttribPointer(c["morphTarget"+m],3,j.FLOAT,!1,0,0)),0<=c["morphNormal"+m]&&d.morphNormals&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglMorphNormalsBuffers[l[m]]),
h(c["morphNormal"+m]),j.vertexAttribPointer(c["morphNormal"+m],3,j.FLOAT,!1,0,0)),f.__webglMorphTargetInfluences[m]=i[l[m]],m++}else{l=[];i=f.morphTargetInfluences;var p,n=i.length;for(p=0;p<n;p++)m=i[p],0<m&&l.push([m,p]);l.length>d.numSupportedMorphTargets?(l.sort(k),l.length=d.numSupportedMorphTargets):l.length>d.numSupportedMorphNormals?l.sort(k):0===l.length&&l.push([0,0]);for(m=0;m<d.numSupportedMorphTargets;)l[m]?(p=l[m][1],0<=c["morphTarget"+m]&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglMorphTargetsBuffers[p]),
h(c["morphTarget"+m]),j.vertexAttribPointer(c["morphTarget"+m],3,j.FLOAT,!1,0,0)),0<=c["morphNormal"+m]&&d.morphNormals&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglMorphNormalsBuffers[p]),h(c["morphNormal"+m]),j.vertexAttribPointer(c["morphNormal"+m],3,j.FLOAT,!1,0,0)),f.__webglMorphTargetInfluences[m]=i[p]):f.__webglMorphTargetInfluences[m]=0,m++}null!==d.program.uniforms.morphTargetInfluences&&j.uniform1fv(d.program.uniforms.morphTargetInfluences,f.__webglMorphTargetInfluences)}if(b){if(e.__webglCustomAttributesList){i=
0;for(l=e.__webglCustomAttributesList.length;i<l;i++)c=e.__webglCustomAttributesList[i],0<=a[c.buffer.belongsToAttribute]&&(j.bindBuffer(j.ARRAY_BUFFER,c.buffer),h(a[c.buffer.belongsToAttribute]),j.vertexAttribPointer(a[c.buffer.belongsToAttribute],c.size,j.FLOAT,!1,0,0))}0<=a.color&&(0<f.geometry.colors.length||0<f.geometry.faces.length?(j.bindBuffer(j.ARRAY_BUFFER,e.__webglColorBuffer),h(a.color),j.vertexAttribPointer(a.color,3,j.FLOAT,!1,0,0)):d.defaultAttributeValues&&j.vertexAttrib3fv(a.color,
d.defaultAttributeValues.color));0<=a.normal&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglNormalBuffer),h(a.normal),j.vertexAttribPointer(a.normal,3,j.FLOAT,!1,0,0));0<=a.tangent&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglTangentBuffer),h(a.tangent),j.vertexAttribPointer(a.tangent,4,j.FLOAT,!1,0,0));0<=a.uv&&(f.geometry.faceVertexUvs[0]?(j.bindBuffer(j.ARRAY_BUFFER,e.__webglUVBuffer),h(a.uv),j.vertexAttribPointer(a.uv,2,j.FLOAT,!1,0,0)):d.defaultAttributeValues&&j.vertexAttrib2fv(a.uv,d.defaultAttributeValues.uv));
0<=a.uv2&&(f.geometry.faceVertexUvs[1]?(j.bindBuffer(j.ARRAY_BUFFER,e.__webglUV2Buffer),h(a.uv2),j.vertexAttribPointer(a.uv2,2,j.FLOAT,!1,0,0)):d.defaultAttributeValues&&j.vertexAttrib2fv(a.uv2,d.defaultAttributeValues.uv2));d.skinning&&(0<=a.skinIndex&&0<=a.skinWeight)&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglSkinIndicesBuffer),h(a.skinIndex),j.vertexAttribPointer(a.skinIndex,4,j.FLOAT,!1,0,0),j.bindBuffer(j.ARRAY_BUFFER,e.__webglSkinWeightsBuffer),h(a.skinWeight),j.vertexAttribPointer(a.skinWeight,
4,j.FLOAT,!1,0,0));0<=a.lineDistance&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglLineDistanceBuffer),h(a.lineDistance),j.vertexAttribPointer(a.lineDistance,1,j.FLOAT,!1,0,0))}f instanceof THREE.Mesh?(d.wireframe?(F(d.wireframeLinewidth),b&&j.bindBuffer(j.ELEMENT_ARRAY_BUFFER,e.__webglLineBuffer),j.drawElements(j.LINES,e.__webglLineCount,j.UNSIGNED_SHORT,0)):(b&&j.bindBuffer(j.ELEMENT_ARRAY_BUFFER,e.__webglFaceBuffer),j.drawElements(j.TRIANGLES,e.__webglFaceCount,j.UNSIGNED_SHORT,0)),K.info.render.calls++,
K.info.render.vertices+=e.__webglFaceCount,K.info.render.faces+=e.__webglFaceCount/3):f instanceof THREE.Line?(f=f.type===THREE.LineStrip?j.LINE_STRIP:j.LINES,F(d.linewidth),j.drawArrays(f,0,e.__webglLineCount),K.info.render.calls++):f instanceof THREE.ParticleSystem&&(j.drawArrays(j.POINTS,0,e.__webglParticleCount),K.info.render.calls++,K.info.render.points+=e.__webglParticleCount)}};this.render=function(a,b,c,d){if(!1===b instanceof THREE.Camera)console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
else{var e,f,h,g,k=a.__lights,n=a.fog;Aa=-1;ua=!0;!0===a.autoUpdate&&a.updateMatrixWorld();void 0===b.parent&&b.updateMatrixWorld();b.matrixWorldInverse.getInverse(b.matrixWorld);ra.multiplyMatrices(b.projectionMatrix,b.matrixWorldInverse);la.setFromMatrix(ra);this.autoUpdateObjects&&this.initWebGLObjects(a);m(this.renderPluginsPre,a,b);K.info.render.calls=0;K.info.render.vertices=0;K.info.render.faces=0;K.info.render.points=0;this.setRenderTarget(c);(this.autoClear||d)&&this.clear(this.autoClearColor,
this.autoClearDepth,this.autoClearStencil);g=a.__webglObjects;d=0;for(e=g.length;d<e;d++)if(f=g[d],h=f.object,f.id=d,f.render=!1,h.visible&&(!(h instanceof THREE.Mesh||h instanceof THREE.ParticleSystem)||!h.frustumCulled||la.intersectsObject(h))){var q=h;q._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse,q.matrixWorld);q._normalMatrix.getNormalMatrix(q._modelViewMatrix);var q=f,r=q.buffer,s=void 0,t=s=void 0,t=q.object.material;if(t instanceof THREE.MeshFaceMaterial)s=r.materialIndex,s=t.materials[s],
s.transparent?(q.transparent=s,q.opaque=null):(q.opaque=s,q.transparent=null);else if(s=t)s.transparent?(q.transparent=s,q.opaque=null):(q.opaque=s,q.transparent=null);f.render=!0;!0===this.sortObjects&&(null!==h.renderDepth?f.z=h.renderDepth:(sa.getPositionFromMatrix(h.matrixWorld),sa.applyProjection(ra),f.z=sa.z))}this.sortObjects&&g.sort(i);g=a.__webglObjectsImmediate;d=0;for(e=g.length;d<e;d++)f=g[d],h=f.object,h.visible&&(h._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse,h.matrixWorld),
h._normalMatrix.getNormalMatrix(h._modelViewMatrix),h=f.object.material,h.transparent?(f.transparent=h,f.opaque=null):(f.opaque=h,f.transparent=null));a.overrideMaterial?(d=a.overrideMaterial,this.setBlending(d.blending,d.blendEquation,d.blendSrc,d.blendDst),this.setDepthTest(d.depthTest),this.setDepthWrite(d.depthWrite),A(d.polygonOffset,d.polygonOffsetFactor,d.polygonOffsetUnits),l(a.__webglObjects,!1,"",b,k,n,!0,d),p(a.__webglObjectsImmediate,"",b,k,n,!1,d)):(d=null,this.setBlending(THREE.NoBlending),
l(a.__webglObjects,!0,"opaque",b,k,n,!1,d),p(a.__webglObjectsImmediate,"opaque",b,k,n,!1,d),l(a.__webglObjects,!1,"transparent",b,k,n,!0,d),p(a.__webglObjectsImmediate,"transparent",b,k,n,!0,d));m(this.renderPluginsPost,a,b);c&&(c.generateMipmaps&&c.minFilter!==THREE.NearestFilter&&c.minFilter!==THREE.LinearFilter)&&(c instanceof THREE.WebGLRenderTargetCube?(j.bindTexture(j.TEXTURE_CUBE_MAP,c.__webglTexture),j.generateMipmap(j.TEXTURE_CUBE_MAP),j.bindTexture(j.TEXTURE_CUBE_MAP,null)):(j.bindTexture(j.TEXTURE_2D,
c.__webglTexture),j.generateMipmap(j.TEXTURE_2D),j.bindTexture(j.TEXTURE_2D,null)));this.setDepthTest(!0);this.setDepthWrite(!0)}};this.renderImmediateObject=function(a,b,c,d,e){var f=z(a,b,c,d,e);$=-1;K.setMaterialFaces(d);e.immediateRenderCallback?e.immediateRenderCallback(f,j,la):e.render(function(a){K.renderBufferImmediate(a,f,d)})};this.initWebGLObjects=function(a){a.__webglObjects||(a.__webglObjects=[],a.__webglObjectsImmediate=[],a.__webglSprites=[],a.__webglFlares=[]);for(;a.__objectsAdded.length;)s(a.__objectsAdded[0],
a),a.__objectsAdded.splice(0,1);for(;a.__objectsRemoved.length;)q(a.__objectsRemoved[0],a),a.__objectsRemoved.splice(0,1);for(var b=0,h=a.__webglObjects.length;b<h;b++){var g=a.__webglObjects[b].object;void 0===g.__webglInit&&(void 0!==g.__webglActive&&q(g,a),s(g,a));var i=g,l=i.geometry,m=void 0,p=void 0,t=void 0;if(l instanceof THREE.BufferGeometry){var u=j.DYNAMIC_DRAW,w=!l.dynamic,z=l.attributes,y=void 0,x=void 0;for(y in z)x=z[y],x.needsUpdate&&("index"===y?(j.bindBuffer(j.ELEMENT_ARRAY_BUFFER,
x.buffer),j.bufferData(j.ELEMENT_ARRAY_BUFFER,x.array,u)):(j.bindBuffer(j.ARRAY_BUFFER,x.buffer),j.bufferData(j.ARRAY_BUFFER,x.array,u)),x.needsUpdate=!1),w&&!x.dynamic&&(x.array=null)}else if(i instanceof THREE.Mesh){for(var A=0,B=l.geometryGroupsList.length;A<B;A++)if(m=l.geometryGroupsList[A],t=d(i,m),l.buffersNeedUpdate&&c(m,i),p=t.attributes&&n(t),l.verticesNeedUpdate||l.morphTargetsNeedUpdate||l.elementsNeedUpdate||l.uvsNeedUpdate||l.normalsNeedUpdate||l.colorsNeedUpdate||l.tangentsNeedUpdate||
p){var v=m,C=i,D=j.DYNAMIC_DRAW,F=!l.dynamic,G=t;if(v.__inittedArrays){var J=e(G),K=G.vertexColors?G.vertexColors:!1,N=f(G),O=J===THREE.SmoothShading,E=void 0,I=void 0,V=void 0,M=void 0,R=void 0,U=void 0,Q=void 0,da=void 0,Z=void 0,$=void 0,Fa=void 0,P=void 0,X=void 0,W=void 0,Ba=void 0,ea=void 0,Aa=void 0,ba=void 0,ca=void 0,ia=void 0,fa=void 0,ga=void 0,ka=void 0,la=void 0,oa=void 0,pa=void 0,ta=void 0,ua=void 0,va=void 0,Ca=void 0,Da=void 0,Ga=void 0,Ea=void 0,La=void 0,Sa=void 0,Ha=void 0,wa=
void 0,xa=void 0,Qa=void 0,Ra=void 0,db=0,eb=0,Oa=0,Pa=0,Ua=0,hb=0,Ta=0,tb=0,Za=0,qa=0,ya=0,L=0,Na=void 0,ib=v.__vertexArray,bb=v.__uvArray,cb=v.__uv2Array,Ma=v.__normalArray,Va=v.__tangentArray,jb=v.__colorArray,Wa=v.__skinIndexArray,Xa=v.__skinWeightArray,fb=v.__morphTargetsArrays,sb=v.__morphNormalsArrays,pb=v.__webglCustomAttributesList,H=void 0,Pb=v.__faceArray,vb=v.__lineArray,Ia=C.geometry,Bb=Ia.elementsNeedUpdate,yb=Ia.uvsNeedUpdate,Db=Ia.normalsNeedUpdate,Mb=Ia.tangentsNeedUpdate,Nb=Ia.colorsNeedUpdate,
Ob=Ia.morphTargetsNeedUpdate,ec=Ia.vertices,aa=v.faces3,kb=Ia.faces,Cb=Ia.faceVertexUvs[0],Eb=Ia.faceVertexUvs[1],fc=Ia.skinIndices,Qb=Ia.skinWeights,Rb=Ia.morphTargets,Fb=Ia.morphNormals;if(Ia.verticesNeedUpdate){E=0;for(I=aa.length;E<I;E++)M=kb[aa[E]],P=ec[M.a],X=ec[M.b],W=ec[M.c],ib[eb]=P.x,ib[eb+1]=P.y,ib[eb+2]=P.z,ib[eb+3]=X.x,ib[eb+4]=X.y,ib[eb+5]=X.z,ib[eb+6]=W.x,ib[eb+7]=W.y,ib[eb+8]=W.z,eb+=9;j.bindBuffer(j.ARRAY_BUFFER,v.__webglVertexBuffer);j.bufferData(j.ARRAY_BUFFER,ib,D)}if(Ob){Sa=0;
for(Ha=Rb.length;Sa<Ha;Sa++){E=ya=0;for(I=aa.length;E<I;E++)Qa=aa[E],M=kb[Qa],P=Rb[Sa].vertices[M.a],X=Rb[Sa].vertices[M.b],W=Rb[Sa].vertices[M.c],wa=fb[Sa],wa[ya]=P.x,wa[ya+1]=P.y,wa[ya+2]=P.z,wa[ya+3]=X.x,wa[ya+4]=X.y,wa[ya+5]=X.z,wa[ya+6]=W.x,wa[ya+7]=W.y,wa[ya+8]=W.z,G.morphNormals&&(O?(Ra=Fb[Sa].vertexNormals[Qa],ba=Ra.a,ca=Ra.b,ia=Ra.c):ia=ca=ba=Fb[Sa].faceNormals[Qa],xa=sb[Sa],xa[ya]=ba.x,xa[ya+1]=ba.y,xa[ya+2]=ba.z,xa[ya+3]=ca.x,xa[ya+4]=ca.y,xa[ya+5]=ca.z,xa[ya+6]=ia.x,xa[ya+7]=ia.y,xa[ya+
8]=ia.z),ya+=9;j.bindBuffer(j.ARRAY_BUFFER,v.__webglMorphTargetsBuffers[Sa]);j.bufferData(j.ARRAY_BUFFER,fb[Sa],D);G.morphNormals&&(j.bindBuffer(j.ARRAY_BUFFER,v.__webglMorphNormalsBuffers[Sa]),j.bufferData(j.ARRAY_BUFFER,sb[Sa],D))}}if(Qb.length){E=0;for(I=aa.length;E<I;E++)M=kb[aa[E]],la=Qb[M.a],oa=Qb[M.b],pa=Qb[M.c],Xa[qa]=la.x,Xa[qa+1]=la.y,Xa[qa+2]=la.z,Xa[qa+3]=la.w,Xa[qa+4]=oa.x,Xa[qa+5]=oa.y,Xa[qa+6]=oa.z,Xa[qa+7]=oa.w,Xa[qa+8]=pa.x,Xa[qa+9]=pa.y,Xa[qa+10]=pa.z,Xa[qa+11]=pa.w,ta=fc[M.a],ua=
fc[M.b],va=fc[M.c],Wa[qa]=ta.x,Wa[qa+1]=ta.y,Wa[qa+2]=ta.z,Wa[qa+3]=ta.w,Wa[qa+4]=ua.x,Wa[qa+5]=ua.y,Wa[qa+6]=ua.z,Wa[qa+7]=ua.w,Wa[qa+8]=va.x,Wa[qa+9]=va.y,Wa[qa+10]=va.z,Wa[qa+11]=va.w,qa+=12;0<qa&&(j.bindBuffer(j.ARRAY_BUFFER,v.__webglSkinIndicesBuffer),j.bufferData(j.ARRAY_BUFFER,Wa,D),j.bindBuffer(j.ARRAY_BUFFER,v.__webglSkinWeightsBuffer),j.bufferData(j.ARRAY_BUFFER,Xa,D))}if(Nb&&K){E=0;for(I=aa.length;E<I;E++)M=kb[aa[E]],Q=M.vertexColors,da=M.color,3===Q.length&&K===THREE.VertexColors?(fa=
Q[0],ga=Q[1],ka=Q[2]):ka=ga=fa=da,jb[Za]=fa.r,jb[Za+1]=fa.g,jb[Za+2]=fa.b,jb[Za+3]=ga.r,jb[Za+4]=ga.g,jb[Za+5]=ga.b,jb[Za+6]=ka.r,jb[Za+7]=ka.g,jb[Za+8]=ka.b,Za+=9;0<Za&&(j.bindBuffer(j.ARRAY_BUFFER,v.__webglColorBuffer),j.bufferData(j.ARRAY_BUFFER,jb,D))}if(Mb&&Ia.hasTangents){E=0;for(I=aa.length;E<I;E++)M=kb[aa[E]],Z=M.vertexTangents,Ba=Z[0],ea=Z[1],Aa=Z[2],Va[Ta]=Ba.x,Va[Ta+1]=Ba.y,Va[Ta+2]=Ba.z,Va[Ta+3]=Ba.w,Va[Ta+4]=ea.x,Va[Ta+5]=ea.y,Va[Ta+6]=ea.z,Va[Ta+7]=ea.w,Va[Ta+8]=Aa.x,Va[Ta+9]=Aa.y,Va[Ta+
10]=Aa.z,Va[Ta+11]=Aa.w,Ta+=12;j.bindBuffer(j.ARRAY_BUFFER,v.__webglTangentBuffer);j.bufferData(j.ARRAY_BUFFER,Va,D)}if(Db&&J){E=0;for(I=aa.length;E<I;E++)if(M=kb[aa[E]],R=M.vertexNormals,U=M.normal,3===R.length&&O)for(Ca=0;3>Ca;Ca++)Ga=R[Ca],Ma[hb]=Ga.x,Ma[hb+1]=Ga.y,Ma[hb+2]=Ga.z,hb+=3;else for(Ca=0;3>Ca;Ca++)Ma[hb]=U.x,Ma[hb+1]=U.y,Ma[hb+2]=U.z,hb+=3;j.bindBuffer(j.ARRAY_BUFFER,v.__webglNormalBuffer);j.bufferData(j.ARRAY_BUFFER,Ma,D)}if(yb&&Cb&&N){E=0;for(I=aa.length;E<I;E++)if(V=aa[E],$=Cb[V],
void 0!==$)for(Ca=0;3>Ca;Ca++)Ea=$[Ca],bb[Oa]=Ea.x,bb[Oa+1]=Ea.y,Oa+=2;0<Oa&&(j.bindBuffer(j.ARRAY_BUFFER,v.__webglUVBuffer),j.bufferData(j.ARRAY_BUFFER,bb,D))}if(yb&&Eb&&N){E=0;for(I=aa.length;E<I;E++)if(V=aa[E],Fa=Eb[V],void 0!==Fa)for(Ca=0;3>Ca;Ca++)La=Fa[Ca],cb[Pa]=La.x,cb[Pa+1]=La.y,Pa+=2;0<Pa&&(j.bindBuffer(j.ARRAY_BUFFER,v.__webglUV2Buffer),j.bufferData(j.ARRAY_BUFFER,cb,D))}if(Bb){E=0;for(I=aa.length;E<I;E++)Pb[Ua]=db,Pb[Ua+1]=db+1,Pb[Ua+2]=db+2,Ua+=3,vb[tb]=db,vb[tb+1]=db+1,vb[tb+2]=db,vb[tb+
3]=db+2,vb[tb+4]=db+1,vb[tb+5]=db+2,tb+=6,db+=3;j.bindBuffer(j.ELEMENT_ARRAY_BUFFER,v.__webglFaceBuffer);j.bufferData(j.ELEMENT_ARRAY_BUFFER,Pb,D);j.bindBuffer(j.ELEMENT_ARRAY_BUFFER,v.__webglLineBuffer);j.bufferData(j.ELEMENT_ARRAY_BUFFER,vb,D)}if(pb){Ca=0;for(Da=pb.length;Ca<Da;Ca++)if(H=pb[Ca],H.__original.needsUpdate){L=0;if(1===H.size)if(void 0===H.boundTo||"vertices"===H.boundTo){E=0;for(I=aa.length;E<I;E++)M=kb[aa[E]],H.array[L]=H.value[M.a],H.array[L+1]=H.value[M.b],H.array[L+2]=H.value[M.c],
L+=3}else{if("faces"===H.boundTo){E=0;for(I=aa.length;E<I;E++)Na=H.value[aa[E]],H.array[L]=Na,H.array[L+1]=Na,H.array[L+2]=Na,L+=3}}else if(2===H.size)if(void 0===H.boundTo||"vertices"===H.boundTo){E=0;for(I=aa.length;E<I;E++)M=kb[aa[E]],P=H.value[M.a],X=H.value[M.b],W=H.value[M.c],H.array[L]=P.x,H.array[L+1]=P.y,H.array[L+2]=X.x,H.array[L+3]=X.y,H.array[L+4]=W.x,H.array[L+5]=W.y,L+=6}else{if("faces"===H.boundTo){E=0;for(I=aa.length;E<I;E++)W=X=P=Na=H.value[aa[E]],H.array[L]=P.x,H.array[L+1]=P.y,
H.array[L+2]=X.x,H.array[L+3]=X.y,H.array[L+4]=W.x,H.array[L+5]=W.y,L+=6}}else if(3===H.size){var na;na="c"===H.type?["r","g","b"]:["x","y","z"];if(void 0===H.boundTo||"vertices"===H.boundTo){E=0;for(I=aa.length;E<I;E++)M=kb[aa[E]],P=H.value[M.a],X=H.value[M.b],W=H.value[M.c],H.array[L]=P[na[0]],H.array[L+1]=P[na[1]],H.array[L+2]=P[na[2]],H.array[L+3]=X[na[0]],H.array[L+4]=X[na[1]],H.array[L+5]=X[na[2]],H.array[L+6]=W[na[0]],H.array[L+7]=W[na[1]],H.array[L+8]=W[na[2]],L+=9}else if("faces"===H.boundTo){E=
0;for(I=aa.length;E<I;E++)W=X=P=Na=H.value[aa[E]],H.array[L]=P[na[0]],H.array[L+1]=P[na[1]],H.array[L+2]=P[na[2]],H.array[L+3]=X[na[0]],H.array[L+4]=X[na[1]],H.array[L+5]=X[na[2]],H.array[L+6]=W[na[0]],H.array[L+7]=W[na[1]],H.array[L+8]=W[na[2]],L+=9}else if("faceVertices"===H.boundTo){E=0;for(I=aa.length;E<I;E++)Na=H.value[aa[E]],P=Na[0],X=Na[1],W=Na[2],H.array[L]=P[na[0]],H.array[L+1]=P[na[1]],H.array[L+2]=P[na[2]],H.array[L+3]=X[na[0]],H.array[L+4]=X[na[1]],H.array[L+5]=X[na[2]],H.array[L+6]=W[na[0]],
H.array[L+7]=W[na[1]],H.array[L+8]=W[na[2]],L+=9}}else if(4===H.size)if(void 0===H.boundTo||"vertices"===H.boundTo){E=0;for(I=aa.length;E<I;E++)M=kb[aa[E]],P=H.value[M.a],X=H.value[M.b],W=H.value[M.c],H.array[L]=P.x,H.array[L+1]=P.y,H.array[L+2]=P.z,H.array[L+3]=P.w,H.array[L+4]=X.x,H.array[L+5]=X.y,H.array[L+6]=X.z,H.array[L+7]=X.w,H.array[L+8]=W.x,H.array[L+9]=W.y,H.array[L+10]=W.z,H.array[L+11]=W.w,L+=12}else if("faces"===H.boundTo){E=0;for(I=aa.length;E<I;E++)W=X=P=Na=H.value[aa[E]],H.array[L]=
P.x,H.array[L+1]=P.y,H.array[L+2]=P.z,H.array[L+3]=P.w,H.array[L+4]=X.x,H.array[L+5]=X.y,H.array[L+6]=X.z,H.array[L+7]=X.w,H.array[L+8]=W.x,H.array[L+9]=W.y,H.array[L+10]=W.z,H.array[L+11]=W.w,L+=12}else if("faceVertices"===H.boundTo){E=0;for(I=aa.length;E<I;E++)Na=H.value[aa[E]],P=Na[0],X=Na[1],W=Na[2],H.array[L]=P.x,H.array[L+1]=P.y,H.array[L+2]=P.z,H.array[L+3]=P.w,H.array[L+4]=X.x,H.array[L+5]=X.y,H.array[L+6]=X.z,H.array[L+7]=X.w,H.array[L+8]=W.x,H.array[L+9]=W.y,H.array[L+10]=W.z,H.array[L+
11]=W.w,L+=12}j.bindBuffer(j.ARRAY_BUFFER,H.buffer);j.bufferData(j.ARRAY_BUFFER,H.array,D)}}F&&(delete v.__inittedArrays,delete v.__colorArray,delete v.__normalArray,delete v.__tangentArray,delete v.__uvArray,delete v.__uv2Array,delete v.__faceArray,delete v.__vertexArray,delete v.__lineArray,delete v.__skinIndexArray,delete v.__skinWeightArray)}}l.verticesNeedUpdate=!1;l.morphTargetsNeedUpdate=!1;l.elementsNeedUpdate=!1;l.uvsNeedUpdate=!1;l.normalsNeedUpdate=!1;l.colorsNeedUpdate=!1;l.tangentsNeedUpdate=
!1;l.buffersNeedUpdate=!1;t.attributes&&r(t)}else if(i instanceof THREE.Line){t=d(i,l);p=t.attributes&&n(t);if(l.verticesNeedUpdate||l.colorsNeedUpdate||l.lineDistancesNeedUpdate||p){var Ya=l,Sb=j.DYNAMIC_DRAW,Ib=void 0,Jb=void 0,Kb=void 0,Tb=void 0,ma=void 0,Ub=void 0,Gb=Ya.vertices,Hb=Ya.colors,kc=Ya.lineDistances,Zb=Gb.length,$b=Hb.length,ac=kc.length,Vb=Ya.__vertexArray,Wb=Ya.__colorArray,lc=Ya.__lineDistanceArray,bc=Ya.colorsNeedUpdate,cc=Ya.lineDistancesNeedUpdate,gc=Ya.__webglCustomAttributesList,
Xb=void 0,mc=void 0,za=void 0,zb=void 0,Ja=void 0,ja=void 0;if(Ya.verticesNeedUpdate){for(Ib=0;Ib<Zb;Ib++)Tb=Gb[Ib],ma=3*Ib,Vb[ma]=Tb.x,Vb[ma+1]=Tb.y,Vb[ma+2]=Tb.z;j.bindBuffer(j.ARRAY_BUFFER,Ya.__webglVertexBuffer);j.bufferData(j.ARRAY_BUFFER,Vb,Sb)}if(bc){for(Jb=0;Jb<$b;Jb++)Ub=Hb[Jb],ma=3*Jb,Wb[ma]=Ub.r,Wb[ma+1]=Ub.g,Wb[ma+2]=Ub.b;j.bindBuffer(j.ARRAY_BUFFER,Ya.__webglColorBuffer);j.bufferData(j.ARRAY_BUFFER,Wb,Sb)}if(cc){for(Kb=0;Kb<ac;Kb++)lc[Kb]=kc[Kb];j.bindBuffer(j.ARRAY_BUFFER,Ya.__webglLineDistanceBuffer);
j.bufferData(j.ARRAY_BUFFER,lc,Sb)}if(gc){Xb=0;for(mc=gc.length;Xb<mc;Xb++)if(ja=gc[Xb],ja.needsUpdate&&(void 0===ja.boundTo||"vertices"===ja.boundTo)){ma=0;zb=ja.value.length;if(1===ja.size)for(za=0;za<zb;za++)ja.array[za]=ja.value[za];else if(2===ja.size)for(za=0;za<zb;za++)Ja=ja.value[za],ja.array[ma]=Ja.x,ja.array[ma+1]=Ja.y,ma+=2;else if(3===ja.size)if("c"===ja.type)for(za=0;za<zb;za++)Ja=ja.value[za],ja.array[ma]=Ja.r,ja.array[ma+1]=Ja.g,ja.array[ma+2]=Ja.b,ma+=3;else for(za=0;za<zb;za++)Ja=
ja.value[za],ja.array[ma]=Ja.x,ja.array[ma+1]=Ja.y,ja.array[ma+2]=Ja.z,ma+=3;else if(4===ja.size)for(za=0;za<zb;za++)Ja=ja.value[za],ja.array[ma]=Ja.x,ja.array[ma+1]=Ja.y,ja.array[ma+2]=Ja.z,ja.array[ma+3]=Ja.w,ma+=4;j.bindBuffer(j.ARRAY_BUFFER,ja.buffer);j.bufferData(j.ARRAY_BUFFER,ja.array,Sb)}}}l.verticesNeedUpdate=!1;l.colorsNeedUpdate=!1;l.lineDistancesNeedUpdate=!1;t.attributes&&r(t)}else if(i instanceof THREE.ParticleSystem){t=d(i,l);p=t.attributes&&n(t);if(l.verticesNeedUpdate||l.colorsNeedUpdate||
i.sortParticles||p){var lb=l,hc=j.DYNAMIC_DRAW,Lb=i,Ka=void 0,mb=void 0,nb=void 0,T=void 0,ob=void 0,ub=void 0,Yb=lb.vertices,ic=Yb.length,jc=lb.colors,nc=jc.length,wb=lb.__vertexArray,xb=lb.__colorArray,qb=lb.__sortArray,oc=lb.verticesNeedUpdate,pc=lb.colorsNeedUpdate,rb=lb.__webglCustomAttributesList,$a=void 0,Ab=void 0,Y=void 0,ab=void 0,ha=void 0,S=void 0;if(Lb.sortParticles){gb.copy(ra);gb.multiply(Lb.matrixWorld);for(Ka=0;Ka<ic;Ka++)nb=Yb[Ka],sa.copy(nb),sa.applyProjection(gb),qb[Ka]=[sa.z,
Ka];qb.sort(k);for(Ka=0;Ka<ic;Ka++)nb=Yb[qb[Ka][1]],T=3*Ka,wb[T]=nb.x,wb[T+1]=nb.y,wb[T+2]=nb.z;for(mb=0;mb<nc;mb++)T=3*mb,ub=jc[qb[mb][1]],xb[T]=ub.r,xb[T+1]=ub.g,xb[T+2]=ub.b;if(rb){$a=0;for(Ab=rb.length;$a<Ab;$a++)if(S=rb[$a],void 0===S.boundTo||"vertices"===S.boundTo)if(T=0,ab=S.value.length,1===S.size)for(Y=0;Y<ab;Y++)ob=qb[Y][1],S.array[Y]=S.value[ob];else if(2===S.size)for(Y=0;Y<ab;Y++)ob=qb[Y][1],ha=S.value[ob],S.array[T]=ha.x,S.array[T+1]=ha.y,T+=2;else if(3===S.size)if("c"===S.type)for(Y=
0;Y<ab;Y++)ob=qb[Y][1],ha=S.value[ob],S.array[T]=ha.r,S.array[T+1]=ha.g,S.array[T+2]=ha.b,T+=3;else for(Y=0;Y<ab;Y++)ob=qb[Y][1],ha=S.value[ob],S.array[T]=ha.x,S.array[T+1]=ha.y,S.array[T+2]=ha.z,T+=3;else if(4===S.size)for(Y=0;Y<ab;Y++)ob=qb[Y][1],ha=S.value[ob],S.array[T]=ha.x,S.array[T+1]=ha.y,S.array[T+2]=ha.z,S.array[T+3]=ha.w,T+=4}}else{if(oc)for(Ka=0;Ka<ic;Ka++)nb=Yb[Ka],T=3*Ka,wb[T]=nb.x,wb[T+1]=nb.y,wb[T+2]=nb.z;if(pc)for(mb=0;mb<nc;mb++)ub=jc[mb],T=3*mb,xb[T]=ub.r,xb[T+1]=ub.g,xb[T+2]=ub.b;
if(rb){$a=0;for(Ab=rb.length;$a<Ab;$a++)if(S=rb[$a],S.needsUpdate&&(void 0===S.boundTo||"vertices"===S.boundTo))if(ab=S.value.length,T=0,1===S.size)for(Y=0;Y<ab;Y++)S.array[Y]=S.value[Y];else if(2===S.size)for(Y=0;Y<ab;Y++)ha=S.value[Y],S.array[T]=ha.x,S.array[T+1]=ha.y,T+=2;else if(3===S.size)if("c"===S.type)for(Y=0;Y<ab;Y++)ha=S.value[Y],S.array[T]=ha.r,S.array[T+1]=ha.g,S.array[T+2]=ha.b,T+=3;else for(Y=0;Y<ab;Y++)ha=S.value[Y],S.array[T]=ha.x,S.array[T+1]=ha.y,S.array[T+2]=ha.z,T+=3;else if(4===
S.size)for(Y=0;Y<ab;Y++)ha=S.value[Y],S.array[T]=ha.x,S.array[T+1]=ha.y,S.array[T+2]=ha.z,S.array[T+3]=ha.w,T+=4}}if(oc||Lb.sortParticles)j.bindBuffer(j.ARRAY_BUFFER,lb.__webglVertexBuffer),j.bufferData(j.ARRAY_BUFFER,wb,hc);if(pc||Lb.sortParticles)j.bindBuffer(j.ARRAY_BUFFER,lb.__webglColorBuffer),j.bufferData(j.ARRAY_BUFFER,xb,hc);if(rb){$a=0;for(Ab=rb.length;$a<Ab;$a++)if(S=rb[$a],S.needsUpdate||Lb.sortParticles)j.bindBuffer(j.ARRAY_BUFFER,S.buffer),j.bufferData(j.ARRAY_BUFFER,S.array,hc)}}l.verticesNeedUpdate=
!1;l.colorsNeedUpdate=!1;t.attributes&&r(t)}}};this.initMaterial=function(a,b,c,d){var e,f,h,g;a.addEventListener("dispose",Fb);var i,k,l,m,p;a instanceof THREE.MeshDepthMaterial?p="depth":a instanceof THREE.MeshNormalMaterial?p="normal":a instanceof THREE.MeshBasicMaterial?p="basic":a instanceof THREE.MeshLambertMaterial?p="lambert":a instanceof THREE.MeshPhongMaterial?p="phong":a instanceof THREE.LineBasicMaterial?p="basic":a instanceof THREE.LineDashedMaterial?p="dashed":a instanceof THREE.ParticleSystemMaterial&&
(p="particle_basic");if(p){var n=THREE.ShaderLib[p];a.uniforms=THREE.UniformsUtils.clone(n.uniforms);a.vertexShader=n.vertexShader;a.fragmentShader=n.fragmentShader}var q=e=0,r=0,t=n=0;for(f=b.length;t<f;t++)h=b[t],h.onlyShadow||(h instanceof THREE.DirectionalLight&&e++,h instanceof THREE.PointLight&&q++,h instanceof THREE.SpotLight&&r++,h instanceof THREE.HemisphereLight&&n++);f=q;h=r;g=n;r=n=0;for(q=b.length;r<q;r++)t=b[r],t.castShadow&&(t instanceof THREE.SpotLight&&n++,t instanceof THREE.DirectionalLight&&
!t.shadowCascade&&n++);m=n;yb&&d&&d.useVertexTexture?l=1024:(b=j.getParameter(j.MAX_VERTEX_UNIFORM_VECTORS),b=Math.floor((b-20)/4),void 0!==d&&d instanceof THREE.SkinnedMesh&&(b=Math.min(d.bones.length,b),b<d.bones.length&&console.warn("WebGLRenderer: too many bones - "+d.bones.length+", this GPU supports just "+b+" (try OpenGL instead of ANGLE)")),l=b);a:{var r=a.fragmentShader,q=a.vertexShader,n=a.uniforms,b=a.attributes,t=a.defines,c={map:!!a.map,envMap:!!a.envMap,lightMap:!!a.lightMap,bumpMap:!!a.bumpMap,
normalMap:!!a.normalMap,specularMap:!!a.specularMap,vertexColors:a.vertexColors,fog:c,useFog:a.fog,fogExp:c instanceof THREE.FogExp2,sizeAttenuation:a.sizeAttenuation,skinning:a.skinning,maxBones:l,useVertexTexture:yb&&d&&d.useVertexTexture,morphTargets:a.morphTargets,morphNormals:a.morphNormals,maxMorphTargets:this.maxMorphTargets,maxMorphNormals:this.maxMorphNormals,maxDirLights:e,maxPointLights:f,maxSpotLights:h,maxHemiLights:g,maxShadows:m,shadowMapEnabled:this.shadowMapEnabled&&d.receiveShadow,
shadowMapType:this.shadowMapType,shadowMapDebug:this.shadowMapDebug,shadowMapCascade:this.shadowMapCascade,alphaTest:a.alphaTest,metal:a.metal,perPixel:a.perPixel,wrapAround:a.wrapAround,doubleSided:a.side===THREE.DoubleSide,flipSided:a.side===THREE.BackSide},d=a.index0AttributeName,s,u,w;e=[];p?e.push(p):(e.push(r),e.push(q));for(u in t)e.push(u),e.push(t[u]);for(s in c)e.push(s),e.push(c[s]);p=e.join();s=0;for(u=ca.length;s<u;s++)if(e=ca[s],e.code===p){e.usedTimes++;k=e.program;break a}s="SHADOWMAP_TYPE_BASIC";
c.shadowMapType===THREE.PCFShadowMap?s="SHADOWMAP_TYPE_PCF":c.shadowMapType===THREE.PCFSoftShadowMap&&(s="SHADOWMAP_TYPE_PCF_SOFT");u=[];for(w in t)e=t[w],!1!==e&&(e="#define "+w+" "+e,u.push(e));e=u.join("\n");w=j.createProgram();u=["precision "+R+" float;","precision "+R+" int;",e,Bb?"#define VERTEX_TEXTURES":"",K.gammaInput?"#define GAMMA_INPUT":"",K.gammaOutput?"#define GAMMA_OUTPUT":"",K.physicallyBasedShading?"#define PHYSICALLY_BASED_SHADING":"","#define MAX_DIR_LIGHTS "+c.maxDirLights,"#define MAX_POINT_LIGHTS "+
c.maxPointLights,"#define MAX_SPOT_LIGHTS "+c.maxSpotLights,"#define MAX_HEMI_LIGHTS "+c.maxHemiLights,"#define MAX_SHADOWS "+c.maxShadows,"#define MAX_BONES "+c.maxBones,c.map?"#define USE_MAP":"",c.envMap?"#define USE_ENVMAP":"",c.lightMap?"#define USE_LIGHTMAP":"",c.bumpMap?"#define USE_BUMPMAP":"",c.normalMap?"#define USE_NORMALMAP":"",c.specularMap?"#define USE_SPECULARMAP":"",c.vertexColors?"#define USE_COLOR":"",c.skinning?"#define USE_SKINNING":"",c.useVertexTexture?"#define BONE_TEXTURE":
"",c.morphTargets?"#define USE_MORPHTARGETS":"",c.morphNormals?"#define USE_MORPHNORMALS":"",c.perPixel?"#define PHONG_PER_PIXEL":"",c.wrapAround?"#define WRAP_AROUND":"",c.doubleSided?"#define DOUBLE_SIDED":"",c.flipSided?"#define FLIP_SIDED":"",c.shadowMapEnabled?"#define USE_SHADOWMAP":"",c.shadowMapEnabled?"#define "+s:"",c.shadowMapDebug?"#define SHADOWMAP_DEBUG":"",c.shadowMapCascade?"#define SHADOWMAP_CASCADE":"",c.sizeAttenuation?"#define USE_SIZEATTENUATION":"","uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\nattribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\nattribute vec3 morphTarget0;\nattribute vec3 morphTarget1;\nattribute vec3 morphTarget2;\nattribute vec3 morphTarget3;\n#ifdef USE_MORPHNORMALS\nattribute vec3 morphNormal0;\nattribute vec3 morphNormal1;\nattribute vec3 morphNormal2;\nattribute vec3 morphNormal3;\n#else\nattribute vec3 morphTarget4;\nattribute vec3 morphTarget5;\nattribute vec3 morphTarget6;\nattribute vec3 morphTarget7;\n#endif\n#endif\n#ifdef USE_SKINNING\nattribute vec4 skinIndex;\nattribute vec4 skinWeight;\n#endif\n"].join("\n");
s=["precision "+R+" float;","precision "+R+" int;",c.bumpMap||c.normalMap?"#extension GL_OES_standard_derivatives : enable":"",e,"#define MAX_DIR_LIGHTS "+c.maxDirLights,"#define MAX_POINT_LIGHTS "+c.maxPointLights,"#define MAX_SPOT_LIGHTS "+c.maxSpotLights,"#define MAX_HEMI_LIGHTS "+c.maxHemiLights,"#define MAX_SHADOWS "+c.maxShadows,c.alphaTest?"#define ALPHATEST "+c.alphaTest:"",K.gammaInput?"#define GAMMA_INPUT":"",K.gammaOutput?"#define GAMMA_OUTPUT":"",K.physicallyBasedShading?"#define PHYSICALLY_BASED_SHADING":
"",c.useFog&&c.fog?"#define USE_FOG":"",c.useFog&&c.fogExp?"#define FOG_EXP2":"",c.map?"#define USE_MAP":"",c.envMap?"#define USE_ENVMAP":"",c.lightMap?"#define USE_LIGHTMAP":"",c.bumpMap?"#define USE_BUMPMAP":"",c.normalMap?"#define USE_NORMALMAP":"",c.specularMap?"#define USE_SPECULARMAP":"",c.vertexColors?"#define USE_COLOR":"",c.metal?"#define METAL":"",c.perPixel?"#define PHONG_PER_PIXEL":"",c.wrapAround?"#define WRAP_AROUND":"",c.doubleSided?"#define DOUBLE_SIDED":"",c.flipSided?"#define FLIP_SIDED":
"",c.shadowMapEnabled?"#define USE_SHADOWMAP":"",c.shadowMapEnabled?"#define "+s:"",c.shadowMapDebug?"#define SHADOWMAP_DEBUG":"",c.shadowMapCascade?"#define SHADOWMAP_CASCADE":"","uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n"].join("\n");u=C("vertex",u+q);s=C("fragment",s+r);j.attachShader(w,u);j.attachShader(w,s);d&&j.bindAttribLocation(w,0,d);j.linkProgram(w);j.getProgramParameter(w,j.LINK_STATUS)||(console.error("Could not initialise shader\nVALIDATE_STATUS: "+j.getProgramParameter(w,
j.VALIDATE_STATUS)+", gl error ["+j.getError()+"]"),console.error("Program Info Log: "+j.getProgramInfoLog(w)));j.deleteShader(s);j.deleteShader(u);w.uniforms={};w.attributes={};var v;s="viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences".split(" ");c.useVertexTexture?(s.push("boneTexture"),s.push("boneTextureWidth"),s.push("boneTextureHeight")):s.push("boneGlobalMatrices");for(v in n)s.push(v);v=s;s=0;for(u=v.length;s<u;s++)n=v[s],w.uniforms[n]=
j.getUniformLocation(w,n);s="position normal uv uv2 tangent color skinIndex skinWeight lineDistance".split(" ");for(v=0;v<c.maxMorphTargets;v++)s.push("morphTarget"+v);for(v=0;v<c.maxMorphNormals;v++)s.push("morphNormal"+v);for(k in b)s.push(k);k=s;v=0;for(b=k.length;v<b;v++)s=k[v],w.attributes[s]=j.getAttribLocation(w,s);w.id=Fa++;ca.push({program:w,code:p,usedTimes:1});K.info.memory.programs=ca.length;k=w}a.program=k;v=a.program.attributes;if(a.morphTargets){a.numSupportedMorphTargets=0;b="morphTarget";
for(k=0;k<this.maxMorphTargets;k++)w=b+k,0<=v[w]&&a.numSupportedMorphTargets++}if(a.morphNormals){a.numSupportedMorphNormals=0;b="morphNormal";for(k=0;k<this.maxMorphNormals;k++)w=b+k,0<=v[w]&&a.numSupportedMorphNormals++}a.uniformsList=[];for(i in a.uniforms)a.uniformsList.push([a.uniforms[i],i])};this.setFaceCulling=function(a,b){a===THREE.CullFaceNone?j.disable(j.CULL_FACE):(b===THREE.FrontFaceDirectionCW?j.frontFace(j.CW):j.frontFace(j.CCW),a===THREE.CullFaceBack?j.cullFace(j.BACK):a===THREE.CullFaceFront?
j.cullFace(j.FRONT):j.cullFace(j.FRONT_AND_BACK),j.enable(j.CULL_FACE))};this.setMaterialFaces=function(a){var b=a.side===THREE.DoubleSide,a=a.side===THREE.BackSide;Z!==b&&(b?j.disable(j.CULL_FACE):j.enable(j.CULL_FACE),Z=b);U!==a&&(a?j.frontFace(j.CW):j.frontFace(j.CCW),U=a)};this.setDepthTest=function(a){Ga!==a&&(a?j.enable(j.DEPTH_TEST):j.disable(j.DEPTH_TEST),Ga=a)};this.setDepthWrite=function(a){fa!==a&&(j.depthMask(a),fa=a)};this.setBlending=function(a,b,c,d){a!==ka&&(a===THREE.NoBlending?j.disable(j.BLEND):
a===THREE.AdditiveBlending?(j.enable(j.BLEND),j.blendEquation(j.FUNC_ADD),j.blendFunc(j.SRC_ALPHA,j.ONE)):a===THREE.SubtractiveBlending?(j.enable(j.BLEND),j.blendEquation(j.FUNC_ADD),j.blendFunc(j.ZERO,j.ONE_MINUS_SRC_COLOR)):a===THREE.MultiplyBlending?(j.enable(j.BLEND),j.blendEquation(j.FUNC_ADD),j.blendFunc(j.ZERO,j.SRC_COLOR)):a===THREE.CustomBlending?j.enable(j.BLEND):(j.enable(j.BLEND),j.blendEquationSeparate(j.FUNC_ADD,j.FUNC_ADD),j.blendFuncSeparate(j.SRC_ALPHA,j.ONE_MINUS_SRC_ALPHA,j.ONE,
j.ONE_MINUS_SRC_ALPHA)),ka=a);if(a===THREE.CustomBlending){if(b!==ta&&(j.blendEquation(v(b)),ta=b),c!==ia||d!==La)j.blendFunc(v(c),v(d)),ia=c,La=d}else La=ia=ta=null};this.setTexture=function(a,b){if(a.needsUpdate){a.__webglInit||(a.__webglInit=!0,a.addEventListener("dispose",Db),a.__webglTexture=j.createTexture(),K.info.memory.textures++);j.activeTexture(j.TEXTURE0+b);j.bindTexture(j.TEXTURE_2D,a.__webglTexture);j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL,a.flipY);j.pixelStorei(j.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
a.premultiplyAlpha);j.pixelStorei(j.UNPACK_ALIGNMENT,a.unpackAlignment);var c=a.image,d=0===(c.width&c.width-1)&&0===(c.height&c.height-1),e=v(a.format),f=v(a.type);E(j.TEXTURE_2D,a,d);var h=a.mipmaps;if(a instanceof THREE.DataTexture)if(0<h.length&&d){for(var g=0,i=h.length;g<i;g++)c=h[g],j.texImage2D(j.TEXTURE_2D,g,e,c.width,c.height,0,e,f,c.data);a.generateMipmaps=!1}else j.texImage2D(j.TEXTURE_2D,0,e,c.width,c.height,0,e,f,c.data);else if(a instanceof THREE.CompressedTexture){g=0;for(i=h.length;g<
i;g++)c=h[g],a.format!==THREE.RGBAFormat?j.compressedTexImage2D(j.TEXTURE_2D,g,e,c.width,c.height,0,c.data):j.texImage2D(j.TEXTURE_2D,g,e,c.width,c.height,0,e,f,c.data)}else if(0<h.length&&d){g=0;for(i=h.length;g<i;g++)c=h[g],j.texImage2D(j.TEXTURE_2D,g,e,e,f,c);a.generateMipmaps=!1}else j.texImage2D(j.TEXTURE_2D,0,e,e,f,a.image);a.generateMipmaps&&d&&j.generateMipmap(j.TEXTURE_2D);a.needsUpdate=!1;if(a.onUpdate)a.onUpdate()}else j.activeTexture(j.TEXTURE0+b),j.bindTexture(j.TEXTURE_2D,a.__webglTexture)};
this.setRenderTarget=function(a){var b=a instanceof THREE.WebGLRenderTargetCube;if(a&&!a.__webglFramebuffer){void 0===a.depthBuffer&&(a.depthBuffer=!0);void 0===a.stencilBuffer&&(a.stencilBuffer=!0);a.addEventListener("dispose",Eb);a.__webglTexture=j.createTexture();K.info.memory.textures++;var c=0===(a.width&a.width-1)&&0===(a.height&a.height-1),d=v(a.format),e=v(a.type);if(b){a.__webglFramebuffer=[];a.__webglRenderbuffer=[];j.bindTexture(j.TEXTURE_CUBE_MAP,a.__webglTexture);E(j.TEXTURE_CUBE_MAP,
a,c);for(var f=0;6>f;f++){a.__webglFramebuffer[f]=j.createFramebuffer();a.__webglRenderbuffer[f]=j.createRenderbuffer();j.texImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X+f,0,d,a.width,a.height,0,d,e,null);var h=a,g=j.TEXTURE_CUBE_MAP_POSITIVE_X+f;j.bindFramebuffer(j.FRAMEBUFFER,a.__webglFramebuffer[f]);j.framebufferTexture2D(j.FRAMEBUFFER,j.COLOR_ATTACHMENT0,g,h.__webglTexture,0);I(a.__webglRenderbuffer[f],a)}c&&j.generateMipmap(j.TEXTURE_CUBE_MAP)}else a.__webglFramebuffer=j.createFramebuffer(),a.__webglRenderbuffer=
a.shareDepthFrom?a.shareDepthFrom.__webglRenderbuffer:j.createRenderbuffer(),j.bindTexture(j.TEXTURE_2D,a.__webglTexture),E(j.TEXTURE_2D,a,c),j.texImage2D(j.TEXTURE_2D,0,d,a.width,a.height,0,d,e,null),d=j.TEXTURE_2D,j.bindFramebuffer(j.FRAMEBUFFER,a.__webglFramebuffer),j.framebufferTexture2D(j.FRAMEBUFFER,j.COLOR_ATTACHMENT0,d,a.__webglTexture,0),a.shareDepthFrom?a.depthBuffer&&!a.stencilBuffer?j.framebufferRenderbuffer(j.FRAMEBUFFER,j.DEPTH_ATTACHMENT,j.RENDERBUFFER,a.__webglRenderbuffer):a.depthBuffer&&
a.stencilBuffer&&j.framebufferRenderbuffer(j.FRAMEBUFFER,j.DEPTH_STENCIL_ATTACHMENT,j.RENDERBUFFER,a.__webglRenderbuffer):I(a.__webglRenderbuffer,a),c&&j.generateMipmap(j.TEXTURE_2D);b?j.bindTexture(j.TEXTURE_CUBE_MAP,null):j.bindTexture(j.TEXTURE_2D,null);j.bindRenderbuffer(j.RENDERBUFFER,null);j.bindFramebuffer(j.FRAMEBUFFER,null)}a?(b=b?a.__webglFramebuffer[a.activeCubeFace]:a.__webglFramebuffer,c=a.width,a=a.height,e=d=0):(b=null,c=Ma,a=fb,d=bb,e=cb);b!==da&&(j.bindFramebuffer(j.FRAMEBUFFER,b),
j.viewport(d,e,c,a),da=b);sb=c;pb=a};this.shadowMapPlugin=new THREE.ShadowMapPlugin;this.addPrePlugin(this.shadowMapPlugin);this.addPostPlugin(new THREE.SpritePlugin);this.addPostPlugin(new THREE.LensFlarePlugin)};THREE.WebGLRenderTarget=function(a,b,c){this.width=a;this.height=b;c=c||{};this.wrapS=void 0!==c.wrapS?c.wrapS:THREE.ClampToEdgeWrapping;this.wrapT=void 0!==c.wrapT?c.wrapT:THREE.ClampToEdgeWrapping;this.magFilter=void 0!==c.magFilter?c.magFilter:THREE.LinearFilter;this.minFilter=void 0!==c.minFilter?c.minFilter:THREE.LinearMipMapLinearFilter;this.anisotropy=void 0!==c.anisotropy?c.anisotropy:1;this.offset=new THREE.Vector2(0,0);this.repeat=new THREE.Vector2(1,1);this.format=void 0!==c.format?c.format:
THREE.RGBAFormat;this.type=void 0!==c.type?c.type:THREE.UnsignedByteType;this.depthBuffer=void 0!==c.depthBuffer?c.depthBuffer:!0;this.stencilBuffer=void 0!==c.stencilBuffer?c.stencilBuffer:!0;this.generateMipmaps=!0;this.shareDepthFrom=null};
THREE.WebGLRenderTarget.prototype={constructor:THREE.WebGLRenderTarget,clone:function(){var a=new THREE.WebGLRenderTarget(this.width,this.height);a.wrapS=this.wrapS;a.wrapT=this.wrapT;a.magFilter=this.magFilter;a.minFilter=this.minFilter;a.anisotropy=this.anisotropy;a.offset.copy(this.offset);a.repeat.copy(this.repeat);a.format=this.format;a.type=this.type;a.depthBuffer=this.depthBuffer;a.stencilBuffer=this.stencilBuffer;a.generateMipmaps=this.generateMipmaps;a.shareDepthFrom=this.shareDepthFrom;
return a},dispose:function(){this.dispatchEvent({type:"dispose"})}};THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);THREE.WebGLRenderTargetCube=function(a,b,c){THREE.WebGLRenderTarget.call(this,a,b,c);this.activeCubeFace=0};THREE.WebGLRenderTargetCube.prototype=Object.create(THREE.WebGLRenderTarget.prototype);THREE.RenderableVertex=function(){this.positionWorld=new THREE.Vector3;this.positionScreen=new THREE.Vector4;this.visible=!0};THREE.RenderableVertex.prototype.copy=function(a){this.positionWorld.copy(a.positionWorld);this.positionScreen.copy(a.positionScreen)};THREE.RenderableFace3=function(){this.id=0;this.v1=new THREE.RenderableVertex;this.v2=new THREE.RenderableVertex;this.v3=new THREE.RenderableVertex;this.centroidModel=new THREE.Vector3;this.normalModel=new THREE.Vector3;this.normalModelView=new THREE.Vector3;this.vertexNormalsLength=0;this.vertexNormalsModel=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3];this.vertexNormalsModelView=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3];this.material=this.color=null;this.uvs=[[]];this.z=
0};THREE.RenderableObject=function(){this.id=0;this.object=null;this.z=0};THREE.RenderableSprite=function(){this.id=0;this.object=null;this.rotation=this.z=this.y=this.x=0;this.scale=new THREE.Vector2;this.material=null};THREE.RenderableLine=function(){this.id=0;this.v1=new THREE.RenderableVertex;this.v2=new THREE.RenderableVertex;this.vertexColors=[new THREE.Color,new THREE.Color];this.material=null;this.z=0};THREE.GeometryUtils={merge:function(a,b,c){var d,e,f=a.vertices.length,h=b instanceof THREE.Mesh?b.geometry:b,g=a.vertices,i=h.vertices,k=a.faces,m=h.faces,a=a.faceVertexUvs[0],h=h.faceVertexUvs[0];void 0===c&&(c=0);b instanceof THREE.Mesh&&(b.matrixAutoUpdate&&b.updateMatrix(),d=b.matrix,e=(new THREE.Matrix3).getNormalMatrix(d));for(var b=0,l=i.length;b<l;b++){var p=i[b].clone();d&&p.applyMatrix4(d);g.push(p)}b=0;for(l=m.length;b<l;b++){var p=m[b],s,t,n=p.vertexNormals,r=p.vertexColors;s=new THREE.Face3(p.a+
f,p.b+f,p.c+f);s.normal.copy(p.normal);e&&s.normal.applyMatrix3(e).normalize();g=0;for(i=n.length;g<i;g++)t=n[g].clone(),e&&t.applyMatrix3(e).normalize(),s.vertexNormals.push(t);s.color.copy(p.color);g=0;for(i=r.length;g<i;g++)t=r[g],s.vertexColors.push(t.clone());s.materialIndex=p.materialIndex+c;s.centroid.copy(p.centroid);d&&s.centroid.applyMatrix4(d);k.push(s)}b=0;for(l=h.length;b<l;b++){c=h[b];d=[];g=0;for(i=c.length;g<i;g++)d.push(new THREE.Vector2(c[g].x,c[g].y));a.push(d)}},randomPointInTriangle:function(){var a=
new THREE.Vector3;return function(b,c,d){var e=new THREE.Vector3,f=THREE.Math.random16(),h=THREE.Math.random16();1<f+h&&(f=1-f,h=1-h);var g=1-f-h;e.copy(b);e.multiplyScalar(f);a.copy(c);a.multiplyScalar(h);e.add(a);a.copy(d);a.multiplyScalar(g);e.add(a);return e}}(),randomPointInFace:function(a,b){return THREE.GeometryUtils.randomPointInTriangle(b.vertices[a.a],b.vertices[a.b],b.vertices[a.c])},randomPointsInGeometry:function(a,b){function c(a){function b(c,d){if(d<c)return c;var e=c+Math.floor((d-
c)/2);return k[e]>a?b(c,e-1):k[e]<a?b(e+1,d):e}return b(0,k.length-1)}var d,e,f=a.faces,h=a.vertices,g=f.length,i=0,k=[],m,l,p;for(e=0;e<g;e++)d=f[e],m=h[d.a],l=h[d.b],p=h[d.c],d._area=THREE.GeometryUtils.triangleArea(m,l,p),i+=d._area,k[e]=i;d=[];for(e=0;e<b;e++)h=THREE.Math.random16()*i,h=c(h),d[e]=THREE.GeometryUtils.randomPointInFace(f[h],a,!0);return d},triangleArea:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d,e){a.subVectors(d,c);b.subVectors(e,c);a.cross(b);return 0.5*
a.length()}}(),center:function(a){a.computeBoundingBox();var b=a.boundingBox,c=new THREE.Vector3;c.addVectors(b.min,b.max);c.multiplyScalar(-0.5);a.applyMatrix((new THREE.Matrix4).makeTranslation(c.x,c.y,c.z));a.computeBoundingBox();return c},triangulateQuads:function(a){var b,c,d,e,f=[],h=[];b=0;for(c=a.faceVertexUvs.length;b<c;b++)h[b]=[];b=0;for(c=a.faces.length;b<c;b++){f.push(a.faces[b]);d=0;for(e=a.faceVertexUvs.length;d<e;d++)h[d].push(a.faceVertexUvs[d][b])}a.faces=f;a.faceVertexUvs=h;a.computeCentroids();
a.computeFaceNormals();a.computeVertexNormals();a.hasTangents&&a.computeTangents()}};THREE.ImageUtils={crossOrigin:"anonymous",loadTexture:function(a,b,c){var d=new THREE.ImageLoader;d.crossOrigin=this.crossOrigin;var e=new THREE.Texture(void 0,b),b=d.load(a,function(){e.needsUpdate=!0;c&&c(e)});e.image=b;e.sourceFile=a;return e},loadCompressedTexture:function(a,b,c,d){var e=new THREE.CompressedTexture;e.mapping=b;var f=new XMLHttpRequest;f.onload=function(){var a=THREE.ImageUtils.parseDDS(f.response,!0);e.format=a.format;e.mipmaps=a.mipmaps;e.image.width=a.width;e.image.height=a.height;
e.generateMipmaps=!1;e.needsUpdate=!0;c&&c(e)};f.onerror=d;f.open("GET",a,!0);f.responseType="arraybuffer";f.send(null);return e},loadTextureCube:function(a,b,c,d){var e=[];e.loadCount=0;var f=new THREE.Texture;f.image=e;void 0!==b&&(f.mapping=b);f.flipY=!1;for(var b=0,h=a.length;b<h;++b){var g=new Image;e[b]=g;g.onload=function(){e.loadCount+=1;6===e.loadCount&&(f.needsUpdate=!0,c&&c(f))};g.onerror=d;g.crossOrigin=this.crossOrigin;g.src=a[b]}return f},loadCompressedTextureCube:function(a,b,c,d){var e=
[];e.loadCount=0;var f=new THREE.CompressedTexture;f.image=e;void 0!==b&&(f.mapping=b);f.flipY=!1;f.generateMipmaps=!1;b=function(a,b){return function(){var d=THREE.ImageUtils.parseDDS(a.response,!0);b.format=d.format;b.mipmaps=d.mipmaps;b.width=d.width;b.height=d.height;e.loadCount+=1;6===e.loadCount&&(f.format=d.format,f.needsUpdate=!0,c&&c(f))}};if(a instanceof Array)for(var h=0,g=a.length;h<g;++h){var i={};e[h]=i;var k=new XMLHttpRequest;k.onload=b(k,i);k.onerror=d;i=a[h];k.open("GET",i,!0);k.responseType=
"arraybuffer";k.send(null)}else k=new XMLHttpRequest,k.onload=function(){var a=THREE.ImageUtils.parseDDS(k.response,!0);if(a.isCubemap){for(var b=a.mipmaps.length/a.mipmapCount,d=0;d<b;d++){e[d]={mipmaps:[]};for(var h=0;h<a.mipmapCount;h++)e[d].mipmaps.push(a.mipmaps[d*a.mipmapCount+h]),e[d].format=a.format,e[d].width=a.width,e[d].height=a.height}f.format=a.format;f.needsUpdate=!0;c&&c(f)}},k.onerror=d,k.open("GET",a,!0),k.responseType="arraybuffer",k.send(null);return f},loadDDSTexture:function(a,
b,c,d){var e=[];e.loadCount=0;var f=new THREE.CompressedTexture;f.image=e;void 0!==b&&(f.mapping=b);f.flipY=!1;f.generateMipmaps=!1;var h=new XMLHttpRequest;h.onload=function(){var a=THREE.ImageUtils.parseDDS(h.response,!0);if(a.isCubemap)for(var b=a.mipmaps.length/a.mipmapCount,d=0;d<b;d++){e[d]={mipmaps:[]};for(var m=0;m<a.mipmapCount;m++)e[d].mipmaps.push(a.mipmaps[d*a.mipmapCount+m]),e[d].format=a.format,e[d].width=a.width,e[d].height=a.height}else f.image.width=a.width,f.image.height=a.height,
f.mipmaps=a.mipmaps;f.format=a.format;f.needsUpdate=!0;c&&c(f)};h.onerror=d;h.open("GET",a,!0);h.responseType="arraybuffer";h.send(null);return f},parseDDS:function(a,b){function c(a){return a.charCodeAt(0)+(a.charCodeAt(1)<<8)+(a.charCodeAt(2)<<16)+(a.charCodeAt(3)<<24)}var d={mipmaps:[],width:0,height:0,format:null,mipmapCount:1},e=c("DXT1"),f=c("DXT3"),h=c("DXT5"),g=new Int32Array(a,0,31);if(542327876!==g[0])return console.error("ImageUtils.parseDDS(): Invalid magic number in DDS header"),d;if(!g[20]&
4)return console.error("ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code"),d;var i=g[21],k=!1;switch(i){case e:e=8;d.format=THREE.RGB_S3TC_DXT1_Format;break;case f:e=16;d.format=THREE.RGBA_S3TC_DXT3_Format;break;case h:e=16;d.format=THREE.RGBA_S3TC_DXT5_Format;break;default:if(32==g[22]&&g[23]&16711680&&g[24]&65280&&g[25]&255&&g[26]&4278190080)k=!0,e=64,d.format=THREE.RGBAFormat;else return console.error("ImageUtils.parseDDS(): Unsupported FourCC code: ",String.fromCharCode(i&
255,i>>8&255,i>>16&255,i>>24&255)),d}d.mipmapCount=1;g[2]&131072&&!1!==b&&(d.mipmapCount=Math.max(1,g[7]));d.isCubemap=g[28]&512?!0:!1;d.width=g[4];d.height=g[3];for(var g=g[1]+4,f=d.width,h=d.height,i=d.isCubemap?6:1,m=0;m<i;m++){for(var l=0;l<d.mipmapCount;l++){if(k){var p;p=f;for(var s=h,t=4*p*s,n=new Uint8Array(a,g,t),t=new Uint8Array(t),r=0,q=0,u=0;u<s;u++)for(var w=0;w<p;w++){var z=n[q];q++;var B=n[q];q++;var D=n[q];q++;var x=n[q];q++;t[r]=D;r++;t[r]=B;r++;t[r]=z;r++;t[r]=x;r++}p=t;s=p.length}else s=
Math.max(4,f)/4*Math.max(4,h)/4*e,p=new Uint8Array(a,g,s);d.mipmaps.push({data:p,width:f,height:h});g+=s;f=Math.max(0.5*f,1);h=Math.max(0.5*h,1)}f=d.width;h=d.height}return d},getNormalMap:function(a,b){var c=function(a){var b=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);return[a[0]/b,a[1]/b,a[2]/b]},b=b|1,d=a.width,e=a.height,f=document.createElement("canvas");f.width=d;f.height=e;var h=f.getContext("2d");h.drawImage(a,0,0);for(var g=h.getImageData(0,0,d,e).data,i=h.createImageData(d,e),k=i.data,m=0;m<
d;m++)for(var l=0;l<e;l++){var p=0>l-1?0:l-1,s=l+1>e-1?e-1:l+1,t=0>m-1?0:m-1,n=m+1>d-1?d-1:m+1,r=[],q=[0,0,g[4*(l*d+m)]/255*b];r.push([-1,0,g[4*(l*d+t)]/255*b]);r.push([-1,-1,g[4*(p*d+t)]/255*b]);r.push([0,-1,g[4*(p*d+m)]/255*b]);r.push([1,-1,g[4*(p*d+n)]/255*b]);r.push([1,0,g[4*(l*d+n)]/255*b]);r.push([1,1,g[4*(s*d+n)]/255*b]);r.push([0,1,g[4*(s*d+m)]/255*b]);r.push([-1,1,g[4*(s*d+t)]/255*b]);p=[];t=r.length;for(s=0;s<t;s++){var n=r[s],u=r[(s+1)%t],n=[n[0]-q[0],n[1]-q[1],n[2]-q[2]],u=[u[0]-q[0],
u[1]-q[1],u[2]-q[2]];p.push(c([n[1]*u[2]-n[2]*u[1],n[2]*u[0]-n[0]*u[2],n[0]*u[1]-n[1]*u[0]]))}r=[0,0,0];for(s=0;s<p.length;s++)r[0]+=p[s][0],r[1]+=p[s][1],r[2]+=p[s][2];r[0]/=p.length;r[1]/=p.length;r[2]/=p.length;q=4*(l*d+m);k[q]=255*((r[0]+1)/2)|0;k[q+1]=255*((r[1]+1)/2)|0;k[q+2]=255*r[2]|0;k[q+3]=255}h.putImageData(i,0,0);return f},generateDataTexture:function(a,b,c){for(var d=a*b,e=new Uint8Array(3*d),f=Math.floor(255*c.r),h=Math.floor(255*c.g),c=Math.floor(255*c.b),g=0;g<d;g++)e[3*g]=f,e[3*g+
1]=h,e[3*g+2]=c;a=new THREE.DataTexture(e,a,b,THREE.RGBFormat);a.needsUpdate=!0;return a}};THREE.SceneUtils={createMultiMaterialObject:function(a,b){for(var c=new THREE.Object3D,d=0,e=b.length;d<e;d++)c.add(new THREE.Mesh(a,b[d]));return c},detach:function(a,b,c){a.applyMatrix(b.matrixWorld);b.remove(a);c.add(a)},attach:function(a,b,c){var d=new THREE.Matrix4;d.getInverse(c.matrixWorld);a.applyMatrix(d);b.remove(a);c.add(a)}};THREE.FontUtils={faces:{},face:"helvetiker",weight:"normal",style:"normal",size:150,divisions:10,getFace:function(){return this.faces[this.face][this.weight][this.style]},loadFace:function(a){var b=a.familyName.toLowerCase();this.faces[b]=this.faces[b]||{};this.faces[b][a.cssFontWeight]=this.faces[b][a.cssFontWeight]||{};this.faces[b][a.cssFontWeight][a.cssFontStyle]=a;return this.faces[b][a.cssFontWeight][a.cssFontStyle]=a},drawText:function(a){for(var b=this.getFace(),c=this.size/b.resolution,d=
0,e=String(a).split(""),f=e.length,h=[],a=0;a<f;a++){var g=new THREE.Path,g=this.extractGlyphPoints(e[a],b,c,d,g),d=d+g.offset;h.push(g.path)}return{paths:h,offset:d/2}},extractGlyphPoints:function(a,b,c,d,e){var f=[],h,g,i,k,m,l,p,s,t,n,r,q=b.glyphs[a]||b.glyphs["?"];if(q){if(q.o){b=q._cachedOutline||(q._cachedOutline=q.o.split(" "));k=b.length;for(a=0;a<k;)switch(i=b[a++],i){case "m":i=b[a++]*c+d;m=b[a++]*c;e.moveTo(i,m);break;case "l":i=b[a++]*c+d;m=b[a++]*c;e.lineTo(i,m);break;case "q":i=b[a++]*
c+d;m=b[a++]*c;s=b[a++]*c+d;t=b[a++]*c;e.quadraticCurveTo(s,t,i,m);if(h=f[f.length-1]){l=h.x;p=h.y;h=1;for(g=this.divisions;h<=g;h++){var u=h/g;THREE.Shape.Utils.b2(u,l,s,i);THREE.Shape.Utils.b2(u,p,t,m)}}break;case "b":if(i=b[a++]*c+d,m=b[a++]*c,s=b[a++]*c+d,t=b[a++]*-c,n=b[a++]*c+d,r=b[a++]*-c,e.bezierCurveTo(i,m,s,t,n,r),h=f[f.length-1]){l=h.x;p=h.y;h=1;for(g=this.divisions;h<=g;h++)u=h/g,THREE.Shape.Utils.b3(u,l,s,n,i),THREE.Shape.Utils.b3(u,p,t,r,m)}}}return{offset:q.ha*c,path:e}}}};
THREE.FontUtils.generateShapes=function(a,b){var b=b||{},c=void 0!==b.curveSegments?b.curveSegments:4,d=void 0!==b.font?b.font:"helvetiker",e=void 0!==b.weight?b.weight:"normal",f=void 0!==b.style?b.style:"normal";THREE.FontUtils.size=void 0!==b.size?b.size:100;THREE.FontUtils.divisions=c;THREE.FontUtils.face=d;THREE.FontUtils.weight=e;THREE.FontUtils.style=f;c=THREE.FontUtils.drawText(a).paths;d=[];e=0;for(f=c.length;e<f;e++)Array.prototype.push.apply(d,c[e].toShapes());return d};
(function(a){var b=function(a){for(var b=a.length,e=0,f=b-1,h=0;h<b;f=h++)e+=a[f].x*a[h].y-a[h].x*a[f].y;return 0.5*e};a.Triangulate=function(a,d){var e=a.length;if(3>e)return null;var f=[],h=[],g=[],i,k,m;if(0<b(a))for(k=0;k<e;k++)h[k]=k;else for(k=0;k<e;k++)h[k]=e-1-k;var l=2*e;for(k=e-1;2<e;){if(0>=l--){console.log("Warning, unable to triangulate polygon!");break}i=k;e<=i&&(i=0);k=i+1;e<=k&&(k=0);m=k+1;e<=m&&(m=0);var p;a:{var s=p=void 0,t=void 0,n=void 0,r=void 0,q=void 0,u=void 0,w=void 0,z=
void 0,s=a[h[i]].x,t=a[h[i]].y,n=a[h[k]].x,r=a[h[k]].y,q=a[h[m]].x,u=a[h[m]].y;if(1E-10>(n-s)*(u-t)-(r-t)*(q-s))p=!1;else{var B=void 0,D=void 0,x=void 0,F=void 0,A=void 0,O=void 0,C=void 0,E=void 0,I=void 0,y=void 0,I=E=C=z=w=void 0,B=q-n,D=u-r,x=s-q,F=t-u,A=n-s,O=r-t;for(p=0;p<e;p++)if(!(p===i||p===k||p===m))if(w=a[h[p]].x,z=a[h[p]].y,C=w-s,E=z-t,I=w-n,y=z-r,w-=q,z-=u,I=B*y-D*I,C=A*E-O*C,E=x*z-F*w,-1E-10<=I&&-1E-10<=E&&-1E-10<=C){p=!1;break a}p=!0}}if(p){f.push([a[h[i]],a[h[k]],a[h[m]]]);g.push([h[i],
h[k],h[m]]);i=k;for(m=k+1;m<e;i++,m++)h[i]=h[m];e--;l=2*e}}return d?g:f};a.Triangulate.area=b;return a})(THREE.FontUtils);self._typeface_js={faces:THREE.FontUtils.faces,loadFace:THREE.FontUtils.loadFace};THREE.typeface_js=self._typeface_js;THREE.Curve=function(){};THREE.Curve.prototype.getPoint=function(){console.log("Warning, getPoint() not implemented!");return null};THREE.Curve.prototype.getPointAt=function(a){a=this.getUtoTmapping(a);return this.getPoint(a)};THREE.Curve.prototype.getPoints=function(a){a||(a=5);var b,c=[];for(b=0;b<=a;b++)c.push(this.getPoint(b/a));return c};THREE.Curve.prototype.getSpacedPoints=function(a){a||(a=5);var b,c=[];for(b=0;b<=a;b++)c.push(this.getPointAt(b/a));return c};
THREE.Curve.prototype.getLength=function(){var a=this.getLengths();return a[a.length-1]};THREE.Curve.prototype.getLengths=function(a){a||(a=this.__arcLengthDivisions?this.__arcLengthDivisions:200);if(this.cacheArcLengths&&this.cacheArcLengths.length==a+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;var b=[],c,d=this.getPoint(0),e,f=0;b.push(0);for(e=1;e<=a;e++)c=this.getPoint(e/a),f+=c.distanceTo(d),b.push(f),d=c;return this.cacheArcLengths=b};
THREE.Curve.prototype.updateArcLengths=function(){this.needsUpdate=!0;this.getLengths()};THREE.Curve.prototype.getUtoTmapping=function(a,b){var c=this.getLengths(),d=0,e=c.length,f;f=b?b:a*c[e-1];for(var h=0,g=e-1,i;h<=g;)if(d=Math.floor(h+(g-h)/2),i=c[d]-f,0>i)h=d+1;else if(0<i)g=d-1;else{g=d;break}d=g;if(c[d]==f)return d/(e-1);h=c[d];return c=(d+(f-h)/(c[d+1]-h))/(e-1)};THREE.Curve.prototype.getTangent=function(a){var b=a-1E-4,a=a+1E-4;0>b&&(b=0);1<a&&(a=1);b=this.getPoint(b);return this.getPoint(a).clone().sub(b).normalize()};
THREE.Curve.prototype.getTangentAt=function(a){a=this.getUtoTmapping(a);return this.getTangent(a)};
THREE.Curve.Utils={tangentQuadraticBezier:function(a,b,c,d){return 2*(1-a)*(c-b)+2*a*(d-c)},tangentCubicBezier:function(a,b,c,d,e){return-3*b*(1-a)*(1-a)+3*c*(1-a)*(1-a)-6*a*c*(1-a)+6*a*d*(1-a)-3*a*a*d+3*a*a*e},tangentSpline:function(a){return 6*a*a-6*a+(3*a*a-4*a+1)+(-6*a*a+6*a)+(3*a*a-2*a)},interpolate:function(a,b,c,d,e){var a=0.5*(c-a),d=0.5*(d-b),f=e*e;return(2*b-2*c+a+d)*e*f+(-3*b+3*c-2*a-d)*f+a*e+b}};
THREE.Curve.create=function(a,b){a.prototype=Object.create(THREE.Curve.prototype);a.prototype.getPoint=b;return a};THREE.CurvePath=function(){this.curves=[];this.bends=[];this.autoClose=!1};THREE.CurvePath.prototype=Object.create(THREE.Curve.prototype);THREE.CurvePath.prototype.add=function(a){this.curves.push(a)};THREE.CurvePath.prototype.checkConnection=function(){};THREE.CurvePath.prototype.closePath=function(){var a=this.curves[0].getPoint(0),b=this.curves[this.curves.length-1].getPoint(1);a.equals(b)||this.curves.push(new THREE.LineCurve(b,a))};
THREE.CurvePath.prototype.getPoint=function(a){for(var b=a*this.getLength(),c=this.getCurveLengths(),a=0;a<c.length;){if(c[a]>=b)return b=c[a]-b,a=this.curves[a],b=1-b/a.getLength(),a.getPointAt(b);a++}return null};THREE.CurvePath.prototype.getLength=function(){var a=this.getCurveLengths();return a[a.length-1]};
THREE.CurvePath.prototype.getCurveLengths=function(){if(this.cacheLengths&&this.cacheLengths.length==this.curves.length)return this.cacheLengths;var a=[],b=0,c,d=this.curves.length;for(c=0;c<d;c++)b+=this.curves[c].getLength(),a.push(b);return this.cacheLengths=a};
THREE.CurvePath.prototype.getBoundingBox=function(){var a=this.getPoints(),b,c,d,e,f,h;b=c=Number.NEGATIVE_INFINITY;e=f=Number.POSITIVE_INFINITY;var g,i,k,m,l=a[0]instanceof THREE.Vector3;m=l?new THREE.Vector3:new THREE.Vector2;i=0;for(k=a.length;i<k;i++)g=a[i],g.x>b?b=g.x:g.x<e&&(e=g.x),g.y>c?c=g.y:g.y<f&&(f=g.y),l&&(g.z>d?d=g.z:g.z<h&&(h=g.z)),m.add(g);a={minX:e,minY:f,maxX:b,maxY:c,centroid:m.divideScalar(k)};l&&(a.maxZ=d,a.minZ=h);return a};
THREE.CurvePath.prototype.createPointsGeometry=function(a){a=this.getPoints(a,!0);return this.createGeometry(a)};THREE.CurvePath.prototype.createSpacedPointsGeometry=function(a){a=this.getSpacedPoints(a,!0);return this.createGeometry(a)};THREE.CurvePath.prototype.createGeometry=function(a){for(var b=new THREE.Geometry,c=0;c<a.length;c++)b.vertices.push(new THREE.Vector3(a[c].x,a[c].y,a[c].z||0));return b};THREE.CurvePath.prototype.addWrapPath=function(a){this.bends.push(a)};
THREE.CurvePath.prototype.getTransformedPoints=function(a,b){var c=this.getPoints(a),d,e;b||(b=this.bends);d=0;for(e=b.length;d<e;d++)c=this.getWrapPoints(c,b[d]);return c};THREE.CurvePath.prototype.getTransformedSpacedPoints=function(a,b){var c=this.getSpacedPoints(a),d,e;b||(b=this.bends);d=0;for(e=b.length;d<e;d++)c=this.getWrapPoints(c,b[d]);return c};
THREE.CurvePath.prototype.getWrapPoints=function(a,b){var c=this.getBoundingBox(),d,e,f,h,g,i;d=0;for(e=a.length;d<e;d++)f=a[d],h=f.x,g=f.y,i=h/c.maxX,i=b.getUtoTmapping(i,h),h=b.getPoint(i),g=b.getNormalVector(i).multiplyScalar(g),f.x=h.x+g.x,f.y=h.y+g.y;return a};THREE.Gyroscope=function(){THREE.Object3D.call(this)};THREE.Gyroscope.prototype=Object.create(THREE.Object3D.prototype);
THREE.Gyroscope.prototype.updateMatrixWorld=function(a){this.matrixAutoUpdate&&this.updateMatrix();if(this.matrixWorldNeedsUpdate||a)this.parent?(this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorld.decompose(this.translationWorld,this.quaternionWorld,this.scaleWorld),this.matrix.decompose(this.translationObject,this.quaternionObject,this.scaleObject),this.matrixWorld.compose(this.translationWorld,this.quaternionObject,this.scaleWorld)):this.matrixWorld.copy(this.matrix),
this.matrixWorldNeedsUpdate=!1,a=!0;for(var b=0,c=this.children.length;b<c;b++)this.children[b].updateMatrixWorld(a)};THREE.Gyroscope.prototype.translationWorld=new THREE.Vector3;THREE.Gyroscope.prototype.translationObject=new THREE.Vector3;THREE.Gyroscope.prototype.quaternionWorld=new THREE.Quaternion;THREE.Gyroscope.prototype.quaternionObject=new THREE.Quaternion;THREE.Gyroscope.prototype.scaleWorld=new THREE.Vector3;THREE.Gyroscope.prototype.scaleObject=new THREE.Vector3;THREE.Path=function(a){THREE.CurvePath.call(this);this.actions=[];a&&this.fromPoints(a)};THREE.Path.prototype=Object.create(THREE.CurvePath.prototype);THREE.PathActions={MOVE_TO:"moveTo",LINE_TO:"lineTo",QUADRATIC_CURVE_TO:"quadraticCurveTo",BEZIER_CURVE_TO:"bezierCurveTo",CSPLINE_THRU:"splineThru",ARC:"arc",ELLIPSE:"ellipse"};THREE.Path.prototype.fromPoints=function(a){this.moveTo(a[0].x,a[0].y);for(var b=1,c=a.length;b<c;b++)this.lineTo(a[b].x,a[b].y)};
THREE.Path.prototype.moveTo=function(a,b){var c=Array.prototype.slice.call(arguments);this.actions.push({action:THREE.PathActions.MOVE_TO,args:c})};THREE.Path.prototype.lineTo=function(a,b){var c=Array.prototype.slice.call(arguments),d=this.actions[this.actions.length-1].args,d=new THREE.LineCurve(new THREE.Vector2(d[d.length-2],d[d.length-1]),new THREE.Vector2(a,b));this.curves.push(d);this.actions.push({action:THREE.PathActions.LINE_TO,args:c})};
THREE.Path.prototype.quadraticCurveTo=function(a,b,c,d){var e=Array.prototype.slice.call(arguments),f=this.actions[this.actions.length-1].args,f=new THREE.QuadraticBezierCurve(new THREE.Vector2(f[f.length-2],f[f.length-1]),new THREE.Vector2(a,b),new THREE.Vector2(c,d));this.curves.push(f);this.actions.push({action:THREE.PathActions.QUADRATIC_CURVE_TO,args:e})};
THREE.Path.prototype.bezierCurveTo=function(a,b,c,d,e,f){var h=Array.prototype.slice.call(arguments),g=this.actions[this.actions.length-1].args,g=new THREE.CubicBezierCurve(new THREE.Vector2(g[g.length-2],g[g.length-1]),new THREE.Vector2(a,b),new THREE.Vector2(c,d),new THREE.Vector2(e,f));this.curves.push(g);this.actions.push({action:THREE.PathActions.BEZIER_CURVE_TO,args:h})};
THREE.Path.prototype.splineThru=function(a){var b=Array.prototype.slice.call(arguments),c=this.actions[this.actions.length-1].args,c=[new THREE.Vector2(c[c.length-2],c[c.length-1])];Array.prototype.push.apply(c,a);c=new THREE.SplineCurve(c);this.curves.push(c);this.actions.push({action:THREE.PathActions.CSPLINE_THRU,args:b})};THREE.Path.prototype.arc=function(a,b,c,d,e,f){var h=this.actions[this.actions.length-1].args;this.absarc(a+h[h.length-2],b+h[h.length-1],c,d,e,f)};
THREE.Path.prototype.absarc=function(a,b,c,d,e,f){this.absellipse(a,b,c,c,d,e,f)};THREE.Path.prototype.ellipse=function(a,b,c,d,e,f,h){var g=this.actions[this.actions.length-1].args;this.absellipse(a+g[g.length-2],b+g[g.length-1],c,d,e,f,h)};THREE.Path.prototype.absellipse=function(a,b,c,d,e,f,h){var g=Array.prototype.slice.call(arguments),i=new THREE.EllipseCurve(a,b,c,d,e,f,h);this.curves.push(i);i=i.getPoint(1);g.push(i.x);g.push(i.y);this.actions.push({action:THREE.PathActions.ELLIPSE,args:g})};
THREE.Path.prototype.getSpacedPoints=function(a){a||(a=40);for(var b=[],c=0;c<a;c++)b.push(this.getPoint(c/a));return b};
THREE.Path.prototype.getPoints=function(a,b){if(this.useSpacedPoints)return console.log("tata"),this.getSpacedPoints(a,b);var a=a||12,c=[],d,e,f,h,g,i,k,m,l,p,s,t,n;d=0;for(e=this.actions.length;d<e;d++)switch(f=this.actions[d],h=f.action,f=f.args,h){case THREE.PathActions.MOVE_TO:c.push(new THREE.Vector2(f[0],f[1]));break;case THREE.PathActions.LINE_TO:c.push(new THREE.Vector2(f[0],f[1]));break;case THREE.PathActions.QUADRATIC_CURVE_TO:g=f[2];i=f[3];l=f[0];p=f[1];0<c.length?(h=c[c.length-1],s=h.x,
t=h.y):(h=this.actions[d-1].args,s=h[h.length-2],t=h[h.length-1]);for(f=1;f<=a;f++)n=f/a,h=THREE.Shape.Utils.b2(n,s,l,g),n=THREE.Shape.Utils.b2(n,t,p,i),c.push(new THREE.Vector2(h,n));break;case THREE.PathActions.BEZIER_CURVE_TO:g=f[4];i=f[5];l=f[0];p=f[1];k=f[2];m=f[3];0<c.length?(h=c[c.length-1],s=h.x,t=h.y):(h=this.actions[d-1].args,s=h[h.length-2],t=h[h.length-1]);for(f=1;f<=a;f++)n=f/a,h=THREE.Shape.Utils.b3(n,s,l,k,g),n=THREE.Shape.Utils.b3(n,t,p,m,i),c.push(new THREE.Vector2(h,n));break;case THREE.PathActions.CSPLINE_THRU:h=
this.actions[d-1].args;n=[new THREE.Vector2(h[h.length-2],h[h.length-1])];h=a*f[0].length;n=n.concat(f[0]);n=new THREE.SplineCurve(n);for(f=1;f<=h;f++)c.push(n.getPointAt(f/h));break;case THREE.PathActions.ARC:g=f[0];i=f[1];p=f[2];k=f[3];h=f[4];l=!!f[5];s=h-k;t=2*a;for(f=1;f<=t;f++)n=f/t,l||(n=1-n),n=k+n*s,h=g+p*Math.cos(n),n=i+p*Math.sin(n),c.push(new THREE.Vector2(h,n));break;case THREE.PathActions.ELLIPSE:g=f[0];i=f[1];p=f[2];m=f[3];k=f[4];h=f[5];l=!!f[6];s=h-k;t=2*a;for(f=1;f<=t;f++)n=f/t,l||
(n=1-n),n=k+n*s,h=g+p*Math.cos(n),n=i+m*Math.sin(n),c.push(new THREE.Vector2(h,n))}d=c[c.length-1];1E-10>Math.abs(d.x-c[0].x)&&1E-10>Math.abs(d.y-c[0].y)&&c.splice(c.length-1,1);b&&c.push(c[0]);return c};
THREE.Path.prototype.toShapes=function(a){var b,c,d,e,f=[],h=new THREE.Path;b=0;for(c=this.actions.length;b<c;b++)d=this.actions[b],e=d.args,d=d.action,d==THREE.PathActions.MOVE_TO&&0!=h.actions.length&&(f.push(h),h=new THREE.Path),h[d].apply(h,e);0!=h.actions.length&&f.push(h);if(0==f.length)return[];var g;e=[];if(1==f.length)return d=f[0],g=new THREE.Shape,g.actions=d.actions,g.curves=d.curves,e.push(g),e;b=!THREE.Shape.Utils.isClockWise(f[0].getPoints());if(a?!b:b){g=new THREE.Shape;b=0;for(c=
f.length;b<c;b++)d=f[b],h=THREE.Shape.Utils.isClockWise(d.getPoints()),(h=a?!h:h)?(g.actions=d.actions,g.curves=d.curves,e.push(g),g=new THREE.Shape):g.holes.push(d)}else{g=void 0;b=0;for(c=f.length;b<c;b++)d=f[b],h=THREE.Shape.Utils.isClockWise(d.getPoints()),(h=a?!h:h)?(g&&e.push(g),g=new THREE.Shape,g.actions=d.actions,g.curves=d.curves):g.holes.push(d);e.push(g)}return e};THREE.Shape=function(){THREE.Path.apply(this,arguments);this.holes=[]};THREE.Shape.prototype=Object.create(THREE.Path.prototype);THREE.Shape.prototype.extrude=function(a){return new THREE.ExtrudeGeometry(this,a)};THREE.Shape.prototype.makeGeometry=function(a){return new THREE.ShapeGeometry(this,a)};THREE.Shape.prototype.getPointsHoles=function(a){var b,c=this.holes.length,d=[];for(b=0;b<c;b++)d[b]=this.holes[b].getTransformedPoints(a,this.bends);return d};
THREE.Shape.prototype.getSpacedPointsHoles=function(a){var b,c=this.holes.length,d=[];for(b=0;b<c;b++)d[b]=this.holes[b].getTransformedSpacedPoints(a,this.bends);return d};THREE.Shape.prototype.extractAllPoints=function(a){return{shape:this.getTransformedPoints(a),holes:this.getPointsHoles(a)}};THREE.Shape.prototype.extractPoints=function(a){return this.useSpacedPoints?this.extractAllSpacedPoints(a):this.extractAllPoints(a)};
THREE.Shape.prototype.extractAllSpacedPoints=function(a){return{shape:this.getTransformedSpacedPoints(a),holes:this.getSpacedPointsHoles(a)}};
THREE.Shape.Utils={removeHoles:function(a,b){var c=a.concat(),d=c.concat(),e,f,h,g,i,k,m,l,p,s,t=[];for(i=0;i<b.length;i++){k=b[i];Array.prototype.push.apply(d,k);f=Number.POSITIVE_INFINITY;for(e=0;e<k.length;e++){p=k[e];s=[];for(l=0;l<c.length;l++)m=c[l],m=p.distanceToSquared(m),s.push(m),m<f&&(f=m,h=e,g=l)}e=0<=g-1?g-1:c.length-1;f=0<=h-1?h-1:k.length-1;var n=[k[h],c[g],c[e]];l=THREE.FontUtils.Triangulate.area(n);var r=[k[h],k[f],c[g]];p=THREE.FontUtils.Triangulate.area(r);s=g;m=h;g+=1;h+=-1;0>
g&&(g+=c.length);g%=c.length;0>h&&(h+=k.length);h%=k.length;e=0<=g-1?g-1:c.length-1;f=0<=h-1?h-1:k.length-1;n=[k[h],c[g],c[e]];n=THREE.FontUtils.Triangulate.area(n);r=[k[h],k[f],c[g]];r=THREE.FontUtils.Triangulate.area(r);l+p>n+r&&(g=s,h=m,0>g&&(g+=c.length),g%=c.length,0>h&&(h+=k.length),h%=k.length,e=0<=g-1?g-1:c.length-1,f=0<=h-1?h-1:k.length-1);l=c.slice(0,g);p=c.slice(g);s=k.slice(h);m=k.slice(0,h);f=[k[h],k[f],c[g]];t.push([k[h],c[g],c[e]]);t.push(f);c=l.concat(s).concat(m).concat(p)}return{shape:c,
isolatedPts:t,allpoints:d}},triangulateShape:function(a,b){var c=THREE.Shape.Utils.removeHoles(a,b),d=c.allpoints,e=c.isolatedPts,c=THREE.FontUtils.Triangulate(c.shape,!1),f,h,g,i,k={};f=0;for(h=d.length;f<h;f++)i=d[f].x+":"+d[f].y,void 0!==k[i]&&console.log("Duplicate point",i),k[i]=f;f=0;for(h=c.length;f<h;f++){g=c[f];for(d=0;3>d;d++)i=g[d].x+":"+g[d].y,i=k[i],void 0!==i&&(g[d]=i)}f=0;for(h=e.length;f<h;f++){g=e[f];for(d=0;3>d;d++)i=g[d].x+":"+g[d].y,i=k[i],void 0!==i&&(g[d]=i)}return c.concat(e)},
isClockWise:function(a){return 0>THREE.FontUtils.Triangulate.area(a)},b2p0:function(a,b){var c=1-a;return c*c*b},b2p1:function(a,b){return 2*(1-a)*a*b},b2p2:function(a,b){return a*a*b},b2:function(a,b,c,d){return this.b2p0(a,b)+this.b2p1(a,c)+this.b2p2(a,d)},b3p0:function(a,b){var c=1-a;return c*c*c*b},b3p1:function(a,b){var c=1-a;return 3*c*c*a*b},b3p2:function(a,b){return 3*(1-a)*a*a*b},b3p3:function(a,b){return a*a*a*b},b3:function(a,b,c,d,e){return this.b3p0(a,b)+this.b3p1(a,c)+this.b3p2(a,d)+
this.b3p3(a,e)}};THREE.LineCurve=function(a,b){this.v1=a;this.v2=b};THREE.LineCurve.prototype=Object.create(THREE.Curve.prototype);THREE.LineCurve.prototype.getPoint=function(a){var b=this.v2.clone().sub(this.v1);b.multiplyScalar(a).add(this.v1);return b};THREE.LineCurve.prototype.getPointAt=function(a){return this.getPoint(a)};THREE.LineCurve.prototype.getTangent=function(){return this.v2.clone().sub(this.v1).normalize()};THREE.QuadraticBezierCurve=function(a,b,c){this.v0=a;this.v1=b;this.v2=c};THREE.QuadraticBezierCurve.prototype=Object.create(THREE.Curve.prototype);THREE.QuadraticBezierCurve.prototype.getPoint=function(a){var b;b=THREE.Shape.Utils.b2(a,this.v0.x,this.v1.x,this.v2.x);a=THREE.Shape.Utils.b2(a,this.v0.y,this.v1.y,this.v2.y);return new THREE.Vector2(b,a)};
THREE.QuadraticBezierCurve.prototype.getTangent=function(a){var b;b=THREE.Curve.Utils.tangentQuadraticBezier(a,this.v0.x,this.v1.x,this.v2.x);a=THREE.Curve.Utils.tangentQuadraticBezier(a,this.v0.y,this.v1.y,this.v2.y);b=new THREE.Vector2(b,a);b.normalize();return b};THREE.CubicBezierCurve=function(a,b,c,d){this.v0=a;this.v1=b;this.v2=c;this.v3=d};THREE.CubicBezierCurve.prototype=Object.create(THREE.Curve.prototype);THREE.CubicBezierCurve.prototype.getPoint=function(a){var b;b=THREE.Shape.Utils.b3(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x);a=THREE.Shape.Utils.b3(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y);return new THREE.Vector2(b,a)};
THREE.CubicBezierCurve.prototype.getTangent=function(a){var b;b=THREE.Curve.Utils.tangentCubicBezier(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x);a=THREE.Curve.Utils.tangentCubicBezier(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y);b=new THREE.Vector2(b,a);b.normalize();return b};THREE.SplineCurve=function(a){this.points=void 0==a?[]:a};THREE.SplineCurve.prototype=Object.create(THREE.Curve.prototype);THREE.SplineCurve.prototype.getPoint=function(a){var b=new THREE.Vector2,c=[],d=this.points,e;e=(d.length-1)*a;a=Math.floor(e);e-=a;c[0]=0==a?a:a-1;c[1]=a;c[2]=a>d.length-2?d.length-1:a+1;c[3]=a>d.length-3?d.length-1:a+2;b.x=THREE.Curve.Utils.interpolate(d[c[0]].x,d[c[1]].x,d[c[2]].x,d[c[3]].x,e);b.y=THREE.Curve.Utils.interpolate(d[c[0]].y,d[c[1]].y,d[c[2]].y,d[c[3]].y,e);return b};THREE.EllipseCurve=function(a,b,c,d,e,f,h){this.aX=a;this.aY=b;this.xRadius=c;this.yRadius=d;this.aStartAngle=e;this.aEndAngle=f;this.aClockwise=h};THREE.EllipseCurve.prototype=Object.create(THREE.Curve.prototype);
THREE.EllipseCurve.prototype.getPoint=function(a){var b;b=this.aEndAngle-this.aStartAngle;0>b&&(b+=2*Math.PI);b>2*Math.PI&&(b-=2*Math.PI);b=!0===this.aClockwise?this.aEndAngle+(1-a)*(2*Math.PI-b):this.aStartAngle+a*b;a=this.aX+this.xRadius*Math.cos(b);b=this.aY+this.yRadius*Math.sin(b);return new THREE.Vector2(a,b)};THREE.ArcCurve=function(a,b,c,d,e,f){THREE.EllipseCurve.call(this,a,b,c,c,d,e,f)};THREE.ArcCurve.prototype=Object.create(THREE.EllipseCurve.prototype);THREE.LineCurve3=THREE.Curve.create(function(a,b){this.v1=a;this.v2=b},function(a){var b=new THREE.Vector3;b.subVectors(this.v2,this.v1);b.multiplyScalar(a);b.add(this.v1);return b});THREE.QuadraticBezierCurve3=THREE.Curve.create(function(a,b,c){this.v0=a;this.v1=b;this.v2=c},function(a){var b,c;b=THREE.Shape.Utils.b2(a,this.v0.x,this.v1.x,this.v2.x);c=THREE.Shape.Utils.b2(a,this.v0.y,this.v1.y,this.v2.y);a=THREE.Shape.Utils.b2(a,this.v0.z,this.v1.z,this.v2.z);return new THREE.Vector3(b,c,a)});THREE.CubicBezierCurve3=THREE.Curve.create(function(a,b,c,d){this.v0=a;this.v1=b;this.v2=c;this.v3=d},function(a){var b,c;b=THREE.Shape.Utils.b3(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x);c=THREE.Shape.Utils.b3(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y);a=THREE.Shape.Utils.b3(a,this.v0.z,this.v1.z,this.v2.z,this.v3.z);return new THREE.Vector3(b,c,a)});THREE.SplineCurve3=THREE.Curve.create(function(a){this.points=void 0==a?[]:a},function(a){var b=new THREE.Vector3,c=[],d=this.points,e,a=(d.length-1)*a;e=Math.floor(a);a-=e;c[0]=0==e?e:e-1;c[1]=e;c[2]=e>d.length-2?d.length-1:e+1;c[3]=e>d.length-3?d.length-1:e+2;e=d[c[0]];var f=d[c[1]],h=d[c[2]],c=d[c[3]];b.x=THREE.Curve.Utils.interpolate(e.x,f.x,h.x,c.x,a);b.y=THREE.Curve.Utils.interpolate(e.y,f.y,h.y,c.y,a);b.z=THREE.Curve.Utils.interpolate(e.z,f.z,h.z,c.z,a);return b});THREE.ClosedSplineCurve3=THREE.Curve.create(function(a){this.points=void 0==a?[]:a},function(a){var b=new THREE.Vector3,c=[],d=this.points,e;e=(d.length-0)*a;a=Math.floor(e);e-=a;a+=0<a?0:(Math.floor(Math.abs(a)/d.length)+1)*d.length;c[0]=(a-1)%d.length;c[1]=a%d.length;c[2]=(a+1)%d.length;c[3]=(a+2)%d.length;b.x=THREE.Curve.Utils.interpolate(d[c[0]].x,d[c[1]].x,d[c[2]].x,d[c[3]].x,e);b.y=THREE.Curve.Utils.interpolate(d[c[0]].y,d[c[1]].y,d[c[2]].y,d[c[3]].y,e);b.z=THREE.Curve.Utils.interpolate(d[c[0]].z,
d[c[1]].z,d[c[2]].z,d[c[3]].z,e);return b});THREE.AnimationHandler=function(){var a=[],b={},c={update:function(b){for(var c=0;c<a.length;c++)a[c].update(b)},addToUpdate:function(b){-1===a.indexOf(b)&&a.push(b)},removeFromUpdate:function(b){b=a.indexOf(b);-1!==b&&a.splice(b,1)},add:function(a){void 0!==b[a.name]&&console.log("THREE.AnimationHandler.add: Warning! "+a.name+" already exists in library. Overwriting.");b[a.name]=a;if(!0!==a.initialized){for(var c=0;c<a.hierarchy.length;c++){for(var d=0;d<a.hierarchy[c].keys.length;d++)if(0>a.hierarchy[c].keys[d].time&&
(a.hierarchy[c].keys[d].time=0),void 0!==a.hierarchy[c].keys[d].rot&&!(a.hierarchy[c].keys[d].rot instanceof THREE.Quaternion)){var g=a.hierarchy[c].keys[d].rot;a.hierarchy[c].keys[d].rot=new THREE.Quaternion(g[0],g[1],g[2],g[3])}if(a.hierarchy[c].keys.length&&void 0!==a.hierarchy[c].keys[0].morphTargets){g={};for(d=0;d<a.hierarchy[c].keys.length;d++)for(var i=0;i<a.hierarchy[c].keys[d].morphTargets.length;i++){var k=a.hierarchy[c].keys[d].morphTargets[i];g[k]=-1}a.hierarchy[c].usedMorphTargets=g;
for(d=0;d<a.hierarchy[c].keys.length;d++){var m={};for(k in g){for(i=0;i<a.hierarchy[c].keys[d].morphTargets.length;i++)if(a.hierarchy[c].keys[d].morphTargets[i]===k){m[k]=a.hierarchy[c].keys[d].morphTargetsInfluences[i];break}i===a.hierarchy[c].keys[d].morphTargets.length&&(m[k]=0)}a.hierarchy[c].keys[d].morphTargetsInfluences=m}}for(d=1;d<a.hierarchy[c].keys.length;d++)a.hierarchy[c].keys[d].time===a.hierarchy[c].keys[d-1].time&&(a.hierarchy[c].keys.splice(d,1),d--);for(d=0;d<a.hierarchy[c].keys.length;d++)a.hierarchy[c].keys[d].index=
d}d=parseInt(a.length*a.fps,10);a.JIT={};a.JIT.hierarchy=[];for(c=0;c<a.hierarchy.length;c++)a.JIT.hierarchy.push(Array(d));a.initialized=!0}},get:function(a){if("string"===typeof a){if(b[a])return b[a];console.log("THREE.AnimationHandler.get: Couldn't find animation "+a);return null}},parse:function(a){var b=[];if(a instanceof THREE.SkinnedMesh)for(var c=0;c<a.bones.length;c++)b.push(a.bones[c]);else d(a,b);return b}},d=function(a,b){b.push(a);for(var c=0;c<a.children.length;c++)d(a.children[c],
b)};c.LINEAR=0;c.CATMULLROM=1;c.CATMULLROM_FORWARD=2;return c}();THREE.Animation=function(a,b,c){this.root=a;this.data=THREE.AnimationHandler.get(b);this.hierarchy=THREE.AnimationHandler.parse(a);this.currentTime=0;this.timeScale=1;this.isPlaying=!1;this.loop=this.isPaused=!0;this.interpolationType=void 0!==c?c:THREE.AnimationHandler.LINEAR;this.points=[];this.target=new THREE.Vector3};
THREE.Animation.prototype.play=function(a,b){if(!1===this.isPlaying){this.isPlaying=!0;this.loop=void 0!==a?a:!0;this.currentTime=void 0!==b?b:0;var c,d=this.hierarchy.length,e;for(c=0;c<d;c++){e=this.hierarchy[c];e.matrixAutoUpdate=!0;void 0===e.animationCache&&(e.animationCache={},e.animationCache.prevKey={pos:0,rot:0,scl:0},e.animationCache.nextKey={pos:0,rot:0,scl:0},e.animationCache.originalMatrix=e instanceof THREE.Bone?e.skinMatrix:e.matrix);var f=e.animationCache.prevKey;e=e.animationCache.nextKey;
f.pos=this.data.hierarchy[c].keys[0];f.rot=this.data.hierarchy[c].keys[0];f.scl=this.data.hierarchy[c].keys[0];e.pos=this.getNextKeyWith("pos",c,1);e.rot=this.getNextKeyWith("rot",c,1);e.scl=this.getNextKeyWith("scl",c,1)}this.update(0)}this.isPaused=!1;THREE.AnimationHandler.addToUpdate(this)};THREE.Animation.prototype.pause=function(){!0===this.isPaused?THREE.AnimationHandler.addToUpdate(this):THREE.AnimationHandler.removeFromUpdate(this);this.isPaused=!this.isPaused};
THREE.Animation.prototype.stop=function(){this.isPaused=this.isPlaying=!1;THREE.AnimationHandler.removeFromUpdate(this)};
THREE.Animation.prototype.update=function(a){if(!1!==this.isPlaying){var b=["pos","rot","scl"],c,d,e,f,h,g,i,k,m;m=this.currentTime+=a*this.timeScale;k=this.currentTime%=this.data.length;parseInt(Math.min(k*this.data.fps,this.data.length*this.data.fps),10);for(var l=0,p=this.hierarchy.length;l<p;l++){a=this.hierarchy[l];i=a.animationCache;for(var s=0;3>s;s++){c=b[s];h=i.prevKey[c];g=i.nextKey[c];if(g.time<=m){if(k<m)if(this.loop){h=this.data.hierarchy[l].keys[0];for(g=this.getNextKeyWith(c,l,1);g.time<
k;)h=g,g=this.getNextKeyWith(c,l,g.index+1)}else{this.stop();return}else{do h=g,g=this.getNextKeyWith(c,l,g.index+1);while(g.time<k)}i.prevKey[c]=h;i.nextKey[c]=g}a.matrixAutoUpdate=!0;a.matrixWorldNeedsUpdate=!0;d=(k-h.time)/(g.time-h.time);e=h[c];f=g[c];if(0>d||1<d)console.log("THREE.Animation.update: Warning! Scale out of bounds:"+d+" on bone "+l),d=0>d?0:1;if("pos"===c)if(c=a.position,this.interpolationType===THREE.AnimationHandler.LINEAR)c.x=e[0]+(f[0]-e[0])*d,c.y=e[1]+(f[1]-e[1])*d,c.z=e[2]+
(f[2]-e[2])*d;else{if(this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD)this.points[0]=this.getPrevKeyWith("pos",l,h.index-1).pos,this.points[1]=e,this.points[2]=f,this.points[3]=this.getNextKeyWith("pos",l,g.index+1).pos,d=0.33*d+0.33,e=this.interpolateCatmullRom(this.points,d),c.x=e[0],c.y=e[1],c.z=e[2],this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD&&(d=this.interpolateCatmullRom(this.points,1.01*d),
this.target.set(d[0],d[1],d[2]),this.target.sub(c),this.target.y=0,this.target.normalize(),d=Math.atan2(this.target.x,this.target.z),a.rotation.set(0,d,0))}else"rot"===c?THREE.Quaternion.slerp(e,f,a.quaternion,d):"scl"===c&&(c=a.scale,c.x=e[0]+(f[0]-e[0])*d,c.y=e[1]+(f[1]-e[1])*d,c.z=e[2]+(f[2]-e[2])*d)}}}};
THREE.Animation.prototype.interpolateCatmullRom=function(a,b){var c=[],d=[],e,f,h,g,i,k;e=(a.length-1)*b;f=Math.floor(e);e-=f;c[0]=0===f?f:f-1;c[1]=f;c[2]=f>a.length-2?f:f+1;c[3]=f>a.length-3?f:f+2;f=a[c[0]];g=a[c[1]];i=a[c[2]];k=a[c[3]];c=e*e;h=e*c;d[0]=this.interpolate(f[0],g[0],i[0],k[0],e,c,h);d[1]=this.interpolate(f[1],g[1],i[1],k[1],e,c,h);d[2]=this.interpolate(f[2],g[2],i[2],k[2],e,c,h);return d};
THREE.Animation.prototype.interpolate=function(a,b,c,d,e,f,h){a=0.5*(c-a);d=0.5*(d-b);return(2*(b-c)+a+d)*h+(-3*(b-c)-2*a-d)*f+a*e+b};THREE.Animation.prototype.getNextKeyWith=function(a,b,c){for(var d=this.data.hierarchy[b].keys,c=this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD?c<d.length-1?c:d.length-1:c%d.length;c<d.length;c++)if(void 0!==d[c][a])return d[c];return this.data.hierarchy[b].keys[0]};
THREE.Animation.prototype.getPrevKeyWith=function(a,b,c){for(var d=this.data.hierarchy[b].keys,c=this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD?0<c?c:0:0<=c?c:c+d.length;0<=c;c--)if(void 0!==d[c][a])return d[c];return this.data.hierarchy[b].keys[d.length-1]};THREE.KeyFrameAnimation=function(a,b,c){this.root=a;this.data=THREE.AnimationHandler.get(b);this.hierarchy=THREE.AnimationHandler.parse(a);this.currentTime=0;this.timeScale=0.001;this.isPlaying=!1;this.loop=this.isPaused=!0;this.JITCompile=void 0!==c?c:!0;a=0;for(b=this.hierarchy.length;a<b;a++){var c=this.data.hierarchy[a].sids,d=this.hierarchy[a];if(this.data.hierarchy[a].keys.length&&c){for(var e=0;e<c.length;e++){var f=c[e],h=this.getNextKeyWith(f,a,0);h&&h.apply(f)}d.matrixAutoUpdate=!1;this.data.hierarchy[a].node.updateMatrix();
d.matrixWorldNeedsUpdate=!0}}};
THREE.KeyFrameAnimation.prototype.play=function(a,b){if(!this.isPlaying){this.isPlaying=!0;this.loop=void 0!==a?a:!0;this.currentTime=void 0!==b?b:0;this.startTimeMs=b;this.startTime=1E7;this.endTime=-this.startTime;var c,d=this.hierarchy.length,e,f;for(c=0;c<d;c++)e=this.hierarchy[c],f=this.data.hierarchy[c],void 0===f.animationCache&&(f.animationCache={},f.animationCache.prevKey=null,f.animationCache.nextKey=null,f.animationCache.originalMatrix=e instanceof THREE.Bone?e.skinMatrix:e.matrix),e=this.data.hierarchy[c].keys,
e.length&&(f.animationCache.prevKey=e[0],f.animationCache.nextKey=e[1],this.startTime=Math.min(e[0].time,this.startTime),this.endTime=Math.max(e[e.length-1].time,this.endTime));this.update(0)}this.isPaused=!1;THREE.AnimationHandler.addToUpdate(this)};THREE.KeyFrameAnimation.prototype.pause=function(){this.isPaused?THREE.AnimationHandler.addToUpdate(this):THREE.AnimationHandler.removeFromUpdate(this);this.isPaused=!this.isPaused};
THREE.KeyFrameAnimation.prototype.stop=function(){this.isPaused=this.isPlaying=!1;THREE.AnimationHandler.removeFromUpdate(this);for(var a=0;a<this.data.hierarchy.length;a++){var b=this.hierarchy[a],c=this.data.hierarchy[a];if(void 0!==c.animationCache){var d=c.animationCache.originalMatrix;b instanceof THREE.Bone?(d.copy(b.skinMatrix),b.skinMatrix=d):(d.copy(b.matrix),b.matrix=d);delete c.animationCache}}};
THREE.KeyFrameAnimation.prototype.update=function(a){if(this.isPlaying){var b,c,d,e,f=this.data.JIT.hierarchy,h,g,i;g=this.currentTime+=a*this.timeScale;h=this.currentTime%=this.data.length;h<this.startTimeMs&&(h=this.currentTime=this.startTimeMs+h);e=parseInt(Math.min(h*this.data.fps,this.data.length*this.data.fps),10);if((i=h<g)&&!this.loop){for(var a=0,k=this.hierarchy.length;a<k;a++){var m=this.data.hierarchy[a].keys,f=this.data.hierarchy[a].sids;d=m.length-1;e=this.hierarchy[a];if(m.length){for(m=
0;m<f.length;m++)h=f[m],(g=this.getPrevKeyWith(h,a,d))&&g.apply(h);this.data.hierarchy[a].node.updateMatrix();e.matrixWorldNeedsUpdate=!0}}this.stop()}else if(!(h<this.startTime)){a=0;for(k=this.hierarchy.length;a<k;a++){d=this.hierarchy[a];b=this.data.hierarchy[a];var m=b.keys,l=b.animationCache;if(this.JITCompile&&void 0!==f[a][e])d instanceof THREE.Bone?(d.skinMatrix=f[a][e],d.matrixWorldNeedsUpdate=!1):(d.matrix=f[a][e],d.matrixWorldNeedsUpdate=!0);else if(m.length){this.JITCompile&&l&&(d instanceof
THREE.Bone?d.skinMatrix=l.originalMatrix:d.matrix=l.originalMatrix);b=l.prevKey;c=l.nextKey;if(b&&c){if(c.time<=g){if(i&&this.loop){b=m[0];for(c=m[1];c.time<h;)b=c,c=m[b.index+1]}else if(!i)for(var p=m.length-1;c.time<h&&c.index!==p;)b=c,c=m[b.index+1];l.prevKey=b;l.nextKey=c}c.time>=h?b.interpolate(c,h):b.interpolate(c,c.time)}this.data.hierarchy[a].node.updateMatrix();d.matrixWorldNeedsUpdate=!0}}if(this.JITCompile&&void 0===f[0][e]){this.hierarchy[0].updateMatrixWorld(!0);for(a=0;a<this.hierarchy.length;a++)f[a][e]=
this.hierarchy[a]instanceof THREE.Bone?this.hierarchy[a].skinMatrix.clone():this.hierarchy[a].matrix.clone()}}}};THREE.KeyFrameAnimation.prototype.getNextKeyWith=function(a,b,c){b=this.data.hierarchy[b].keys;for(c%=b.length;c<b.length;c++)if(b[c].hasTarget(a))return b[c];return b[0]};THREE.KeyFrameAnimation.prototype.getPrevKeyWith=function(a,b,c){b=this.data.hierarchy[b].keys;for(c=0<=c?c:c+b.length;0<=c;c--)if(b[c].hasTarget(a))return b[c];return b[b.length-1]};THREE.CubeCamera=function(a,b,c){THREE.Object3D.call(this);var d=new THREE.PerspectiveCamera(90,1,a,b);d.up.set(0,-1,0);d.lookAt(new THREE.Vector3(1,0,0));this.add(d);var e=new THREE.PerspectiveCamera(90,1,a,b);e.up.set(0,-1,0);e.lookAt(new THREE.Vector3(-1,0,0));this.add(e);var f=new THREE.PerspectiveCamera(90,1,a,b);f.up.set(0,0,1);f.lookAt(new THREE.Vector3(0,1,0));this.add(f);var h=new THREE.PerspectiveCamera(90,1,a,b);h.up.set(0,0,-1);h.lookAt(new THREE.Vector3(0,-1,0));this.add(h);var g=new THREE.PerspectiveCamera(90,
1,a,b);g.up.set(0,-1,0);g.lookAt(new THREE.Vector3(0,0,1));this.add(g);var i=new THREE.PerspectiveCamera(90,1,a,b);i.up.set(0,-1,0);i.lookAt(new THREE.Vector3(0,0,-1));this.add(i);this.renderTarget=new THREE.WebGLRenderTargetCube(c,c,{format:THREE.RGBFormat,magFilter:THREE.LinearFilter,minFilter:THREE.LinearFilter});this.updateCubeMap=function(a,b){var c=this.renderTarget,p=c.generateMipmaps;c.generateMipmaps=!1;c.activeCubeFace=0;a.render(b,d,c);c.activeCubeFace=1;a.render(b,e,c);c.activeCubeFace=
2;a.render(b,f,c);c.activeCubeFace=3;a.render(b,h,c);c.activeCubeFace=4;a.render(b,g,c);c.generateMipmaps=p;c.activeCubeFace=5;a.render(b,i,c)}};THREE.CubeCamera.prototype=Object.create(THREE.Object3D.prototype);THREE.CombinedCamera=function(a,b,c,d,e,f,h){THREE.Camera.call(this);this.fov=c;this.left=-a/2;this.right=a/2;this.top=b/2;this.bottom=-b/2;this.cameraO=new THREE.OrthographicCamera(a/-2,a/2,b/2,b/-2,f,h);this.cameraP=new THREE.PerspectiveCamera(c,a/b,d,e);this.zoom=1;this.toPerspective()};THREE.CombinedCamera.prototype=Object.create(THREE.Camera.prototype);
THREE.CombinedCamera.prototype.toPerspective=function(){this.near=this.cameraP.near;this.far=this.cameraP.far;this.cameraP.fov=this.fov/this.zoom;this.cameraP.updateProjectionMatrix();this.projectionMatrix=this.cameraP.projectionMatrix;this.inPerspectiveMode=!0;this.inOrthographicMode=!1};
THREE.CombinedCamera.prototype.toOrthographic=function(){var a=this.cameraP.aspect,b=(this.cameraP.near+this.cameraP.far)/2,b=Math.tan(this.fov/2)*b,a=2*b*a/2,b=b/this.zoom,a=a/this.zoom;this.cameraO.left=-a;this.cameraO.right=a;this.cameraO.top=b;this.cameraO.bottom=-b;this.cameraO.updateProjectionMatrix();this.near=this.cameraO.near;this.far=this.cameraO.far;this.projectionMatrix=this.cameraO.projectionMatrix;this.inPerspectiveMode=!1;this.inOrthographicMode=!0};
THREE.CombinedCamera.prototype.setSize=function(a,b){this.cameraP.aspect=a/b;this.left=-a/2;this.right=a/2;this.top=b/2;this.bottom=-b/2};THREE.CombinedCamera.prototype.setFov=function(a){this.fov=a;this.inPerspectiveMode?this.toPerspective():this.toOrthographic()};THREE.CombinedCamera.prototype.updateProjectionMatrix=function(){this.inPerspectiveMode?this.toPerspective():(this.toPerspective(),this.toOrthographic())};
THREE.CombinedCamera.prototype.setLens=function(a,b){void 0===b&&(b=24);var c=2*THREE.Math.radToDeg(Math.atan(b/(2*a)));this.setFov(c);return c};THREE.CombinedCamera.prototype.setZoom=function(a){this.zoom=a;this.inPerspectiveMode?this.toPerspective():this.toOrthographic()};THREE.CombinedCamera.prototype.toFrontView=function(){this.rotation.x=0;this.rotation.y=0;this.rotation.z=0;this.rotationAutoUpdate=!1};
THREE.CombinedCamera.prototype.toBackView=function(){this.rotation.x=0;this.rotation.y=Math.PI;this.rotation.z=0;this.rotationAutoUpdate=!1};THREE.CombinedCamera.prototype.toLeftView=function(){this.rotation.x=0;this.rotation.y=-Math.PI/2;this.rotation.z=0;this.rotationAutoUpdate=!1};THREE.CombinedCamera.prototype.toRightView=function(){this.rotation.x=0;this.rotation.y=Math.PI/2;this.rotation.z=0;this.rotationAutoUpdate=!1};
THREE.CombinedCamera.prototype.toTopView=function(){this.rotation.x=-Math.PI/2;this.rotation.y=0;this.rotation.z=0;this.rotationAutoUpdate=!1};THREE.CombinedCamera.prototype.toBottomView=function(){this.rotation.x=Math.PI/2;this.rotation.y=0;this.rotation.z=0;this.rotationAutoUpdate=!1};THREE.CircleGeometry=function(a,b,c,d){THREE.Geometry.call(this);this.radius=a=a||50;this.segments=b=void 0!==b?Math.max(3,b):8;this.thetaStart=c=void 0!==c?c:0;this.thetaLength=d=void 0!==d?d:2*Math.PI;var e,f=[];e=new THREE.Vector3;var h=new THREE.Vector2(0.5,0.5);this.vertices.push(e);f.push(h);for(e=0;e<=b;e++){var g=new THREE.Vector3,i=c+e/b*d;g.x=a*Math.cos(i);g.y=a*Math.sin(i);this.vertices.push(g);f.push(new THREE.Vector2((g.x/a+1)/2,(g.y/a+1)/2))}c=new THREE.Vector3(0,0,1);for(e=1;e<=b;e++)this.faces.push(new THREE.Face3(e,
e+1,0,[c,c,c])),this.faceVertexUvs[0].push([f[e],f[e+1],h]);this.computeCentroids();this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,a)};THREE.CircleGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.CubeGeometry=function(a,b,c,d,e,f){function h(a,b,c,d,e,f,h,n){var r,q=g.widthSegments,u=g.heightSegments,w=e/2,z=f/2,B=g.vertices.length;if("x"===a&&"y"===b||"y"===a&&"x"===b)r="z";else if("x"===a&&"z"===b||"z"===a&&"x"===b)r="y",u=g.depthSegments;else if("z"===a&&"y"===b||"y"===a&&"z"===b)r="x",q=g.depthSegments;var D=q+1,x=u+1,F=e/q,A=f/u,O=new THREE.Vector3;O[r]=0<h?1:-1;for(e=0;e<x;e++)for(f=0;f<D;f++){var C=new THREE.Vector3;C[a]=(f*F-w)*c;C[b]=(e*A-z)*d;C[r]=h;g.vertices.push(C)}for(e=
0;e<u;e++)for(f=0;f<q;f++)z=f+D*e,a=f+D*(e+1),b=f+1+D*(e+1),c=f+1+D*e,d=new THREE.Vector2(f/q,1-e/u),h=new THREE.Vector2(f/q,1-(e+1)/u),r=new THREE.Vector2((f+1)/q,1-(e+1)/u),w=new THREE.Vector2((f+1)/q,1-e/u),z=new THREE.Face3(z+B,a+B,c+B),z.normal.copy(O),z.vertexNormals.push(O.clone(),O.clone(),O.clone()),z.materialIndex=n,g.faces.push(z),g.faceVertexUvs[0].push([d,h,w]),z=new THREE.Face3(a+B,b+B,c+B),z.normal.copy(O),z.vertexNormals.push(O.clone(),O.clone(),O.clone()),z.materialIndex=n,g.faces.push(z),
g.faceVertexUvs[0].push([h.clone(),r,w.clone()])}THREE.Geometry.call(this);var g=this;this.width=a;this.height=b;this.depth=c;this.widthSegments=d||1;this.heightSegments=e||1;this.depthSegments=f||1;a=this.width/2;b=this.height/2;c=this.depth/2;h("z","y",-1,-1,this.depth,this.height,a,0);h("z","y",1,-1,this.depth,this.height,-a,1);h("x","z",1,1,this.width,this.depth,b,2);h("x","z",1,-1,this.width,this.depth,-b,3);h("x","y",1,-1,this.width,this.height,c,4);h("x","y",-1,-1,this.width,this.height,-c,
5);this.computeCentroids();this.mergeVertices()};THREE.CubeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.CylinderGeometry=function(a,b,c,d,e,f){THREE.Geometry.call(this);this.radiusTop=a=void 0!==a?a:20;this.radiusBottom=b=void 0!==b?b:20;this.height=c=void 0!==c?c:100;this.radialSegments=d=d||8;this.heightSegments=e=e||1;this.openEnded=f=void 0!==f?f:!1;var h=c/2,g,i,k=[],m=[];for(i=0;i<=e;i++){var l=[],p=[],s=i/e,t=s*(b-a)+a;for(g=0;g<=d;g++){var n=g/d,r=new THREE.Vector3;r.x=t*Math.sin(2*n*Math.PI);r.y=-s*c+h;r.z=t*Math.cos(2*n*Math.PI);this.vertices.push(r);l.push(this.vertices.length-1);p.push(new THREE.Vector2(n,
1-s))}k.push(l);m.push(p)}c=(b-a)/c;for(g=0;g<d;g++){0!==a?(l=this.vertices[k[0][g]].clone(),p=this.vertices[k[0][g+1]].clone()):(l=this.vertices[k[1][g]].clone(),p=this.vertices[k[1][g+1]].clone());l.setY(Math.sqrt(l.x*l.x+l.z*l.z)*c).normalize();p.setY(Math.sqrt(p.x*p.x+p.z*p.z)*c).normalize();for(i=0;i<e;i++){var s=k[i][g],t=k[i+1][g],n=k[i+1][g+1],r=k[i][g+1],q=l.clone(),u=l.clone(),w=p.clone(),z=p.clone(),B=m[i][g].clone(),D=m[i+1][g].clone(),x=m[i+1][g+1].clone(),F=m[i][g+1].clone();this.faces.push(new THREE.Face3(s,
t,r,[q,u,z]));this.faceVertexUvs[0].push([B,D,F]);this.faces.push(new THREE.Face3(t,n,r,[u,w,z]));this.faceVertexUvs[0].push([D,x,F])}}if(!1===f&&0<a){this.vertices.push(new THREE.Vector3(0,h,0));for(g=0;g<d;g++)s=k[0][g],t=k[0][g+1],n=this.vertices.length-1,q=new THREE.Vector3(0,1,0),u=new THREE.Vector3(0,1,0),w=new THREE.Vector3(0,1,0),B=m[0][g].clone(),D=m[0][g+1].clone(),x=new THREE.Vector2(D.u,0),this.faces.push(new THREE.Face3(s,t,n,[q,u,w])),this.faceVertexUvs[0].push([B,D,x])}if(!1===f&&0<
b){this.vertices.push(new THREE.Vector3(0,-h,0));for(g=0;g<d;g++)s=k[i][g+1],t=k[i][g],n=this.vertices.length-1,q=new THREE.Vector3(0,-1,0),u=new THREE.Vector3(0,-1,0),w=new THREE.Vector3(0,-1,0),B=m[i][g+1].clone(),D=m[i][g].clone(),x=new THREE.Vector2(D.u,1),this.faces.push(new THREE.Face3(s,t,n,[q,u,w])),this.faceVertexUvs[0].push([B,D,x])}this.computeCentroids();this.computeFaceNormals()};THREE.CylinderGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ExtrudeGeometry=function(a,b){"undefined"!==typeof a&&(THREE.Geometry.call(this),a=a instanceof Array?a:[a],this.shapebb=a[a.length-1].getBoundingBox(),this.addShapeList(a,b),this.computeCentroids(),this.computeFaceNormals())};THREE.ExtrudeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ExtrudeGeometry.prototype.addShapeList=function(a,b){for(var c=a.length,d=0;d<c;d++)this.addShape(a[d],b)};
THREE.ExtrudeGeometry.prototype.addShape=function(a,b){function c(a,b,c){b||console.log("die");return b.clone().multiplyScalar(c).add(a)}function d(a,b,c){var d=THREE.ExtrudeGeometry.__v1,e=THREE.ExtrudeGeometry.__v2,f=THREE.ExtrudeGeometry.__v3,g=THREE.ExtrudeGeometry.__v4,h=THREE.ExtrudeGeometry.__v5,i=THREE.ExtrudeGeometry.__v6;d.set(a.x-b.x,a.y-b.y);e.set(a.x-c.x,a.y-c.y);d=d.normalize();e=e.normalize();f.set(-d.y,d.x);g.set(e.y,-e.x);h.copy(a).add(f);i.copy(a).add(g);if(h.equals(i))return g.clone();
h.copy(b).add(f);i.copy(c).add(g);f=d.dot(g);g=i.sub(h).dot(g);0===f&&(console.log("Either infinite or no solutions!"),0===g?console.log("Its finite solutions."):console.log("Too bad, no solutions."));g/=f;return 0>g?(b=Math.atan2(b.y-a.y,b.x-a.x),a=Math.atan2(c.y-a.y,c.x-a.x),b>a&&(a+=2*Math.PI),c=(b+a)/2,a=-Math.cos(c),c=-Math.sin(c),new THREE.Vector2(a,c)):d.multiplyScalar(g).add(h).sub(a).clone()}function e(c,d){var e,f;for(N=c.length;0<=--N;){e=N;f=N-1;0>f&&(f=c.length-1);for(var g=0,h=s+2*m,
g=0;g<h;g++){var i=ba*g,k=ba*(g+1),l=d+e+i,i=d+f+i,p=d+f+k,k=d+e+k,n=c,q=g,r=h,t=e,v=f,l=l+E,i=i+E,p=p+E,k=k+E;C.faces.push(new THREE.Face3(l,i,k,null,null,u));C.faces.push(new THREE.Face3(i,p,k,null,null,u));l=w.generateSideWallUV(C,a,n,b,l,i,p,k,q,r,t,v);C.faceVertexUvs[0].push([l[0],l[1],l[3]]);C.faceVertexUvs[0].push([l[1],l[2],l[3]])}}}function f(a,b,c){C.vertices.push(new THREE.Vector3(a,b,c))}function h(c,d,e,f){c+=E;d+=E;e+=E;C.faces.push(new THREE.Face3(c,d,e,null,null,q));c=f?w.generateBottomUV(C,
a,b,c,d,e):w.generateTopUV(C,a,b,c,d,e);C.faceVertexUvs[0].push(c)}var g=void 0!==b.amount?b.amount:100,i=void 0!==b.bevelThickness?b.bevelThickness:6,k=void 0!==b.bevelSize?b.bevelSize:i-2,m=void 0!==b.bevelSegments?b.bevelSegments:3,l=void 0!==b.bevelEnabled?b.bevelEnabled:!0,p=void 0!==b.curveSegments?b.curveSegments:12,s=void 0!==b.steps?b.steps:1,t=b.extrudePath,n,r=!1,q=b.material,u=b.extrudeMaterial,w=void 0!==b.UVGenerator?b.UVGenerator:THREE.ExtrudeGeometry.WorldUVGenerator,z,B,D,x;t&&(n=
t.getSpacedPoints(s),r=!0,l=!1,z=void 0!==b.frames?b.frames:new THREE.TubeGeometry.FrenetFrames(t,s,!1),B=new THREE.Vector3,D=new THREE.Vector3,x=new THREE.Vector3);l||(k=i=m=0);var F,A,O,C=this,E=this.vertices.length,p=a.extractPoints(p),I=p.shape,p=p.holes;if(t=!THREE.Shape.Utils.isClockWise(I)){I=I.reverse();A=0;for(O=p.length;A<O;A++)F=p[A],THREE.Shape.Utils.isClockWise(F)&&(p[A]=F.reverse());t=!1}var y=THREE.Shape.Utils.triangulateShape(I,p),t=I;A=0;for(O=p.length;A<O;A++)F=p[A],I=I.concat(F);
var v,G,R,J,ba=I.length,oa=y.length,pa=[],N=0,M=t.length;v=M-1;for(G=N+1;N<M;N++,v++,G++)v===M&&(v=0),G===M&&(G=0),pa[N]=d(t[N],t[v],t[G]);var Q=[],K,ca=pa.concat();A=0;for(O=p.length;A<O;A++){F=p[A];K=[];N=0;M=F.length;v=M-1;for(G=N+1;N<M;N++,v++,G++)v===M&&(v=0),G===M&&(G=0),K[N]=d(F[N],F[v],F[G]);Q.push(K);ca=ca.concat(K)}for(v=0;v<m;v++){F=v/m;R=i*(1-F);G=k*Math.sin(F*Math.PI/2);N=0;for(M=t.length;N<M;N++)J=c(t[N],pa[N],G),f(J.x,J.y,-R);A=0;for(O=p.length;A<O;A++){F=p[A];K=Q[A];N=0;for(M=F.length;N<
M;N++)J=c(F[N],K[N],G),f(J.x,J.y,-R)}}G=k;for(N=0;N<ba;N++)J=l?c(I[N],ca[N],G):I[N],r?(D.copy(z.normals[0]).multiplyScalar(J.x),B.copy(z.binormals[0]).multiplyScalar(J.y),x.copy(n[0]).add(D).add(B),f(x.x,x.y,x.z)):f(J.x,J.y,0);for(F=1;F<=s;F++)for(N=0;N<ba;N++)J=l?c(I[N],ca[N],G):I[N],r?(D.copy(z.normals[F]).multiplyScalar(J.x),B.copy(z.binormals[F]).multiplyScalar(J.y),x.copy(n[F]).add(D).add(B),f(x.x,x.y,x.z)):f(J.x,J.y,g/s*F);for(v=m-1;0<=v;v--){F=v/m;R=i*(1-F);G=k*Math.sin(F*Math.PI/2);N=0;for(M=
t.length;N<M;N++)J=c(t[N],pa[N],G),f(J.x,J.y,g+R);A=0;for(O=p.length;A<O;A++){F=p[A];K=Q[A];N=0;for(M=F.length;N<M;N++)J=c(F[N],K[N],G),r?f(J.x,J.y+n[s-1].y,n[s-1].x+R):f(J.x,J.y,g+R)}}if(l){i=0*ba;for(N=0;N<oa;N++)g=y[N],h(g[2]+i,g[1]+i,g[0]+i,!0);i=ba*(s+2*m);for(N=0;N<oa;N++)g=y[N],h(g[0]+i,g[1]+i,g[2]+i,!1)}else{for(N=0;N<oa;N++)g=y[N],h(g[2],g[1],g[0],!0);for(N=0;N<oa;N++)g=y[N],h(g[0]+ba*s,g[1]+ba*s,g[2]+ba*s,!1)}g=0;e(t,g);g+=t.length;A=0;for(O=p.length;A<O;A++)F=p[A],e(F,g),g+=F.length};
THREE.ExtrudeGeometry.WorldUVGenerator={generateTopUV:function(a,b,c,d,e,f){b=a.vertices[e].x;e=a.vertices[e].y;c=a.vertices[f].x;f=a.vertices[f].y;return[new THREE.Vector2(a.vertices[d].x,a.vertices[d].y),new THREE.Vector2(b,e),new THREE.Vector2(c,f)]},generateBottomUV:function(a,b,c,d,e,f){return this.generateTopUV(a,b,c,d,e,f)},generateSideWallUV:function(a,b,c,d,e,f,h,g){var b=a.vertices[e].x,c=a.vertices[e].y,e=a.vertices[e].z,d=a.vertices[f].x,i=a.vertices[f].y,f=a.vertices[f].z,k=a.vertices[h].x,
m=a.vertices[h].y,h=a.vertices[h].z,l=a.vertices[g].x,p=a.vertices[g].y,a=a.vertices[g].z;return 0.01>Math.abs(c-i)?[new THREE.Vector2(b,1-e),new THREE.Vector2(d,1-f),new THREE.Vector2(k,1-h),new THREE.Vector2(l,1-a)]:[new THREE.Vector2(c,1-e),new THREE.Vector2(i,1-f),new THREE.Vector2(m,1-h),new THREE.Vector2(p,1-a)]}};THREE.ExtrudeGeometry.__v1=new THREE.Vector2;THREE.ExtrudeGeometry.__v2=new THREE.Vector2;THREE.ExtrudeGeometry.__v3=new THREE.Vector2;THREE.ExtrudeGeometry.__v4=new THREE.Vector2;
THREE.ExtrudeGeometry.__v5=new THREE.Vector2;THREE.ExtrudeGeometry.__v6=new THREE.Vector2;THREE.ShapeGeometry=function(a,b){THREE.Geometry.call(this);!1===a instanceof Array&&(a=[a]);this.shapebb=a[a.length-1].getBoundingBox();this.addShapeList(a,b);this.computeCentroids();this.computeFaceNormals()};THREE.ShapeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ShapeGeometry.prototype.addShapeList=function(a,b){for(var c=0,d=a.length;c<d;c++)this.addShape(a[c],b);return this};
THREE.ShapeGeometry.prototype.addShape=function(a,b){void 0===b&&(b={});var c=b.material,d=void 0===b.UVGenerator?THREE.ExtrudeGeometry.WorldUVGenerator:b.UVGenerator,e,f,h,g=this.vertices.length;e=a.extractPoints(void 0!==b.curveSegments?b.curveSegments:12);var i=e.shape,k=e.holes;if(!THREE.Shape.Utils.isClockWise(i)){i=i.reverse();e=0;for(f=k.length;e<f;e++)h=k[e],THREE.Shape.Utils.isClockWise(h)&&(k[e]=h.reverse())}var m=THREE.Shape.Utils.triangulateShape(i,k);e=0;for(f=k.length;e<f;e++)h=k[e],
i=i.concat(h);k=i.length;f=m.length;for(e=0;e<k;e++)h=i[e],this.vertices.push(new THREE.Vector3(h.x,h.y,0));for(e=0;e<f;e++)k=m[e],i=k[0]+g,h=k[1]+g,k=k[2]+g,this.faces.push(new THREE.Face3(i,h,k,null,null,c)),this.faceVertexUvs[0].push(d.generateBottomUV(this,a,b,i,h,k))};THREE.LatheGeometry=function(a,b,c,d){THREE.Geometry.call(this);for(var b=b||12,c=c||0,d=d||2*Math.PI,e=1/(a.length-1),f=1/b,h=0,g=b;h<=g;h++)for(var i=c+h*f*d,k=Math.cos(i),m=Math.sin(i),i=0,l=a.length;i<l;i++){var p=a[i],s=new THREE.Vector3;s.x=k*p.x-m*p.y;s.y=m*p.x+k*p.y;s.z=p.z;this.vertices.push(s)}c=a.length;h=0;for(g=b;h<g;h++){i=0;for(l=a.length-1;i<l;i++){var b=m=i+c*h,d=m+c,k=m+1+c,m=m+1,p=h*f,s=i*e,t=p+f,n=s+e;this.faces.push(new THREE.Face3(b,d,m));this.faceVertexUvs[0].push([new THREE.Vector2(p,
s),new THREE.Vector2(t,s),new THREE.Vector2(p,n)]);this.faces.push(new THREE.Face3(d,k,m));this.faceVertexUvs[0].push([new THREE.Vector2(t,s),new THREE.Vector2(t,n),new THREE.Vector2(p,n)])}}this.mergeVertices();this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.LatheGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.PlaneGeometry=function(a,b,c,d){THREE.Geometry.call(this);this.width=a;this.height=b;this.widthSegments=c||1;this.heightSegments=d||1;for(var e=a/2,f=b/2,c=this.widthSegments,d=this.heightSegments,h=c+1,g=d+1,i=this.width/c,k=this.height/d,m=new THREE.Vector3(0,0,1),a=0;a<g;a++)for(b=0;b<h;b++)this.vertices.push(new THREE.Vector3(b*i-e,-(a*k-f),0));for(a=0;a<d;a++)for(b=0;b<c;b++){var l=b+h*a,e=b+h*(a+1),f=b+1+h*(a+1),g=b+1+h*a,i=new THREE.Vector2(b/c,1-a/d),k=new THREE.Vector2(b/c,1-(a+1)/
d),p=new THREE.Vector2((b+1)/c,1-(a+1)/d),s=new THREE.Vector2((b+1)/c,1-a/d),l=new THREE.Face3(l,e,g);l.normal.copy(m);l.vertexNormals.push(m.clone(),m.clone(),m.clone());this.faces.push(l);this.faceVertexUvs[0].push([i,k,s]);l=new THREE.Face3(e,f,g);l.normal.copy(m);l.vertexNormals.push(m.clone(),m.clone(),m.clone());this.faces.push(l);this.faceVertexUvs[0].push([k.clone(),p,s.clone()])}this.computeCentroids()};THREE.PlaneGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.RingGeometry=function(a,b,c,d,e,f){THREE.Geometry.call(this);for(var a=a||0,b=b||50,e=void 0!==e?e:0,f=void 0!==f?f:2*Math.PI,c=void 0!==c?Math.max(3,c):8,d=void 0!==d?Math.max(3,d):8,h=[],g=a,i=(b-a)/d,a=0;a<=d;a++){for(b=0;b<=c;b++){var k=new THREE.Vector3,m=e+b/c*f;k.x=g*Math.cos(m);k.y=g*Math.sin(m);this.vertices.push(k);h.push(new THREE.Vector2((k.x/g+1)/2,-(k.y/g+1)/2+1))}g+=i}e=new THREE.Vector3(0,0,1);for(a=0;a<d;a++){f=a*c;for(b=0;b<=c;b++){var m=b+f,i=m+a,k=m+c+a,l=m+c+1+a;this.faces.push(new THREE.Face3(i,
k,l,[e,e,e]));this.faceVertexUvs[0].push([h[i],h[k],h[l]]);i=m+a;k=m+c+1+a;l=m+1+a;this.faces.push(new THREE.Face3(i,k,l,[e,e,e]));this.faceVertexUvs[0].push([h[i],h[k],h[l]])}}this.computeCentroids();this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,g)};THREE.RingGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.SphereGeometry=function(a,b,c,d,e,f,h){THREE.Geometry.call(this);this.radius=a=a||50;this.widthSegments=b=Math.max(3,Math.floor(b)||8);this.heightSegments=c=Math.max(2,Math.floor(c)||6);this.phiStart=d=void 0!==d?d:0;this.phiLength=e=void 0!==e?e:2*Math.PI;this.thetaStart=f=void 0!==f?f:0;this.thetaLength=h=void 0!==h?h:Math.PI;var g,i,k=[],m=[];for(i=0;i<=c;i++){var l=[],p=[];for(g=0;g<=b;g++){var s=g/b,t=i/c,n=new THREE.Vector3;n.x=-a*Math.cos(d+s*e)*Math.sin(f+t*h);n.y=a*Math.cos(f+t*h);
n.z=a*Math.sin(d+s*e)*Math.sin(f+t*h);this.vertices.push(n);l.push(this.vertices.length-1);p.push(new THREE.Vector2(s,1-t))}k.push(l);m.push(p)}for(i=0;i<this.heightSegments;i++)for(g=0;g<this.widthSegments;g++){var b=k[i][g+1],c=k[i][g],d=k[i+1][g],e=k[i+1][g+1],f=this.vertices[b].clone().normalize(),h=this.vertices[c].clone().normalize(),l=this.vertices[d].clone().normalize(),p=this.vertices[e].clone().normalize(),s=m[i][g+1].clone(),t=m[i][g].clone(),n=m[i+1][g].clone(),r=m[i+1][g+1].clone();Math.abs(this.vertices[b].y)===
this.radius?(this.faces.push(new THREE.Face3(b,d,e,[f,l,p])),this.faceVertexUvs[0].push([s,n,r])):Math.abs(this.vertices[d].y)===this.radius?(this.faces.push(new THREE.Face3(b,c,d,[f,h,l])),this.faceVertexUvs[0].push([s,t,n])):(this.faces.push(new THREE.Face3(b,c,e,[f,h,p])),this.faceVertexUvs[0].push([s,t,r]),this.faces.push(new THREE.Face3(c,d,e,[h,l,p])),this.faceVertexUvs[0].push([t.clone(),n,r.clone()]))}this.computeCentroids();this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,
a)};THREE.SphereGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TextGeometry=function(a,b){var b=b||{},c=THREE.FontUtils.generateShapes(a,b);b.amount=void 0!==b.height?b.height:50;void 0===b.bevelThickness&&(b.bevelThickness=10);void 0===b.bevelSize&&(b.bevelSize=8);void 0===b.bevelEnabled&&(b.bevelEnabled=!1);THREE.ExtrudeGeometry.call(this,c,b)};THREE.TextGeometry.prototype=Object.create(THREE.ExtrudeGeometry.prototype);THREE.TorusGeometry=function(a,b,c,d,e){THREE.Geometry.call(this);this.radius=a||100;this.tube=b||40;this.radialSegments=c||8;this.tubularSegments=d||6;this.arc=e||2*Math.PI;e=new THREE.Vector3;a=[];b=[];for(c=0;c<=this.radialSegments;c++)for(d=0;d<=this.tubularSegments;d++){var f=d/this.tubularSegments*this.arc,h=2*c/this.radialSegments*Math.PI;e.x=this.radius*Math.cos(f);e.y=this.radius*Math.sin(f);var g=new THREE.Vector3;g.x=(this.radius+this.tube*Math.cos(h))*Math.cos(f);g.y=(this.radius+this.tube*
Math.cos(h))*Math.sin(f);g.z=this.tube*Math.sin(h);this.vertices.push(g);a.push(new THREE.Vector2(d/this.tubularSegments,c/this.radialSegments));b.push(g.clone().sub(e).normalize())}for(c=1;c<=this.radialSegments;c++)for(d=1;d<=this.tubularSegments;d++){var e=(this.tubularSegments+1)*c+d-1,f=(this.tubularSegments+1)*(c-1)+d-1,h=(this.tubularSegments+1)*(c-1)+d,g=(this.tubularSegments+1)*c+d,i=new THREE.Face3(e,f,g,[b[e],b[f],b[g]]);i.normal.add(b[e]);i.normal.add(b[f]);i.normal.add(b[g]);i.normal.normalize();
this.faces.push(i);this.faceVertexUvs[0].push([a[e].clone(),a[f].clone(),a[g].clone()]);i=new THREE.Face3(f,h,g,[b[f],b[h],b[g]]);i.normal.add(b[f]);i.normal.add(b[h]);i.normal.add(b[g]);i.normal.normalize();this.faces.push(i);this.faceVertexUvs[0].push([a[f].clone(),a[h].clone(),a[g].clone()])}this.computeCentroids()};THREE.TorusGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TorusKnotGeometry=function(a,b,c,d,e,f,h){function g(a,b,c,d,e){var f=Math.cos(a),g=Math.sin(a),a=b/c*a,b=Math.cos(a),f=0.5*(d*(2+b))*f,g=0.5*d*(2+b)*g,d=0.5*e*d*Math.sin(a);return new THREE.Vector3(f,g,d)}THREE.Geometry.call(this);this.radius=a||100;this.tube=b||40;this.radialSegments=c||64;this.tubularSegments=d||8;this.p=e||2;this.q=f||3;this.heightScale=h||1;this.grid=Array(this.radialSegments);c=new THREE.Vector3;d=new THREE.Vector3;e=new THREE.Vector3;for(a=0;a<this.radialSegments;++a){this.grid[a]=
Array(this.tubularSegments);b=2*(a/this.radialSegments)*this.p*Math.PI;f=g(b,this.q,this.p,this.radius,this.heightScale);b=g(b+0.01,this.q,this.p,this.radius,this.heightScale);c.subVectors(b,f);d.addVectors(b,f);e.crossVectors(c,d);d.crossVectors(e,c);e.normalize();d.normalize();for(b=0;b<this.tubularSegments;++b){var i=2*(b/this.tubularSegments)*Math.PI,h=-this.tube*Math.cos(i),i=this.tube*Math.sin(i),k=new THREE.Vector3;k.x=f.x+h*d.x+i*e.x;k.y=f.y+h*d.y+i*e.y;k.z=f.z+h*d.z+i*e.z;this.grid[a][b]=
this.vertices.push(k)-1}}for(a=0;a<this.radialSegments;++a)for(b=0;b<this.tubularSegments;++b){var e=(a+1)%this.radialSegments,f=(b+1)%this.tubularSegments,c=this.grid[a][b],d=this.grid[e][b],e=this.grid[e][f],f=this.grid[a][f],h=new THREE.Vector2(a/this.radialSegments,b/this.tubularSegments),i=new THREE.Vector2((a+1)/this.radialSegments,b/this.tubularSegments),k=new THREE.Vector2((a+1)/this.radialSegments,(b+1)/this.tubularSegments),m=new THREE.Vector2(a/this.radialSegments,(b+1)/this.tubularSegments);
this.faces.push(new THREE.Face3(c,d,f));this.faceVertexUvs[0].push([h,i,m]);this.faces.push(new THREE.Face3(d,e,f));this.faceVertexUvs[0].push([i.clone(),k,m.clone()])}this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.TorusKnotGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TubeGeometry=function(a,b,c,d,e){THREE.Geometry.call(this);this.path=a;this.segments=b||64;this.radius=c||1;this.radialSegments=d||8;this.closed=e||!1;this.grid=[];var f,h,d=this.segments+1,g,i,k,e=new THREE.Vector3,m,l,b=new THREE.TubeGeometry.FrenetFrames(this.path,this.segments,this.closed);m=b.normals;l=b.binormals;this.tangents=b.tangents;this.normals=m;this.binormals=l;for(b=0;b<d;b++){this.grid[b]=[];c=b/(d-1);k=a.getPointAt(c);f=m[b];h=l[b];for(c=0;c<this.radialSegments;c++)g=2*(c/this.radialSegments)*
Math.PI,i=-this.radius*Math.cos(g),g=this.radius*Math.sin(g),e.copy(k),e.x+=i*f.x+g*h.x,e.y+=i*f.y+g*h.y,e.z+=i*f.z+g*h.z,this.grid[b][c]=this.vertices.push(new THREE.Vector3(e.x,e.y,e.z))-1}for(b=0;b<this.segments;b++)for(c=0;c<this.radialSegments;c++)e=this.closed?(b+1)%this.segments:b+1,m=(c+1)%this.radialSegments,a=this.grid[b][c],d=this.grid[e][c],e=this.grid[e][m],m=this.grid[b][m],l=new THREE.Vector2(b/this.segments,c/this.radialSegments),f=new THREE.Vector2((b+1)/this.segments,c/this.radialSegments),
h=new THREE.Vector2((b+1)/this.segments,(c+1)/this.radialSegments),i=new THREE.Vector2(b/this.segments,(c+1)/this.radialSegments),this.faces.push(new THREE.Face3(a,d,m)),this.faceVertexUvs[0].push([l,f,i]),this.faces.push(new THREE.Face3(d,e,m)),this.faceVertexUvs[0].push([f.clone(),h,i.clone()]);this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.TubeGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry.FrenetFrames=function(a,b,c){new THREE.Vector3;var d=new THREE.Vector3;new THREE.Vector3;var e=[],f=[],h=[],g=new THREE.Vector3,i=new THREE.Matrix4,b=b+1,k,m,l;this.tangents=e;this.normals=f;this.binormals=h;for(k=0;k<b;k++)m=k/(b-1),e[k]=a.getTangentAt(m),e[k].normalize();f[0]=new THREE.Vector3;h[0]=new THREE.Vector3;a=Number.MAX_VALUE;k=Math.abs(e[0].x);m=Math.abs(e[0].y);l=Math.abs(e[0].z);k<=a&&(a=k,d.set(1,0,0));m<=a&&(a=m,d.set(0,1,0));l<=a&&d.set(0,0,1);g.crossVectors(e[0],
d).normalize();f[0].crossVectors(e[0],g);h[0].crossVectors(e[0],f[0]);for(k=1;k<b;k++)f[k]=f[k-1].clone(),h[k]=h[k-1].clone(),g.crossVectors(e[k-1],e[k]),1E-4<g.length()&&(g.normalize(),d=Math.acos(THREE.Math.clamp(e[k-1].dot(e[k]),-1,1)),f[k].applyMatrix4(i.makeRotationAxis(g,d))),h[k].crossVectors(e[k],f[k]);if(c){d=Math.acos(THREE.Math.clamp(f[0].dot(f[b-1]),-1,1));d/=b-1;0<e[0].dot(g.crossVectors(f[0],f[b-1]))&&(d=-d);for(k=1;k<b;k++)f[k].applyMatrix4(i.makeRotationAxis(e[k],d*k)),h[k].crossVectors(e[k],
f[k])}};THREE.PolyhedronGeometry=function(a,b,c,d){function e(a){var b=a.normalize().clone();b.index=g.vertices.push(b)-1;var c=Math.atan2(a.z,-a.x)/2/Math.PI+0.5,a=Math.atan2(-a.y,Math.sqrt(a.x*a.x+a.z*a.z))/Math.PI+0.5;b.uv=new THREE.Vector2(c,1-a);return b}function f(a,b,c){var d=new THREE.Face3(a.index,b.index,c.index,[a.clone(),b.clone(),c.clone()]);d.centroid.add(a).add(b).add(c).divideScalar(3);g.faces.push(d);d=Math.atan2(d.centroid.z,-d.centroid.x);g.faceVertexUvs[0].push([h(a.uv,a,d),h(b.uv,b,d),
h(c.uv,c,d)])}function h(a,b,c){0>c&&1===a.x&&(a=new THREE.Vector2(a.x-1,a.y));0===b.x&&0===b.z&&(a=new THREE.Vector2(c/2/Math.PI+0.5,a.y));return a.clone()}THREE.Geometry.call(this);for(var c=c||1,d=d||0,g=this,i=0,k=a.length;i<k;i++)e(new THREE.Vector3(a[i][0],a[i][1],a[i][2]));for(var m=this.vertices,a=[],i=0,k=b.length;i<k;i++){var l=m[b[i][0]],p=m[b[i][1]],s=m[b[i][2]];a[i]=new THREE.Face3(l.index,p.index,s.index,[l.clone(),p.clone(),s.clone()])}i=0;for(k=a.length;i<k;i++){p=a[i];m=d;b=Math.pow(2,
m);Math.pow(4,m);for(var m=e(g.vertices[p.a]),l=e(g.vertices[p.b]),t=e(g.vertices[p.c]),p=[],s=0;s<=b;s++){p[s]=[];for(var n=e(m.clone().lerp(t,s/b)),r=e(l.clone().lerp(t,s/b)),q=b-s,u=0;u<=q;u++)p[s][u]=0==u&&s==b?n:e(n.clone().lerp(r,u/q))}for(s=0;s<b;s++)for(u=0;u<2*(b-s)-1;u++)m=Math.floor(u/2),0==u%2?f(p[s][m+1],p[s+1][m],p[s][m]):f(p[s][m+1],p[s+1][m+1],p[s+1][m])}i=0;for(k=this.faceVertexUvs[0].length;i<k;i++)d=this.faceVertexUvs[0][i],a=d[0].x,b=d[1].x,m=d[2].x,l=Math.max(a,Math.max(b,m)),
p=Math.min(a,Math.min(b,m)),0.9<l&&0.1>p&&(0.2>a&&(d[0].x+=1),0.2>b&&(d[1].x+=1),0.2>m&&(d[2].x+=1));i=0;for(k=this.vertices.length;i<k;i++)this.vertices[i].multiplyScalar(c);this.mergeVertices();this.computeCentroids();this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,c)};THREE.PolyhedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.IcosahedronGeometry=function(a,b){this.radius=a;this.detail=b;var c=(1+Math.sqrt(5))/2;THREE.PolyhedronGeometry.call(this,[[-1,c,0],[1,c,0],[-1,-c,0],[1,-c,0],[0,-1,c],[0,1,c],[0,-1,-c],[0,1,-c],[c,0,-1],[c,0,1],[-c,0,-1],[-c,0,1]],[[0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],[1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],[3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],[4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]],a,b)};THREE.IcosahedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.OctahedronGeometry=function(a,b){THREE.PolyhedronGeometry.call(this,[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]],[[0,2,4],[0,4,3],[0,3,5],[0,5,2],[1,2,5],[1,5,3],[1,3,4],[1,4,2]],a,b)};THREE.OctahedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TetrahedronGeometry=function(a,b){THREE.PolyhedronGeometry.call(this,[[1,1,1],[-1,-1,1],[-1,1,-1],[1,-1,-1]],[[2,1,0],[0,3,2],[1,3,0],[2,3,1]],a,b)};THREE.TetrahedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ParametricGeometry=function(a,b,c){THREE.Geometry.call(this);var d=this.vertices,e=this.faces,f=this.faceVertexUvs[0],h,g,i,k,m=b+1;for(h=0;h<=c;h++){k=h/c;for(g=0;g<=b;g++)i=g/b,i=a(i,k),d.push(i)}var l,p,s,t;for(h=0;h<c;h++)for(g=0;g<b;g++)a=h*m+g,d=h*m+g+1,k=(h+1)*m+g+1,i=(h+1)*m+g,l=new THREE.Vector2(g/b,h/c),p=new THREE.Vector2((g+1)/b,h/c),s=new THREE.Vector2((g+1)/b,(h+1)/c),t=new THREE.Vector2(g/b,(h+1)/c),e.push(new THREE.Face3(a,d,i)),f.push([l,p,t]),e.push(new THREE.Face3(d,k,i)),
f.push([p.clone(),s,t.clone()]);this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.ParametricGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.AxisHelper=function(a){var a=a||1,b=new THREE.Geometry;b.vertices.push(new THREE.Vector3,new THREE.Vector3(a,0,0),new THREE.Vector3,new THREE.Vector3(0,a,0),new THREE.Vector3,new THREE.Vector3(0,0,a));b.colors.push(new THREE.Color(16711680),new THREE.Color(16755200),new THREE.Color(65280),new THREE.Color(11206400),new THREE.Color(255),new THREE.Color(43775));a=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});THREE.Line.call(this,b,a,THREE.LinePieces)};
THREE.AxisHelper.prototype=Object.create(THREE.Line.prototype);THREE.ArrowHelper=function(a,b,c,d){THREE.Object3D.call(this);void 0===d&&(d=16776960);void 0===c&&(c=1);this.position=b;b=new THREE.Geometry;b.vertices.push(new THREE.Vector3(0,0,0));b.vertices.push(new THREE.Vector3(0,1,0));this.line=new THREE.Line(b,new THREE.LineBasicMaterial({color:d}));this.line.matrixAutoUpdate=!1;this.add(this.line);b=new THREE.CylinderGeometry(0,0.05,0.25,5,1);b.applyMatrix((new THREE.Matrix4).makeTranslation(0,0.875,0));this.cone=new THREE.Mesh(b,new THREE.MeshBasicMaterial({color:d}));
this.cone.matrixAutoUpdate=!1;this.add(this.cone);this.setDirection(a);this.setLength(c)};THREE.ArrowHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.ArrowHelper.prototype.setDirection=function(){var a=new THREE.Vector3,b;return function(c){0.99999<c.y?this.quaternion.set(0,0,0,1):-0.99999>c.y?this.quaternion.set(1,0,0,0):(a.set(c.z,0,-c.x).normalize(),b=Math.acos(c.y),this.quaternion.setFromAxisAngle(a,b))}}();THREE.ArrowHelper.prototype.setLength=function(a){this.scale.set(a,a,a)};
THREE.ArrowHelper.prototype.setColor=function(a){this.line.material.color.setHex(a);this.cone.material.color.setHex(a)};THREE.BoxHelper=function(a){var b=[new THREE.Vector3(1,1,1),new THREE.Vector3(-1,1,1),new THREE.Vector3(-1,-1,1),new THREE.Vector3(1,-1,1),new THREE.Vector3(1,1,-1),new THREE.Vector3(-1,1,-1),new THREE.Vector3(-1,-1,-1),new THREE.Vector3(1,-1,-1)];this.vertices=b;var c=new THREE.Geometry;c.vertices.push(b[0],b[1],b[1],b[2],b[2],b[3],b[3],b[0],b[4],b[5],b[5],b[6],b[6],b[7],b[7],b[4],b[0],b[4],b[1],b[5],b[2],b[6],b[3],b[7]);THREE.Line.call(this,c,new THREE.LineBasicMaterial({color:16776960}),THREE.LinePieces);
void 0!==a&&this.update(a)};THREE.BoxHelper.prototype=Object.create(THREE.Line.prototype);
THREE.BoxHelper.prototype.update=function(a){var b=a.geometry;null===b.boundingBox&&b.computeBoundingBox();var c=b.boundingBox.min,b=b.boundingBox.max,d=this.vertices;d[0].set(b.x,b.y,b.z);d[1].set(c.x,b.y,b.z);d[2].set(c.x,c.y,b.z);d[3].set(b.x,c.y,b.z);d[4].set(b.x,b.y,c.z);d[5].set(c.x,b.y,c.z);d[6].set(c.x,c.y,c.z);d[7].set(b.x,c.y,c.z);this.geometry.computeBoundingSphere();this.geometry.verticesNeedUpdate=!0;this.matrixAutoUpdate=!1;this.matrixWorld=a.matrixWorld};THREE.BoundingBoxHelper=function(a,b){var c=b||8947848;this.object=a;this.box=new THREE.Box3;THREE.Mesh.call(this,new THREE.CubeGeometry(1,1,1),new THREE.MeshBasicMaterial({color:c,wireframe:!0}))};THREE.BoundingBoxHelper.prototype=Object.create(THREE.Mesh.prototype);THREE.BoundingBoxHelper.prototype.update=function(){this.box.setFromObject(this.object);this.box.size(this.scale);this.box.center(this.position)};THREE.CameraHelper=function(a){function b(a,b,d){c(a,d);c(b,d)}function c(a,b){d.vertices.push(new THREE.Vector3);d.colors.push(new THREE.Color(b));void 0===f[a]&&(f[a]=[]);f[a].push(d.vertices.length-1)}var d=new THREE.Geometry,e=new THREE.LineBasicMaterial({color:16777215,vertexColors:THREE.FaceColors}),f={};b("n1","n2",16755200);b("n2","n4",16755200);b("n4","n3",16755200);b("n3","n1",16755200);b("f1","f2",16755200);b("f2","f4",16755200);b("f4","f3",16755200);b("f3","f1",16755200);b("n1","f1",16755200);
b("n2","f2",16755200);b("n3","f3",16755200);b("n4","f4",16755200);b("p","n1",16711680);b("p","n2",16711680);b("p","n3",16711680);b("p","n4",16711680);b("u1","u2",43775);b("u2","u3",43775);b("u3","u1",43775);b("c","t",16777215);b("p","c",3355443);b("cn1","cn2",3355443);b("cn3","cn4",3355443);b("cf1","cf2",3355443);b("cf3","cf4",3355443);THREE.Line.call(this,d,e,THREE.LinePieces);this.camera=a;this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;this.pointMap=f;this.update()};
THREE.CameraHelper.prototype=Object.create(THREE.Line.prototype);
THREE.CameraHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Camera,c=new THREE.Projector;return function(){function d(d,h,g,i){a.set(h,g,i);c.unprojectVector(a,b);d=e.pointMap[d];if(void 0!==d){h=0;for(g=d.length;h<g;h++)e.geometry.vertices[d[h]].copy(a)}}var e=this;b.projectionMatrix.copy(this.camera.projectionMatrix);d("c",0,0,-1);d("t",0,0,1);d("n1",-1,-1,-1);d("n2",1,-1,-1);d("n3",-1,1,-1);d("n4",1,1,-1);d("f1",-1,-1,1);d("f2",1,-1,1);d("f3",-1,1,1);d("f4",1,1,1);d("u1",
0.7,1.1,-1);d("u2",-0.7,1.1,-1);d("u3",0,2,-1);d("cf1",-1,0,1);d("cf2",1,0,1);d("cf3",0,-1,1);d("cf4",0,1,1);d("cn1",-1,0,-1);d("cn2",1,0,-1);d("cn3",0,-1,-1);d("cn4",0,1,-1);this.geometry.verticesNeedUpdate=!0}}();THREE.DirectionalLightHelper=function(a,b){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;var c=new THREE.PlaneGeometry(b,b),d=new THREE.MeshBasicMaterial({wireframe:!0,fog:!1});d.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.lightPlane=new THREE.Mesh(c,d);this.add(this.lightPlane);c=new THREE.Geometry;c.vertices.push(new THREE.Vector3);c.vertices.push(new THREE.Vector3);c.computeLineDistances();
d=new THREE.LineBasicMaterial({fog:!1});d.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.targetLine=new THREE.Line(c,d);this.add(this.targetLine);this.update()};THREE.DirectionalLightHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.DirectionalLightHelper.prototype.dispose=function(){this.lightPlane.geometry.dispose();this.lightPlane.material.dispose();this.targetLine.geometry.dispose();this.targetLine.material.dispose()};
THREE.DirectionalLightHelper.prototype.update=function(){var a=new THREE.Vector3;return function(){a.getPositionFromMatrix(this.light.matrixWorld).negate();this.lightPlane.lookAt(a);this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.targetLine.geometry.vertices[1].copy(a);this.targetLine.geometry.verticesNeedUpdate=!0;this.targetLine.material.color.copy(this.lightPlane.material.color)}}();THREE.FaceNormalsHelper=function(a,b,c,d){this.object=a;this.size=b||1;for(var a=c||16776960,d=d||1,b=new THREE.Geometry,c=0,e=this.object.geometry.faces.length;c<e;c++)b.vertices.push(new THREE.Vector3),b.vertices.push(new THREE.Vector3);THREE.Line.call(this,b,new THREE.LineBasicMaterial({color:a,linewidth:d}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.normalMatrix=new THREE.Matrix3;this.update()};THREE.FaceNormalsHelper.prototype=Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper.prototype.update=function(){var a=new THREE.Vector3;return function(){this.object.updateMatrixWorld(!0);this.normalMatrix.getNormalMatrix(this.object.matrixWorld);for(var b=this.geometry.vertices,c=this.object.geometry.faces,d=this.object.matrixWorld,e=0,f=c.length;e<f;e++){var h=c[e];a.copy(h.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);var g=2*e;b[g].copy(h.centroid).applyMatrix4(d);b[g+1].addVectors(b[g],a)}this.geometry.verticesNeedUpdate=
!0;return this}}();THREE.GridHelper=function(a,b){var c=new THREE.Geometry,d=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});this.color1=new THREE.Color(4473924);this.color2=new THREE.Color(8947848);for(var e=-a;e<=a;e+=b){c.vertices.push(new THREE.Vector3(-a,0,e),new THREE.Vector3(a,0,e),new THREE.Vector3(e,0,-a),new THREE.Vector3(e,0,a));var f=0===e?this.color1:this.color2;c.colors.push(f,f,f,f)}THREE.Line.call(this,c,d,THREE.LinePieces)};THREE.GridHelper.prototype=Object.create(THREE.Line.prototype);
THREE.GridHelper.prototype.setColors=function(a,b){this.color1.set(a);this.color2.set(b);this.geometry.colorsNeedUpdate=!0};THREE.HemisphereLightHelper=function(a,b){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;this.colors=[new THREE.Color,new THREE.Color];var c=new THREE.SphereGeometry(b,4,2);c.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI/2));for(var d=0;8>d;d++)c.faces[d].color=this.colors[4>d?0:1];d=new THREE.MeshBasicMaterial({vertexColors:THREE.FaceColors,wireframe:!0});this.lightSphere=new THREE.Mesh(c,d);this.add(this.lightSphere);
this.update()};THREE.HemisphereLightHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.HemisphereLightHelper.prototype.dispose=function(){this.lightSphere.geometry.dispose();this.lightSphere.material.dispose()};
THREE.HemisphereLightHelper.prototype.update=function(){var a=new THREE.Vector3;return function(){this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);this.lightSphere.lookAt(a.getPositionFromMatrix(this.light.matrixWorld).negate());this.lightSphere.geometry.colorsNeedUpdate=!0}}();THREE.PointLightHelper=function(a,b){this.light=a;this.light.updateMatrixWorld();var c=new THREE.SphereGeometry(b,4,2),d=new THREE.MeshBasicMaterial({wireframe:!0,fog:!1});d.color.copy(this.light.color).multiplyScalar(this.light.intensity);THREE.Mesh.call(this,c,d);this.matrixWorld=this.light.matrixWorld;this.matrixAutoUpdate=!1};THREE.PointLightHelper.prototype=Object.create(THREE.Mesh.prototype);THREE.PointLightHelper.prototype.dispose=function(){this.geometry.dispose();this.material.dispose()};
THREE.PointLightHelper.prototype.update=function(){this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)};THREE.SpotLightHelper=function(a){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;a=new THREE.CylinderGeometry(0,1,1,8,1,!0);a.applyMatrix((new THREE.Matrix4).makeTranslation(0,-0.5,0));a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI/2));var b=new THREE.MeshBasicMaterial({wireframe:!0,fog:!1});this.cone=new THREE.Mesh(a,b);this.add(this.cone);this.update()};THREE.SpotLightHelper.prototype=Object.create(THREE.Object3D.prototype);
THREE.SpotLightHelper.prototype.dispose=function(){this.cone.geometry.dispose();this.cone.material.dispose()};THREE.SpotLightHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(){var c=this.light.distance?this.light.distance:1E4,d=c*Math.tan(this.light.angle);this.cone.scale.set(d,d,c);a.getPositionFromMatrix(this.light.matrixWorld);b.getPositionFromMatrix(this.light.target.matrixWorld);this.cone.lookAt(b.sub(a));this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)}}();THREE.VertexNormalsHelper=function(a,b,c,d){this.object=a;this.size=b||1;for(var b=c||16711680,d=d||1,c=new THREE.Geometry,a=a.geometry.faces,e=0,f=a.length;e<f;e++)for(var h=0,g=a[e].vertexNormals.length;h<g;h++)c.vertices.push(new THREE.Vector3),c.vertices.push(new THREE.Vector3);THREE.Line.call(this,c,new THREE.LineBasicMaterial({color:b,linewidth:d}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.normalMatrix=new THREE.Matrix3;this.update()};THREE.VertexNormalsHelper.prototype=Object.create(THREE.Line.prototype);
THREE.VertexNormalsHelper.prototype.update=function(){var a=new THREE.Vector3;return function(){var b=["a","b","c","d"];this.object.updateMatrixWorld(!0);this.normalMatrix.getNormalMatrix(this.object.matrixWorld);for(var c=this.geometry.vertices,d=this.object.geometry.vertices,e=this.object.geometry.faces,f=this.object.matrixWorld,h=0,g=0,i=e.length;g<i;g++)for(var k=e[g],m=0,l=k.vertexNormals.length;m<l;m++){var p=k.vertexNormals[m];c[h].copy(d[k[b[m]]]).applyMatrix4(f);a.copy(p).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
a.add(c[h]);h+=1;c[h].copy(a);h+=1}this.geometry.verticesNeedUpdate=!0;return this}}();THREE.VertexTangentsHelper=function(a,b,c,d){this.object=a;this.size=b||1;for(var b=c||255,d=d||1,c=new THREE.Geometry,a=a.geometry.faces,e=0,f=a.length;e<f;e++)for(var h=0,g=a[e].vertexTangents.length;h<g;h++)c.vertices.push(new THREE.Vector3),c.vertices.push(new THREE.Vector3);THREE.Line.call(this,c,new THREE.LineBasicMaterial({color:b,linewidth:d}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.update()};THREE.VertexTangentsHelper.prototype=Object.create(THREE.Line.prototype);
THREE.VertexTangentsHelper.prototype.update=function(){var a=new THREE.Vector3;return function(){var b=["a","b","c","d"];this.object.updateMatrixWorld(!0);for(var c=this.geometry.vertices,d=this.object.geometry.vertices,e=this.object.geometry.faces,f=this.object.matrixWorld,h=0,g=0,i=e.length;g<i;g++)for(var k=e[g],m=0,l=k.vertexTangents.length;m<l;m++){var p=k.vertexTangents[m];c[h].copy(d[k[b[m]]]).applyMatrix4(f);a.copy(p).transformDirection(f).multiplyScalar(this.size);a.add(c[h]);h+=1;c[h].copy(a);
h+=1}this.geometry.verticesNeedUpdate=!0;return this}}();THREE.WireframeHelper=function(a){for(var b=[0,0],c={},d=function(a,b){return a-b},e=["a","b","c","d"],f=new THREE.Geometry,h=a.geometry.vertices,g=a.geometry.faces,i=0,k=g.length;i<k;i++)for(var m=g[i],l=0;3>l;l++){b[0]=m[e[l]];b[1]=m[e[(l+1)%3]];b.sort(d);var p=b.toString();void 0===c[p]&&(f.vertices.push(h[b[0]]),f.vertices.push(h[b[1]]),c[p]=!0)}THREE.Line.call(this,f,new THREE.LineBasicMaterial({color:16777215}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.matrixWorld=a.matrixWorld};
THREE.WireframeHelper.prototype=Object.create(THREE.Line.prototype);THREE.ImmediateRenderObject=function(){THREE.Object3D.call(this);this.render=function(){}};THREE.ImmediateRenderObject.prototype=Object.create(THREE.Object3D.prototype);THREE.LensFlare=function(a,b,c,d,e){THREE.Object3D.call(this);this.lensFlares=[];this.positionScreen=new THREE.Vector3;this.customUpdateCallback=void 0;void 0!==a&&this.add(a,b,c,d,e)};THREE.LensFlare.prototype=Object.create(THREE.Object3D.prototype);
THREE.LensFlare.prototype.add=function(a,b,c,d,e,f){void 0===b&&(b=-1);void 0===c&&(c=0);void 0===f&&(f=1);void 0===e&&(e=new THREE.Color(16777215));void 0===d&&(d=THREE.NormalBlending);c=Math.min(c,Math.max(0,c));this.lensFlares.push({texture:a,size:b,distance:c,x:0,y:0,z:0,scale:1,rotation:1,opacity:f,color:e,blending:d})};
THREE.LensFlare.prototype.updateLensFlares=function(){var a,b=this.lensFlares.length,c,d=2*-this.positionScreen.x,e=2*-this.positionScreen.y;for(a=0;a<b;a++)c=this.lensFlares[a],c.x=this.positionScreen.x+d*c.distance,c.y=this.positionScreen.y+e*c.distance,c.wantedRotation=0.25*c.x*Math.PI,c.rotation+=0.25*(c.wantedRotation-c.rotation)};THREE.MorphBlendMesh=function(a,b){THREE.Mesh.call(this,a,b);this.animationsMap={};this.animationsList=[];var c=this.geometry.morphTargets.length;this.createAnimation("__default",0,c-1,c/1);this.setAnimationWeight("__default",1)};THREE.MorphBlendMesh.prototype=Object.create(THREE.Mesh.prototype);
THREE.MorphBlendMesh.prototype.createAnimation=function(a,b,c,d){b={startFrame:b,endFrame:c,length:c-b+1,fps:d,duration:(c-b)/d,lastFrame:0,currentFrame:0,active:!1,time:0,direction:1,weight:1,directionBackwards:!1,mirroredLoop:!1};this.animationsMap[a]=b;this.animationsList.push(b)};
THREE.MorphBlendMesh.prototype.autoCreateAnimations=function(a){for(var b=/([a-z]+)(\d+)/,c,d={},e=this.geometry,f=0,h=e.morphTargets.length;f<h;f++){var g=e.morphTargets[f].name.match(b);if(g&&1<g.length){var i=g[1];d[i]||(d[i]={start:Infinity,end:-Infinity});g=d[i];f<g.start&&(g.start=f);f>g.end&&(g.end=f);c||(c=i)}}for(i in d)g=d[i],this.createAnimation(i,g.start,g.end,a);this.firstAnimation=c};
THREE.MorphBlendMesh.prototype.setAnimationDirectionForward=function(a){if(a=this.animationsMap[a])a.direction=1,a.directionBackwards=!1};THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward=function(a){if(a=this.animationsMap[a])a.direction=-1,a.directionBackwards=!0};THREE.MorphBlendMesh.prototype.setAnimationFPS=function(a,b){var c=this.animationsMap[a];c&&(c.fps=b,c.duration=(c.end-c.start)/c.fps)};
THREE.MorphBlendMesh.prototype.setAnimationDuration=function(a,b){var c=this.animationsMap[a];c&&(c.duration=b,c.fps=(c.end-c.start)/c.duration)};THREE.MorphBlendMesh.prototype.setAnimationWeight=function(a,b){var c=this.animationsMap[a];c&&(c.weight=b)};THREE.MorphBlendMesh.prototype.setAnimationTime=function(a,b){var c=this.animationsMap[a];c&&(c.time=b)};THREE.MorphBlendMesh.prototype.getAnimationTime=function(a){var b=0;if(a=this.animationsMap[a])b=a.time;return b};
THREE.MorphBlendMesh.prototype.getAnimationDuration=function(a){var b=-1;if(a=this.animationsMap[a])b=a.duration;return b};THREE.MorphBlendMesh.prototype.playAnimation=function(a){var b=this.animationsMap[a];b?(b.time=0,b.active=!0):console.warn("animation["+a+"] undefined")};THREE.MorphBlendMesh.prototype.stopAnimation=function(a){if(a=this.animationsMap[a])a.active=!1};
THREE.MorphBlendMesh.prototype.update=function(a){for(var b=0,c=this.animationsList.length;b<c;b++){var d=this.animationsList[b];if(d.active){var e=d.duration/d.length;d.time+=d.direction*a;if(d.mirroredLoop){if(d.time>d.duration||0>d.time)d.direction*=-1,d.time>d.duration&&(d.time=d.duration,d.directionBackwards=!0),0>d.time&&(d.time=0,d.directionBackwards=!1)}else d.time%=d.duration,0>d.time&&(d.time+=d.duration);var f=d.startFrame+THREE.Math.clamp(Math.floor(d.time/e),0,d.length-1),h=d.weight;
f!==d.currentFrame&&(this.morphTargetInfluences[d.lastFrame]=0,this.morphTargetInfluences[d.currentFrame]=1*h,this.morphTargetInfluences[f]=0,d.lastFrame=d.currentFrame,d.currentFrame=f);e=d.time%e/e;d.directionBackwards&&(e=1-e);this.morphTargetInfluences[d.currentFrame]=e*h;this.morphTargetInfluences[d.lastFrame]=(1-e)*h}}};THREE.LensFlarePlugin=function(){function a(a,c){var d=b.createProgram(),e=b.createShader(b.FRAGMENT_SHADER),f=b.createShader(b.VERTEX_SHADER),g="precision "+c+" float;\n";b.shaderSource(e,g+a.fragmentShader);b.shaderSource(f,g+a.vertexShader);b.compileShader(e);b.compileShader(f);b.attachShader(d,e);b.attachShader(d,f);b.linkProgram(d);return d}var b,c,d,e,f,h,g,i,k,m,l,p,s;this.init=function(t){b=t.context;c=t;d=t.getPrecision();e=new Float32Array(16);f=new Uint16Array(6);t=0;e[t++]=-1;e[t++]=-1;
e[t++]=0;e[t++]=0;e[t++]=1;e[t++]=-1;e[t++]=1;e[t++]=0;e[t++]=1;e[t++]=1;e[t++]=1;e[t++]=1;e[t++]=-1;e[t++]=1;e[t++]=0;e[t++]=1;t=0;f[t++]=0;f[t++]=1;f[t++]=2;f[t++]=0;f[t++]=2;f[t++]=3;h=b.createBuffer();g=b.createBuffer();b.bindBuffer(b.ARRAY_BUFFER,h);b.bufferData(b.ARRAY_BUFFER,e,b.STATIC_DRAW);b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,g);b.bufferData(b.ELEMENT_ARRAY_BUFFER,f,b.STATIC_DRAW);i=b.createTexture();k=b.createTexture();b.bindTexture(b.TEXTURE_2D,i);b.texImage2D(b.TEXTURE_2D,0,b.RGB,16,16,
0,b.RGB,b.UNSIGNED_BYTE,null);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_S,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_T,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,b.NEAREST);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,b.NEAREST);b.bindTexture(b.TEXTURE_2D,k);b.texImage2D(b.TEXTURE_2D,0,b.RGBA,16,16,0,b.RGBA,b.UNSIGNED_BYTE,null);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_S,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_T,b.CLAMP_TO_EDGE);
b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,b.NEAREST);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,b.NEAREST);0>=b.getParameter(b.MAX_VERTEX_TEXTURE_IMAGE_UNITS)?(m=!1,l=a(THREE.ShaderFlares.lensFlare,d)):(m=!0,l=a(THREE.ShaderFlares.lensFlareVertexTexture,d));p={};s={};p.vertex=b.getAttribLocation(l,"position");p.uv=b.getAttribLocation(l,"uv");s.renderType=b.getUniformLocation(l,"renderType");s.map=b.getUniformLocation(l,"map");s.occlusionMap=b.getUniformLocation(l,"occlusionMap");s.opacity=
b.getUniformLocation(l,"opacity");s.color=b.getUniformLocation(l,"color");s.scale=b.getUniformLocation(l,"scale");s.rotation=b.getUniformLocation(l,"rotation");s.screenPosition=b.getUniformLocation(l,"screenPosition")};this.render=function(a,d,e,f){var a=a.__webglFlares,u=a.length;if(u){var w=new THREE.Vector3,z=f/e,B=0.5*e,D=0.5*f,x=16/f,F=new THREE.Vector2(x*z,x),A=new THREE.Vector3(1,1,0),O=new THREE.Vector2(1,1),C=s,x=p;b.useProgram(l);b.enableVertexAttribArray(p.vertex);b.enableVertexAttribArray(p.uv);
b.uniform1i(C.occlusionMap,0);b.uniform1i(C.map,1);b.bindBuffer(b.ARRAY_BUFFER,h);b.vertexAttribPointer(x.vertex,2,b.FLOAT,!1,16,0);b.vertexAttribPointer(x.uv,2,b.FLOAT,!1,16,8);b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,g);b.disable(b.CULL_FACE);b.depthMask(!1);var E,I,y,v,G;for(E=0;E<u;E++)if(x=16/f,F.set(x*z,x),v=a[E],w.set(v.matrixWorld.elements[12],v.matrixWorld.elements[13],v.matrixWorld.elements[14]),w.applyMatrix4(d.matrixWorldInverse),w.applyProjection(d.projectionMatrix),A.copy(w),O.x=A.x*B+B,
O.y=A.y*D+D,m||0<O.x&&O.x<e&&0<O.y&&O.y<f){b.activeTexture(b.TEXTURE1);b.bindTexture(b.TEXTURE_2D,i);b.copyTexImage2D(b.TEXTURE_2D,0,b.RGB,O.x-8,O.y-8,16,16,0);b.uniform1i(C.renderType,0);b.uniform2f(C.scale,F.x,F.y);b.uniform3f(C.screenPosition,A.x,A.y,A.z);b.disable(b.BLEND);b.enable(b.DEPTH_TEST);b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0);b.activeTexture(b.TEXTURE0);b.bindTexture(b.TEXTURE_2D,k);b.copyTexImage2D(b.TEXTURE_2D,0,b.RGBA,O.x-8,O.y-8,16,16,0);b.uniform1i(C.renderType,1);b.disable(b.DEPTH_TEST);
b.activeTexture(b.TEXTURE1);b.bindTexture(b.TEXTURE_2D,i);b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0);v.positionScreen.copy(A);v.customUpdateCallback?v.customUpdateCallback(v):v.updateLensFlares();b.uniform1i(C.renderType,2);b.enable(b.BLEND);I=0;for(y=v.lensFlares.length;I<y;I++)G=v.lensFlares[I],0.001<G.opacity&&0.001<G.scale&&(A.x=G.x,A.y=G.y,A.z=G.z,x=G.size*G.scale/f,F.x=x*z,F.y=x,b.uniform3f(C.screenPosition,A.x,A.y,A.z),b.uniform2f(C.scale,F.x,F.y),b.uniform1f(C.rotation,G.rotation),b.uniform1f(C.opacity,
G.opacity),b.uniform3f(C.color,G.color.r,G.color.g,G.color.b),c.setBlending(G.blending,G.blendEquation,G.blendSrc,G.blendDst),c.setTexture(G.texture,1),b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0))}b.enable(b.CULL_FACE);b.enable(b.DEPTH_TEST);b.depthMask(!0)}}};THREE.ShadowMapPlugin=function(){var a,b,c,d,e,f,h=new THREE.Frustum,g=new THREE.Matrix4,i=new THREE.Vector3,k=new THREE.Vector3,m=new THREE.Vector3;this.init=function(g){a=g.context;b=g;var g=THREE.ShaderLib.depthRGBA,h=THREE.UniformsUtils.clone(g.uniforms);c=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h});d=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h,morphTargets:!0});e=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,
vertexShader:g.vertexShader,uniforms:h,skinning:!0});f=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h,morphTargets:!0,skinning:!0});c._shadowPass=!0;d._shadowPass=!0;e._shadowPass=!0;f._shadowPass=!0};this.render=function(a,c){b.shadowMapEnabled&&b.shadowMapAutoUpdate&&this.update(a,c)};this.update=function(l,p){var s,t,n,r,q,u,w,z,B,D=[];r=0;a.clearColor(1,1,1,1);a.disable(a.BLEND);a.enable(a.CULL_FACE);a.frontFace(a.CCW);b.shadowMapCullFace===THREE.CullFaceFront?
a.cullFace(a.FRONT):a.cullFace(a.BACK);b.setDepthTest(!0);s=0;for(t=l.__lights.length;s<t;s++)if(n=l.__lights[s],n.castShadow)if(n instanceof THREE.DirectionalLight&&n.shadowCascade)for(q=0;q<n.shadowCascadeCount;q++){var x;if(n.shadowCascadeArray[q])x=n.shadowCascadeArray[q];else{B=n;w=q;x=new THREE.DirectionalLight;x.isVirtual=!0;x.onlyShadow=!0;x.castShadow=!0;x.shadowCameraNear=B.shadowCameraNear;x.shadowCameraFar=B.shadowCameraFar;x.shadowCameraLeft=B.shadowCameraLeft;x.shadowCameraRight=B.shadowCameraRight;
x.shadowCameraBottom=B.shadowCameraBottom;x.shadowCameraTop=B.shadowCameraTop;x.shadowCameraVisible=B.shadowCameraVisible;x.shadowDarkness=B.shadowDarkness;x.shadowBias=B.shadowCascadeBias[w];x.shadowMapWidth=B.shadowCascadeWidth[w];x.shadowMapHeight=B.shadowCascadeHeight[w];x.pointsWorld=[];x.pointsFrustum=[];z=x.pointsWorld;u=x.pointsFrustum;for(var F=0;8>F;F++)z[F]=new THREE.Vector3,u[F]=new THREE.Vector3;z=B.shadowCascadeNearZ[w];B=B.shadowCascadeFarZ[w];u[0].set(-1,-1,z);u[1].set(1,-1,z);u[2].set(-1,
1,z);u[3].set(1,1,z);u[4].set(-1,-1,B);u[5].set(1,-1,B);u[6].set(-1,1,B);u[7].set(1,1,B);x.originalCamera=p;u=new THREE.Gyroscope;u.position=n.shadowCascadeOffset;u.add(x);u.add(x.target);p.add(u);n.shadowCascadeArray[q]=x;console.log("Created virtualLight",x)}w=n;z=q;B=w.shadowCascadeArray[z];B.position.copy(w.position);B.target.position.copy(w.target.position);B.lookAt(B.target);B.shadowCameraVisible=w.shadowCameraVisible;B.shadowDarkness=w.shadowDarkness;B.shadowBias=w.shadowCascadeBias[z];u=w.shadowCascadeNearZ[z];
w=w.shadowCascadeFarZ[z];B=B.pointsFrustum;B[0].z=u;B[1].z=u;B[2].z=u;B[3].z=u;B[4].z=w;B[5].z=w;B[6].z=w;B[7].z=w;D[r]=x;r++}else D[r]=n,r++;s=0;for(t=D.length;s<t;s++){n=D[s];n.shadowMap||(q=THREE.LinearFilter,b.shadowMapType===THREE.PCFSoftShadowMap&&(q=THREE.NearestFilter),n.shadowMap=new THREE.WebGLRenderTarget(n.shadowMapWidth,n.shadowMapHeight,{minFilter:q,magFilter:q,format:THREE.RGBAFormat}),n.shadowMapSize=new THREE.Vector2(n.shadowMapWidth,n.shadowMapHeight),n.shadowMatrix=new THREE.Matrix4);
if(!n.shadowCamera){if(n instanceof THREE.SpotLight)n.shadowCamera=new THREE.PerspectiveCamera(n.shadowCameraFov,n.shadowMapWidth/n.shadowMapHeight,n.shadowCameraNear,n.shadowCameraFar);else if(n instanceof THREE.DirectionalLight)n.shadowCamera=new THREE.OrthographicCamera(n.shadowCameraLeft,n.shadowCameraRight,n.shadowCameraTop,n.shadowCameraBottom,n.shadowCameraNear,n.shadowCameraFar);else{console.error("Unsupported light type for shadow");continue}l.add(n.shadowCamera);!0===l.autoUpdate&&l.updateMatrixWorld()}n.shadowCameraVisible&&
!n.cameraHelper&&(n.cameraHelper=new THREE.CameraHelper(n.shadowCamera),n.shadowCamera.add(n.cameraHelper));if(n.isVirtual&&x.originalCamera==p){q=p;r=n.shadowCamera;u=n.pointsFrustum;B=n.pointsWorld;i.set(Infinity,Infinity,Infinity);k.set(-Infinity,-Infinity,-Infinity);for(w=0;8>w;w++)z=B[w],z.copy(u[w]),THREE.ShadowMapPlugin.__projector.unprojectVector(z,q),z.applyMatrix4(r.matrixWorldInverse),z.x<i.x&&(i.x=z.x),z.x>k.x&&(k.x=z.x),z.y<i.y&&(i.y=z.y),z.y>k.y&&(k.y=z.y),z.z<i.z&&(i.z=z.z),z.z>k.z&&
(k.z=z.z);r.left=i.x;r.right=k.x;r.top=k.y;r.bottom=i.y;r.updateProjectionMatrix()}r=n.shadowMap;u=n.shadowMatrix;q=n.shadowCamera;q.position.getPositionFromMatrix(n.matrixWorld);m.getPositionFromMatrix(n.target.matrixWorld);q.lookAt(m);q.updateMatrixWorld();q.matrixWorldInverse.getInverse(q.matrixWorld);n.cameraHelper&&(n.cameraHelper.visible=n.shadowCameraVisible);n.shadowCameraVisible&&n.cameraHelper.update();u.set(0.5,0,0,0.5,0,0.5,0,0.5,0,0,0.5,0.5,0,0,0,1);u.multiply(q.projectionMatrix);u.multiply(q.matrixWorldInverse);
g.multiplyMatrices(q.projectionMatrix,q.matrixWorldInverse);h.setFromMatrix(g);b.setRenderTarget(r);b.clear();B=l.__webglObjects;n=0;for(r=B.length;n<r;n++)if(w=B[n],u=w.object,w.render=!1,u.visible&&u.castShadow&&(!(u instanceof THREE.Mesh||u instanceof THREE.ParticleSystem)||!u.frustumCulled||h.intersectsObject(u)))u._modelViewMatrix.multiplyMatrices(q.matrixWorldInverse,u.matrixWorld),w.render=!0;n=0;for(r=B.length;n<r;n++)w=B[n],w.render&&(u=w.object,w=w.buffer,F=u.material instanceof THREE.MeshFaceMaterial?
u.material.materials[0]:u.material,z=0<u.geometry.morphTargets.length&&F.morphTargets,F=u instanceof THREE.SkinnedMesh&&F.skinning,z=u.customDepthMaterial?u.customDepthMaterial:F?z?f:e:z?d:c,w instanceof THREE.BufferGeometry?b.renderBufferDirect(q,l.__lights,null,z,w,u):b.renderBuffer(q,l.__lights,null,z,w,u));B=l.__webglObjectsImmediate;n=0;for(r=B.length;n<r;n++)w=B[n],u=w.object,u.visible&&u.castShadow&&(u._modelViewMatrix.multiplyMatrices(q.matrixWorldInverse,u.matrixWorld),b.renderImmediateObject(q,
l.__lights,null,c,u))}s=b.getClearColor();t=b.getClearAlpha();a.clearColor(s.r,s.g,s.b,t);a.enable(a.BLEND);b.shadowMapCullFace===THREE.CullFaceFront&&a.cullFace(a.BACK)}};THREE.ShadowMapPlugin.__projector=new THREE.Projector;THREE.SpritePlugin=function(){function a(a,b){return a.z!==b.z?b.z-a.z:b.id-a.id}var b,c,d,e,f,h,g,i,k,m;this.init=function(a){b=a.context;c=a;d=a.getPrecision();e=new Float32Array(16);f=new Uint16Array(6);a=0;e[a++]=-0.5;e[a++]=-0.5;e[a++]=0;e[a++]=0;e[a++]=0.5;e[a++]=-0.5;e[a++]=1;e[a++]=0;e[a++]=0.5;e[a++]=0.5;e[a++]=1;e[a++]=1;e[a++]=-0.5;e[a++]=0.5;e[a++]=0;e[a++]=1;a=0;f[a++]=0;f[a++]=1;f[a++]=2;f[a++]=0;f[a++]=2;f[a++]=3;h=b.createBuffer();g=b.createBuffer();b.bindBuffer(b.ARRAY_BUFFER,h);
b.bufferData(b.ARRAY_BUFFER,e,b.STATIC_DRAW);b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,g);b.bufferData(b.ELEMENT_ARRAY_BUFFER,f,b.STATIC_DRAW);var a=THREE.ShaderSprite.sprite,p=b.createProgram(),s=b.createShader(b.FRAGMENT_SHADER),t=b.createShader(b.VERTEX_SHADER),n="precision "+d+" float;\n";b.shaderSource(s,n+a.fragmentShader);b.shaderSource(t,n+a.vertexShader);b.compileShader(s);b.compileShader(t);b.attachShader(p,s);b.attachShader(p,t);b.linkProgram(p);i=p;k={};m={};k.position=b.getAttribLocation(i,
"position");k.uv=b.getAttribLocation(i,"uv");m.uvOffset=b.getUniformLocation(i,"uvOffset");m.uvScale=b.getUniformLocation(i,"uvScale");m.rotation=b.getUniformLocation(i,"rotation");m.scale=b.getUniformLocation(i,"scale");m.alignment=b.getUniformLocation(i,"alignment");m.halfViewport=b.getUniformLocation(i,"halfViewport");m.color=b.getUniformLocation(i,"color");m.map=b.getUniformLocation(i,"map");m.opacity=b.getUniformLocation(i,"opacity");m.useScreenCoordinates=b.getUniformLocation(i,"useScreenCoordinates");
m.sizeAttenuation=b.getUniformLocation(i,"sizeAttenuation");m.screenPosition=b.getUniformLocation(i,"screenPosition");m.modelViewMatrix=b.getUniformLocation(i,"modelViewMatrix");m.projectionMatrix=b.getUniformLocation(i,"projectionMatrix");m.fogType=b.getUniformLocation(i,"fogType");m.fogDensity=b.getUniformLocation(i,"fogDensity");m.fogNear=b.getUniformLocation(i,"fogNear");m.fogFar=b.getUniformLocation(i,"fogFar");m.fogColor=b.getUniformLocation(i,"fogColor");m.alphaTest=b.getUniformLocation(i,
"alphaTest")};this.render=function(d,e,f,t){var n=d.__webglSprites,r=n.length;if(r){var q=k,u=m,f=0.5*f,t=0.5*t;b.useProgram(i);b.enableVertexAttribArray(q.position);b.enableVertexAttribArray(q.uv);b.disable(b.CULL_FACE);b.enable(b.BLEND);b.bindBuffer(b.ARRAY_BUFFER,h);b.vertexAttribPointer(q.position,2,b.FLOAT,!1,16,0);b.vertexAttribPointer(q.uv,2,b.FLOAT,!1,16,8);b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,g);b.uniformMatrix4fv(u.projectionMatrix,!1,e.projectionMatrix.elements);b.activeTexture(b.TEXTURE0);
b.uniform1i(u.map,0);var w=q=0,z=d.fog;z?(b.uniform3f(u.fogColor,z.color.r,z.color.g,z.color.b),z instanceof THREE.Fog?(b.uniform1f(u.fogNear,z.near),b.uniform1f(u.fogFar,z.far),b.uniform1i(u.fogType,1),w=q=1):z instanceof THREE.FogExp2&&(b.uniform1f(u.fogDensity,z.density),b.uniform1i(u.fogType,2),w=q=2)):(b.uniform1i(u.fogType,0),w=q=0);for(var B,D,x=[],z=0;z<r;z++)B=n[z],D=B.material,B.visible&&0!==D.opacity&&(D.useScreenCoordinates?B.z=-B.position.z:(B._modelViewMatrix.multiplyMatrices(e.matrixWorldInverse,
B.matrixWorld),B.z=-B._modelViewMatrix.elements[14]));n.sort(a);for(z=0;z<r;z++)B=n[z],D=B.material,B.visible&&0!==D.opacity&&(D.map&&D.map.image&&D.map.image.width)&&(b.uniform1f(u.alphaTest,D.alphaTest),!0===D.useScreenCoordinates?(b.uniform1i(u.useScreenCoordinates,1),b.uniform3f(u.screenPosition,(B.position.x*c.devicePixelRatio-f)/f,(t-B.position.y*c.devicePixelRatio)/t,Math.max(0,Math.min(1,B.position.z))),x[0]=c.devicePixelRatio*B.scale.x,x[1]=c.devicePixelRatio*B.scale.y):(b.uniform1i(u.useScreenCoordinates,
0),b.uniform1i(u.sizeAttenuation,D.sizeAttenuation?1:0),b.uniformMatrix4fv(u.modelViewMatrix,!1,B._modelViewMatrix.elements),x[0]=B.scale.x,x[1]=B.scale.y),e=d.fog&&D.fog?w:0,q!==e&&(b.uniform1i(u.fogType,e),q=e),b.uniform2f(u.uvScale,D.uvScale.x,D.uvScale.y),b.uniform2f(u.uvOffset,D.uvOffset.x,D.uvOffset.y),b.uniform2f(u.alignment,D.alignment.x,D.alignment.y),b.uniform1f(u.opacity,D.opacity),b.uniform3f(u.color,D.color.r,D.color.g,D.color.b),b.uniform1f(u.rotation,B.rotation),b.uniform2fv(u.scale,
x),b.uniform2f(u.halfViewport,f,t),c.setBlending(D.blending,D.blendEquation,D.blendSrc,D.blendDst),c.setDepthTest(D.depthTest),c.setDepthWrite(D.depthWrite),c.setTexture(D.map,0),b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0));b.enable(b.CULL_FACE)}}};THREE.DepthPassPlugin=function(){this.enabled=!1;this.renderTarget=null;var a,b,c,d,e,f,h=new THREE.Frustum,g=new THREE.Matrix4;this.init=function(g){a=g.context;b=g;var g=THREE.ShaderLib.depthRGBA,h=THREE.UniformsUtils.clone(g.uniforms);c=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h});d=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h,morphTargets:!0});e=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,
vertexShader:g.vertexShader,uniforms:h,skinning:!0});f=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h,morphTargets:!0,skinning:!0});c._shadowPass=!0;d._shadowPass=!0;e._shadowPass=!0;f._shadowPass=!0};this.render=function(a,b){this.enabled&&this.update(a,b)};this.update=function(i,k){var m,l,p,s,t,n;a.clearColor(1,1,1,1);a.disable(a.BLEND);b.setDepthTest(!0);!0===i.autoUpdate&&i.updateMatrixWorld();k.matrixWorldInverse.getInverse(k.matrixWorld);g.multiplyMatrices(k.projectionMatrix,
k.matrixWorldInverse);h.setFromMatrix(g);b.setRenderTarget(this.renderTarget);b.clear();n=i.__webglObjects;m=0;for(l=n.length;m<l;m++)if(p=n[m],t=p.object,p.render=!1,t.visible&&(!(t instanceof THREE.Mesh||t instanceof THREE.ParticleSystem)||!t.frustumCulled||h.intersectsObject(t)))t._modelViewMatrix.multiplyMatrices(k.matrixWorldInverse,t.matrixWorld),p.render=!0;var r;m=0;for(l=n.length;m<l;m++)if(p=n[m],p.render&&(t=p.object,p=p.buffer,!(t instanceof THREE.ParticleSystem)||t.customDepthMaterial))(r=
t.material instanceof THREE.MeshFaceMaterial?t.material.materials[0]:t.material)&&b.setMaterialFaces(t.material),s=0<t.geometry.morphTargets.length&&r.morphTargets,r=t instanceof THREE.SkinnedMesh&&r.skinning,s=t.customDepthMaterial?t.customDepthMaterial:r?s?f:e:s?d:c,p instanceof THREE.BufferGeometry?b.renderBufferDirect(k,i.__lights,null,s,p,t):b.renderBuffer(k,i.__lights,null,s,p,t);n=i.__webglObjectsImmediate;m=0;for(l=n.length;m<l;m++)p=n[m],t=p.object,t.visible&&(t._modelViewMatrix.multiplyMatrices(k.matrixWorldInverse,
t.matrixWorld),b.renderImmediateObject(k,i.__lights,null,c,t));m=b.getClearColor();l=b.getClearAlpha();a.clearColor(m.r,m.g,m.b,l);a.enable(a.BLEND)}};THREE.ShaderFlares={lensFlareVertexTexture:{vertexShader:"uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
fragmentShader:"uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"},lensFlare:{vertexShader:"uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
fragmentShader:"precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"}};THREE.ShaderSprite={sprite:{vertexShader:"uniform int useScreenCoordinates;\nuniform int sizeAttenuation;\nuniform vec3 screenPosition;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 alignment;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nuniform vec2 halfViewport;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = ( position + alignment ) * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nif( useScreenCoordinates != 0 ) {\nfinalPosition = vec4( screenPosition.xy + ( rotatedPosition / halfViewport ), screenPosition.z, 1.0 );\n} else {\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition * ( sizeAttenuation == 1 ? 1.0 : finalPosition.z );\nfinalPosition = projectionMatrix * finalPosition;\n}\ngl_Position = finalPosition;\n}",
fragmentShader:"uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"}};

module.exports = THREE;

},{}],153:[function(require,module,exports){
/**
* @jsx React.DOM
*/

var React = require('react'),
Detector = require('./third-party/Detector.js'),
TWEEN = require('./third-party/Tween.js'),
DAT = require('./globe.js');

var WebGLGlobe = React.createClass({displayName: 'WebGLGlobe',
  render: function() {
    return (
      React.createElement("div", null, 
      React.createElement("div", {className: "container", ref: "container"}), 

      React.createElement("div", {id: "info"}, 
      React.createElement("strong", null, React.createElement("a", {href: "http://www.chromeexperiments.com/globe"}, "WebGL Globe")), " ", 
      React.createElement("span", {className: "bull"}, "•"), " Created by the Google Data Arts Team ", 
      React.createElement("span", {className: "bull"}, "•"), " Data acquired from ", 
      React.createElement("a", {href: "http://www2.informatik.uni-freiburg.de/~cziegler/BX/"}, "Book-Crossing Dataset"),
      React.createElement("span", {className: "bull"}, "•"), " Used by " ,
      React.createElement("a", {href: "http://naenmong.com"}, "Nan Meng")
      ), 

      React.createElement("div", {id: "currentInfo"}, 
      React.createElement("span", {ref: "year1990", className: "year"}, "Distribution")
      ), 

      React.createElement("div", {id: "title"}, 
      "Book-Crossing"
      ), 

      React.createElement("a", {id: "ce", href: "http://www.chromeexperiments.com/globe"}, 
      React.createElement("span", null, "This is a Chrome Experiment")
      )

      )
    );
  },
  shouldComponentUpdate: function(nextProps, nextState) {
    return false;
  },
  componentDidMount: function() {
    var container = this.refs.container.getDOMNode();
    if(!Detector.webgl){
      Detector.addGetWebGLMessage();
    } else {

      var years = ['1990'];
      // var container = document.getElementById('container');

      var opts = {imgDir: 'assets/'};
      var globe = new DAT.Globe(container, opts);
      var i, tweens = [];

      var settime = function(globe, t) {
        return function() {
          new TWEEN.Tween(globe).to({time: t/years.length},500).easing(TWEEN.Easing.Cubic.EaseOut).start();
          var y = this.refs[('year'+years[t])].getDOMNode();
          if (y.getAttribute('class') === 'year active') {
            return;
          }
          var yy = document.getElementsByClassName('year');
          for(i=0; i<yy.length; i++) {i
            yy[i].setAttribute('class','year');
          }
          y.setAttribute('class', 'year active');
        };
      };

      for(var i = 0; i<years.length; i++) {
        var y = this.refs[('year'+years[i])].getDOMNode();
        y.addEventListener('mouseover', settime(globe,i), false);
      }

      var xhr;
      TWEEN.start();


      xhr = new XMLHttpRequest();
      xhr.open('GET', 'assets/BookCrossingData.json', true);
      var onreadystatechangecallback = function(e) {
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            var data = JSON.parse(xhr.responseText);
            window.data = data;
            for (i=0;i<data.length;i++) {
              globe.addData(data[i][1], {format: 'magnitude', name: data[i][0], animated: true});
            }
            globe.createPoints();
            (settime(globe,0).bind(this))();
            globe.animate();
            document.body.style.backgroundImage = 'none'; // remove loading
          }
        }
      };
      xhr.onreadystatechange = onreadystatechangecallback.bind(this);
      xhr.send(null);
    }

  }

});

module.exports = WebGLGlobe;

},{"./globe.js":149,"./third-party/Detector.js":150,"./third-party/Tween.js":151,"react":148}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvanMvYXBwLmpzeCIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0F1dG9Gb2N1c01peGluLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9DU1NQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9DYWxsYmFja1F1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ2xpZW50UmVhY3RSb290SW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0NvbXBvc2l0aW9uRXZlbnRQbHVnaW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0RPTUNoaWxkcmVuT3BlcmF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRE9NUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0RPTVByb3BlcnR5T3BlcmF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRGFuZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FdmVudENvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRXZlbnRMaXN0ZW5lci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRXZlbnRQbHVnaW5IdWIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50UGx1Z2luUmVnaXN0cnkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50UGx1Z2luVXRpbHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50UHJvcGFnYXRvcnMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0xpbmtlZFZhbHVlVXRpbHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0xvY2FsRXZlbnRUcmFwTWl4aW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL01vYmlsZVNhZmFyaUNsaWNrRXZlbnRQbHVnaW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL09iamVjdC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1Bvb2xlZENsYXNzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET00uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NQnV0dG9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01Gb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUlET3BlcmF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01JbWcuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NSW5wdXQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NT3B0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTVNlbGVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01TZWxlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NVGV4dGFyZWEuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RGVmYXVsdEluamVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3REZWZhdWx0UGVyZi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RWxlbWVudFZhbGlkYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFbXB0eUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFcnJvclV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEV2ZW50TGlzdGVuZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0SW5qZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdElucHV0U2VsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEluc3RhbmNlSGFuZGxlcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RMZWdhY3lFbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE1hcmt1cENoZWNrc3VtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE1vdW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE5hdGl2ZUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RPd25lci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQZXJmLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUcmFuc2ZlcmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHV0TGlzdGVuZXJRdWV1ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RSb290SW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFRleHRDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VXBkYXRlcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU1ZHRE9NUHJvcGVydHlDb25maWcuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TZXJ2ZXJSZWFjdFJvb3RJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU2ltcGxlRXZlbnRQbHVnaW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNEcmFnRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0V2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNGb2N1c0V2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNJbnB1dEV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNUb3VjaEV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNXaGVlbEV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9UcmFuc2FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvVmlld3BvcnRNZXRyaWNzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9hY2N1bXVsYXRlSW50by5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvYWRsZXIzMi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvY2FtZWxpemUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jb250YWluc05vZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2NyZWF0ZUFycmF5RnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvY3JlYXRlRnVsbFBhZ2VDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZGFuZ2Vyb3VzU3R5bGVWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZGVwcmVjYXRlZC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZW1wdHlPYmplY3QuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2VzY2FwZVRleHRGb3JCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9mbGF0dGVuQ2hpbGRyZW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2ZvY3VzTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZm9yRWFjaEFjY3VtdWxhdGVkLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRFdmVudENoYXJDb2RlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRFdmVudEtleS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0RXZlbnRNb2RpZmllclN0YXRlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRFdmVudFRhcmdldC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0TWFya3VwV3JhcC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRUZXh0Q29udGVudEFjY2Vzc29yLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvaHlwaGVuYXRlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2ludmFyaWFudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvaXNFdmVudFN1cHBvcnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvaXNOb2RlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2lzVGV4dE5vZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2pvaW5DbGFzc2VzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9rZXlNaXJyb3IuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2tleU9mLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9tYXBPYmplY3QuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL21lbW9pemVTdHJpbmdPbmx5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9tb25pdG9yQ29kZVVzZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvb25seUNoaWxkLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9wZXJmb3JtYW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvcGVyZm9ybWFuY2VOb3cuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL3NldElubmVySFRNTC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvc2hhbGxvd0VxdWFsLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvdG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvd2FybmluZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9yZWFjdC5qcyIsInNyYy9qcy9nbG9iZS9nbG9iZS5qcyIsInNyYy9qcy9nbG9iZS90aGlyZC1wYXJ0eS9EZXRlY3Rvci5qcyIsInNyYy9qcy9nbG9iZS90aGlyZC1wYXJ0eS9Ud2Vlbi5qcyIsInNyYy9qcy9nbG9iZS90aGlyZC1wYXJ0eS90aHJlZS5taW4uanMiLCJzcmMvanMvZ2xvYmUvd2ViZ2wtZ2xvYmUuanN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzk1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKipcbiogQGpzeCBSZWFjdC5ET01cbiovXG4oZnVuY3Rpb24gKCkge1xuXG4gIHZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG4gIHZhciBXZWJHTEdsb2JlID0gcmVxdWlyZSgnLi9nbG9iZS93ZWJnbC1nbG9iZS5qc3gnKTtcbiAgLy9OZWVkZWQgZm9yIFJlYWN0IERldmVsb3BlciBUb29sc1xuICB3aW5kb3cuUmVhY3QgPSBSZWFjdDtcblxuICAvL1JlbmRlciB0aGUgbWFpbiBhcHAgY29tcG9uZW50XG4gIHZhciBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6ICdBcHAnLFxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChXZWJHTEdsb2JlLCBudWxsKTtcbiAgICB9XG4gIH0pO1xuICBSZWFjdC5yZW5kZXIoUmVhY3QuY3JlYXRlRWxlbWVudChBcHAsIG51bGwpLCBkb2N1bWVudC5ib2R5KTtcblxufSkoKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhbk11dGF0aW9uT2JzZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIHZhciBxdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGNhbk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgdmFyIGhpZGRlbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBxdWV1ZUxpc3QgPSBxdWV1ZS5zbGljZSgpO1xuICAgICAgICAgICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHF1ZXVlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShoaWRkZW5EaXYsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaGlkZGVuRGl2LnNldEF0dHJpYnV0ZSgneWVzJywgJ25vJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQXV0b0ZvY3VzTWl4aW5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKFwiLi9mb2N1c05vZGVcIik7XG5cbnZhciBBdXRvRm9jdXNNaXhpbiA9IHtcbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgZm9jdXNOb2RlKHRoaXMuZ2V0RE9NTm9kZSgpKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0b0ZvY3VzTWl4aW47XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoXCIuL0V2ZW50UHJvcGFnYXRvcnNcIik7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcbnZhciBTeW50aGV0aWNJbnB1dEV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljSW5wdXRFdmVudFwiKTtcblxudmFyIGtleU9mID0gcmVxdWlyZShcIi4va2V5T2ZcIik7XG5cbnZhciBjYW5Vc2VUZXh0SW5wdXRFdmVudCA9IChcbiAgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmXG4gICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJlxuICAhKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50IHx8IGlzUHJlc3RvKCkpXG4pO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBvcGVyYSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHBhcnNlSW50KG9wZXJhLnZlcnNpb24oKSwgMTApIDw9IDEyXG4gICk7XG59XG5cbnZhciBTUEFDRUJBUl9DT0RFID0gMzI7XG52YXIgU1BBQ0VCQVJfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGJlZm9yZUlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkJlZm9yZUlucHV0OiBudWxsfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uQmVmb3JlSW5wdXRDYXB0dXJlOiBudWxsfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcFRleHRJbnB1dCxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wUGFzdGVcbiAgICBdXG4gIH1cbn07XG5cbi8vIFRyYWNrIGNoYXJhY3RlcnMgaW5zZXJ0ZWQgdmlhIGtleXByZXNzIGFuZCBjb21wb3NpdGlvbiBldmVudHMuXG52YXIgZmFsbGJhY2tDaGFycyA9IG51bGw7XG5cbi8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAoXG4gICAgKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gICAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSlcbiAgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uKFxuICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgbmF0aXZlRXZlbnQpIHtcblxuICAgIHZhciBjaGFycztcblxuICAgIGlmIChjYW5Vc2VUZXh0SW5wdXRFdmVudCkge1xuICAgICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cbiAgICAgICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXG4gICAgICAgICAgICogcGFnZS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFRyYWNraW5nIGF0OlxuICAgICAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcbiAgICAgICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgdmFyIHdoaWNoID0gbmF0aXZlRXZlbnQud2hpY2g7XG4gICAgICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICAgICAgY2hhcnMgPSBTUEFDRUJBUl9DSEFSO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUZXh0SW5wdXQ6XG4gICAgICAgICAgLy8gUmVjb3JkIHRoZSBjaGFyYWN0ZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSBET00uXG4gICAgICAgICAgY2hhcnMgPSBuYXRpdmVFdmVudC5kYXRhO1xuXG4gICAgICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAgICAgLy8gZG9lc24ndCBnaXZlIHVzIGtleWNvZGVzLCBzbyB3ZSBuZWVkIHRvIGJsYWNrbGlzdCBpdC5cbiAgICAgICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE90aGVyd2lzZSwgY2Fycnkgb24uXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlOlxuICAgICAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICAgICAgZmFsbGJhY2tDaGFycyA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBcyBvZiB2MjcsIEZpcmVmb3ggbWF5IGZpcmUga2V5cHJlc3MgZXZlbnRzIGV2ZW4gd2hlbiBubyBjaGFyYWN0ZXJcbiAgICAgICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogLSBgd2hpY2hgIGlzIGAwYC4gQXJyb3cga2V5cywgRXNjIGtleSwgZXRjLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgICogICBFeDogJ0FsdEdyICsgZGAgaW4gUG9saXNoLiBUaGVyZSBpcyBubyBtb2RpZmllZCBjaGFyYWN0ZXIgZm9yXG4gICAgICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAgICAgKiAgIE5vIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICAgICAqICAgYmVpbmcgdXNlZC4gRXg6IGBDbWQrQ2AuIE5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgYW5kIG5vXG4gICAgICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgICAgICovXG4gICAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LndoaWNoICYmICFpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGZhbGxiYWNrQ2hhcnMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgICAgICBmYWxsYmFja0NoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gY2hhbmdlcyBoYXZlIG9jY3VycmVkIHRvIHRoZSBmYWxsYmFjayBzdHJpbmcsIG5vIHJlbGV2YW50XG4gICAgICAvLyBldmVudCBoYXMgZmlyZWQgYW5kIHdlJ3JlIGRvbmUuXG4gICAgICBpZiAoZmFsbGJhY2tDaGFycyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNoYXJzID0gZmFsbGJhY2tDaGFycztcbiAgICB9XG5cbiAgICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gICAgLy8gYmUgZmlyZWQuXG4gICAgaWYgKCFjaGFycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBldmVudCA9IFN5bnRoZXRpY0lucHV0RXZlbnQuZ2V0UG9vbGVkKFxuICAgICAgZXZlbnRUeXBlcy5iZWZvcmVJbnB1dCxcbiAgICAgIHRvcExldmVsVGFyZ2V0SUQsXG4gICAgICBuYXRpdmVFdmVudFxuICAgICk7XG5cbiAgICBldmVudC5kYXRhID0gY2hhcnM7XG4gICAgZmFsbGJhY2tDaGFycyA9IG51bGw7XG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmVmb3JlSW5wdXRFdmVudFBsdWdpbjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NQcm9wZXJ0eVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhTaHJpbms6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddO1xuXG4vLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBNb3N0IHN0eWxlIHByb3BlcnRpZXMgY2FuIGJlIHVuc2V0IGJ5IGRvaW5nIC5zdHlsZVtwcm9wXSA9ICcnIGJ1dCBJRThcbiAqIGRvZXNuJ3QgbGlrZSBkb2luZyB0aGF0IHdpdGggc2hvcnRoYW5kIHByb3BlcnRpZXMgc28gZm9yIHRoZSBwcm9wZXJ0aWVzIHRoYXRcbiAqIElFOCBicmVha3Mgb24sIHdoaWNoIGFyZSBsaXN0ZWQgaGVyZSwgd2UgaW5zdGVhZCB1bnNldCBlYWNoIG9mIHRoZVxuICogaW5kaXZpZHVhbCBwcm9wZXJ0aWVzLiBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzODUuXG4gKiBUaGUgNC12YWx1ZSAnY2xvY2snIHByb3BlcnRpZXMgbGlrZSBtYXJnaW4sIHBhZGRpbmcsIGJvcmRlci13aWR0aCBzZWVtIHRvXG4gKiBiZWhhdmUgd2l0aG91dCBhbnkgcHJvYmxlbXMuIEN1cmlvdXNseSwgbGlzdC1zdHlsZSB3b3JrcyB0b28gd2l0aG91dCBhbnlcbiAqIHNwZWNpYWwgcHJvZGRpbmcuXG4gKi9cbnZhciBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnMgPSB7XG4gIGJhY2tncm91bmQ6IHtcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uOiB0cnVlLFxuICAgIGJhY2tncm91bmRSZXBlYXQ6IHRydWUsXG4gICAgYmFja2dyb3VuZENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlcjoge1xuICAgIGJvcmRlcldpZHRoOiB0cnVlLFxuICAgIGJvcmRlclN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckJvdHRvbToge1xuICAgIGJvcmRlckJvdHRvbVdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbVN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbUNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckxlZnQ6IHtcbiAgICBib3JkZXJMZWZ0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyTGVmdFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckxlZnRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJSaWdodDoge1xuICAgIGJvcmRlclJpZ2h0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJSaWdodENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclRvcDoge1xuICAgIGJvcmRlclRvcFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclRvcFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclRvcENvbG9yOiB0cnVlXG4gIH0sXG4gIGZvbnQ6IHtcbiAgICBmb250U3R5bGU6IHRydWUsXG4gICAgZm9udFZhcmlhbnQ6IHRydWUsXG4gICAgZm9udFdlaWdodDogdHJ1ZSxcbiAgICBmb250U2l6ZTogdHJ1ZSxcbiAgICBsaW5lSGVpZ2h0OiB0cnVlLFxuICAgIGZvbnRGYW1pbHk6IHRydWVcbiAgfVxufTtcblxudmFyIENTU1Byb3BlcnR5ID0ge1xuICBpc1VuaXRsZXNzTnVtYmVyOiBpc1VuaXRsZXNzTnVtYmVyLFxuICBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnM6IHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NQcm9wZXJ0eTtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ1NTUHJvcGVydHlPcGVyYXRpb25zXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKFwiLi9DU1NQcm9wZXJ0eVwiKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xuXG52YXIgY2FtZWxpemVTdHlsZU5hbWUgPSByZXF1aXJlKFwiLi9jYW1lbGl6ZVN0eWxlTmFtZVwiKTtcbnZhciBkYW5nZXJvdXNTdHlsZVZhbHVlID0gcmVxdWlyZShcIi4vZGFuZ2Vyb3VzU3R5bGVWYWx1ZVwiKTtcbnZhciBoeXBoZW5hdGVTdHlsZU5hbWUgPSByZXF1aXJlKFwiLi9oeXBoZW5hdGVTdHlsZU5hbWVcIik7XG52YXIgbWVtb2l6ZVN0cmluZ09ubHkgPSByZXF1aXJlKFwiLi9tZW1vaXplU3RyaW5nT25seVwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxudmFyIHByb2Nlc3NTdHlsZU5hbWUgPSBtZW1vaXplU3RyaW5nT25seShmdW5jdGlvbihzdHlsZU5hbWUpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpO1xufSk7XG5cbnZhciBzdHlsZUZsb2F0QWNjZXNzb3IgPSAnY3NzRmxvYXQnO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTggb25seSBzdXBwb3J0cyBhY2Nlc3NpbmcgY3NzRmxvYXQgKHN0YW5kYXJkKSBhcyBzdHlsZUZsb2F0XG4gIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3NzRmxvYXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdzdHlsZUZsb2F0JztcbiAgfVxufVxuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICcgKyBuYW1lICsgJy4gRGlkIHlvdSBtZWFuICcgK1xuICAgICAgY2FtZWxpemVTdHlsZU5hbWUobmFtZSkgKyAnPydcbiAgICApIDogbnVsbCk7XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGEgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIGZvciB1c2UgYXMgaW5saW5lIHN0eWxlczpcbiAgICpcbiAgICogICA+IGNyZWF0ZU1hcmt1cEZvclN0eWxlcyh7d2lkdGg6ICcyMDBweCcsIGhlaWdodDogMH0pXG4gICAqICAgXCJ3aWR0aDoyMDBweDtoZWlnaHQ6MDtcIlxuICAgKlxuICAgKiBVbmRlZmluZWQgdmFsdWVzIGFyZSBpZ25vcmVkIHNvIHRoYXQgZGVjbGFyYXRpdmUgcHJvZ3JhbW1pbmcgaXMgZWFzaWVyLlxuICAgKiBUaGUgcmVzdWx0IHNob3VsZCBiZSBIVE1MLWVzY2FwZWQgYmVmb3JlIGluc2VydGlvbiBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHJldHVybiB7P3N0cmluZ31cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvclN0eWxlczogZnVuY3Rpb24oc3R5bGVzKSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICBpZiAoc3R5bGVOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUoc3R5bGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2VyaWFsaXplZCArPSBwcm9jZXNzU3R5bGVOYW1lKHN0eWxlTmFtZSkgKyAnOic7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpICsgJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gICAqICcnIChlbXB0eSBzdHJpbmcpLCB0aGUgY29ycmVzcG9uZGluZyBzdHlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVuc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICAgKi9cbiAgc2V0VmFsdWVGb3JTdHlsZXM6IGZ1bmN0aW9uKG5vZGUsIHN0eWxlcykge1xuICAgIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgaWYgKHN0eWxlTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKHN0eWxlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdKTtcbiAgICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgICAgc3R5bGVOYW1lID0gc3R5bGVGbG9hdEFjY2Vzc29yO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlVmFsdWUpIHtcbiAgICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXhwYW5zaW9uID0gQ1NTUHJvcGVydHkuc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zW3N0eWxlTmFtZV07XG4gICAgICAgIGlmIChleHBhbnNpb24pIHtcbiAgICAgICAgICAvLyBTaG9ydGhhbmQgcHJvcGVydHkgdGhhdCBJRTggd29uJ3QgbGlrZSB1bnNldHRpbmcsIHNvIHVuc2V0IGVhY2hcbiAgICAgICAgICAvLyBjb21wb25lbnQgdG8gcGxhY2F0ZSBpdFxuICAgICAgICAgIGZvciAodmFyIGluZGl2aWR1YWxTdHlsZU5hbWUgaW4gZXhwYW5zaW9uKSB7XG4gICAgICAgICAgICBzdHlsZVtpbmRpdmlkdWFsU3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnM7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2FsbGJhY2tRdWV1ZVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKFwiLi9Qb29sZWRDbGFzc1wiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgcHNldWRvLWV2ZW50IG1vZHVsZSB0byBoZWxwIGtlZXAgdHJhY2sgb2YgY29tcG9uZW50cyB3YWl0aW5nIHRvXG4gKiBiZSBub3RpZmllZCB3aGVuIHRoZWlyIERPTSByZXByZXNlbnRhdGlvbnMgYXJlIGF2YWlsYWJsZSBmb3IgdXNlLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50cyBgUG9vbGVkQ2xhc3NgLCBzbyB5b3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcy5cbiAqIEluc3RlYWQsIHVzZSBgQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKWAuXG4gKlxuICogQGNsYXNzIFJlYWN0TW91bnRSZWFkeVxuICogQGltcGxlbWVudHMgUG9vbGVkQ2xhc3NcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBDYWxsYmFja1F1ZXVlKCkge1xuICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG59XG5cbmFzc2lnbihDYWxsYmFja1F1ZXVlLnByb3RvdHlwZSwge1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0IENvbnRleHQgdG8gY2FsbCBgY2FsbGJhY2tgIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZTogZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwgW107XG4gICAgdGhpcy5fY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cyB8fCBbXTtcbiAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgdGhpcy5fY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlcyBhbGwgZW5xdWV1ZWQgY2FsbGJhY2tzIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLiBUaGlzIGlzIGludm9rZWQgYWZ0ZXJcbiAgICogdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbXBvbmVudCBoYXMgYmVlbiBjcmVhdGVkIG9yIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbm90aWZ5QWxsOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICAgIHZhciBjb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzO1xuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIGNhbGxiYWNrcy5sZW5ndGggPT09IGNvbnRleHRzLmxlbmd0aCxcbiAgICAgICAgXCJNaXNtYXRjaGVkIGxpc3Qgb2YgY29udGV4dHMgaW4gY2FsbGJhY2sgcXVldWVcIlxuICAgICAgKSA6IGludmFyaWFudChjYWxsYmFja3MubGVuZ3RoID09PSBjb250ZXh0cy5sZW5ndGgpKTtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwoY29udGV4dHNbaV0pO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb250ZXh0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBpbnRlcm5hbCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDYWxsYmFja1F1ZXVlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYWxsYmFja1F1ZXVlO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2hhbmdlRXZlbnRQbHVnaW5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpbkh1YlwiKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZShcIi4vRXZlbnRQcm9wYWdhdG9yc1wiKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlc1wiKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0V2ZW50XCIpO1xuXG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoXCIuL2lzRXZlbnRTdXBwb3J0ZWRcIik7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZShcIi4vaXNUZXh0SW5wdXRFbGVtZW50XCIpO1xudmFyIGtleU9mID0gcmVxdWlyZShcIi4va2V5T2ZcIik7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25DaGFuZ2U6IG51bGx9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25DaGFuZ2VDYXB0dXJlOiBudWxsfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BCbHVyLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BDaGFuZ2UsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcENsaWNrLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BGb2N1cyxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wSW5wdXQsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2VcbiAgICBdXG4gIH1cbn07XG5cbi8qKlxuICogRm9yIElFIHNoaW1zXG4gKi9cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IG51bGw7XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjaGFuZ2VgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNoYW5nZUV2ZW50KGVsZW0pIHtcbiAgcmV0dXJuIChcbiAgICBlbGVtLm5vZGVOYW1lID09PSAnU0VMRUNUJyB8fFxuICAgIChlbGVtLm5vZGVOYW1lID09PSAnSU5QVVQnICYmIGVsZW0udHlwZSA9PT0gJ2ZpbGUnKVxuICApO1xufVxuXG52YXIgZG9lc0NoYW5nZUV2ZW50QnViYmxlID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIFNlZSBgaGFuZGxlQ2hhbmdlYCBjb21tZW50IGJlbG93XG4gIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2NoYW5nZScpICYmIChcbiAgICAhKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA4XG4gICk7XG59XG5cbmZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKFxuICAgIGV2ZW50VHlwZXMuY2hhbmdlLFxuICAgIGFjdGl2ZUVsZW1lbnRJRCxcbiAgICBuYXRpdmVFdmVudFxuICApO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50SW5CYXRjaChldmVudCkge1xuICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50KTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KHRhcmdldCwgdGFyZ2V0SUQpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudElEID0gdGFyZ2V0SUQ7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG59XG5cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldElERm9yQ2hhbmdlRXZlbnQoXG4gICAgdG9wTGV2ZWxUeXBlLFxuICAgIHRvcExldmVsVGFyZ2V0LFxuICAgIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDaGFuZ2UpIHtcbiAgICByZXR1cm4gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTgoXG4gICAgdG9wTGV2ZWxUeXBlLFxuICAgIHRvcExldmVsVGFyZ2V0LFxuICAgIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BGb2N1cykge1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgfVxufVxuXG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBpbnB1dGAgZXZlbnRcbiAqL1xudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTkgY2xhaW1zIHRvIHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IGJ1dCBmYWlscyB0byB0cmlnZ2VyIGl0IHdoZW5cbiAgLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHNcbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoXG4gICAgISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOVxuICApO1xufVxuXG4vKipcbiAqIChGb3Igb2xkIElFLikgUmVwbGFjZW1lbnQgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGB2YWx1ZWAgcHJvcGVydHkgdGhhdCBnZXRzXG4gKiBzZXQgb24gdGhlIGFjdGl2ZSBlbGVtZW50LlxuICovXG52YXIgbmV3VmFsdWVQcm9wID0gIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5nZXQuY2FsbCh0aGlzKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAvLyBDYXN0IHRvIGEgc3RyaW5nIHNvIHdlIGNhbiBkbyBlcXVhbGl0eSBjaGVja3MuXG4gICAgYWN0aXZlRWxlbWVudFZhbHVlID0gJycgKyB2YWw7XG4gICAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5zZXQuY2FsbCh0aGlzLCB2YWwpO1xuICB9XG59O1xuXG4vKipcbiAqIChGb3Igb2xkIElFLikgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SUQpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudElEID0gdGFyZ2V0SUQ7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IHRhcmdldC52YWx1ZTtcbiAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgdGFyZ2V0LmNvbnN0cnVjdG9yLnByb3RvdHlwZSxcbiAgICAndmFsdWUnXG4gICk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFjdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5ld1ZhbHVlUHJvcCk7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG5cbi8qKlxuICogKEZvciBvbGQgSUUuKSBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgY3VycmVudGx5LXRyYWNrZWQgZWxlbWVudCxcbiAqIGlmIGFueSBleGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBkZWxldGUgcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHByb3BlcnR5IGRlZmluaXRpb25cbiAgZGVsZXRlIGFjdGl2ZUVsZW1lbnQudmFsdWU7XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG5cbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3Igb2xkIElFLikgSGFuZGxlcyBhIHByb3BlcnR5Y2hhbmdlIGV2ZW50LCBzZW5kaW5nIGEgYGNoYW5nZWAgZXZlbnQgaWZcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgYWN0aXZlIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5Q2hhbmdlKG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5wcm9wZXJ0eU5hbWUgIT09ICd2YWx1ZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHZhbHVlID0gbmF0aXZlRXZlbnQuc3JjRWxlbWVudC52YWx1ZTtcbiAgaWYgKHZhbHVlID09PSBhY3RpdmVFbGVtZW50VmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdmFsdWU7XG5cbiAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG59XG5cbi8qKlxuICogSWYgYSBgY2hhbmdlYCBldmVudCBzaG91bGQgYmUgZmlyZWQsIHJldHVybnMgdGhlIHRhcmdldCdzIElELlxuICovXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvcklucHV0RXZlbnQoXG4gICAgdG9wTGV2ZWxUeXBlLFxuICAgIHRvcExldmVsVGFyZ2V0LFxuICAgIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BJbnB1dCkge1xuICAgIC8vIEluIG1vZGVybiBicm93c2VycyAoaS5lLiwgbm90IElFOCBvciBJRTkpLCB0aGUgaW5wdXQgZXZlbnQgaXMgZXhhY3RseVxuICAgIC8vIHdoYXQgd2Ugd2FudCBzbyBmYWxsIHRocm91Z2ggaGVyZSBhbmQgdHJpZ2dlciBhbiBhYnN0cmFjdCBldmVudFxuICAgIHJldHVybiB0b3BMZXZlbFRhcmdldElEO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRShcbiAgICB0b3BMZXZlbFR5cGUsXG4gICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzKSB7XG4gICAgLy8gSW4gSUU4LCB3ZSBjYW4gY2FwdHVyZSBhbG1vc3QgYWxsIC52YWx1ZSBjaGFuZ2VzIGJ5IGFkZGluZyBhXG4gICAgLy8gcHJvcGVydHljaGFuZ2UgaGFuZGxlciBhbmQgbG9va2luZyBmb3IgZXZlbnRzIHdpdGggcHJvcGVydHlOYW1lXG4gICAgLy8gZXF1YWwgdG8gJ3ZhbHVlJ1xuICAgIC8vIEluIElFOSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvcklucHV0RXZlbnRJRShcbiAgICB0b3BMZXZlbFR5cGUsXG4gICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZSB8fFxuICAgICAgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwIHx8XG4gICAgICB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5RG93bikge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIGlmIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQudmFsdWUgIT09IGFjdGl2ZUVsZW1lbnRWYWx1ZSkge1xuICAgICAgYWN0aXZlRWxlbWVudFZhbHVlID0gYWN0aXZlRWxlbWVudC52YWx1ZTtcbiAgICAgIHJldHVybiBhY3RpdmVFbGVtZW50SUQ7XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDbGlja0V2ZW50KGVsZW0pIHtcbiAgLy8gVXNlIHRoZSBgY2xpY2tgIGV2ZW50IHRvIGRldGVjdCBjaGFuZ2VzIHRvIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMuXG4gIC8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXG4gIC8vIHVudGlsIGBibHVyYCBpbiBJRTguXG4gIHJldHVybiAoXG4gICAgZWxlbS5ub2RlTmFtZSA9PT0gJ0lOUFVUJyAmJlxuICAgIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvckNsaWNrRXZlbnQoXG4gICAgdG9wTGV2ZWxUeXBlLFxuICAgIHRvcExldmVsVGFyZ2V0LFxuICAgIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDbGljaykge1xuICAgIHJldHVybiB0b3BMZXZlbFRhcmdldElEO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9cbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uKFxuICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgbmF0aXZlRXZlbnQpIHtcblxuICAgIHZhciBnZXRUYXJnZXRJREZ1bmMsIGhhbmRsZUV2ZW50RnVuYztcbiAgICBpZiAoc2hvdWxkVXNlQ2hhbmdlRXZlbnQodG9wTGV2ZWxUYXJnZXQpKSB7XG4gICAgICBpZiAoZG9lc0NoYW5nZUV2ZW50QnViYmxlKSB7XG4gICAgICAgIGdldFRhcmdldElERnVuYyA9IGdldFRhcmdldElERm9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFODtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0b3BMZXZlbFRhcmdldCkpIHtcbiAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SURGdW5jID0gZ2V0VGFyZ2V0SURGb3JJbnB1dEV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGFyZ2V0SURGdW5jID0gZ2V0VGFyZ2V0SURGb3JJbnB1dEV2ZW50SUU7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodG9wTGV2ZWxUYXJnZXQpKSB7XG4gICAgICBnZXRUYXJnZXRJREZ1bmMgPSBnZXRUYXJnZXRJREZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldElERnVuYykge1xuICAgICAgdmFyIHRhcmdldElEID0gZ2V0VGFyZ2V0SURGdW5jKFxuICAgICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICAgIHRvcExldmVsVGFyZ2V0LFxuICAgICAgICB0b3BMZXZlbFRhcmdldElEXG4gICAgICApO1xuICAgICAgaWYgKHRhcmdldElEKSB7XG4gICAgICAgIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChcbiAgICAgICAgICBldmVudFR5cGVzLmNoYW5nZSxcbiAgICAgICAgICB0YXJnZXRJRCxcbiAgICAgICAgICBuYXRpdmVFdmVudFxuICAgICAgICApO1xuICAgICAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgICAgaGFuZGxlRXZlbnRGdW5jKFxuICAgICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICAgIHRvcExldmVsVGFyZ2V0LFxuICAgICAgICB0b3BMZXZlbFRhcmdldElEXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZUV2ZW50UGx1Z2luO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENsaWVudFJlYWN0Um9vdEluZGV4XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgbmV4dFJlYWN0Um9vdEluZGV4ID0gMDtcblxudmFyIENsaWVudFJlYWN0Um9vdEluZGV4ID0ge1xuICBjcmVhdGVSZWFjdFJvb3RJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5leHRSZWFjdFJvb3RJbmRleCsrO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudFJlYWN0Um9vdEluZGV4O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENvbXBvc2l0aW9uRXZlbnRQbHVnaW5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKFwiLi9FdmVudFByb3BhZ2F0b3JzXCIpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHJlcXVpcmUoXCIuL1JlYWN0SW5wdXRTZWxlY3Rpb25cIik7XG52YXIgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnRcIik7XG5cbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZShcIi4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvclwiKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoXCIuL2tleU9mXCIpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciB1c2VDb21wb3NpdGlvbkV2ZW50ID0gKFxuICBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiZcbiAgJ0NvbXBvc2l0aW9uRXZlbnQnIGluIHdpbmRvd1xuKTtcblxuLy8gSW4gSUU5Kywgd2UgaGF2ZSBhY2Nlc3MgdG8gY29tcG9zaXRpb24gZXZlbnRzLCBidXQgdGhlIGRhdGEgc3VwcGxpZWRcbi8vIGJ5IHRoZSBuYXRpdmUgY29tcG9zaXRpb25lbmQgZXZlbnQgbWF5IGJlIGluY29ycmVjdC4gSW4gS29yZWFuLCBmb3IgZXhhbXBsZSxcbi8vIHRoZSBjb21wb3NpdGlvbmVuZCBldmVudCBjb250YWlucyBvbmx5IG9uZSBjaGFyYWN0ZXIgcmVnYXJkbGVzcyBvZlxuLy8gaG93IG1hbnkgY2hhcmFjdGVycyBoYXZlIGJlZW4gY29tcG9zZWQgc2luY2UgY29tcG9zaXRpb25zdGFydC5cbi8vIFdlIHRoZXJlZm9yZSB1c2UgdGhlIGZhbGxiYWNrIGRhdGEgd2hpbGUgc3RpbGwgdXNpbmcgdGhlIG5hdGl2ZVxuLy8gZXZlbnRzIGFzIHRyaWdnZXJzLlxudmFyIHVzZUZhbGxiYWNrRGF0YSA9IChcbiAgIXVzZUNvbXBvc2l0aW9uRXZlbnQgfHxcbiAgKFxuICAgICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOCAmJlxuICAgIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMVxuICApXG4pO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG52YXIgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGNvbXBvc2l0aW9uRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkNvbXBvc2l0aW9uRW5kOiBudWxsfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uQ29tcG9zaXRpb25FbmRDYXB0dXJlOiBudWxsfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BCbHVyLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wS2V5RG93bixcbiAgICAgIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25cbiAgICBdXG4gIH0sXG4gIGNvbXBvc2l0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uQ29tcG9zaXRpb25TdGFydDogbnVsbH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlOiBudWxsfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BCbHVyLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblN0YXJ0LFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcyxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wS2V5VXAsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93blxuICAgIF1cbiAgfSxcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uQ29tcG9zaXRpb25VcGRhdGU6IG51bGx9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmU6IG51bGx9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcEJsdXIsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uVXBkYXRlLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcyxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wS2V5VXAsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93blxuICAgIF1cbiAgfVxufTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblN0YXJ0OlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQ6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25VcGRhdGU6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja1N0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIChcbiAgICB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5RG93biAmJlxuICAgIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREVcbiAgKTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0VuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgLy8gQ29tbWFuZCBrZXlzIGluc2VydCBvciBjbGVhciBJTUUgaW5wdXQuXG4gICAgICByZXR1cm4gKEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMSk7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiAobmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERSk7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgc2VsZWN0aW9uIGFuZCBkb2N1bWVudCBzdGF0ZVxuICogc28gd2UgY2FuIGZpZ3VyZSBvdXQgd2hhdCBjaGFuZ2VkIGF0IGEgbGF0ZXIgZGF0ZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSByb290XG4gKi9cbmZ1bmN0aW9uIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZShyb290KSB7XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG4gIHRoaXMuc3RhcnRTZWxlY3Rpb24gPSBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbihyb290KTtcbiAgdGhpcy5zdGFydFZhbHVlID0gdGhpcy5nZXRUZXh0KCk7XG59XG5cbi8qKlxuICogR2V0IGN1cnJlbnQgdGV4dCBvZiBpbnB1dC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbkZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yb290LnZhbHVlIHx8IHRoaXMucm9vdFtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldO1xufTtcblxuLyoqXG4gKiBUZXh0IHRoYXQgaGFzIGNoYW5nZWQgc2luY2UgdGhlIHN0YXJ0IG9mIGNvbXBvc2l0aW9uLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlbmRWYWx1ZSA9IHRoaXMuZ2V0VGV4dCgpO1xuICB2YXIgcHJlZml4TGVuZ3RoID0gdGhpcy5zdGFydFNlbGVjdGlvbi5zdGFydDtcbiAgdmFyIHN1ZmZpeExlbmd0aCA9IHRoaXMuc3RhcnRWYWx1ZS5sZW5ndGggLSB0aGlzLnN0YXJ0U2VsZWN0aW9uLmVuZDtcblxuICByZXR1cm4gZW5kVmFsdWUuc3Vic3RyKFxuICAgIHByZWZpeExlbmd0aCxcbiAgICBlbmRWYWx1ZS5sZW5ndGggLSBzdWZmaXhMZW5ndGggLSBwcmVmaXhMZW5ndGhcbiAgKTtcbn07XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBgb25Db21wb3NpdGlvblN0YXJ0YCwgYG9uQ29tcG9zaXRpb25VcGRhdGVgIGFuZFxuICogYG9uQ29tcG9zaXRpb25FbmRgIGV2ZW50cyBvbiBpbnB1dHMsIHRleHRhcmVhcyBhbmQgY29udGVudEVkaXRhYmxlXG4gKiBub2Rlcy5cbiAqL1xudmFyIENvbXBvc2l0aW9uRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbihcbiAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgIHRvcExldmVsVGFyZ2V0LFxuICAgICAgdG9wTGV2ZWxUYXJnZXRJRCxcbiAgICAgIG5hdGl2ZUV2ZW50KSB7XG5cbiAgICB2YXIgZXZlbnRUeXBlO1xuICAgIHZhciBkYXRhO1xuXG4gICAgaWYgKHVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSk7XG4gICAgfSBlbHNlIGlmICghY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgICBpZiAoaXNGYWxsYmFja1N0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tFbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gICAgfVxuXG4gICAgaWYgKHVzZUZhbGxiYWNrRGF0YSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4gICAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgICBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbiAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBuZXcgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKHRvcExldmVsVGFyZ2V0KTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICAgICAgICBkYXRhID0gY3VycmVudENvbXBvc2l0aW9uLmdldERhdGEoKTtcbiAgICAgICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50VHlwZSkge1xuICAgICAgdmFyIGV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5nZXRQb29sZWQoXG4gICAgICAgIGV2ZW50VHlwZSxcbiAgICAgICAgdG9wTGV2ZWxUYXJnZXRJRCxcbiAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICk7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAgICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICAgICAgZXZlbnQuZGF0YSA9IGRhdGE7XG4gICAgICB9XG4gICAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb3NpdGlvbkV2ZW50UGx1Z2luO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01DaGlsZHJlbk9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBEYW5nZXIgPSByZXF1aXJlKFwiLi9EYW5nZXJcIik7XG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSByZXF1aXJlKFwiLi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlc1wiKTtcblxudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKFwiLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBUaGUgRE9NIHByb3BlcnR5IHRvIHVzZSB3aGVuIHNldHRpbmcgdGV4dCBjb250ZW50LlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdGV4dENvbnRlbnRBY2Nlc3NvciA9IGdldFRleHRDb250ZW50QWNjZXNzb3IoKTtcblxuLyoqXG4gKiBJbnNlcnRzIGBjaGlsZE5vZGVgIGFzIGEgY2hpbGQgb2YgYHBhcmVudE5vZGVgIGF0IHRoZSBgaW5kZXhgLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcGFyZW50Tm9kZSBQYXJlbnQgbm9kZSBpbiB3aGljaCB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNoaWxkTm9kZSBDaGlsZCBub2RlIHRvIGluc2VydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCBpbmRleCkge1xuICAvLyBCeSBleHBsb2l0aW5nIGFycmF5cyByZXR1cm5pbmcgYHVuZGVmaW5lZGAgZm9yIGFuIHVuZGVmaW5lZCBpbmRleCwgd2UgY2FuXG4gIC8vIHJlbHkgZXhjbHVzaXZlbHkgb24gYGluc2VydEJlZm9yZShub2RlLCBudWxsKWAgaW5zdGVhZCBvZiBhbHNvIHVzaW5nXG4gIC8vIGBhcHBlbmRDaGlsZChub2RlKWAuIEhvd2V2ZXIsIHVzaW5nIGB1bmRlZmluZWRgIGlzIG5vdCBhbGxvd2VkIGJ5IGFsbFxuICAvLyBicm93c2VycyBzbyB3ZSBtdXN0IHJlcGxhY2UgaXQgd2l0aCBgbnVsbGAuXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKFxuICAgIGNoaWxkTm9kZSxcbiAgICBwYXJlbnROb2RlLmNoaWxkTm9kZXNbaW5kZXhdIHx8IG51bGxcbiAgKTtcbn1cblxudmFyIHVwZGF0ZVRleHRDb250ZW50O1xuaWYgKHRleHRDb250ZW50QWNjZXNzb3IgPT09ICd0ZXh0Q29udGVudCcpIHtcbiAgLyoqXG4gICAqIFNldHMgdGhlIHRleHQgY29udGVudCBvZiBgbm9kZWAgdG8gYHRleHRgLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgTm9kZSB0byBjaGFuZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgTmV3IHRleHQgY29udGVudFxuICAgKi9cbiAgdXBkYXRlVGV4dENvbnRlbnQgPSBmdW5jdGlvbihub2RlLCB0ZXh0KSB7XG4gICAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG4gIH07XG59IGVsc2Uge1xuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dCBjb250ZW50IG9mIGBub2RlYCB0byBgdGV4dGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBOb2RlIHRvIGNoYW5nZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBOZXcgdGV4dCBjb250ZW50XG4gICAqL1xuICB1cGRhdGVUZXh0Q29udGVudCA9IGZ1bmN0aW9uKG5vZGUsIHRleHQpIHtcbiAgICAvLyBJbiBvcmRlciB0byBwcmVzZXJ2ZSBuZXdsaW5lcyBjb3JyZWN0bHksIHdlIGNhbid0IHVzZSAuaW5uZXJUZXh0IHRvIHNldFxuICAgIC8vIHRoZSBjb250ZW50cyAoc2VlICMxMDgwKSwgc28gd2UgZW1wdHkgdGhlIGVsZW1lbnQgdGhlbiBhcHBlbmQgYSB0ZXh0IG5vZGVcbiAgICB3aGlsZSAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIGlmICh0ZXh0KSB7XG4gICAgICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciB1cGRhdGluZyB3aXRoIERPTSBjaGlsZHJlbi5cbiAqL1xudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHtcblxuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogRGFuZ2VyLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwLFxuXG4gIHVwZGF0ZVRleHRDb250ZW50OiB1cGRhdGVUZXh0Q29udGVudCxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy4gVGhlXG4gICAqIHVwZGF0ZSBjb25maWd1cmF0aW9ucyBhcmUgZWFjaCBleHBlY3RlZCB0byBoYXZlIGEgYHBhcmVudE5vZGVgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gbWFya3VwTGlzdCBMaXN0IG9mIG1hcmt1cCBzdHJpbmdzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb2Nlc3NVcGRhdGVzOiBmdW5jdGlvbih1cGRhdGVzLCBtYXJrdXBMaXN0KSB7XG4gICAgdmFyIHVwZGF0ZTtcbiAgICAvLyBNYXBwaW5nIGZyb20gcGFyZW50IElEcyB0byBpbml0aWFsIGNoaWxkIG9yZGVyaW5ncy5cbiAgICB2YXIgaW5pdGlhbENoaWxkcmVuID0gbnVsbDtcbiAgICAvLyBMaXN0IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBiZSBtb3ZlZCBvciByZW1vdmVkLlxuICAgIHZhciB1cGRhdGVkQ2hpbGRyZW4gPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IHVwZGF0ZSA9IHVwZGF0ZXNbaV07IGkrKykge1xuICAgICAgaWYgKHVwZGF0ZS50eXBlID09PSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HIHx8XG4gICAgICAgICAgdXBkYXRlLnR5cGUgPT09IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFKSB7XG4gICAgICAgIHZhciB1cGRhdGVkSW5kZXggPSB1cGRhdGUuZnJvbUluZGV4O1xuICAgICAgICB2YXIgdXBkYXRlZENoaWxkID0gdXBkYXRlLnBhcmVudE5vZGUuY2hpbGROb2Rlc1t1cGRhdGVkSW5kZXhdO1xuICAgICAgICB2YXIgcGFyZW50SUQgPSB1cGRhdGUucGFyZW50SUQ7XG5cbiAgICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgICB1cGRhdGVkQ2hpbGQsXG4gICAgICAgICAgJ3Byb2Nlc3NVcGRhdGVzKCk6IFVuYWJsZSB0byBmaW5kIGNoaWxkICVzIG9mIGVsZW1lbnQuIFRoaXMgJyArXG4gICAgICAgICAgJ3Byb2JhYmx5IG1lYW5zIHRoZSBET00gd2FzIHVuZXhwZWN0ZWRseSBtdXRhdGVkIChlLmcuLCBieSB0aGUgJyArXG4gICAgICAgICAgJ2Jyb3dzZXIpLCB1c3VhbGx5IGR1ZSB0byBmb3JnZXR0aW5nIGEgPHRib2R5PiB3aGVuIHVzaW5nIHRhYmxlcywgJyArXG4gICAgICAgICAgJ25lc3RpbmcgdGFncyBsaWtlIDxmb3JtPiwgPHA+LCBvciA8YT4sIG9yIHVzaW5nIG5vbi1TVkcgZWxlbWVudHMgJytcbiAgICAgICAgICAnaW4gYW4gPHN2Zz4gcGFyZW50LiBUcnkgaW5zcGVjdGluZyB0aGUgY2hpbGQgbm9kZXMgb2YgdGhlIGVsZW1lbnQgJyArXG4gICAgICAgICAgJ3dpdGggUmVhY3QgSUQgYCVzYC4nLFxuICAgICAgICAgIHVwZGF0ZWRJbmRleCxcbiAgICAgICAgICBwYXJlbnRJRFxuICAgICAgICApIDogaW52YXJpYW50KHVwZGF0ZWRDaGlsZCkpO1xuXG4gICAgICAgIGluaXRpYWxDaGlsZHJlbiA9IGluaXRpYWxDaGlsZHJlbiB8fCB7fTtcbiAgICAgICAgaW5pdGlhbENoaWxkcmVuW3BhcmVudElEXSA9IGluaXRpYWxDaGlsZHJlbltwYXJlbnRJRF0gfHwgW107XG4gICAgICAgIGluaXRpYWxDaGlsZHJlbltwYXJlbnRJRF1bdXBkYXRlZEluZGV4XSA9IHVwZGF0ZWRDaGlsZDtcblxuICAgICAgICB1cGRhdGVkQ2hpbGRyZW4gPSB1cGRhdGVkQ2hpbGRyZW4gfHwgW107XG4gICAgICAgIHVwZGF0ZWRDaGlsZHJlbi5wdXNoKHVwZGF0ZWRDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlbmRlcmVkTWFya3VwID0gRGFuZ2VyLmRhbmdlcm91c2x5UmVuZGVyTWFya3VwKG1hcmt1cExpc3QpO1xuXG4gICAgLy8gUmVtb3ZlIHVwZGF0ZWQgY2hpbGRyZW4gZmlyc3Qgc28gdGhhdCBgdG9JbmRleGAgaXMgY29uc2lzdGVudC5cbiAgICBpZiAodXBkYXRlZENoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHVwZGF0ZWRDaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICB1cGRhdGVkQ2hpbGRyZW5bal0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh1cGRhdGVkQ2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyB1cGRhdGUgPSB1cGRhdGVzW2tdOyBrKyspIHtcbiAgICAgIHN3aXRjaCAodXBkYXRlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5JTlNFUlRfTUFSS1VQOlxuICAgICAgICAgIGluc2VydENoaWxkQXQoXG4gICAgICAgICAgICB1cGRhdGUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgIHJlbmRlcmVkTWFya3VwW3VwZGF0ZS5tYXJrdXBJbmRleF0sXG4gICAgICAgICAgICB1cGRhdGUudG9JbmRleFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuTU9WRV9FWElTVElORzpcbiAgICAgICAgICBpbnNlcnRDaGlsZEF0KFxuICAgICAgICAgICAgdXBkYXRlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICBpbml0aWFsQ2hpbGRyZW5bdXBkYXRlLnBhcmVudElEXVt1cGRhdGUuZnJvbUluZGV4XSxcbiAgICAgICAgICAgIHVwZGF0ZS50b0luZGV4XG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5URVhUX0NPTlRFTlQ6XG4gICAgICAgICAgdXBkYXRlVGV4dENvbnRlbnQoXG4gICAgICAgICAgICB1cGRhdGUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgIHVwZGF0ZS50ZXh0Q29udGVudFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuUkVNT1ZFX05PREU6XG4gICAgICAgICAgLy8gQWxyZWFkeSByZW1vdmVkIGJ5IHRoZSBmb3ItbG9vcCBhYm92ZS5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01DaGlsZHJlbk9wZXJhdGlvbnM7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NUHJvcGVydHlcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuZnVuY3Rpb24gY2hlY2tNYXNrKHZhbHVlLCBiaXRtYXNrKSB7XG4gIHJldHVybiAodmFsdWUgJiBiaXRtYXNrKSA9PT0gYml0bWFzaztcbn1cblxudmFyIERPTVByb3BlcnR5SW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQsIGNhbWVsY2FzZWQgcHJvcGVydHkgbmFtZXMgdG8gYSBjb25maWd1cmF0aW9uIHRoYXRcbiAgICogc3BlY2lmaWVzIGhvdyB0aGUgYXNzb2NpYXRlZCBET00gcHJvcGVydHkgc2hvdWxkIGJlIGFjY2Vzc2VkIG9yIHJlbmRlcmVkLlxuICAgKi9cbiAgTVVTVF9VU0VfQVRUUklCVVRFOiAweDEsXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDIsXG4gIEhBU19TSURFX0VGRkVDVFM6IDB4NCxcbiAgSEFTX0JPT0xFQU5fVkFMVUU6IDB4OCxcbiAgSEFTX05VTUVSSUNfVkFMVUU6IDB4MTAsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDIwIHwgMHgxMCxcbiAgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTogMHg0MCxcblxuICAvKipcbiAgICogSW5qZWN0IHNvbWUgc3BlY2lhbGl6ZWQga25vd2xlZGdlIGFib3V0IHRoZSBET00uIFRoaXMgdGFrZXMgYSBjb25maWcgb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gdGhhdCBnaXZlbiBhbiBhdHRyaWJ1dGUgbmFtZSB3aWxsIHJldHVybiB0cnVlXG4gICAqIGlmIGl0IGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00gdmVyYmF0aW0uIFVzZWZ1bCBmb3IgZGF0YS0qIG9yIGFyaWEtKlxuICAgKiBhdHRyaWJ1dGVzIHdoZXJlIGl0J3MgaW1wb3NzaWJsZSB0byBlbnVtZXJhdGUgYWxsIG9mIHRoZSBwb3NzaWJsZVxuICAgKiBhdHRyaWJ1dGUgbmFtZXMsXG4gICAqXG4gICAqIFByb3BlcnRpZXM6IG9iamVjdCBtYXBwaW5nIERPTSBwcm9wZXJ0eSBuYW1lIHRvIG9uZSBvZiB0aGVcbiAgICogRE9NUHJvcGVydHlJbmplY3Rpb24gY29uc3RhbnRzIG9yIG51bGwuIElmIHlvdXIgYXR0cmlidXRlIGlzbid0IGluIGhlcmUsXG4gICAqIGl0IHdvbid0IGdldCB3cml0dGVuIHRvIHRoZSBET00uXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lLiBBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlICoqbG93ZXJjYXNlKipcbiAgICogbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01Qcm9wZXJ0eU5hbWVzOiBzaW1pbGFyIHRvIERPTUF0dHJpYnV0ZU5hbWVzIGJ1dCBmb3IgRE9NIHByb3BlcnRpZXMuXG4gICAqIFByb3BlcnR5IG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIHRoZSBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTU11dGF0aW9uTWV0aG9kczogUHJvcGVydGllcyB0aGF0IHJlcXVpcmUgc3BlY2lhbCBtdXRhdGlvbiBtZXRob2RzLiBJZlxuICAgKiBgdmFsdWVgIGlzIHVuZGVmaW5lZCwgdGhlIG11dGF0aW9uIG1ldGhvZCBzaG91bGQgdW5zZXQgdGhlIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZG9tUHJvcGVydHlDb25maWcgdGhlIGNvbmZpZyBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAqL1xuICBpbmplY3RET01Qcm9wZXJ0eUNvbmZpZzogZnVuY3Rpb24oZG9tUHJvcGVydHlDb25maWcpIHtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXMgfHwge307XG4gICAgdmFyIERPTVByb3BlcnR5TmFtZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01Qcm9wZXJ0eU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01NdXRhdGlvbk1ldGhvZHMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01NdXRhdGlvbk1ldGhvZHMgfHwge307XG5cbiAgICBpZiAoZG9tUHJvcGVydHlDb25maWcuaXNDdXN0b21BdHRyaWJ1dGUpIHtcbiAgICAgIERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucy5wdXNoKFxuICAgICAgICBkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBQcm9wZXJ0aWVzKSB7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICAhRE9NUHJvcGVydHkuaXNTdGFuZGFyZE5hbWUuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpLFxuICAgICAgICAnaW5qZWN0RE9NUHJvcGVydHlDb25maWcoLi4uKTogWW91XFwncmUgdHJ5aW5nIHRvIGluamVjdCBET00gcHJvcGVydHkgJyArXG4gICAgICAgICdcXCclc1xcJyB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkLiBZb3UgbWF5IGJlIGFjY2lkZW50YWxseSAnICtcbiAgICAgICAgJ2luamVjdGluZyB0aGUgc2FtZSBET00gcHJvcGVydHkgY29uZmlnIHR3aWNlLCBvciB5b3UgbWF5IGJlICcgK1xuICAgICAgICAnaW5qZWN0aW5nIHR3byBjb25maWdzIHRoYXQgaGF2ZSBjb25mbGljdGluZyBwcm9wZXJ0eSBuYW1lcy4nLFxuICAgICAgICBwcm9wTmFtZVxuICAgICAgKSA6IGludmFyaWFudCghRE9NUHJvcGVydHkuaXNTdGFuZGFyZE5hbWUuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSk7XG5cbiAgICAgIERPTVByb3BlcnR5LmlzU3RhbmRhcmROYW1lW3Byb3BOYW1lXSA9IHRydWU7XG5cbiAgICAgIHZhciBsb3dlckNhc2VkID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWRdID0gcHJvcE5hbWU7XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01BdHRyaWJ1dGVOYW1lc1twcm9wTmFtZV07XG4gICAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2F0dHJpYnV0ZU5hbWVdID0gcHJvcE5hbWU7XG4gICAgICAgIERPTVByb3BlcnR5LmdldEF0dHJpYnV0ZU5hbWVbcHJvcE5hbWVdID0gYXR0cmlidXRlTmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERPTVByb3BlcnR5LmdldEF0dHJpYnV0ZU5hbWVbcHJvcE5hbWVdID0gbG93ZXJDYXNlZDtcbiAgICAgIH1cblxuICAgICAgRE9NUHJvcGVydHkuZ2V0UHJvcGVydHlOYW1lW3Byb3BOYW1lXSA9XG4gICAgICAgIERPTVByb3BlcnR5TmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpID9cbiAgICAgICAgICBET01Qcm9wZXJ0eU5hbWVzW3Byb3BOYW1lXSA6XG4gICAgICAgICAgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChET01NdXRhdGlvbk1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIERPTVByb3BlcnR5LmdldE11dGF0aW9uTWV0aG9kW3Byb3BOYW1lXSA9IERPTU11dGF0aW9uTWV0aG9kc1twcm9wTmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRNdXRhdGlvbk1ldGhvZFtwcm9wTmFtZV0gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcENvbmZpZyA9IFByb3BlcnRpZXNbcHJvcE5hbWVdO1xuICAgICAgRE9NUHJvcGVydHkubXVzdFVzZUF0dHJpYnV0ZVtwcm9wTmFtZV0gPVxuICAgICAgICBjaGVja01hc2socHJvcENvbmZpZywgRE9NUHJvcGVydHlJbmplY3Rpb24uTVVTVF9VU0VfQVRUUklCVVRFKTtcbiAgICAgIERPTVByb3BlcnR5Lm11c3RVc2VQcm9wZXJ0eVtwcm9wTmFtZV0gPVxuICAgICAgICBjaGVja01hc2socHJvcENvbmZpZywgRE9NUHJvcGVydHlJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpO1xuICAgICAgRE9NUHJvcGVydHkuaGFzU2lkZUVmZmVjdHNbcHJvcE5hbWVdID1cbiAgICAgICAgY2hlY2tNYXNrKHByb3BDb25maWcsIERPTVByb3BlcnR5SW5qZWN0aW9uLkhBU19TSURFX0VGRkVDVFMpO1xuICAgICAgRE9NUHJvcGVydHkuaGFzQm9vbGVhblZhbHVlW3Byb3BOYW1lXSA9XG4gICAgICAgIGNoZWNrTWFzayhwcm9wQ29uZmlnLCBET01Qcm9wZXJ0eUluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRSk7XG4gICAgICBET01Qcm9wZXJ0eS5oYXNOdW1lcmljVmFsdWVbcHJvcE5hbWVdID1cbiAgICAgICAgY2hlY2tNYXNrKHByb3BDb25maWcsIERPTVByb3BlcnR5SW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFKTtcbiAgICAgIERPTVByb3BlcnR5Lmhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlW3Byb3BOYW1lXSA9XG4gICAgICAgIGNoZWNrTWFzayhwcm9wQ29uZmlnLCBET01Qcm9wZXJ0eUluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSk7XG4gICAgICBET01Qcm9wZXJ0eS5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlW3Byb3BOYW1lXSA9XG4gICAgICAgIGNoZWNrTWFzayhwcm9wQ29uZmlnLCBET01Qcm9wZXJ0eUluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFKTtcblxuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgIURPTVByb3BlcnR5Lm11c3RVc2VBdHRyaWJ1dGVbcHJvcE5hbWVdIHx8XG4gICAgICAgICAgIURPTVByb3BlcnR5Lm11c3RVc2VQcm9wZXJ0eVtwcm9wTmFtZV0sXG4gICAgICAgICdET01Qcm9wZXJ0eTogQ2Fubm90IHJlcXVpcmUgdXNpbmcgYm90aCBhdHRyaWJ1dGUgYW5kIHByb3BlcnR5OiAlcycsXG4gICAgICAgIHByb3BOYW1lXG4gICAgICApIDogaW52YXJpYW50KCFET01Qcm9wZXJ0eS5tdXN0VXNlQXR0cmlidXRlW3Byb3BOYW1lXSB8fFxuICAgICAgICAhRE9NUHJvcGVydHkubXVzdFVzZVByb3BlcnR5W3Byb3BOYW1lXSkpO1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgRE9NUHJvcGVydHkubXVzdFVzZVByb3BlcnR5W3Byb3BOYW1lXSB8fFxuICAgICAgICAgICFET01Qcm9wZXJ0eS5oYXNTaWRlRWZmZWN0c1twcm9wTmFtZV0sXG4gICAgICAgICdET01Qcm9wZXJ0eTogUHJvcGVydGllcyB0aGF0IGhhdmUgc2lkZSBlZmZlY3RzIG11c3QgdXNlIHByb3BlcnR5OiAlcycsXG4gICAgICAgIHByb3BOYW1lXG4gICAgICApIDogaW52YXJpYW50KERPTVByb3BlcnR5Lm11c3RVc2VQcm9wZXJ0eVtwcm9wTmFtZV0gfHxcbiAgICAgICAgIURPTVByb3BlcnR5Lmhhc1NpZGVFZmZlY3RzW3Byb3BOYW1lXSkpO1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgISFET01Qcm9wZXJ0eS5oYXNCb29sZWFuVmFsdWVbcHJvcE5hbWVdICtcbiAgICAgICAgICAhIURPTVByb3BlcnR5Lmhhc051bWVyaWNWYWx1ZVtwcm9wTmFtZV0gK1xuICAgICAgICAgICEhRE9NUHJvcGVydHkuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZVtwcm9wTmFtZV0gPD0gMSxcbiAgICAgICAgJ0RPTVByb3BlcnR5OiBWYWx1ZSBjYW4gYmUgb25lIG9mIGJvb2xlYW4sIG92ZXJsb2FkZWQgYm9vbGVhbiwgb3IgJyArXG4gICAgICAgICdudW1lcmljIHZhbHVlLCBidXQgbm90IGEgY29tYmluYXRpb246ICVzJyxcbiAgICAgICAgcHJvcE5hbWVcbiAgICAgICkgOiBpbnZhcmlhbnQoISFET01Qcm9wZXJ0eS5oYXNCb29sZWFuVmFsdWVbcHJvcE5hbWVdICtcbiAgICAgICAgISFET01Qcm9wZXJ0eS5oYXNOdW1lcmljVmFsdWVbcHJvcE5hbWVdICtcbiAgICAgICAgISFET01Qcm9wZXJ0eS5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlW3Byb3BOYW1lXSA8PSAxKSk7XG4gICAgfVxuICB9XG59O1xudmFyIGRlZmF1bHRWYWx1ZUNhY2hlID0ge307XG5cbi8qKlxuICogRE9NUHJvcGVydHkgZXhwb3J0cyBsb29rdXAgb2JqZWN0cyB0aGF0IGNhbiBiZSB1c2VkIGxpa2UgZnVuY3Rpb25zOlxuICpcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydpZCddXG4gKiAgIHRydWVcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydmb29iYXInXVxuICogICB1bmRlZmluZWRcbiAqXG4gKiBBbHRob3VnaCB0aGlzIG1heSBiZSBjb25mdXNpbmcsIGl0IHBlcmZvcm1zIGJldHRlciBpbiBnZW5lcmFsLlxuICpcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LWV4aXN0c1xuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktbWlzc2luZ1xuICovXG52YXIgRE9NUHJvcGVydHkgPSB7XG5cbiAgSURfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0aWQnLFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSBzdGFuZGFyZCBwcm9wZXJ0eS5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGlzU3RhbmRhcmROYW1lOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbiwgdXNlZFxuICAgKiB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgcHJvcGVydGllcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldFBvc3NpYmxlU3RhbmRhcmROYW1lOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQgbmFtZXMgdG8gYXR0cmlidXRlIG5hbWVzIHRoYXQgZGlmZmVyLiBBdHRyaWJ1dGVcbiAgICogbmFtZXMgYXJlIHVzZWQgd2hlbiByZW5kZXJpbmcgbWFya3VwIG9yIHdpdGggYCpBdHRyaWJ1dGUoKWAuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBnZXRBdHRyaWJ1dGVOYW1lOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQgbmFtZXMgdG8gcHJvcGVydGllcyBvbiBET00gbm9kZSBpbnN0YW5jZXMuXG4gICAqIChUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBtdXRhdGUgZHVlIHRvIGV4dGVybmFsIGZhY3RvcnMuKVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UHJvcGVydHlOYW1lOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQgbmFtZXMgdG8gbXV0YXRpb24gbWV0aG9kcy4gVGhpcyB3aWxsIG9ubHkgZXhpc3QgaWZcbiAgICogbXV0YXRpb24gY2Fubm90IGJlIHNldCBzaW1wbHkgYnkgdGhlIHByb3BlcnR5IG9yIGBzZXRBdHRyaWJ1dGUoKWAuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBnZXRNdXRhdGlvbk1ldGhvZDoge30sXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgbXVzdFVzZUF0dHJpYnV0ZToge30sXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgdXNpbmcgYCpBdHRyaWJ1dGUoKWAuXG4gICAqIChUaGlzIGluY2x1ZGVzIGFueXRoaW5nIHRoYXQgZmFpbHMgYDxwcm9wTmFtZT4gaW4gPGVsZW1lbnQ+YC4pXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBtdXN0VXNlUHJvcGVydHk6IHt9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCBzZXR0aW5nIGEgdmFsdWUgY2F1c2VzIHNpZGUgZWZmZWN0cyBzdWNoIGFzIHRyaWdnZXJpbmdcbiAgICogcmVzb3VyY2VzIHRvIGJlIGxvYWRlZCBvciB0ZXh0IHNlbGVjdGlvbiBjaGFuZ2VzLiBXZSBtdXN0IGVuc3VyZSB0aGF0XG4gICAqIHRoZSB2YWx1ZSBpcyBvbmx5IHNldCBpZiBpdCBoYXMgY2hhbmdlZC5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGhhc1NpZGVFZmZlY3RzOiB7fSxcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBoYXNCb29sZWFuVmFsdWU6IHt9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYVxuICAgKiBudW1lcmljIGFuZCBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGhhc051bWVyaWNWYWx1ZToge30sXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gICAqIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6IHt9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuIFJlbW92ZWRcbiAgICogd2hlbiBzdHJpY3RseSBlcXVhbCB0byBmYWxzZTsgcHJlc2VudCB3aXRob3V0IGEgdmFsdWUgd2hlbiBzdHJpY3RseSBlcXVhbFxuICAgKiB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOiB7fSxcblxuICAvKipcbiAgICogQWxsIG9mIHRoZSBpc0N1c3RvbUF0dHJpYnV0ZSgpIGZ1bmN0aW9ucyB0aGF0IGhhdmUgYmVlbiBpbmplY3RlZC5cbiAgICovXG4gIF9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9uczogW10sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGEgcHJvcGVydHkgbmFtZSBpcyBhIGN1c3RvbSBhdHRyaWJ1dGUuXG4gICAqIEBtZXRob2RcbiAgICovXG4gIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbihhdHRyaWJ1dGVOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpc0N1c3RvbUF0dHJpYnV0ZUZuID0gRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zW2ldO1xuICAgICAgaWYgKGlzQ3VzdG9tQXR0cmlidXRlRm4oYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBET00gcHJvcGVydHkgKGkuZS4sIG5vdCBhblxuICAgKiBhdHRyaWJ1dGUpLiBNb3N0IGRlZmF1bHQgdmFsdWVzIGFyZSAnJyBvciBmYWxzZSwgYnV0IG5vdCBhbGwuIFdvcnNlIHlldCxcbiAgICogc29tZSAoaW4gcGFydGljdWxhciwgYHR5cGVgKSB2YXJ5IGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiBlbGVtZW50LlxuICAgKlxuICAgKiBUT0RPOiBJcyBpdCBiZXR0ZXIgdG8gZ3JhYiBhbGwgdGhlIHBvc3NpYmxlIHByb3BlcnRpZXMgd2hlbiBjcmVhdGluZyBhblxuICAgKiBlbGVtZW50IHRvIGF2b2lkIGhhdmluZyB0byBjcmVhdGUgdGhlIHNhbWUgZWxlbWVudCB0d2ljZT9cbiAgICovXG4gIGdldERlZmF1bHRWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbihub2RlTmFtZSwgcHJvcCkge1xuICAgIHZhciBub2RlRGVmYXVsdHMgPSBkZWZhdWx0VmFsdWVDYWNoZVtub2RlTmFtZV07XG4gICAgdmFyIHRlc3RFbGVtZW50O1xuICAgIGlmICghbm9kZURlZmF1bHRzKSB7XG4gICAgICBkZWZhdWx0VmFsdWVDYWNoZVtub2RlTmFtZV0gPSBub2RlRGVmYXVsdHMgPSB7fTtcbiAgICB9XG4gICAgaWYgKCEocHJvcCBpbiBub2RlRGVmYXVsdHMpKSB7XG4gICAgICB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgICAgbm9kZURlZmF1bHRzW3Byb3BdID0gdGVzdEVsZW1lbnRbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiBub2RlRGVmYXVsdHNbcHJvcF07XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBET01Qcm9wZXJ0eUluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01Qcm9wZXJ0eU9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5XCIpO1xuXG52YXIgZXNjYXBlVGV4dEZvckJyb3dzZXIgPSByZXF1aXJlKFwiLi9lc2NhcGVUZXh0Rm9yQnJvd3NlclwiKTtcbnZhciBtZW1vaXplU3RyaW5nT25seSA9IHJlcXVpcmUoXCIuL21lbW9pemVTdHJpbmdPbmx5XCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fFxuICAgIChET01Qcm9wZXJ0eS5oYXNCb29sZWFuVmFsdWVbbmFtZV0gJiYgIXZhbHVlKSB8fFxuICAgIChET01Qcm9wZXJ0eS5oYXNOdW1lcmljVmFsdWVbbmFtZV0gJiYgaXNOYU4odmFsdWUpKSB8fFxuICAgIChET01Qcm9wZXJ0eS5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZVtuYW1lXSAmJiAodmFsdWUgPCAxKSkgfHxcbiAgICAoRE9NUHJvcGVydHkuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZVtuYW1lXSAmJiB2YWx1ZSA9PT0gZmFsc2UpO1xufVxuXG52YXIgcHJvY2Vzc0F0dHJpYnV0ZU5hbWVBbmRQcmVmaXggPSBtZW1vaXplU3RyaW5nT25seShmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiBlc2NhcGVUZXh0Rm9yQnJvd3NlcihuYW1lKSArICc9XCInO1xufSk7XG5cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgdmFyIHJlYWN0UHJvcHMgPSB7XG4gICAgY2hpbGRyZW46IHRydWUsXG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHRydWUsXG4gICAga2V5OiB0cnVlLFxuICAgIHJlZjogdHJ1ZVxuICB9O1xuICB2YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xuXG4gIHZhciB3YXJuVW5rbm93blByb3BlcnR5ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmIChyZWFjdFByb3BzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHJlYWN0UHJvcHNbbmFtZV0gfHxcbiAgICAgICAgd2FybmVkUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gZGF0YS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb25cbiAgICB2YXIgc3RhbmRhcmROYW1lID0gKFxuICAgICAgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobG93ZXJDYXNlZE5hbWUpID9cbiAgICAgICAgbG93ZXJDYXNlZE5hbWUgOlxuICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID9cbiAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbbG93ZXJDYXNlZE5hbWVdIDpcbiAgICAgICAgbnVsbFxuICAgICk7XG5cbiAgICAvLyBGb3Igbm93LCBvbmx5IHdhcm4gd2hlbiB3ZSBoYXZlIGEgc3VnZ2VzdGVkIGNvcnJlY3Rpb24uIFRoaXMgcHJldmVudHNcbiAgICAvLyBsb2dnaW5nIHRvbyBtdWNoIHdoZW4gdXNpbmcgdHJhbnNmZXJQcm9wc1RvLlxuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFxuICAgICAgc3RhbmRhcmROYW1lID09IG51bGwsXG4gICAgICAnVW5rbm93biBET00gcHJvcGVydHkgJyArIG5hbWUgKyAnLiBEaWQgeW91IG1lYW4gJyArIHN0YW5kYXJkTmFtZSArICc/J1xuICAgICkgOiBudWxsKTtcblxuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBET00gcHJvcGVydGllcy5cbiAqL1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBJRCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuZXNjYXBlZCBJRC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9ySUQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHByb2Nlc3NBdHRyaWJ1dGVOYW1lQW5kUHJlZml4KERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FKSArXG4gICAgICBlc2NhcGVUZXh0Rm9yQnJvd3NlcihpZCkgKyAnXCInO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBudWxsIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvclByb3BlcnR5OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJlxuICAgICAgICBET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZVtuYW1lXSkge1xuICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKG5hbWUsIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IERPTVByb3BlcnR5LmdldEF0dHJpYnV0ZU5hbWVbbmFtZV07XG4gICAgICBpZiAoRE9NUHJvcGVydHkuaGFzQm9vbGVhblZhbHVlW25hbWVdIHx8XG4gICAgICAgICAgKERPTVByb3BlcnR5Lmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWVbbmFtZV0gJiYgdmFsdWUgPT09IHRydWUpKSB7XG4gICAgICAgIHJldHVybiBlc2NhcGVUZXh0Rm9yQnJvd3NlcihhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9jZXNzQXR0cmlidXRlTmFtZUFuZFByZWZpeChhdHRyaWJ1dGVOYW1lKSArXG4gICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSArICdcIic7XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb2Nlc3NBdHRyaWJ1dGVOYW1lQW5kUHJlZml4KG5hbWUpICtcbiAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpICsgJ1wiJztcbiAgICB9IGVsc2UgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgd2FyblVua25vd25Qcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKERPTVByb3BlcnR5LmlzU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KG5hbWUpICYmXG4gICAgICAgIERPTVByb3BlcnR5LmlzU3RhbmRhcmROYW1lW25hbWVdKSB7XG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBET01Qcm9wZXJ0eS5nZXRNdXRhdGlvbk1ldGhvZFtuYW1lXTtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZElnbm9yZVZhbHVlKG5hbWUsIHZhbHVlKSkge1xuICAgICAgICB0aGlzLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5Lm11c3RVc2VBdHRyaWJ1dGVbbmFtZV0pIHtcbiAgICAgICAgLy8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxuICAgICAgICAvLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LmdldEF0dHJpYnV0ZU5hbWVbbmFtZV0sICcnICsgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gRE9NUHJvcGVydHkuZ2V0UHJvcGVydHlOYW1lW25hbWVdO1xuICAgICAgICAvLyBNdXN0IGV4cGxpY2l0bHkgY2FzdCB2YWx1ZXMgZm9yIEhBU19TSURFX0VGRkVDVFMtcHJvcGVydGllcyB0byB0aGVcbiAgICAgICAgLy8gcHJvcGVydHkgdHlwZSBiZWZvcmUgY29tcGFyaW5nOyBvbmx5IGB2YWx1ZWAgZG9lcyBhbmQgaXMgc3RyaW5nLlxuICAgICAgICBpZiAoIURPTVByb3BlcnR5Lmhhc1NpZGVFZmZlY3RzW25hbWVdIHx8XG4gICAgICAgICAgICAoJycgKyBub2RlW3Byb3BOYW1lXSkgIT09ICgnJyArIHZhbHVlKSkge1xuICAgICAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbiAgICAgICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIHdhcm5Vbmtub3duUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24obm9kZSwgbmFtZSkge1xuICAgIGlmIChET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJlxuICAgICAgICBET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZVtuYW1lXSkge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gRE9NUHJvcGVydHkuZ2V0TXV0YXRpb25NZXRob2RbbmFtZV07XG4gICAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdW5kZWZpbmVkKTtcbiAgICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkubXVzdFVzZUF0dHJpYnV0ZVtuYW1lXSkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShET01Qcm9wZXJ0eS5nZXRBdHRyaWJ1dGVOYW1lW25hbWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IERPTVByb3BlcnR5LmdldFByb3BlcnR5TmFtZVtuYW1lXTtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IERPTVByb3BlcnR5LmdldERlZmF1bHRWYWx1ZUZvclByb3BlcnR5KFxuICAgICAgICAgIG5vZGUubm9kZU5hbWUsXG4gICAgICAgICAgcHJvcE5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFET01Qcm9wZXJ0eS5oYXNTaWRlRWZmZWN0c1tuYW1lXSB8fFxuICAgICAgICAgICAgKCcnICsgbm9kZVtwcm9wTmFtZV0pICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICB3YXJuVW5rbm93blByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5T3BlcmF0aW9ucztcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEYW5nZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuLypqc2xpbnQgZXZpbDogdHJ1ZSwgc3ViOiB0cnVlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxudmFyIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cCA9IHJlcXVpcmUoXCIuL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cFwiKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcbnZhciBnZXRNYXJrdXBXcmFwID0gcmVxdWlyZShcIi4vZ2V0TWFya3VwV3JhcFwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbnZhciBPUEVOX1RBR19OQU1FX0VYUCA9IC9eKDxbXiBcXC8+XSspLztcbnZhciBSRVNVTFRfSU5ERVhfQVRUUiA9ICdkYXRhLWRhbmdlci1pbmRleCc7XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGBub2RlTmFtZWAgZnJvbSBhIHN0cmluZyBvZiBtYXJrdXAuXG4gKlxuICogTk9URTogRXh0cmFjdGluZyB0aGUgYG5vZGVOYW1lYCBkb2VzIG5vdCByZXF1aXJlIGEgcmVndWxhciBleHByZXNzaW9uIG1hdGNoXG4gKiBiZWNhdXNlIHdlIG1ha2UgYXNzdW1wdGlvbnMgYWJvdXQgUmVhY3QtZ2VuZXJhdGVkIG1hcmt1cCAoaS5lLiB0aGVyZSBhcmUgbm9cbiAqIHNwYWNlcyBzdXJyb3VuZGluZyB0aGUgb3BlbmluZyB0YWcgYW5kIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBhdHRyaWJ1dGUpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9kZSBuYW1lIG9mIHRoZSBzdXBwbGllZCBtYXJrdXAuXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2V4dHJhY3Qtbm9kZW5hbWVcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobWFya3VwKSB7XG4gIHJldHVybiBtYXJrdXAuc3Vic3RyaW5nKDEsIG1hcmt1cC5pbmRleE9mKCcgJykpO1xufVxuXG52YXIgRGFuZ2VyID0ge1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIG1hcmt1cCBpbnRvIGFuIGFycmF5IG9mIG5vZGVzLiBUaGUgbWFya3VwIGlzIGV4cGVjdGVkIHRvIHJlbmRlclxuICAgKiBpbnRvIGEgbGlzdCBvZiByb290IG5vZGVzLiBBbHNvLCB0aGUgbGVuZ3RoIG9mIGByZXN1bHRMaXN0YCBhbmRcbiAgICogYG1hcmt1cExpc3RgIHNob3VsZCBiZSB0aGUgc2FtZS5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBtYXJrdXBMaXN0IExpc3Qgb2YgbWFya3VwIHN0cmluZ3MgdG8gcmVuZGVyLlxuICAgKiBAcmV0dXJuIHthcnJheTxET01FbGVtZW50Pn0gTGlzdCBvZiByZW5kZXJlZCBub2Rlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVJlbmRlck1hcmt1cDogZnVuY3Rpb24obWFya3VwTGlzdCkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00sXG4gICAgICAnZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAoLi4uKTogQ2Fubm90IHJlbmRlciBtYXJrdXAgaW4gYSB3b3JrZXIgJyArXG4gICAgICAndGhyZWFkLiBNYWtlIHN1cmUgYHdpbmRvd2AgYW5kIGBkb2N1bWVudGAgYXJlIGF2YWlsYWJsZSBnbG9iYWxseSAnICtcbiAgICAgICdiZWZvcmUgcmVxdWlyaW5nIFJlYWN0IHdoZW4gdW5pdCB0ZXN0aW5nIG9yIHVzZSAnICtcbiAgICAgICdSZWFjdC5yZW5kZXJUb1N0cmluZyBmb3Igc2VydmVyIHJlbmRlcmluZy4nXG4gICAgKSA6IGludmFyaWFudChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pKTtcbiAgICB2YXIgbm9kZU5hbWU7XG4gICAgdmFyIG1hcmt1cEJ5Tm9kZU5hbWUgPSB7fTtcbiAgICAvLyBHcm91cCBtYXJrdXAgYnkgYG5vZGVOYW1lYCBpZiBhIHdyYXAgaXMgbmVjZXNzYXJ5LCBlbHNlIGJ5ICcqJy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmt1cExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIG1hcmt1cExpc3RbaV0sXG4gICAgICAgICdkYW5nZXJvdXNseVJlbmRlck1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nXG4gICAgICApIDogaW52YXJpYW50KG1hcmt1cExpc3RbaV0pKTtcbiAgICAgIG5vZGVOYW1lID0gZ2V0Tm9kZU5hbWUobWFya3VwTGlzdFtpXSk7XG4gICAgICBub2RlTmFtZSA9IGdldE1hcmt1cFdyYXAobm9kZU5hbWUpID8gbm9kZU5hbWUgOiAnKic7XG4gICAgICBtYXJrdXBCeU5vZGVOYW1lW25vZGVOYW1lXSA9IG1hcmt1cEJ5Tm9kZU5hbWVbbm9kZU5hbWVdIHx8IFtdO1xuICAgICAgbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV1baV0gPSBtYXJrdXBMaXN0W2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0TGlzdCA9IFtdO1xuICAgIHZhciByZXN1bHRMaXN0QXNzaWdubWVudENvdW50ID0gMDtcbiAgICBmb3IgKG5vZGVOYW1lIGluIG1hcmt1cEJ5Tm9kZU5hbWUpIHtcbiAgICAgIGlmICghbWFya3VwQnlOb2RlTmFtZS5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgbWFya3VwTGlzdEJ5Tm9kZU5hbWUgPSBtYXJrdXBCeU5vZGVOYW1lW25vZGVOYW1lXTtcblxuICAgICAgLy8gVGhpcyBmb3ItaW4gbG9vcCBza2lwcyB0aGUgaG9sZXMgb2YgdGhlIHNwYXJzZSBhcnJheS4gVGhlIG9yZGVyIG9mXG4gICAgICAvLyBpdGVyYXRpb24gc2hvdWxkIGZvbGxvdyB0aGUgb3JkZXIgb2YgYXNzaWdubWVudCwgd2hpY2ggaGFwcGVucyB0byBtYXRjaFxuICAgICAgLy8gbnVtZXJpY2FsIGluZGV4IG9yZGVyLCBidXQgd2UgZG9uJ3QgcmVseSBvbiB0aGF0LlxuICAgICAgZm9yICh2YXIgcmVzdWx0SW5kZXggaW4gbWFya3VwTGlzdEJ5Tm9kZU5hbWUpIHtcbiAgICAgICAgaWYgKG1hcmt1cExpc3RCeU5vZGVOYW1lLmhhc093blByb3BlcnR5KHJlc3VsdEluZGV4KSkge1xuICAgICAgICAgIHZhciBtYXJrdXAgPSBtYXJrdXBMaXN0QnlOb2RlTmFtZVtyZXN1bHRJbmRleF07XG5cbiAgICAgICAgICAvLyBQdXNoIHRoZSByZXF1ZXN0ZWQgbWFya3VwIHdpdGggYW4gYWRkaXRpb25hbCBSRVNVTFRfSU5ERVhfQVRUUlxuICAgICAgICAgIC8vIGF0dHJpYnV0ZS4gIElmIHRoZSBtYXJrdXAgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIDwgY2hhcmFjdGVyLCBpdFxuICAgICAgICAgIC8vIHdpbGwgYmUgZGlzY2FyZGVkIGJlbG93ICh3aXRoIGFuIGFwcHJvcHJpYXRlIGNvbnNvbGUuZXJyb3IpLlxuICAgICAgICAgIG1hcmt1cExpc3RCeU5vZGVOYW1lW3Jlc3VsdEluZGV4XSA9IG1hcmt1cC5yZXBsYWNlKFxuICAgICAgICAgICAgT1BFTl9UQUdfTkFNRV9FWFAsXG4gICAgICAgICAgICAvLyBUaGlzIGluZGV4IHdpbGwgYmUgcGFyc2VkIGJhY2sgb3V0IGJlbG93LlxuICAgICAgICAgICAgJyQxICcgKyBSRVNVTFRfSU5ERVhfQVRUUiArICc9XCInICsgcmVzdWx0SW5kZXggKyAnXCIgJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVuZGVyIGVhY2ggZ3JvdXAgb2YgbWFya3VwIHdpdGggc2ltaWxhciB3cmFwcGluZyBgbm9kZU5hbWVgLlxuICAgICAgdmFyIHJlbmRlck5vZGVzID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwKFxuICAgICAgICBtYXJrdXBMaXN0QnlOb2RlTmFtZS5qb2luKCcnKSxcbiAgICAgICAgZW1wdHlGdW5jdGlvbiAvLyBEbyBub3RoaW5nIHNwZWNpYWwgd2l0aCA8c2NyaXB0PiB0YWdzLlxuICAgICAgKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHJlbmRlck5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciByZW5kZXJOb2RlID0gcmVuZGVyTm9kZXNbaV07XG4gICAgICAgIGlmIChyZW5kZXJOb2RlLmhhc0F0dHJpYnV0ZSAmJlxuICAgICAgICAgICAgcmVuZGVyTm9kZS5oYXNBdHRyaWJ1dGUoUkVTVUxUX0lOREVYX0FUVFIpKSB7XG5cbiAgICAgICAgICByZXN1bHRJbmRleCA9ICtyZW5kZXJOb2RlLmdldEF0dHJpYnV0ZShSRVNVTFRfSU5ERVhfQVRUUik7XG4gICAgICAgICAgcmVuZGVyTm9kZS5yZW1vdmVBdHRyaWJ1dGUoUkVTVUxUX0lOREVYX0FUVFIpO1xuXG4gICAgICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgICAgICFyZXN1bHRMaXN0Lmhhc093blByb3BlcnR5KHJlc3VsdEluZGV4KSxcbiAgICAgICAgICAgICdEYW5nZXI6IEFzc2lnbmluZyB0byBhbiBhbHJlYWR5LW9jY3VwaWVkIHJlc3VsdCBpbmRleC4nXG4gICAgICAgICAgKSA6IGludmFyaWFudCghcmVzdWx0TGlzdC5oYXNPd25Qcm9wZXJ0eShyZXN1bHRJbmRleCkpKTtcblxuICAgICAgICAgIHJlc3VsdExpc3RbcmVzdWx0SW5kZXhdID0gcmVuZGVyTm9kZTtcblxuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG1hdGNoIHJlc3VsdExpc3QubGVuZ3RoIGFuZCBtYXJrdXBMaXN0Lmxlbmd0aCB3aGVuXG4gICAgICAgICAgLy8gd2UncmUgZG9uZS5cbiAgICAgICAgICByZXN1bHRMaXN0QXNzaWdubWVudENvdW50ICs9IDE7XG5cbiAgICAgICAgfSBlbHNlIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJEYW5nZXI6IERpc2NhcmRpbmcgdW5leHBlY3RlZCBub2RlOlwiLFxuICAgICAgICAgICAgcmVuZGVyTm9kZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbHRob3VnaCByZXN1bHRMaXN0IHdhcyBwb3B1bGF0ZWQgb3V0IG9mIG9yZGVyLCBpdCBzaG91bGQgbm93IGJlIGEgZGVuc2VcbiAgICAvLyBhcnJheS5cbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgcmVzdWx0TGlzdEFzc2lnbm1lbnRDb3VudCA9PT0gcmVzdWx0TGlzdC5sZW5ndGgsXG4gICAgICAnRGFuZ2VyOiBEaWQgbm90IGFzc2lnbiB0byBldmVyeSBpbmRleCBvZiByZXN1bHRMaXN0LidcbiAgICApIDogaW52YXJpYW50KHJlc3VsdExpc3RBc3NpZ25tZW50Q291bnQgPT09IHJlc3VsdExpc3QubGVuZ3RoKSk7XG5cbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgcmVzdWx0TGlzdC5sZW5ndGggPT09IG1hcmt1cExpc3QubGVuZ3RoLFxuICAgICAgJ0RhbmdlcjogRXhwZWN0ZWQgbWFya3VwIHRvIHJlbmRlciAlcyBub2RlcywgYnV0IHJlbmRlcmVkICVzLicsXG4gICAgICBtYXJrdXBMaXN0Lmxlbmd0aCxcbiAgICAgIHJlc3VsdExpc3QubGVuZ3RoXG4gICAgKSA6IGludmFyaWFudChyZXN1bHRMaXN0Lmxlbmd0aCA9PT0gbWFya3VwTGlzdC5sZW5ndGgpKTtcblxuICAgIHJldHVybiByZXN1bHRMaXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhIG5vZGUgd2l0aCBhIHN0cmluZyBvZiBtYXJrdXAgYXQgaXRzIGN1cnJlbnQgcG9zaXRpb24gd2l0aGluIGl0c1xuICAgKiBwYXJlbnQuIFRoZSBtYXJrdXAgbXVzdCByZW5kZXIgaW50byBhIHNpbmdsZSByb290IG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb2xkQ2hpbGQgQ2hpbGQgbm9kZSB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0byByZW5kZXIgaW4gcGxhY2Ugb2YgdGhlIGNoaWxkIG5vZGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGZ1bmN0aW9uKG9sZENoaWxkLCBtYXJrdXApIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NLFxuICAgICAgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZW5kZXIgbWFya3VwIGluIGEgJyArXG4gICAgICAnd29ya2VyIHRocmVhZC4gTWFrZSBzdXJlIGB3aW5kb3dgIGFuZCBgZG9jdW1lbnRgIGFyZSBhdmFpbGFibGUgJyArXG4gICAgICAnZ2xvYmFsbHkgYmVmb3JlIHJlcXVpcmluZyBSZWFjdCB3aGVuIHVuaXQgdGVzdGluZyBvciB1c2UgJyArXG4gICAgICAnUmVhY3QucmVuZGVyVG9TdHJpbmcgZm9yIHNlcnZlciByZW5kZXJpbmcuJ1xuICAgICkgOiBpbnZhcmlhbnQoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSk7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChtYXJrdXAsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IGludmFyaWFudChtYXJrdXApKTtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgb2xkQ2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnaHRtbCcsXG4gICAgICAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlcGxhY2UgbWFya3VwIG9mIHRoZSAnICtcbiAgICAgICc8aHRtbD4gbm9kZS4gVGhpcyBpcyBiZWNhdXNlIGJyb3dzZXIgcXVpcmtzIG1ha2UgdGhpcyB1bnJlbGlhYmxlICcgK1xuICAgICAgJ2FuZC9vciBzbG93LiBJZiB5b3Ugd2FudCB0byByZW5kZXIgdG8gdGhlIHJvb3QgeW91IG11c3QgdXNlICcgK1xuICAgICAgJ3NlcnZlciByZW5kZXJpbmcuIFNlZSByZW5kZXJDb21wb25lbnRUb1N0cmluZygpLidcbiAgICApIDogaW52YXJpYW50KG9sZENoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ2h0bWwnKSk7XG5cbiAgICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwLCBlbXB0eUZ1bmN0aW9uKVswXTtcbiAgICBvbGRDaGlsZC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdDaGlsZCwgb2xkQ2hpbGQpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGFuZ2VyO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXJcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuIHZhciBrZXlPZiA9IHJlcXVpcmUoXCIuL2tleU9mXCIpO1xuXG4vKipcbiAqIE1vZHVsZSB0aGF0IGlzIGluamVjdGFibGUgaW50byBgRXZlbnRQbHVnaW5IdWJgLCB0aGF0IHNwZWNpZmllcyBhXG4gKiBkZXRlcm1pbmlzdGljIG9yZGVyaW5nIG9mIGBFdmVudFBsdWdpbmBzLiBBIGNvbnZlbmllbnQgd2F5IHRvIHJlYXNvbiBhYm91dFxuICogcGx1Z2lucywgd2l0aG91dCBoYXZpbmcgdG8gcGFja2FnZSBldmVyeSBvbmUgb2YgdGhlbS4gVGhpcyBpcyBiZXR0ZXIgdGhhblxuICogaGF2aW5nIHBsdWdpbnMgYmUgb3JkZXJlZCBpbiB0aGUgc2FtZSBvcmRlciB0aGF0IHRoZXkgYXJlIGluamVjdGVkIGJlY2F1c2VcbiAqIHRoYXQgb3JkZXJpbmcgd291bGQgYmUgaW5mbHVlbmNlZCBieSB0aGUgcGFja2FnaW5nIG9yZGVyLlxuICogYFJlc3BvbmRlckV2ZW50UGx1Z2luYCBtdXN0IG9jY3VyIGJlZm9yZSBgU2ltcGxlRXZlbnRQbHVnaW5gIHNvIHRoYXRcbiAqIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBldmVudHMgaXMgY29udmVuaWVudCBpbiBgU2ltcGxlRXZlbnRQbHVnaW5gIGhhbmRsZXJzLlxuICovXG52YXIgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIgPSBbXG4gIGtleU9mKHtSZXNwb25kZXJFdmVudFBsdWdpbjogbnVsbH0pLFxuICBrZXlPZih7U2ltcGxlRXZlbnRQbHVnaW46IG51bGx9KSxcbiAga2V5T2Yoe1RhcEV2ZW50UGx1Z2luOiBudWxsfSksXG4gIGtleU9mKHtFbnRlckxlYXZlRXZlbnRQbHVnaW46IG51bGx9KSxcbiAga2V5T2Yoe0NoYW5nZUV2ZW50UGx1Z2luOiBudWxsfSksXG4gIGtleU9mKHtTZWxlY3RFdmVudFBsdWdpbjogbnVsbH0pLFxuICBrZXlPZih7Q29tcG9zaXRpb25FdmVudFBsdWdpbjogbnVsbH0pLFxuICBrZXlPZih7QmVmb3JlSW5wdXRFdmVudFBsdWdpbjogbnVsbH0pLFxuICBrZXlPZih7QW5hbHl0aWNzRXZlbnRQbHVnaW46IG51bGx9KSxcbiAga2V5T2Yoe01vYmlsZVNhZmFyaUNsaWNrRXZlbnRQbHVnaW46IG51bGx9KVxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFbnRlckxlYXZlRXZlbnRQbHVnaW5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKFwiLi9FdmVudFByb3BhZ2F0b3JzXCIpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNNb3VzZUV2ZW50XCIpO1xuXG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoXCIuL1JlYWN0TW91bnRcIik7XG52YXIga2V5T2YgPSByZXF1aXJlKFwiLi9rZXlPZlwiKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xudmFyIGdldEZpcnN0UmVhY3RET00gPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET007XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBtb3VzZUVudGVyOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZToga2V5T2Yoe29uTW91c2VFbnRlcjogbnVsbH0pLFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyXG4gICAgXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZToga2V5T2Yoe29uTW91c2VMZWF2ZTogbnVsbH0pLFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyXG4gICAgXVxuICB9XG59O1xuXG52YXIgZXh0cmFjdGVkRXZlbnRzID0gW251bGwsIG51bGxdO1xuXG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEZvciBhbG1vc3QgZXZlcnkgaW50ZXJhY3Rpb24gd2UgY2FyZSBhYm91dCwgdGhlcmUgd2lsbCBiZSBib3RoIGEgdG9wLWxldmVsXG4gICAqIGBtb3VzZW92ZXJgIGFuZCBgbW91c2VvdXRgIGV2ZW50IHRoYXQgb2NjdXJzLiBPbmx5IHVzZSBgbW91c2VvdXRgIHNvIHRoYXRcbiAgICogd2UgZG8gbm90IGV4dHJhY3QgZHVwbGljYXRlIGV2ZW50cy4gSG93ZXZlciwgbW92aW5nIHRoZSBtb3VzZSBpbnRvIHRoZVxuICAgKiBicm93c2VyIGZyb20gb3V0c2lkZSB3aWxsIG5vdCBmaXJlIGEgYG1vdXNlb3V0YCBldmVudC4gSW4gdGhpcyBjYXNlLCB3ZSB1c2VcbiAgICogdGhlIGBtb3VzZW92ZXJgIHRvcC1sZXZlbCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbihcbiAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgIHRvcExldmVsVGFyZ2V0LFxuICAgICAgdG9wTGV2ZWxUYXJnZXRJRCxcbiAgICAgIG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXIgJiZcbiAgICAgICAgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCAmJlxuICAgICAgICB0b3BMZXZlbFR5cGUgIT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAodG9wTGV2ZWxUYXJnZXQud2luZG93ID09PSB0b3BMZXZlbFRhcmdldCkge1xuICAgICAgLy8gYHRvcExldmVsVGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSB0b3BMZXZlbFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IHRvcExldmVsVGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tLCB0bztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0KSB7XG4gICAgICBmcm9tID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgICB0byA9XG4gICAgICAgIGdldEZpcnN0UmVhY3RET00obmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQpIHx8XG4gICAgICAgIHdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJvbSA9IHdpbjtcbiAgICAgIHRvID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAvLyBOb3RoaW5nIHBlcnRhaW5zIHRvIG91ciBtYW5hZ2VkIGNvbXBvbmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZnJvbUlEID0gZnJvbSA/IFJlYWN0TW91bnQuZ2V0SUQoZnJvbSkgOiAnJztcbiAgICB2YXIgdG9JRCA9IHRvID8gUmVhY3RNb3VudC5nZXRJRCh0bykgOiAnJztcblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKFxuICAgICAgZXZlbnRUeXBlcy5tb3VzZUxlYXZlLFxuICAgICAgZnJvbUlELFxuICAgICAgbmF0aXZlRXZlbnRcbiAgICApO1xuICAgIGxlYXZlLnR5cGUgPSAnbW91c2VsZWF2ZSc7XG4gICAgbGVhdmUudGFyZ2V0ID0gZnJvbTtcbiAgICBsZWF2ZS5yZWxhdGVkVGFyZ2V0ID0gdG87XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChcbiAgICAgIGV2ZW50VHlwZXMubW91c2VFbnRlcixcbiAgICAgIHRvSUQsXG4gICAgICBuYXRpdmVFdmVudFxuICAgICk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0bztcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbTtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbUlELCB0b0lEKTtcblxuICAgIGV4dHJhY3RlZEV2ZW50c1swXSA9IGxlYXZlO1xuICAgIGV4dHJhY3RlZEV2ZW50c1sxXSA9IGVudGVyO1xuXG4gICAgcmV0dXJuIGV4dHJhY3RlZEV2ZW50cztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVudGVyTGVhdmVFdmVudFBsdWdpbjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudENvbnN0YW50c1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZShcIi4va2V5TWlycm9yXCIpO1xuXG52YXIgUHJvcGFnYXRpb25QaGFzZXMgPSBrZXlNaXJyb3Ioe2J1YmJsZWQ6IG51bGwsIGNhcHR1cmVkOiBudWxsfSk7XG5cbi8qKlxuICogVHlwZXMgb2YgcmF3IHNpZ25hbHMgZnJvbSB0aGUgYnJvd3NlciBjYXVnaHQgYXQgdGhlIHRvcCBsZXZlbC5cbiAqL1xudmFyIHRvcExldmVsVHlwZXMgPSBrZXlNaXJyb3Ioe1xuICB0b3BCbHVyOiBudWxsLFxuICB0b3BDaGFuZ2U6IG51bGwsXG4gIHRvcENsaWNrOiBudWxsLFxuICB0b3BDb21wb3NpdGlvbkVuZDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6IG51bGwsXG4gIHRvcENvbnRleHRNZW51OiBudWxsLFxuICB0b3BDb3B5OiBudWxsLFxuICB0b3BDdXQ6IG51bGwsXG4gIHRvcERvdWJsZUNsaWNrOiBudWxsLFxuICB0b3BEcmFnOiBudWxsLFxuICB0b3BEcmFnRW5kOiBudWxsLFxuICB0b3BEcmFnRW50ZXI6IG51bGwsXG4gIHRvcERyYWdFeGl0OiBudWxsLFxuICB0b3BEcmFnTGVhdmU6IG51bGwsXG4gIHRvcERyYWdPdmVyOiBudWxsLFxuICB0b3BEcmFnU3RhcnQ6IG51bGwsXG4gIHRvcERyb3A6IG51bGwsXG4gIHRvcEVycm9yOiBudWxsLFxuICB0b3BGb2N1czogbnVsbCxcbiAgdG9wSW5wdXQ6IG51bGwsXG4gIHRvcEtleURvd246IG51bGwsXG4gIHRvcEtleVByZXNzOiBudWxsLFxuICB0b3BLZXlVcDogbnVsbCxcbiAgdG9wTG9hZDogbnVsbCxcbiAgdG9wTW91c2VEb3duOiBudWxsLFxuICB0b3BNb3VzZU1vdmU6IG51bGwsXG4gIHRvcE1vdXNlT3V0OiBudWxsLFxuICB0b3BNb3VzZU92ZXI6IG51bGwsXG4gIHRvcE1vdXNlVXA6IG51bGwsXG4gIHRvcFBhc3RlOiBudWxsLFxuICB0b3BSZXNldDogbnVsbCxcbiAgdG9wU2Nyb2xsOiBudWxsLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6IG51bGwsXG4gIHRvcFN1Ym1pdDogbnVsbCxcbiAgdG9wVGV4dElucHV0OiBudWxsLFxuICB0b3BUb3VjaENhbmNlbDogbnVsbCxcbiAgdG9wVG91Y2hFbmQ6IG51bGwsXG4gIHRvcFRvdWNoTW92ZTogbnVsbCxcbiAgdG9wVG91Y2hTdGFydDogbnVsbCxcbiAgdG9wV2hlZWw6IG51bGxcbn0pO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSB7XG4gIHRvcExldmVsVHlwZXM6IHRvcExldmVsVHlwZXMsXG4gIFByb3BhZ2F0aW9uUGhhc2VzOiBQcm9wYWdhdGlvblBoYXNlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudENvbnN0YW50cztcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRMaXN0ZW5lclxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2VtcHR5RnVuY3Rpb25cIik7XG5cbi8qKlxuICogVXBzdHJlYW0gdmVyc2lvbiBvZiBldmVudCBsaXN0ZW5lci4gRG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgc3BlY2lmaWNcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cbiAqL1xudmFyIEV2ZW50TGlzdGVuZXIgPSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBsaXN0ZW46IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYXR0YWNoRXZlbnQpIHtcbiAgICAgIHRhcmdldC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgY2FwdHVyZTogZnVuY3Rpb24odGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdBdHRlbXB0ZWQgdG8gbGlzdGVuIHRvIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2Ugb24gYSAnICtcbiAgICAgICAgICAnYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGNhcHR1cmUgcGhhc2UuIFlvdXIgYXBwbGljYXRpb24gJyArXG4gICAgICAgICAgJ3dpbGwgbm90IHJlY2VpdmUgc29tZSBldmVudHMuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBlbXB0eUZ1bmN0aW9uXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIHJlZ2lzdGVyRGVmYXVsdDogZnVuY3Rpb24oKSB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RlbmVyO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luSHViXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZShcIi4vRXZlbnRQbHVnaW5SZWdpc3RyeVwiKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZShcIi4vRXZlbnRQbHVnaW5VdGlsc1wiKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZShcIi4vYWNjdW11bGF0ZUludG9cIik7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZShcIi4vZm9yRWFjaEFjY3VtdWxhdGVkXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBJbnRlcm5hbCBzdG9yZSBmb3IgZXZlbnQgbGlzdGVuZXJzXG4gKi9cbnZhciBsaXN0ZW5lckJhbmsgPSB7fTtcblxuLyoqXG4gKiBJbnRlcm5hbCBxdWV1ZSBvZiBldmVudHMgdGhhdCBoYXZlIGFjY3VtdWxhdGVkIHRoZWlyIGRpc3BhdGNoZXMgYW5kIGFyZVxuICogd2FpdGluZyB0byBoYXZlIHRoZWlyIGRpc3BhdGNoZXMgZXhlY3V0ZWQuXG4gKi9cbnZhciBldmVudFF1ZXVlID0gbnVsbDtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCByZWxlYXNlcyBpdCBiYWNrIGludG8gdGhlIHBvb2wsIHVubGVzcyBwZXJzaXN0ZW50LlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnQgU3ludGhldGljIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgdmFyIGV4ZWN1dGVEaXNwYXRjaCA9IEV2ZW50UGx1Z2luVXRpbHMuZXhlY3V0ZURpc3BhdGNoO1xuICAgIC8vIFBsdWdpbnMgY2FuIHByb3ZpZGUgY3VzdG9tIGJlaGF2aW9yIHdoZW4gZGlzcGF0Y2hpbmcgZXZlbnRzLlxuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LmdldFBsdWdpbk1vZHVsZUZvckV2ZW50KGV2ZW50KTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS5leGVjdXRlRGlzcGF0Y2gpIHtcbiAgICAgIGV4ZWN1dGVEaXNwYXRjaCA9IFBsdWdpbk1vZHVsZS5leGVjdXRlRGlzcGF0Y2g7XG4gICAgfVxuICAgIEV2ZW50UGx1Z2luVXRpbHMuZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBleGVjdXRlRGlzcGF0Y2gpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIC0gYEluc3RhbmNlSGFuZGxlYDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBwZXJmb3JtcyBsb2dpY2FsIHRyYXZlcnNhbHMgb2YgRE9NXG4gKiAgIGhpZXJhcmNoeSBnaXZlbiBpZHMgb2YgdGhlIGxvZ2ljYWwgRE9NIGVsZW1lbnRzIGludm9sdmVkLlxuICovXG52YXIgSW5zdGFuY2VIYW5kbGUgPSBudWxsO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUluc3RhbmNlSGFuZGxlKCkge1xuICB2YXIgaW52YWxpZCA9ICFJbnN0YW5jZUhhbmRsZXx8XG4gICAgIUluc3RhbmNlSGFuZGxlLnRyYXZlcnNlVHdvUGhhc2UgfHxcbiAgICAhSW5zdGFuY2VIYW5kbGUudHJhdmVyc2VFbnRlckxlYXZlO1xuICBpZiAoaW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5zdGFuY2VIYW5kbGUgbm90IGluamVjdGVkIGJlZm9yZSB1c2UhJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGV2ZW50IHBsdWdpbnMgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkLlxuICpcbiAqIEV2ZW50IHBsdWdpbnMgY2FuIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICBgZXh0cmFjdEV2ZW50c2Age2Z1bmN0aW9uKHN0cmluZywgRE9NRXZlbnRUYXJnZXQsIHN0cmluZywgb2JqZWN0KTogKn1cbiAqICAgICBSZXF1aXJlZC4gV2hlbiBhIHRvcC1sZXZlbCBldmVudCBpcyBmaXJlZCwgdGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG9cbiAqICAgICBleHRyYWN0IHN5bnRoZXRpYyBldmVudHMgdGhhdCB3aWxsIGluIHR1cm4gYmUgcXVldWVkIGFuZCBkaXNwYXRjaGVkLlxuICpcbiAqICAgYGV2ZW50VHlwZXNgIHtvYmplY3R9XG4gKiAgICAgT3B0aW9uYWwsIHBsdWdpbnMgdGhhdCBmaXJlIGV2ZW50cyBtdXN0IHB1Ymxpc2ggYSBtYXBwaW5nIG9mIHJlZ2lzdHJhdGlvblxuICogICAgIG5hbWVzIHRoYXQgYXJlIHVzZWQgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLiBWYWx1ZXMgb2YgdGhpcyBtYXBwaW5nIG11c3RcbiAqICAgICBiZSBvYmplY3RzIHRoYXQgY29udGFpbiBgcmVnaXN0cmF0aW9uTmFtZWAgb3IgYHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzYC5cbiAqXG4gKiAgIGBleGVjdXRlRGlzcGF0Y2hgIHtmdW5jdGlvbihvYmplY3QsIGZ1bmN0aW9uLCBzdHJpbmcpfVxuICogICAgIE9wdGlvbmFsLCBhbGxvd3MgcGx1Z2lucyB0byBvdmVycmlkZSBob3cgYW4gZXZlbnQgZ2V0cyBkaXNwYXRjaGVkLiBCeVxuICogICAgIGRlZmF1bHQsIHRoZSBsaXN0ZW5lciBpcyBzaW1wbHkgaW52b2tlZC5cbiAqXG4gKiBFYWNoIHBsdWdpbiB0aGF0IGlzIGluamVjdGVkIGludG8gYEV2ZW50c1BsdWdpbkh1YmAgaXMgaW1tZWRpYXRlbHkgb3BlcmFibGUuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgRXZlbnRQbHVnaW5IdWIgPSB7XG5cbiAgLyoqXG4gICAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBpbmplY3Rpb246IHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBJbmplY3RlZE1vdW50XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdE1vdW50OiBFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RNb3VudCxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBJbmplY3RlZEluc3RhbmNlSGFuZGxlXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdEluc3RhbmNlSGFuZGxlOiBmdW5jdGlvbihJbmplY3RlZEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICBJbnN0YW5jZUhhbmRsZSA9IEluamVjdGVkSW5zdGFuY2VIYW5kbGU7XG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIHZhbGlkYXRlSW5zdGFuY2VIYW5kbGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0SW5zdGFuY2VIYW5kbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICB2YWxpZGF0ZUluc3RhbmNlSGFuZGxlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gSW5zdGFuY2VIYW5kbGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IEV2ZW50UGx1Z2luUmVnaXN0cnkuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG5cbiAgfSxcblxuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLFxuXG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLFxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYGxpc3RlbmVyYCBhdCBgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2lkXWAuIElzIGlkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGxpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBzdG9yZS5cbiAgICovXG4gIHB1dExpc3RlbmVyOiBmdW5jdGlvbihpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgIWxpc3RlbmVyIHx8IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICdFeHBlY3RlZCAlcyBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCB0eXBlICVzJyxcbiAgICAgIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lclxuICAgICkgOiBpbnZhcmlhbnQoIWxpc3RlbmVyIHx8IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykpO1xuXG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID1cbiAgICAgIGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSB8fCAobGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdID0ge30pO1xuICAgIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2lkXSA9IGxpc3RlbmVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAgICovXG4gIGdldExpc3RlbmVyOiBmdW5jdGlvbihpZCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICByZXR1cm4gYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgJiYgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaWRdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgbGlzdGVuZXIgZnJvbSB0aGUgcmVnaXN0cmF0aW9uIGJhbmsuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICovXG4gIGRlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbihpZCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAgIGRlbGV0ZSBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtpZF07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBET00gZWxlbWVudCB3aXRoIHRoZSBzdXBwbGllZCBJRC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBET00gZWxlbWVudC5cbiAgICovXG4gIGRlbGV0ZUFsbExpc3RlbmVyczogZnVuY3Rpb24oaWQpIHtcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIGxpc3RlbmVyQmFuaykge1xuICAgICAgZGVsZXRlIGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtpZF07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgcmVnaXN0ZXJlZCBwbHVnaW5zIGFuIG9wcG9ydHVuaXR5IHRvIGV4dHJhY3QgZXZlbnRzIGZyb20gdG9wLWxldmVsXG4gICAqIG5hdGl2ZSBicm93c2VyIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24oXG4gICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICB0b3BMZXZlbFRhcmdldCxcbiAgICAgIHRvcExldmVsVGFyZ2V0SUQsXG4gICAgICBuYXRpdmVFdmVudCkge1xuICAgIHZhciBldmVudHM7XG4gICAgdmFyIHBsdWdpbnMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwbHVnaW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgIGlmIChwb3NzaWJsZVBsdWdpbikge1xuICAgICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyhcbiAgICAgICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICAgICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgICAgICAgdG9wTGV2ZWxUYXJnZXRJRCxcbiAgICAgICAgICBuYXRpdmVFdmVudFxuICAgICAgICApO1xuICAgICAgICBpZiAoZXh0cmFjdGVkRXZlbnRzKSB7XG4gICAgICAgICAgZXZlbnRzID0gYWNjdW11bGF0ZUludG8oZXZlbnRzLCBleHRyYWN0ZWRFdmVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudHM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgc3ludGhldGljIGV2ZW50IHRoYXQgc2hvdWxkIGJlIGRpc3BhdGNoZWQgd2hlblxuICAgKiBgcHJvY2Vzc0V2ZW50UXVldWVgIGlzIGludm9rZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZXZlbnRzIEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgIGV2ZW50UXVldWUgPSBhY2N1bXVsYXRlSW50byhldmVudFF1ZXVlLCBldmVudHMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbGwgc3ludGhldGljIGV2ZW50cyBvbiB0aGUgZXZlbnQgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc0V2ZW50UXVldWU6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgICAvLyBldmVudHMgZ2V0IGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcuXG4gICAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcbiAgICBldmVudFF1ZXVlID0gbnVsbDtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSk7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICFldmVudFF1ZXVlLFxuICAgICAgJ3Byb2Nlc3NFdmVudFF1ZXVlKCk6IEFkZGl0aW9uYWwgZXZlbnRzIHdlcmUgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZyAnICtcbiAgICAgICdhbiBldmVudCBxdWV1ZS4gU3VwcG9ydCBmb3IgdGhpcyBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLidcbiAgICApIDogaW52YXJpYW50KCFldmVudFF1ZXVlKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZXNlIGFyZSBuZWVkZWQgZm9yIHRlc3RzIG9ubHkuIERvIG5vdCB1c2UhXG4gICAqL1xuICBfX3B1cmdlOiBmdW5jdGlvbigpIHtcbiAgICBsaXN0ZW5lckJhbmsgPSB7fTtcbiAgfSxcblxuICBfX2dldExpc3RlbmVyQmFuazogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQmFuaztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luSHViO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luUmVnaXN0cnlcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxuICovXG52YXIgRXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXG4gKi9cbnZhciBuYW1lc1RvUGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIFJlY29tcHV0ZXMgdGhlIHBsdWdpbiBsaXN0IHVzaW5nIHRoZSBpbmplY3RlZCBwbHVnaW5zIGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XG4gIGlmICghRXZlbnRQbHVnaW5PcmRlcikge1xuICAgIC8vIFdhaXQgdW50aWwgYW4gYEV2ZW50UGx1Z2luT3JkZXJgIGlzIGluamVjdGVkLlxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIHZhciBwbHVnaW5JbmRleCA9IEV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgcGx1Z2luSW5kZXggPiAtMSxcbiAgICAgICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbnMgdGhhdCBkbyBub3QgZXhpc3QgaW4gJyArXG4gICAgICAndGhlIHBsdWdpbiBvcmRlcmluZywgYCVzYC4nLFxuICAgICAgcGx1Z2luTmFtZVxuICAgICkgOiBpbnZhcmlhbnQocGx1Z2luSW5kZXggPiAtMSkpO1xuICAgIGlmIChFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIFBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzLFxuICAgICAgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgICcgK1xuICAgICAgJ21ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJyxcbiAgICAgIHBsdWdpbk5hbWVcbiAgICApIDogaW52YXJpYW50KFBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzKSk7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSA9IFBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gUGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgcHVibGlzaEV2ZW50Rm9yUGx1Z2luKFxuICAgICAgICAgIHB1Ymxpc2hlZEV2ZW50c1tldmVudE5hbWVdLFxuICAgICAgICAgIFBsdWdpbk1vZHVsZSxcbiAgICAgICAgICBldmVudE5hbWVcbiAgICAgICAgKSxcbiAgICAgICAgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsXG4gICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgcGx1Z2luTmFtZVxuICAgICAgKSA6IGludmFyaWFudChwdWJsaXNoRXZlbnRGb3JQbHVnaW4oXG4gICAgICAgIHB1Ymxpc2hlZEV2ZW50c1tldmVudE5hbWVdLFxuICAgICAgICBQbHVnaW5Nb2R1bGUsXG4gICAgICAgIGV2ZW50TmFtZVxuICAgICAgKSkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhbiBldmVudCBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBzdXBwbGllZCBwbHVnaW4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIERpc3BhdGNoIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoRXZlbnRGb3JQbHVnaW4oZGlzcGF0Y2hDb25maWcsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgIUV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSksXG4gICAgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSAnICtcbiAgICAnZXZlbnQgbmFtZSwgYCVzYC4nLFxuICAgIGV2ZW50TmFtZVxuICApIDogaW52YXJpYW50KCFFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSk7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV0gPSBkaXNwYXRjaENvbmZpZztcblxuICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcbiAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgZm9yICh2YXIgcGhhc2VOYW1lIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2VOYW1lKSkge1xuICAgICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZSA9IHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlTmFtZV07XG4gICAgICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKFxuICAgICAgICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgICAgICAgUGx1Z2luTW9kdWxlLFxuICAgICAgICAgIGV2ZW50TmFtZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUoXG4gICAgICBkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLFxuICAgICAgUGx1Z2luTW9kdWxlLFxuICAgICAgZXZlbnROYW1lXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGEgcmVnaXN0cmF0aW9uIG5hbWUgdGhhdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGRpc3BhdGNoZWQgZXZlbnRzIGFuZFxuICogY2FuIGJlIHVzZWQgd2l0aCBgRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXJgIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgIUV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0sXG4gICAgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSAnICtcbiAgICAncmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJyxcbiAgICByZWdpc3RyYXRpb25OYW1lXG4gICkgOiBpbnZhcmlhbnQoIUV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0pKTtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA9IFBsdWdpbk1vZHVsZTtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID1cbiAgICBQbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgcGx1Z2lucyBzbyB0aGF0IHRoZXkgY2FuIGV4dHJhY3QgYW5kIGRpc3BhdGNoIGV2ZW50cy5cbiAqXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yn1cbiAqL1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSB7XG5cbiAgLyoqXG4gICAqIE9yZGVyZWQgbGlzdCBvZiBpbmplY3RlZCBwbHVnaW5zLlxuICAgKi9cbiAgcGx1Z2luczogW10sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBldmVudCBuYW1lIHRvIGRpc3BhdGNoIGNvbmZpZ1xuICAgKi9cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIHBsdWdpbiBtb2R1bGVcbiAgICovXG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIGV2ZW50IG5hbWVcbiAgICovXG4gIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBJbmplY3RzIGFuIG9yZGVyaW5nIG9mIHBsdWdpbnMgKGJ5IHBsdWdpbiBuYW1lKS4gVGhpcyBhbGxvd3MgdGhlIG9yZGVyaW5nXG4gICAqIHRvIGJlIGRlY291cGxlZCBmcm9tIGluamVjdGlvbiBvZiB0aGUgYWN0dWFsIHBsdWdpbnMgc28gdGhhdCBvcmRlcmluZyBpc1xuICAgKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcn1cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGZ1bmN0aW9uKEluamVjdGVkRXZlbnRQbHVnaW5PcmRlcikge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAhRXZlbnRQbHVnaW5PcmRlcixcbiAgICAgICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbiBvcmRlcmluZyBtb3JlIHRoYW4gJyArXG4gICAgICAnb25jZS4gWW91IGFyZSBsaWtlbHkgdHJ5aW5nIHRvIGxvYWQgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0LidcbiAgICApIDogaW52YXJpYW50KCFFdmVudFBsdWdpbk9yZGVyKSk7XG4gICAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICAgIEV2ZW50UGx1Z2luT3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpO1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxuICAgKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICAgKlxuICAgKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBmdW5jdGlvbihpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIGlzT3JkZXJpbmdEaXJ0eSA9IGZhbHNlO1xuICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKCFpbmplY3RlZE5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IGluamVjdGVkTmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICBpZiAoIW5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpIHx8XG4gICAgICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IFBsdWdpbk1vZHVsZSkge1xuICAgICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICAgICFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSxcbiAgICAgICAgICAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgJyArXG4gICAgICAgICAgJ3VzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJyxcbiAgICAgICAgICBwbHVnaW5OYW1lXG4gICAgICAgICkgOiBpbnZhcmlhbnQoIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdKSk7XG4gICAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID0gUGx1Z2luTW9kdWxlO1xuICAgICAgICBpc09yZGVyaW5nRGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNPcmRlcmluZ0RpcnR5KSB7XG4gICAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTG9va3MgdXAgdGhlIHBsdWdpbiBmb3IgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgQSBzeW50aGV0aWMgZXZlbnQuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IFRoZSBwbHVnaW4gdGhhdCBjcmVhdGVkIHRoZSBzdXBwbGllZCBldmVudC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRQbHVnaW5Nb2R1bGVGb3JFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSBldmVudC5kaXNwYXRjaENvbmZpZztcbiAgICBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbXG4gICAgICAgIGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWVcbiAgICAgIF0gfHwgbnVsbDtcbiAgICB9XG4gICAgZm9yICh2YXIgcGhhc2UgaW4gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmICghZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2UpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbXG4gICAgICAgIGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlXVxuICAgICAgXTtcbiAgICAgIGlmIChQbHVnaW5Nb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbk1vZHVsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldEV2ZW50UGx1Z2luczogZnVuY3Rpb24oKSB7XG4gICAgRXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKG5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zLmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncykge1xuICAgICAgaWYgKGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMpIHtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShyZWdpc3RyYXRpb25OYW1lKSkge1xuICAgICAgICBkZWxldGUgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5SZWdpc3RyeTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpblV0aWxzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIEluamVjdGVkIGRlcGVuZGVuY2llczpcbiAqL1xuXG4vKipcbiAqIC0gYE1vdW50YDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBjYW4gY29udmVydCBiZXR3ZWVuIFJlYWN0IGRvbSBJRHMgYW5kXG4gKiAgIGFjdHVhbCBub2RlIHJlZmVyZW5jZXMuXG4gKi9cbnZhciBpbmplY3Rpb24gPSB7XG4gIE1vdW50OiBudWxsLFxuICBpbmplY3RNb3VudDogZnVuY3Rpb24oSW5qZWN0ZWRNb3VudCkge1xuICAgIGluamVjdGlvbi5Nb3VudCA9IEluamVjdGVkTW91bnQ7XG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgSW5qZWN0ZWRNb3VudCAmJiBJbmplY3RlZE1vdW50LmdldE5vZGUsXG4gICAgICAgICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RNb3VudCguLi4pOiBJbmplY3RlZCBNb3VudCBtb2R1bGUgJyArXG4gICAgICAgICdpcyBtaXNzaW5nIGdldE5vZGUuJ1xuICAgICAgKSA6IGludmFyaWFudChJbmplY3RlZE1vdW50ICYmIEluamVjdGVkTW91bnQuZ2V0Tm9kZSkpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG5mdW5jdGlvbiBpc0VuZGlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwIHx8XG4gICAgICAgICB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQgfHxcbiAgICAgICAgIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaENhbmNlbDtcbn1cblxuZnVuY3Rpb24gaXNNb3ZlaXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlTW92ZSB8fFxuICAgICAgICAgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoTW92ZTtcbn1cbmZ1bmN0aW9uIGlzU3RhcnRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duIHx8XG4gICAgICAgICB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDtcbn1cblxuXG52YXIgdmFsaWRhdGVFdmVudERpc3BhdGNoZXM7XG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSURzID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGlkc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaElEcyk7XG4gICAgdmFyIElEc0xlbiA9IGlkc0lzQXJyID8gZGlzcGF0Y2hJRHMubGVuZ3RoIDogZGlzcGF0Y2hJRHMgPyAxIDogMDtcbiAgICB2YXIgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnIgP1xuICAgICAgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDpcbiAgICAgIGRpc3BhdGNoTGlzdGVuZXJzID8gMSA6IDA7XG5cbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgaWRzSXNBcnIgPT09IGxpc3RlbmVyc0lzQXJyICYmIElEc0xlbiA9PT0gbGlzdGVuZXJzTGVuLFxuICAgICAgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nXG4gICAgKSA6IGludmFyaWFudChpZHNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgSURzTGVuID09PSBsaXN0ZW5lcnNMZW4pKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjYihldmVudCwgbGlzdGVuZXIsIGlkKWAuIEF2b2lkcyB1c2luZyBjYWxsIGlmIG5vIHNjb3BlIGlzXG4gKiBwcm92aWRlZC4gVGhlIGAobGlzdGVuZXIsaWQpYCBwYWlyIGVmZmVjdGl2ZWx5IGZvcm1zIHRoZSBcImRpc3BhdGNoXCIgYnV0IGFyZVxuICoga2VwdCBzZXBhcmF0ZSB0byBjb25zZXJ2ZSBtZW1vcnkuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hFdmVudERpc3BhdGNoKGV2ZW50LCBjYikge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaElEcyA9IGV2ZW50Ll9kaXNwYXRjaElEcztcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSURzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgY2IoZXZlbnQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaElEc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgY2IoZXZlbnQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaElEcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIFBsdWdpbk1vZHVsZS5leGVjdXRlRGlzcGF0Y2goKS5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IFN5bnRoZXRpY0V2ZW50IHRvIGhhbmRsZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb21JRCBET00gaWQgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgbGlzdGVuZXIsIGRvbUlEKSB7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBpbmplY3Rpb24uTW91bnQuZ2V0Tm9kZShkb21JRCk7XG4gIHZhciByZXR1cm5WYWx1ZSA9IGxpc3RlbmVyKGV2ZW50LCBkb21JRCk7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgZXhlY3V0ZURpc3BhdGNoKSB7XG4gIGZvckVhY2hFdmVudERpc3BhdGNoKGV2ZW50LCBleGVjdXRlRGlzcGF0Y2gpO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJRHMgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLCBidXQgc3RvcHNcbiAqIGF0IHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gcmV0dXJuaW5nIHRydWUsIGFuZCByZXR1cm5zIHRoYXQgaWQuXG4gKlxuICogQHJldHVybiBpZCBvZiB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHdobydzIGxpc3RlbmVyIHJldHVybnMgdHJ1ZSwgb3JcbiAqIG51bGwgaWYgbm8gbGlzdGVuZXIgcmV0dXJuZWQgdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJRHMgPSBldmVudC5fZGlzcGF0Y2hJRHM7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIElEcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGlmIChkaXNwYXRjaExpc3RlbmVyc1tpXShldmVudCwgZGlzcGF0Y2hJRHNbaV0pKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaElEc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMoZXZlbnQsIGRpc3BhdGNoSURzKSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoSURzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUoZXZlbnQpIHtcbiAgdmFyIHJldCA9IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KTtcbiAgZXZlbnQuX2Rpc3BhdGNoSURzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXJlY3REaXNwYXRjaChldmVudCkge1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIHZhciBkaXNwYXRjaExpc3RlbmVyID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJRCA9IGV2ZW50Ll9kaXNwYXRjaElEcztcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAhQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVyKSxcbiAgICAnZXhlY3V0ZURpcmVjdERpc3BhdGNoKC4uLik6IEludmFsaWQgYGV2ZW50YC4nXG4gICkgOiBpbnZhcmlhbnQoIUFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcikpKTtcbiAgdmFyIHJlcyA9IGRpc3BhdGNoTGlzdGVuZXIgP1xuICAgIGRpc3BhdGNoTGlzdGVuZXIoZXZlbnQsIGRpc3BhdGNoSUQpIDpcbiAgICBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJRHMgPSBudWxsO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sfSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuZnVuY3Rpb24gaGFzRGlzcGF0Y2hlcyhldmVudCkge1xuICByZXR1cm4gISFldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG59XG5cbi8qKlxuICogR2VuZXJhbCB1dGlsaXRpZXMgdGhhdCBhcmUgdXNlZnVsIGluIGNyZWF0aW5nIGN1c3RvbSBFdmVudCBQbHVnaW5zLlxuICovXG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHtcbiAgaXNFbmRpc2g6IGlzRW5kaXNoLFxuICBpc01vdmVpc2g6IGlzTW92ZWlzaCxcbiAgaXNTdGFydGlzaDogaXNTdGFydGlzaCxcblxuICBleGVjdXRlRGlyZWN0RGlzcGF0Y2g6IGV4ZWN1dGVEaXJlY3REaXNwYXRjaCxcbiAgZXhlY3V0ZURpc3BhdGNoOiBleGVjdXRlRGlzcGF0Y2gsXG4gIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcjogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlOiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlLFxuICBoYXNEaXNwYXRjaGVzOiBoYXNEaXNwYXRjaGVzLFxuICBpbmplY3Rpb246IGluamVjdGlvbixcbiAgdXNlVG91Y2hFdmVudHM6IGZhbHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luVXRpbHM7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQcm9wYWdhdG9yc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luSHViXCIpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKFwiLi9hY2N1bXVsYXRlSW50b1wiKTtcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKFwiLi9mb3JFYWNoQWNjdW11bGF0ZWRcIik7XG5cbnZhciBQcm9wYWdhdGlvblBoYXNlcyA9IEV2ZW50Q29uc3RhbnRzLlByb3BhZ2F0aW9uUGhhc2VzO1xudmFyIGdldExpc3RlbmVyID0gRXZlbnRQbHVnaW5IdWIuZ2V0TGlzdGVuZXI7XG5cbi8qKlxuICogU29tZSBldmVudCB0eXBlcyBoYXZlIGEgbm90aW9uIG9mIGRpZmZlcmVudCByZWdpc3RyYXRpb24gbmFtZXMgZm9yIGRpZmZlcmVudFxuICogXCJwaGFzZXNcIiBvZiBwcm9wYWdhdGlvbi4gVGhpcyBmaW5kcyBsaXN0ZW5lcnMgYnkgYSBnaXZlbiBwaGFzZS5cbiAqL1xuZnVuY3Rpb24gbGlzdGVuZXJBdFBoYXNlKGlkLCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9XG4gICAgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcHJvcGFnYXRpb25QaGFzZV07XG4gIHJldHVybiBnZXRMaXN0ZW5lcihpZCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbi8qKlxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cbiAqIE11dGF0aW5nIHRoZSBldmVudCdzIG1lbWJlcnMgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBhIHdyYXBwaW5nXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGRvbUlELCB1cHdhcmRzLCBldmVudCkge1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgaWYgKCFkb21JRCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaXNwYXRjaGluZyBpZCBtdXN0IG5vdCBiZSBudWxsJyk7XG4gICAgfVxuICB9XG4gIHZhciBwaGFzZSA9IHVwd2FyZHMgPyBQcm9wYWdhdGlvblBoYXNlcy5idWJibGVkIDogUHJvcGFnYXRpb25QaGFzZXMuY2FwdHVyZWQ7XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShkb21JRCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID1cbiAgICAgIGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgIGV2ZW50Ll9kaXNwYXRjaElEcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaElEcywgZG9tSUQpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxuICogdGVzdHMpLiBMYXppbHkgYWxsb2NhdGUgdGhlIGFycmF5IHRvIGNvbnNlcnZlIG1lbW9yeS4gIFdlIG11c3QgbG9vcCB0aHJvdWdoXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW4gbm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uZ2V0SW5zdGFuY2VIYW5kbGUoKS50cmF2ZXJzZVR3b1BoYXNlKFxuICAgICAgZXZlbnQuZGlzcGF0Y2hNYXJrZXIsXG4gICAgICBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLFxuICAgICAgZXZlbnRcbiAgICApO1xuICB9XG59XG5cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyB3aXRob3V0IHJlZ2FyZCB0byBkaXJlY3Rpb24sIGRvZXMgbm90IGxvb2sgZm9yIHBoYXNlZFxuICogcmVnaXN0cmF0aW9uIG5hbWVzLiBTYW1lIGFzIGBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZWAgYnV0IHdpdGhvdXRcbiAqIHJlcXVpcmluZyB0aGF0IHRoZSBgZGlzcGF0Y2hNYXJrZXJgIGJlIHRoZSBzYW1lIGFzIHRoZSBkaXNwYXRjaGVkIElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpZCwgaWdub3JlZERpcmVjdGlvbiwgZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgdmFyIGxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID1cbiAgICAgICAgYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJRHMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJRHMsIGlkKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBkaXNwYXRjaGVzIG9uIGFuIGBTeW50aGV0aWNFdmVudGAsIGJ1dCBvbmx5IGZvciB0aGVcbiAqIGBkaXNwYXRjaE1hcmtlcmAuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGV2ZW50LmRpc3BhdGNoTWFya2VyLCBudWxsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb21JRCwgdG9JRCkge1xuICBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uZ2V0SW5zdGFuY2VIYW5kbGUoKS50cmF2ZXJzZUVudGVyTGVhdmUoXG4gICAgZnJvbUlELFxuICAgIHRvSUQsXG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMsXG4gICAgbGVhdmUsXG4gICAgZW50ZXJcbiAgKTtcbn1cblxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG5cblxuLyoqXG4gKiBBIHNtYWxsIHNldCBvZiBwcm9wYWdhdGlvbiBwYXR0ZXJucywgZWFjaCBvZiB3aGljaCB3aWxsIGFjY2VwdCBhIHNtYWxsIGFtb3VudFxuICogb2YgaW5mb3JtYXRpb24sIGFuZCBnZW5lcmF0ZSBhIHNldCBvZiBcImRpc3BhdGNoIHJlYWR5IGV2ZW50IG9iamVjdHNcIiAtIHdoaWNoXG4gKiBhcmUgc2V0cyBvZiBldmVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhbm5vdGF0ZWQgd2l0aCBhIHNldCBvZiBkaXNwYXRjaGVkXG4gKiBsaXN0ZW5lciBmdW5jdGlvbnMvaWRzLiBUaGUgQVBJIGlzIGRlc2lnbmVkIHRoaXMgd2F5IHRvIGRpc2NvdXJhZ2UgdGhlc2VcbiAqIHByb3BhZ2F0aW9uIHN0cmF0ZWdpZXMgZnJvbSBhY3R1YWxseSBleGVjdXRpbmcgdGhlIGRpc3BhdGNoZXMsIHNpbmNlIHdlXG4gKiBhbHdheXMgd2FudCB0byBjb2xsZWN0IHRoZSBlbnRpcmUgc2V0IG9mIGRpc3BhdGNoZXMgYmVmb3JlIGV4ZWN1dGluZyBldmVudCBhXG4gKiBzaW5nbGUgb25lLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBFdmVudFByb3BhZ2F0b3JzXG4gKi9cbnZhciBFdmVudFByb3BhZ2F0b3JzID0ge1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzOiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlczogYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlczogYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UHJvcGFnYXRvcnM7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFeGVjdXRpb25FbnZpcm9ubWVudFxuICovXG5cbi8qanNsaW50IGV2aWw6IHRydWUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjYW5Vc2VET00gPSAhIShcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgd2luZG93LmRvY3VtZW50ICYmXG4gIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50XG4pO1xuXG4vKipcbiAqIFNpbXBsZSwgbGlnaHR3ZWlnaHQgbW9kdWxlIGFzc2lzdGluZyB3aXRoIHRoZSBkZXRlY3Rpb24gYW5kIGNvbnRleHQgb2ZcbiAqIFdvcmtlci4gSGVscHMgYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCBhbGxvd3MgY29kZSB0byByZWFzb24gYWJvdXRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxuICogYFJlYWN0V29ya2VyYCBkZXBlbmRlbmN5LlxuICovXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cbiAgY2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cbiAgY2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6XG4gICAgY2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cbiAgY2FuVXNlVmlld3BvcnQ6IGNhblVzZURPTSAmJiAhIXdpbmRvdy5zY3JlZW4sXG5cbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBIVE1MRE9NUHJvcGVydHlDb25maWdcbiAqL1xuXG4vKmpzbGludCBiaXR3aXNlOiB0cnVlKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5XCIpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciBNVVNUX1VTRV9BVFRSSUJVVEUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uTVVTVF9VU0VfQVRUUklCVVRFO1xudmFyIE1VU1RfVVNFX1BST1BFUlRZID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZO1xudmFyIEhBU19CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFO1xudmFyIEhBU19TSURFX0VGRkVDVFMgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX1NJREVfRUZGRUNUUztcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9XG4gIERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID1cbiAgRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG5cbnZhciBoYXNTVkc7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHZhciBpbXBsZW1lbnRhdGlvbiA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uO1xuICBoYXNTVkcgPSAoXG4gICAgaW1wbGVtZW50YXRpb24gJiZcbiAgICBpbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gICAgaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcbiAgICAgICdodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0Jhc2ljU3RydWN0dXJlJyxcbiAgICAgICcxLjEnXG4gICAgKVxuICApO1xufVxuXG5cbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIGlzQ3VzdG9tQXR0cmlidXRlOiBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZChcbiAgICAvXihkYXRhfGFyaWEpLVthLXpfXVthLXpcXGRfLlxcLV0qJC9cbiAgKSxcbiAgUHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFN0YW5kYXJkIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBhY2NlcHQ6IG51bGwsXG4gICAgYWNjZXB0Q2hhcnNldDogbnVsbCxcbiAgICBhY2Nlc3NLZXk6IG51bGwsXG4gICAgYWN0aW9uOiBudWxsLFxuICAgIGFsbG93RnVsbFNjcmVlbjogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYWxsb3dUcmFuc3BhcmVuY3k6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBhbHQ6IG51bGwsXG4gICAgYXN5bmM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9Db21wbGV0ZTogbnVsbCxcbiAgICAvLyBhdXRvRm9jdXMgaXMgcG9seWZpbGxlZC9ub3JtYWxpemVkIGJ5IEF1dG9Gb2N1c01peGluXG4gICAgLy8gYXV0b0ZvY3VzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvUGxheTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2VsbFBhZGRpbmc6IG51bGwsXG4gICAgY2VsbFNwYWNpbmc6IG51bGwsXG4gICAgY2hhclNldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2xhc3NJRDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIC8vIFRvIHNldCBjbGFzc05hbWUgb24gU1ZHIGVsZW1lbnRzLCBpdCdzIG5lY2Vzc2FyeSB0byB1c2UgLnNldEF0dHJpYnV0ZTtcbiAgICAvLyB0aGlzIHdvcmtzIG9uIEhUTUwgZWxlbWVudHMgdG9vIGluIGFsbCBicm93c2VycyBleGNlcHQgSUU4LiBDb252ZW5pZW50bHksXG4gICAgLy8gSUU4IGRvZXNuJ3Qgc3VwcG9ydCBTVkcgYW5kIHNvIHdlIGNhbiBzaW1wbHkgdXNlIHRoZSBhdHRyaWJ1dGUgaW5cbiAgICAvLyBicm93c2VycyB0aGF0IHN1cHBvcnQgU1ZHIGFuZCB0aGUgcHJvcGVydHkgaW4gYnJvd3NlcnMgdGhhdCBkb24ndCxcbiAgICAvLyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgSFRNTCBvciBTVkcuXG4gICAgY2xhc3NOYW1lOiBoYXNTVkcgPyBNVVNUX1VTRV9BVFRSSUJVVEUgOiBNVVNUX1VTRV9QUk9QRVJUWSxcbiAgICBjb2xzOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBjb2xTcGFuOiBudWxsLFxuICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgY29udGVudEVkaXRhYmxlOiBudWxsLFxuICAgIGNvbnRleHRNZW51OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY29udHJvbHM6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY29vcmRzOiBudWxsLFxuICAgIGNyb3NzT3JpZ2luOiBudWxsLFxuICAgIGRhdGE6IG51bGwsIC8vIEZvciBgPG9iamVjdCAvPmAgYWN0cyBhcyBgc3JjYC5cbiAgICBkYXRlVGltZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGRlZmVyOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkaXI6IG51bGwsXG4gICAgZGlzYWJsZWQ6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRvd25sb2FkOiBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLFxuICAgIGRyYWdnYWJsZTogbnVsbCxcbiAgICBlbmNUeXBlOiBudWxsLFxuICAgIGZvcm06IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZnJhbWVCb3JkZXI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBoZWlnaHQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBoaWRkZW46IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGhyZWY6IG51bGwsXG4gICAgaHJlZkxhbmc6IG51bGwsXG4gICAgaHRtbEZvcjogbnVsbCxcbiAgICBodHRwRXF1aXY6IG51bGwsXG4gICAgaWNvbjogbnVsbCxcbiAgICBpZDogTVVTVF9VU0VfUFJPUEVSVFksXG4gICAgbGFiZWw6IG51bGwsXG4gICAgbGFuZzogbnVsbCxcbiAgICBsaXN0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbG9vcDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBtYW5pZmVzdDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1heDogbnVsbCxcbiAgICBtYXhMZW5ndGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtZWRpYTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1lZGlhR3JvdXA6IG51bGwsXG4gICAgbWV0aG9kOiBudWxsLFxuICAgIG1pbjogbnVsbCxcbiAgICBtdWx0aXBsZTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBtdXRlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBuYW1lOiBudWxsLFxuICAgIG5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wZW46IG51bGwsXG4gICAgcGF0dGVybjogbnVsbCxcbiAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICBwb3N0ZXI6IG51bGwsXG4gICAgcHJlbG9hZDogbnVsbCxcbiAgICByYWRpb0dyb3VwOiBudWxsLFxuICAgIHJlYWRPbmx5OiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlbDogbnVsbCxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcm9sZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJvd3M6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IG51bGwsXG4gICAgc2FuZGJveDogbnVsbCxcbiAgICBzY29wZTogbnVsbCxcbiAgICBzY3JvbGxpbmc6IG51bGwsXG4gICAgc2VhbWxlc3M6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNoYXBlOiBudWxsLFxuICAgIHNpemU6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNpemVzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3BhbjogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3BlbGxDaGVjazogbnVsbCxcbiAgICBzcmM6IG51bGwsXG4gICAgc3JjRG9jOiBNVVNUX1VTRV9QUk9QRVJUWSxcbiAgICBzcmNTZXQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdGFydDogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc3RlcDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICB0YWJJbmRleDogbnVsbCxcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgdGl0bGU6IG51bGwsXG4gICAgdHlwZTogbnVsbCxcbiAgICB1c2VNYXA6IG51bGwsXG4gICAgdmFsdWU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX1NJREVfRUZGRUNUUyxcbiAgICB3aWR0aDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHdtb2RlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG5cbiAgICAvKipcbiAgICAgKiBOb24tc3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGF1dG9DYXBpdGFsaXplOiBudWxsLCAvLyBTdXBwb3J0ZWQgaW4gTW9iaWxlIFNhZmFyaSBmb3Iga2V5Ym9hcmQgaGludHNcbiAgICBhdXRvQ29ycmVjdDogbnVsbCwgLy8gU3VwcG9ydGVkIGluIE1vYmlsZSBTYWZhcmkgZm9yIGtleWJvYXJkIGhpbnRzXG4gICAgaXRlbVByb3A6IE1VU1RfVVNFX0FUVFJJQlVURSwgLy8gTWljcm9kYXRhOiBodHRwOi8vc2NoZW1hLm9yZy9kb2NzL2dzLmh0bWxcbiAgICBpdGVtU2NvcGU6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLCAvLyBNaWNyb2RhdGE6IGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1UeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsIC8vIE1pY3JvZGF0YTogaHR0cDovL3NjaGVtYS5vcmcvZG9jcy9ncy5odG1sXG4gICAgcHJvcGVydHk6IG51bGwgLy8gU3VwcG9ydHMgT0cgaW4gbWV0YSB0YWdzXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NUHJvcGVydHlOYW1lczoge1xuICAgIGF1dG9DYXBpdGFsaXplOiAnYXV0b2NhcGl0YWxpemUnLFxuICAgIGF1dG9Db21wbGV0ZTogJ2F1dG9jb21wbGV0ZScsXG4gICAgYXV0b0NvcnJlY3Q6ICdhdXRvY29ycmVjdCcsXG4gICAgYXV0b0ZvY3VzOiAnYXV0b2ZvY3VzJyxcbiAgICBhdXRvUGxheTogJ2F1dG9wbGF5JyxcbiAgICBlbmNUeXBlOiAnZW5jdHlwZScsXG4gICAgaHJlZkxhbmc6ICdocmVmbGFuZycsXG4gICAgcmFkaW9Hcm91cDogJ3JhZGlvZ3JvdXAnLFxuICAgIHNwZWxsQ2hlY2s6ICdzcGVsbGNoZWNrJyxcbiAgICBzcmNEb2M6ICdzcmNkb2MnLFxuICAgIHNyY1NldDogJ3NyY3NldCdcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIVE1MRE9NUHJvcGVydHlDb25maWc7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIExpbmtlZFZhbHVlVXRpbHNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoXCIuL1JlYWN0UHJvcFR5cGVzXCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgJ2J1dHRvbic6IHRydWUsXG4gICdjaGVja2JveCc6IHRydWUsXG4gICdpbWFnZSc6IHRydWUsXG4gICdoaWRkZW4nOiB0cnVlLFxuICAncmFkaW8nOiB0cnVlLFxuICAncmVzZXQnOiB0cnVlLFxuICAnc3VibWl0JzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXQpIHtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBpbnB1dC5wcm9wcy5jaGVja2VkTGluayA9PSBudWxsIHx8IGlucHV0LnByb3BzLnZhbHVlTGluayA9PSBudWxsLFxuICAgICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIHZhbHVlTGluay4gSWYgeW91IHdhbnQgdG8gdXNlICcgK1xuICAgICdjaGVja2VkTGluaywgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rIGFuZCB2aWNlIHZlcnNhLidcbiAgKSA6IGludmFyaWFudChpbnB1dC5wcm9wcy5jaGVja2VkTGluayA9PSBudWxsIHx8IGlucHV0LnByb3BzLnZhbHVlTGluayA9PSBudWxsKSk7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0KSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0KTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBpbnB1dC5wcm9wcy52YWx1ZSA9PSBudWxsICYmIGlucHV0LnByb3BzLm9uQ2hhbmdlID09IG51bGwsXG4gICAgJ0Nhbm5vdCBwcm92aWRlIGEgdmFsdWVMaW5rIGFuZCBhIHZhbHVlIG9yIG9uQ2hhbmdlIGV2ZW50LiBJZiB5b3Ugd2FudCAnICtcbiAgICAndG8gdXNlIHZhbHVlIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsuJ1xuICApIDogaW52YXJpYW50KGlucHV0LnByb3BzLnZhbHVlID09IG51bGwgJiYgaW5wdXQucHJvcHMub25DaGFuZ2UgPT0gbnVsbCkpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXQpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXQpO1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIGlucHV0LnByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBpbnB1dC5wcm9wcy5vbkNoYW5nZSA9PSBudWxsLFxuICAgICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIGNoZWNrZWQgcHJvcGVydHkgb3Igb25DaGFuZ2UgZXZlbnQuICcgK1xuICAgICdJZiB5b3Ugd2FudCB0byB1c2UgY2hlY2tlZCBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byAnICtcbiAgICAndXNlIGNoZWNrZWRMaW5rJ1xuICApIDogaW52YXJpYW50KGlucHV0LnByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBpbnB1dC5wcm9wcy5vbkNoYW5nZSA9PSBudWxsKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZSBjaGFuZ2UgZXZlbnQgdG8gaGFuZGxlXG4gKi9cbmZ1bmN0aW9uIF9oYW5kbGVMaW5rZWRWYWx1ZUNoYW5nZShlKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHRoaXMucHJvcHMudmFsdWVMaW5rLnJlcXVlc3RDaGFuZ2UoZS50YXJnZXQudmFsdWUpO1xufVxuXG4vKipcbiAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBlIGNoYW5nZSBldmVudCB0byBoYW5kbGVcbiAgKi9cbmZ1bmN0aW9uIF9oYW5kbGVMaW5rZWRDaGVja0NoYW5nZShlKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHRoaXMucHJvcHMuY2hlY2tlZExpbmsucmVxdWVzdENoYW5nZShlLnRhcmdldC5jaGVja2VkKTtcbn1cblxuLyoqXG4gKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gKi9cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0ge1xuICBNaXhpbjoge1xuICAgIHByb3BUeXBlczoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fFxuICAgICAgICAgICAgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fFxuICAgICAgICAgICAgcHJvcHMub25DaGFuZ2UgfHxcbiAgICAgICAgICAgIHByb3BzLnJlYWRPbmx5IHx8XG4gICAgICAgICAgICBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAgICdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArXG4gICAgICAgICAgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArXG4gICAgICAgICAgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArXG4gICAgICAgICAgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLidcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBjaGVja2VkOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHxcbiAgICAgICAgICAgIHByb3BzLm9uQ2hhbmdlIHx8XG4gICAgICAgICAgICBwcm9wcy5yZWFkT25seSB8fFxuICAgICAgICAgICAgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgICAnWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArXG4gICAgICAgICAgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArXG4gICAgICAgICAgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICtcbiAgICAgICAgICAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJ1xuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIG9uQ2hhbmdlOiBSZWFjdFByb3BUeXBlcy5mdW5jXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnB1dCBGb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSB2YWx1ZSBwcm9wIG9yIGxpbmsuXG4gICAqL1xuICBnZXRWYWx1ZTogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQucHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0KTtcbiAgICAgIHJldHVybiBpbnB1dC5wcm9wcy52YWx1ZUxpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dC5wcm9wcy52YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW5wdXQgRm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCBjaGVja2VkIHN0YXR1cyBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gY2hlY2tlZCBwcm9wXG4gICAqICAgICAgICAgICAgIG9yIGxpbmsuXG4gICAqL1xuICBnZXRDaGVja2VkOiBmdW5jdGlvbihpbnB1dCkge1xuICAgIGlmIChpbnB1dC5wcm9wcy5jaGVja2VkTGluaykge1xuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0KTtcbiAgICAgIHJldHVybiBpbnB1dC5wcm9wcy5jaGVja2VkTGluay52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0LnByb3BzLmNoZWNrZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGlucHV0IEZvcm0gY29tcG9uZW50XG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBjaGFuZ2UgY2FsbGJhY2sgZWl0aGVyIGZyb20gb25DaGFuZ2UgcHJvcCBvciBsaW5rLlxuICAgKi9cbiAgZ2V0T25DaGFuZ2U6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaWYgKGlucHV0LnByb3BzLnZhbHVlTGluaykge1xuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dCk7XG4gICAgICByZXR1cm4gX2hhbmRsZUxpbmtlZFZhbHVlQ2hhbmdlO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQucHJvcHMuY2hlY2tlZExpbmspIHtcbiAgICAgIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dCk7XG4gICAgICByZXR1cm4gX2hhbmRsZUxpbmtlZENoZWNrQ2hhbmdlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQucHJvcHMub25DaGFuZ2U7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2VkVmFsdWVVdGlscztcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgTG9jYWxFdmVudFRyYXBNaXhpblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXCIpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKFwiLi9hY2N1bXVsYXRlSW50b1wiKTtcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKFwiLi9mb3JFYWNoQWNjdW11bGF0ZWRcIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG5mdW5jdGlvbiByZW1vdmUoZXZlbnQpIHtcbiAgZXZlbnQucmVtb3ZlKCk7XG59XG5cbnZhciBMb2NhbEV2ZW50VHJhcE1peGluID0ge1xuICB0cmFwQnViYmxlZEV2ZW50OmZ1bmN0aW9uKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudCh0aGlzLmlzTW91bnRlZCgpLCAnTXVzdCBiZSBtb3VudGVkIHRvIHRyYXAgZXZlbnRzJykgOiBpbnZhcmlhbnQodGhpcy5pc01vdW50ZWQoKSkpO1xuICAgIHZhciBsaXN0ZW5lciA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KFxuICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgaGFuZGxlckJhc2VOYW1lLFxuICAgICAgdGhpcy5nZXRET01Ob2RlKClcbiAgICApO1xuICAgIHRoaXMuX2xvY2FsRXZlbnRMaXN0ZW5lcnMgPVxuICAgICAgYWNjdW11bGF0ZUludG8odGhpcy5fbG9jYWxFdmVudExpc3RlbmVycywgbGlzdGVuZXIpO1xuICB9LFxuXG4gIC8vIHRyYXBDYXB0dXJlZEV2ZW50IHdvdWxkIGxvb2sgbmVhcmx5IGlkZW50aWNhbC4gV2UgZG9uJ3QgaW1wbGVtZW50IHRoYXRcbiAgLy8gbWV0aG9kIGJlY2F1c2UgaXQgaXNuJ3QgY3VycmVudGx5IG5lZWRlZC5cblxuICBjb21wb25lbnRXaWxsVW5tb3VudDpmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbG9jYWxFdmVudExpc3RlbmVycykge1xuICAgICAgZm9yRWFjaEFjY3VtdWxhdGVkKHRoaXMuX2xvY2FsRXZlbnRMaXN0ZW5lcnMsIHJlbW92ZSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsRXZlbnRUcmFwTWl4aW47XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBNb2JpbGVTYWZhcmlDbGlja0V2ZW50UGx1Z2luXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbi8qKlxuICogTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb24gbm9uLWludGVyYWN0aXZlXG4gKiBlbGVtZW50cywgd2hpY2ggbWVhbnMgZGVsZWdhdGVkIGNsaWNrIGxpc3RlbmVycyBkbyBub3QgZmlyZS4gVGhlIHdvcmthcm91bmRcbiAqIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2sgbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGFydGljdWxhciBwbHVnaW4gd29ya3MgYXJvdW5kIHRoZSBidWcgYnkgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gKiBsaXN0ZW5lciBvbiBgdG91Y2hzdGFydGAgKHdoaWNoIGRvZXMgZmlyZSBvbiBldmVyeSBlbGVtZW50KS5cbiAqL1xudmFyIE1vYmlsZVNhZmFyaUNsaWNrRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogbnVsbCxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbihcbiAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgIHRvcExldmVsVGFyZ2V0LFxuICAgICAgdG9wTGV2ZWxUYXJnZXRJRCxcbiAgICAgIG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaFN0YXJ0KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0O1xuICAgICAgaWYgKHRhcmdldCAmJiAhdGFyZ2V0Lm9uY2xpY2spIHtcbiAgICAgICAgdGFyZ2V0Lm9uY2xpY2sgPSBlbXB0eUZ1bmN0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vYmlsZVNhZmFyaUNsaWNrRXZlbnRQbHVnaW47XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIE9iamVjdC5hc3NpZ25cbiAqL1xuXG4vLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LmFzc2lnblxuXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2VzKSB7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gdGFyZ2V0IGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICB9XG5cbiAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgbmV4dEluZGV4ID0gMTsgbmV4dEluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgbmV4dEluZGV4KyspIHtcbiAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tuZXh0SW5kZXhdO1xuICAgIGlmIChuZXh0U291cmNlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBmcm9tID0gT2JqZWN0KG5leHRTb3VyY2UpO1xuXG4gICAgLy8gV2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQgYWNjZXNzb3JzIG5vciBwcm94aWVzLiBUaGVyZWZvcmUgdGhpc1xuICAgIC8vIGNvcHkgY2Fubm90IHRocm93LiBJZiB3ZSBldmVyIHN1cHBvcnRlZCB0aGlzIHRoZW4gd2UgbXVzdCBoYW5kbGVcbiAgICAvLyBleGNlcHRpb25zIGFuZCBzaWRlLWVmZmVjdHMuIFdlIGRvbid0IHN1cHBvcnQgc3ltYm9scyBzbyB0aGV5IHdvbid0XG4gICAgLy8gYmUgdHJhbnNmZXJyZWQuXG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuICAgICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0bztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBQb29sZWRDbGFzc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uKGNvcHlGaWVsZHNGcm9tKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGNvcHlGaWVsZHNGcm9tKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhjb3B5RmllbGRzRnJvbSk7XG4gIH1cbn07XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uKGExLCBhMikge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMik7XG4gIH1cbn07XG5cbnZhciB0aHJlZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24oYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZpdmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uKGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gIH1cbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBpbnN0YW5jZSBpbnN0YW5jZW9mIEtsYXNzLFxuICAgICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBpbnN0YW5jZSBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLidcbiAgKSA6IGludmFyaWFudChpbnN0YW5jZSBpbnN0YW5jZW9mIEtsYXNzKSk7XG4gIGlmIChpbnN0YW5jZS5kZXN0cnVjdG9yKSB7XG4gICAgaW5zdGFuY2UuZGVzdHJ1Y3RvcigpO1xuICB9XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoIDwgS2xhc3MucG9vbFNpemUpIHtcbiAgICBLbGFzcy5pbnN0YW5jZVBvb2wucHVzaChpbnN0YW5jZSk7XG4gIH1cbn07XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogQXVnbWVudHMgYENvcHlDb25zdHJ1Y3RvcmAgdG8gYmUgYSBwb29sYWJsZSBjbGFzcywgYXVnbWVudGluZyBvbmx5IHRoZSBjbGFzc1xuICogaXRzZWxmIChzdGF0aWNhbGx5KSBub3QgYWRkaW5nIGFueSBwcm90b3R5cGljYWwgZmllbGRzLiBBbnkgQ29weUNvbnN0cnVjdG9yXG4gKiB5b3UgZ2l2ZSB0aGlzIG1heSBoYXZlIGEgYHBvb2xTaXplYCBwcm9wZXJ0eSwgYW5kIHdpbGwgbG9vayBmb3IgYVxuICogcHJvdG90eXBpY2FsIGBkZXN0cnVjdG9yYCBvbiBpbnN0YW5jZXMgKG9wdGlvbmFsKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb3B5Q29uc3RydWN0b3IgQ29uc3RydWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvb2xlciBDdXN0b21pemFibGUgcG9vbGVyLlxuICovXG52YXIgYWRkUG9vbGluZ1RvID0gZnVuY3Rpb24oQ29weUNvbnN0cnVjdG9yLCBwb29sZXIpIHtcbiAgdmFyIE5ld0tsYXNzID0gQ29weUNvbnN0cnVjdG9yO1xuICBOZXdLbGFzcy5pbnN0YW5jZVBvb2wgPSBbXTtcbiAgTmV3S2xhc3MuZ2V0UG9vbGVkID0gcG9vbGVyIHx8IERFRkFVTFRfUE9PTEVSO1xuICBpZiAoIU5ld0tsYXNzLnBvb2xTaXplKSB7XG4gICAgTmV3S2xhc3MucG9vbFNpemUgPSBERUZBVUxUX1BPT0xfU0laRTtcbiAgfVxuICBOZXdLbGFzcy5yZWxlYXNlID0gc3RhbmRhcmRSZWxlYXNlcjtcbiAgcmV0dXJuIE5ld0tsYXNzO1xufTtcblxudmFyIFBvb2xlZENsYXNzID0ge1xuICBhZGRQb29saW5nVG86IGFkZFBvb2xpbmdUbyxcbiAgb25lQXJndW1lbnRQb29sZXI6IG9uZUFyZ3VtZW50UG9vbGVyLFxuICB0d29Bcmd1bWVudFBvb2xlcjogdHdvQXJndW1lbnRQb29sZXIsXG4gIHRocmVlQXJndW1lbnRQb29sZXI6IHRocmVlQXJndW1lbnRQb29sZXIsXG4gIGZpdmVBcmd1bWVudFBvb2xlcjogZml2ZUFyZ3VtZW50UG9vbGVyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnNcIik7XG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luVXRpbHNcIik7XG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoXCIuL1JlYWN0Q2hpbGRyZW5cIik7XG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudFwiKTtcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0Q29udGV4dCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29udGV4dFwiKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoXCIuL1JlYWN0Q3VycmVudE93bmVyXCIpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3JcIik7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKFwiLi9SZWFjdERPTVwiKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0RGVmYXVsdEluamVjdGlvbiA9IHJlcXVpcmUoXCIuL1JlYWN0RGVmYXVsdEluamVjdGlvblwiKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VIYW5kbGVzXCIpO1xudmFyIFJlYWN0TGVnYWN5RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0TGVnYWN5RWxlbWVudFwiKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcbnZhciBSZWFjdE11bHRpQ2hpbGQgPSByZXF1aXJlKFwiLi9SZWFjdE11bHRpQ2hpbGRcIik7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZShcIi4vUmVhY3RQZXJmXCIpO1xudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHlwZXNcIik7XG52YXIgUmVhY3RTZXJ2ZXJSZW5kZXJpbmcgPSByZXF1aXJlKFwiLi9SZWFjdFNlcnZlclJlbmRlcmluZ1wiKTtcbnZhciBSZWFjdFRleHRDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdFRleHRDb21wb25lbnRcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGRlcHJlY2F0ZWQgPSByZXF1aXJlKFwiLi9kZXByZWNhdGVkXCIpO1xudmFyIG9ubHlDaGlsZCA9IHJlcXVpcmUoXCIuL29ubHlDaGlsZFwiKTtcblxuUmVhY3REZWZhdWx0SW5qZWN0aW9uLmluamVjdCgpO1xuXG52YXIgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50O1xudmFyIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeTtcblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQ7XG4gIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeTtcbn1cblxuLy8gVE9ETzogRHJvcCBsZWdhY3kgZWxlbWVudHMgb25jZSBjbGFzc2VzIG5vIGxvbmdlciBleHBvcnQgdGhlc2UgZmFjdG9yaWVzXG5jcmVhdGVFbGVtZW50ID0gUmVhY3RMZWdhY3lFbGVtZW50LndyYXBDcmVhdGVFbGVtZW50KFxuICBjcmVhdGVFbGVtZW50XG4pO1xuY3JlYXRlRmFjdG9yeSA9IFJlYWN0TGVnYWN5RWxlbWVudC53cmFwQ3JlYXRlRmFjdG9yeShcbiAgY3JlYXRlRmFjdG9yeVxuKTtcblxudmFyIHJlbmRlciA9IFJlYWN0UGVyZi5tZWFzdXJlKCdSZWFjdCcsICdyZW5kZXInLCBSZWFjdE1vdW50LnJlbmRlcik7XG5cbnZhciBSZWFjdCA9IHtcbiAgQ2hpbGRyZW46IHtcbiAgICBtYXA6IFJlYWN0Q2hpbGRyZW4ubWFwLFxuICAgIGZvckVhY2g6IFJlYWN0Q2hpbGRyZW4uZm9yRWFjaCxcbiAgICBjb3VudDogUmVhY3RDaGlsZHJlbi5jb3VudCxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcbiAgRE9NOiBSZWFjdERPTSxcbiAgUHJvcFR5cGVzOiBSZWFjdFByb3BUeXBlcyxcbiAgaW5pdGlhbGl6ZVRvdWNoRXZlbnRzOiBmdW5jdGlvbihzaG91bGRVc2VUb3VjaCkge1xuICAgIEV2ZW50UGx1Z2luVXRpbHMudXNlVG91Y2hFdmVudHMgPSBzaG91bGRVc2VUb3VjaDtcbiAgfSxcbiAgY3JlYXRlQ2xhc3M6IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmNyZWF0ZUNsYXNzLFxuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LFxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5LFxuICBjb25zdHJ1Y3RBbmRSZW5kZXJDb21wb25lbnQ6IFJlYWN0TW91bnQuY29uc3RydWN0QW5kUmVuZGVyQ29tcG9uZW50LFxuICBjb25zdHJ1Y3RBbmRSZW5kZXJDb21wb25lbnRCeUlEOiBSZWFjdE1vdW50LmNvbnN0cnVjdEFuZFJlbmRlckNvbXBvbmVudEJ5SUQsXG4gIHJlbmRlcjogcmVuZGVyLFxuICByZW5kZXJUb1N0cmluZzogUmVhY3RTZXJ2ZXJSZW5kZXJpbmcucmVuZGVyVG9TdHJpbmcsXG4gIHJlbmRlclRvU3RhdGljTWFya3VwOiBSZWFjdFNlcnZlclJlbmRlcmluZy5yZW5kZXJUb1N0YXRpY01hcmt1cCxcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlLFxuICBpc1ZhbGlkQ2xhc3M6IFJlYWN0TGVnYWN5RWxlbWVudC5pc1ZhbGlkQ2xhc3MsXG4gIGlzVmFsaWRFbGVtZW50OiBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQsXG4gIHdpdGhDb250ZXh0OiBSZWFjdENvbnRleHQud2l0aENvbnRleHQsXG5cbiAgLy8gSG9vayBmb3IgSlNYIHNwcmVhZCwgZG9uJ3QgdXNlIHRoaXMgZm9yIGFueXRoaW5nIGVsc2UuXG4gIF9fc3ByZWFkOiBhc3NpZ24sXG5cbiAgLy8gRGVwcmVjYXRpb25zIChyZW1vdmUgZm9yIDAuMTMpXG4gIHJlbmRlckNvbXBvbmVudDogZGVwcmVjYXRlZChcbiAgICAnUmVhY3QnLFxuICAgICdyZW5kZXJDb21wb25lbnQnLFxuICAgICdyZW5kZXInLFxuICAgIHRoaXMsXG4gICAgcmVuZGVyXG4gICksXG4gIHJlbmRlckNvbXBvbmVudFRvU3RyaW5nOiBkZXByZWNhdGVkKFxuICAgICdSZWFjdCcsXG4gICAgJ3JlbmRlckNvbXBvbmVudFRvU3RyaW5nJyxcbiAgICAncmVuZGVyVG9TdHJpbmcnLFxuICAgIHRoaXMsXG4gICAgUmVhY3RTZXJ2ZXJSZW5kZXJpbmcucmVuZGVyVG9TdHJpbmdcbiAgKSxcbiAgcmVuZGVyQ29tcG9uZW50VG9TdGF0aWNNYXJrdXA6IGRlcHJlY2F0ZWQoXG4gICAgJ1JlYWN0JyxcbiAgICAncmVuZGVyQ29tcG9uZW50VG9TdGF0aWNNYXJrdXAnLFxuICAgICdyZW5kZXJUb1N0YXRpY01hcmt1cCcsXG4gICAgdGhpcyxcbiAgICBSZWFjdFNlcnZlclJlbmRlcmluZy5yZW5kZXJUb1N0YXRpY01hcmt1cFxuICApLFxuICBpc1ZhbGlkQ29tcG9uZW50OiBkZXByZWNhdGVkKFxuICAgICdSZWFjdCcsXG4gICAgJ2lzVmFsaWRDb21wb25lbnQnLFxuICAgICdpc1ZhbGlkRWxlbWVudCcsXG4gICAgdGhpcyxcbiAgICBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnRcbiAgKVxufTtcblxuLy8gSW5qZWN0IHRoZSBydW50aW1lIGludG8gYSBkZXZ0b29scyBnbG9iYWwgaG9vayByZWdhcmRsZXNzIG9mIGJyb3dzZXIuXG4vLyBBbGxvd3MgZm9yIGRlYnVnZ2luZyB3aGVuIHRoZSBob29rIGlzIGluamVjdGVkIG9uIHRoZSBwYWdlLlxuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0KHtcbiAgICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50LFxuICAgIEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXIsXG4gICAgRE9NQ29tcG9uZW50OiBSZWFjdERPTUNvbXBvbmVudCxcbiAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnM6IERPTVByb3BlcnR5T3BlcmF0aW9ucyxcbiAgICBJbnN0YW5jZUhhbmRsZXM6IFJlYWN0SW5zdGFuY2VIYW5kbGVzLFxuICAgIE1vdW50OiBSZWFjdE1vdW50LFxuICAgIE11bHRpQ2hpbGQ6IFJlYWN0TXVsdGlDaGlsZCxcbiAgICBUZXh0Q29tcG9uZW50OiBSZWFjdFRleHRDb21wb25lbnRcbiAgfSk7XG59XG5cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgdmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG4gIGlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcblxuICAgIC8vIElmIHdlJ3JlIGluIENocm9tZSwgbG9vayBmb3IgdGhlIGRldnRvb2xzIG1hcmtlciBhbmQgcHJvdmlkZSBhIGRvd25sb2FkXG4gICAgLy8gbGluayBpZiBub3QgaW5zdGFsbGVkLlxuICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTEpIHtcbiAgICAgIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICAgICdEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgK1xuICAgICAgICAgICdodHRwOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGV4cGVjdGVkRmVhdHVyZXMgPSBbXG4gICAgICAvLyBzaGltc1xuICAgICAgQXJyYXkuaXNBcnJheSxcbiAgICAgIEFycmF5LnByb3RvdHlwZS5ldmVyeSxcbiAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLFxuICAgICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YsXG4gICAgICBBcnJheS5wcm90b3R5cGUubWFwLFxuICAgICAgRGF0ZS5ub3csXG4gICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCxcbiAgICAgIE9iamVjdC5rZXlzLFxuICAgICAgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCxcbiAgICAgIFN0cmluZy5wcm90b3R5cGUudHJpbSxcblxuICAgICAgLy8gc2hhbXNcbiAgICAgIE9iamVjdC5jcmVhdGUsXG4gICAgICBPYmplY3QuZnJlZXplXG4gICAgXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRGZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFleHBlY3RlZEZlYXR1cmVzW2ldKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ09uZSBvciBtb3JlIEVTNSBzaGltL3NoYW1zIGV4cGVjdGVkIGJ5IFJlYWN0IGFyZSBub3QgYXZhaWxhYmxlOiAnICtcbiAgICAgICAgICAnaHR0cDovL2ZiLm1lL3JlYWN0LXdhcm5pbmctcG9seWZpbGxzJ1xuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gVmVyc2lvbiBleGlzdHMgb25seSBpbiB0aGUgb3Blbi1zb3VyY2UgdmVyc2lvbiBvZiBSZWFjdCwgbm90IGluIEZhY2Vib29rJ3Ncbi8vIGludGVybmFsIHZlcnNpb24uXG5SZWFjdC52ZXJzaW9uID0gJzAuMTIuMSc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVtcHR5Q29tcG9uZW50XCIpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBET00gbm9kZSByZW5kZXJlZCBieSB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gVGhlIHJvb3Qgbm9kZSBvZiB0aGlzIGNvbXBvbmVudC5cbiAgICogQGZpbmFsXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldERPTU5vZGU6IGZ1bmN0aW9uKCkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICB0aGlzLmlzTW91bnRlZCgpLFxuICAgICAgJ2dldERPTU5vZGUoKTogQSBjb21wb25lbnQgbXVzdCBiZSBtb3VudGVkIHRvIGhhdmUgYSBET00gbm9kZS4nXG4gICAgKSA6IGludmFyaWFudCh0aGlzLmlzTW91bnRlZCgpKSk7XG4gICAgaWYgKFJlYWN0RW1wdHlDb21wb25lbnQuaXNOdWxsQ29tcG9uZW50SUQodGhpcy5fcm9vdE5vZGVJRCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY3RNb3VudC5nZXROb2RlKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luSHViXCIpO1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpblJlZ2lzdHJ5XCIpO1xudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEV2ZW50RW1pdHRlck1peGluXCIpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoXCIuL1ZpZXdwb3J0TWV0cmljc1wiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoXCIuL2lzRXZlbnRTdXBwb3J0ZWRcIik7XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdEV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnQgcGx1Z2dhYmxlXG4gKiAgICBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW4gdGhyZWFkLlxuICpcbiAqICAtIFdlIG5vcm1hbGl6ZSBhbmQgZGUtZHVwbGljYXRlIGV2ZW50cyB0byBhY2NvdW50IGZvciBicm93c2VyIHF1aXJrcy4gVGhpc1xuICogICAgbWF5IGJlIGRvbmUgaW4gdGhlIHdvcmtlciB0aHJlYWQuXG4gKlxuICogIC0gRm9yd2FyZCB0aGVzZSBuYXRpdmUgZXZlbnRzICh3aXRoIHRoZSBhc3NvY2lhdGVkIHRvcC1sZXZlbCB0eXBlIHVzZWQgdG9cbiAqICAgIHRyYXAgaXQpIHRvIGBFdmVudFBsdWdpbkh1YmAsIHdoaWNoIGluIHR1cm4gd2lsbCBhc2sgcGx1Z2lucyBpZiB0aGV5IHdhbnRcbiAqICAgIHRvIGV4dHJhY3QgYW55IHN5bnRoZXRpYyBldmVudHMuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgd2lsbCB0aGVuIHByb2Nlc3MgZWFjaCBldmVudCBieSBhbm5vdGF0aW5nIHRoZW0gd2l0aFxuICogICAgXCJkaXNwYXRjaGVzXCIsIGEgc2VxdWVuY2Ugb2YgbGlzdGVuZXJzIGFuZCBJRHMgdGhhdCBjYXJlIGFib3V0IHRoYXQgZXZlbnQuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgdGhlbiBkaXNwYXRjaGVzIHRoZSBldmVudHMuXG4gKlxuICogT3ZlcnZpZXcgb2YgUmVhY3QgYW5kIHRoZSBldmVudCBzeXN0ZW06XG4gKlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCAgICBET00gICAgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogICAgICAgfCAgICAgICAgICAgLlxuICogICAgICAgdiAgICAgICAgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCBSZWFjdEV2ZW50IHwgICAgLlxuICogfCAgTGlzdGVuZXIgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgKy0tLS0tLS0tK3xTaW1wbGVFdmVudHxcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICB8ICAgICAgICAgfFBsdWdpbiAgICAgfFxuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgIHYgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnxFdmVudFBsdWdpbkh1YnwgICAgICAgICAgICAgICAgICAgIHwgICAgRXZlbnQgICB8XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgUHJvcGFnYXRvcnN8XG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgIHxUYXBFdmVudCAgIHwgIHwtLS0tLS0tLS0tLS18XG4gKiB8ICBFbWl0dGVyICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHw8LS0tK3xQbHVnaW4gICAgIHwgIHxvdGhlciBwbHVnaW58XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgIHV0aWxpdGllcyB8XG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLStcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgXiAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICB8ICAgICAgICB8RW50ZXIvTGVhdmV8XG4gKiAgICAgICArICAgICAgICAgICAuICAgICAgICAgICAgICAgICstLS0tLS0tK3xQbHVnaW4gICAgIHxcbiAqICstLS0tLS0tLS0tLS0tKyAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCBhcHBsaWNhdGlvbiB8ICAgLlxuICogfC0tLS0tLS0tLS0tLS18ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogKy0tLS0tLS0tLS0tLS0rICAgLlxuICogICAgICAgICAgICAgICAgICAgLlxuICogICAgUmVhY3QgQ29yZSAgICAgLiAgR2VuZXJhbCBQdXJwb3NlIEV2ZW50IFBsdWdpbiBTeXN0ZW1cbiAqL1xuXG52YXIgYWxyZWFkeUxpc3RlbmluZ1RvID0ge307XG52YXIgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSBmYWxzZTtcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vLyBGb3IgZXZlbnRzIGxpa2UgJ3N1Ym1pdCcgd2hpY2ggZG9uJ3QgY29uc2lzdGVudGx5IGJ1YmJsZSAod2hpY2ggd2UgdHJhcCBhdCBhXG4vLyBsb3dlciBub2RlIHRoYW4gYGRvY3VtZW50YCksIGJpbmRpbmcgYXQgYGRvY3VtZW50YCB3b3VsZCBjYXVzZSBkdXBsaWNhdGVcbi8vIGV2ZW50cyBzbyB3ZSBkb24ndCBpbmNsdWRlIHRoZW0gaGVyZVxudmFyIHRvcEV2ZW50TWFwcGluZyA9IHtcbiAgdG9wQmx1cjogJ2JsdXInLFxuICB0b3BDaGFuZ2U6ICdjaGFuZ2UnLFxuICB0b3BDbGljazogJ2NsaWNrJyxcbiAgdG9wQ29tcG9zaXRpb25FbmQ6ICdjb21wb3NpdGlvbmVuZCcsXG4gIHRvcENvbXBvc2l0aW9uU3RhcnQ6ICdjb21wb3NpdGlvbnN0YXJ0JyxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6ICdjb21wb3NpdGlvbnVwZGF0ZScsXG4gIHRvcENvbnRleHRNZW51OiAnY29udGV4dG1lbnUnLFxuICB0b3BDb3B5OiAnY29weScsXG4gIHRvcEN1dDogJ2N1dCcsXG4gIHRvcERvdWJsZUNsaWNrOiAnZGJsY2xpY2snLFxuICB0b3BEcmFnOiAnZHJhZycsXG4gIHRvcERyYWdFbmQ6ICdkcmFnZW5kJyxcbiAgdG9wRHJhZ0VudGVyOiAnZHJhZ2VudGVyJyxcbiAgdG9wRHJhZ0V4aXQ6ICdkcmFnZXhpdCcsXG4gIHRvcERyYWdMZWF2ZTogJ2RyYWdsZWF2ZScsXG4gIHRvcERyYWdPdmVyOiAnZHJhZ292ZXInLFxuICB0b3BEcmFnU3RhcnQ6ICdkcmFnc3RhcnQnLFxuICB0b3BEcm9wOiAnZHJvcCcsXG4gIHRvcEZvY3VzOiAnZm9jdXMnLFxuICB0b3BJbnB1dDogJ2lucHV0JyxcbiAgdG9wS2V5RG93bjogJ2tleWRvd24nLFxuICB0b3BLZXlQcmVzczogJ2tleXByZXNzJyxcbiAgdG9wS2V5VXA6ICdrZXl1cCcsXG4gIHRvcE1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIHRvcE1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gIHRvcE1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICB0b3BNb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICB0b3BNb3VzZVVwOiAnbW91c2V1cCcsXG4gIHRvcFBhc3RlOiAncGFzdGUnLFxuICB0b3BTY3JvbGw6ICdzY3JvbGwnLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6ICdzZWxlY3Rpb25jaGFuZ2UnLFxuICB0b3BUZXh0SW5wdXQ6ICd0ZXh0SW5wdXQnLFxuICB0b3BUb3VjaENhbmNlbDogJ3RvdWNoY2FuY2VsJyxcbiAgdG9wVG91Y2hFbmQ6ICd0b3VjaGVuZCcsXG4gIHRvcFRvdWNoTW92ZTogJ3RvdWNobW92ZScsXG4gIHRvcFRvdWNoU3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgdG9wV2hlZWw6ICd3aGVlbCdcbn07XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gXCJfcmVhY3RMaXN0ZW5lcnNJRFwiICsgU3RyaW5nKE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBpcyB1c2VkIHRvIGF0dGFjaCB0b3AtbGV2ZWwgZXZlbnQgbGlzdGVuZXJzLiBGb3JcbiAqIGV4YW1wbGU6XG4gKlxuICogICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIucHV0TGlzdGVuZXIoJ215SUQnLCAnb25DbGljaycsIG15RnVuY3Rpb24pO1xuICpcbiAqIFRoaXMgd291bGQgYWxsb2NhdGUgYSBcInJlZ2lzdHJhdGlvblwiIG9mIGAoJ29uQ2xpY2snLCBteUZ1bmN0aW9uKWAgb24gJ215SUQnLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gYXNzaWduKHt9LCBSZWFjdEV2ZW50RW1pdHRlck1peGluLCB7XG5cbiAgLyoqXG4gICAqIEluamVjdGFibGUgZXZlbnQgYmFja2VuZFxuICAgKi9cbiAgUmVhY3RFdmVudExpc3RlbmVyOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAgICAgKi9cbiAgICBpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKFJlYWN0RXZlbnRMaXN0ZW5lcikge1xuICAgICAgUmVhY3RFdmVudExpc3RlbmVyLnNldEhhbmRsZVRvcExldmVsKFxuICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaGFuZGxlVG9wTGV2ZWxcbiAgICAgICk7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyID0gUmVhY3RFdmVudExpc3RlbmVyO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCBhbnkgY3JlYXRlZCBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZCBUcnVlIGlmIGNhbGxiYWNrcyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICovXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICBpZiAoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lcikge1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5zZXRFbmFibGVkKGVuYWJsZWQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBjYWxsYmFja3MgYXJlIGVuYWJsZWQuXG4gICAqL1xuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIShcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIgJiZcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuaXNFbmFibGVkKClcbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gICAqXG4gICAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAgICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAgICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcbiAgICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAgICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcbiAgICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gICAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAgKlxuICAgKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gICAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gICAqL1xuICBsaXN0ZW5UbzogZnVuY3Rpb24ocmVnaXN0cmF0aW9uTmFtZSwgY29udGVudERvY3VtZW50SGFuZGxlKSB7XG4gICAgdmFyIG1vdW50QXQgPSBjb250ZW50RG9jdW1lbnRIYW5kbGU7XG4gICAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gICAgdmFyIGRlcGVuZGVuY2llcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkuXG4gICAgICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gICAgdmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgICBpZiAoIShcbiAgICAgICAgICAgIGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmXG4gICAgICAgICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XVxuICAgICAgICAgICkpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wV2hlZWwpIHtcbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnd2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KFxuICAgICAgICAgICAgICB0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLFxuICAgICAgICAgICAgICAnd2hlZWwnLFxuICAgICAgICAgICAgICBtb3VudEF0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnbW91c2V3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoXG4gICAgICAgICAgICAgIHRvcExldmVsVHlwZXMudG9wV2hlZWwsXG4gICAgICAgICAgICAgICdtb3VzZXdoZWVsJyxcbiAgICAgICAgICAgICAgbW91bnRBdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBuZWVkcyB0byBjYXB0dXJlIGEgZGlmZmVyZW50IG1vdXNlIHNjcm9sbCBldmVudC5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Rlc3RzL3Njcm9sbC5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoXG4gICAgICAgICAgICAgIHRvcExldmVsVHlwZXMudG9wV2hlZWwsXG4gICAgICAgICAgICAgICdET01Nb3VzZVNjcm9sbCcsXG4gICAgICAgICAgICAgIG1vdW50QXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wU2Nyb2xsKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQoXG4gICAgICAgICAgICAgIHRvcExldmVsVHlwZXMudG9wU2Nyb2xsLFxuICAgICAgICAgICAgICAnc2Nyb2xsJyxcbiAgICAgICAgICAgICAgbW91bnRBdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KFxuICAgICAgICAgICAgICB0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCxcbiAgICAgICAgICAgICAgJ3Njcm9sbCcsXG4gICAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuV0lORE9XX0hBTkRMRVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BGb2N1cyB8fFxuICAgICAgICAgICAgZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnZm9jdXMnLCB0cnVlKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudChcbiAgICAgICAgICAgICAgdG9wTGV2ZWxUeXBlcy50b3BGb2N1cyxcbiAgICAgICAgICAgICAgJ2ZvY3VzJyxcbiAgICAgICAgICAgICAgbW91bnRBdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQoXG4gICAgICAgICAgICAgIHRvcExldmVsVHlwZXMudG9wQmx1cixcbiAgICAgICAgICAgICAgJ2JsdXInLFxuICAgICAgICAgICAgICBtb3VudEF0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnZm9jdXNpbicpKSB7XG4gICAgICAgICAgICAvLyBJRSBoYXMgYGZvY3VzaW5gIGFuZCBgZm9jdXNvdXRgIGV2ZW50cyB3aGljaCBidWJibGUuXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDA4LzA0L2RlbGVnYXRpbmdfdGhlLmh0bWxcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudChcbiAgICAgICAgICAgICAgdG9wTGV2ZWxUeXBlcy50b3BGb2N1cyxcbiAgICAgICAgICAgICAgJ2ZvY3VzaW4nLFxuICAgICAgICAgICAgICBtb3VudEF0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KFxuICAgICAgICAgICAgICB0b3BMZXZlbFR5cGVzLnRvcEJsdXIsXG4gICAgICAgICAgICAgICdmb2N1c291dCcsXG4gICAgICAgICAgICAgIG1vdW50QXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGJsdXIgYW5kIGZvY3VzIGV2ZW50IGxpc3RlbmVycyBhcmUgb25seSBhdHRhY2hlZCBvbmNlXG4gICAgICAgICAgaXNMaXN0ZW5pbmdbdG9wTGV2ZWxUeXBlcy50b3BCbHVyXSA9IHRydWU7XG4gICAgICAgICAgaXNMaXN0ZW5pbmdbdG9wTGV2ZWxUeXBlcy50b3BGb2N1c10gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRvcEV2ZW50TWFwcGluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSkge1xuICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudChcbiAgICAgICAgICAgIGRlcGVuZGVuY3ksXG4gICAgICAgICAgICB0b3BFdmVudE1hcHBpbmdbZGVwZW5kZW5jeV0sXG4gICAgICAgICAgICBtb3VudEF0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24odG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoXG4gICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICBoYW5kbGVyQmFzZU5hbWUsXG4gICAgICBoYW5kbGVcbiAgICApO1xuICB9LFxuXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbih0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQoXG4gICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICBoYW5kbGVyQmFzZU5hbWUsXG4gICAgICBoYW5kbGVcbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIHdpbmRvdyBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMuIFdlIGNhY2hlIHNjcm9sbCB2YWx1ZXMgc28gdGhhdFxuICAgKiBhcHBsaWNhdGlvbiBjb2RlIGNhbiBhY2Nlc3MgdGhlbSB3aXRob3V0IHRyaWdnZXJpbmcgcmVmbG93cy5cbiAgICpcbiAgICogTk9URTogU2Nyb2xsIGV2ZW50cyBkbyBub3QgYnViYmxlLlxuICAgKlxuICAgKiBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvZG9tL2V2ZW50cy9zY3JvbGwuaHRtbFxuICAgKi9cbiAgZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nOiBmdW5jdGlvbigpe1xuICAgIGlmICghaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUpIHtcbiAgICAgIHZhciByZWZyZXNoID0gVmlld3BvcnRNZXRyaWNzLnJlZnJlc2hTY3JvbGxWYWx1ZXM7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLm1vbml0b3JTY3JvbGxWYWx1ZShyZWZyZXNoKTtcbiAgICAgIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiBFdmVudFBsdWdpbkh1Yi5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MsXG5cbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IEV2ZW50UGx1Z2luSHViLnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLFxuXG4gIHB1dExpc3RlbmVyOiBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcixcblxuICBnZXRMaXN0ZW5lcjogRXZlbnRQbHVnaW5IdWIuZ2V0TGlzdGVuZXIsXG5cbiAgZGVsZXRlTGlzdGVuZXI6IEV2ZW50UGx1Z2luSHViLmRlbGV0ZUxpc3RlbmVyLFxuXG4gIGRlbGV0ZUFsbExpc3RlbmVyczogRXZlbnRQbHVnaW5IdWIuZGVsZXRlQWxsTGlzdGVuZXJzXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcjtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDaGlsZHJlblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKFwiLi9Qb29sZWRDbGFzc1wiKTtcblxudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKFwiLi90cmF2ZXJzZUFsbENoaWxkcmVuXCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcjtcbnZhciB0aHJlZUFyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MudGhyZWVBcmd1bWVudFBvb2xlcjtcblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIHRyYXZlcnNhbC4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBGb3JFYWNoQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBmb3JFYWNoRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSB0cmF2ZXJzYWwgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBjb250ZXh0IHdpdGguXG4gKi9cbmZ1bmN0aW9uIEZvckVhY2hCb29rS2VlcGluZyhmb3JFYWNoRnVuY3Rpb24sIGZvckVhY2hDb250ZXh0KSB7XG4gIHRoaXMuZm9yRWFjaEZ1bmN0aW9uID0gZm9yRWFjaEZ1bmN0aW9uO1xuICB0aGlzLmZvckVhY2hDb250ZXh0ID0gZm9yRWFjaENvbnRleHQ7XG59XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRm9yRWFjaEJvb2tLZWVwaW5nLCB0d29Bcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lLCBpKSB7XG4gIHZhciBmb3JFYWNoQm9va0tlZXBpbmcgPSB0cmF2ZXJzZUNvbnRleHQ7XG4gIGZvckVhY2hCb29rS2VlcGluZy5mb3JFYWNoRnVuY3Rpb24uY2FsbChcbiAgICBmb3JFYWNoQm9va0tlZXBpbmcuZm9yRWFjaENvbnRleHQsIGNoaWxkLCBpKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmMuXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPVxuICAgIEZvckVhY2hCb29rS2VlcGluZy5nZXRQb29sZWQoZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkLCB0cmF2ZXJzZUNvbnRleHQpO1xuICBGb3JFYWNoQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogbWFwcGluZy4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBNYXBCb29rS2VlcGluZ1xuICogQHBhcmFtIHshKn0gbWFwUmVzdWx0IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICogQHBhcmFtIHshZnVuY3Rpb259IG1hcEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICogQHBhcmFtIHs/Kn0gbWFwQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICovXG5mdW5jdGlvbiBNYXBCb29rS2VlcGluZyhtYXBSZXN1bHQsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIHRoaXMubWFwUmVzdWx0ID0gbWFwUmVzdWx0O1xuICB0aGlzLm1hcEZ1bmN0aW9uID0gbWFwRnVuY3Rpb247XG4gIHRoaXMubWFwQ29udGV4dCA9IG1hcENvbnRleHQ7XG59XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oTWFwQm9va0tlZXBpbmcsIHRocmVlQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUsIGkpIHtcbiAgdmFyIG1hcEJvb2tLZWVwaW5nID0gdHJhdmVyc2VDb250ZXh0O1xuICB2YXIgbWFwUmVzdWx0ID0gbWFwQm9va0tlZXBpbmcubWFwUmVzdWx0O1xuXG4gIHZhciBrZXlVbmlxdWUgPSAhbWFwUmVzdWx0Lmhhc093blByb3BlcnR5KG5hbWUpO1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhcbiAgICBrZXlVbmlxdWUsXG4gICAgJ1JlYWN0Q2hpbGRyZW4ubWFwKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArXG4gICAgJ2Alc2AuIENoaWxkIGtleXMgbXVzdCBiZSB1bmlxdWU7IHdoZW4gdHdvIGNoaWxkcmVuIHNoYXJlIGEga2V5LCBvbmx5ICcgK1xuICAgICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLicsXG4gICAgbmFtZVxuICApIDogbnVsbCk7XG5cbiAgaWYgKGtleVVuaXF1ZSkge1xuICAgIHZhciBtYXBwZWRDaGlsZCA9XG4gICAgICBtYXBCb29rS2VlcGluZy5tYXBGdW5jdGlvbi5jYWxsKG1hcEJvb2tLZWVwaW5nLm1hcENvbnRleHQsIGNoaWxkLCBpKTtcbiAgICBtYXBSZXN1bHRbbmFtZV0gPSBtYXBwZWRDaGlsZDtcbiAgfVxufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogVE9ETzogVGhpcyBtYXkgbGlrZWx5IGJyZWFrIGFueSBjYWxscyB0byBgUmVhY3RDaGlsZHJlbi5tYXBgIHRoYXQgd2VyZVxuICogcHJldmlvdXNseSByZWx5aW5nIG9uIHRoZSBmYWN0IHRoYXQgd2UgZ3VhcmRlZCBhZ2FpbnN0IG51bGwgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IG1hcEZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBtYXBDb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICB2YXIgbWFwUmVzdWx0ID0ge307XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBNYXBCb29rS2VlcGluZy5nZXRQb29sZWQobWFwUmVzdWx0LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgTWFwQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xuICByZXR1cm4gbWFwUmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lLCBpKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXksIG51bGwpO1xufVxuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHtcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBtYXA6IG1hcENoaWxkcmVuLFxuICBjb3VudDogY291bnRDaGlsZHJlblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkcmVuO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG52YXIgUmVhY3RPd25lciA9IHJlcXVpcmUoXCIuL1JlYWN0T3duZXJcIik7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZShcIi4vUmVhY3RVcGRhdGVzXCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIga2V5TWlycm9yID0gcmVxdWlyZShcIi4va2V5TWlycm9yXCIpO1xuXG4vKipcbiAqIEV2ZXJ5IFJlYWN0IGNvbXBvbmVudCBpcyBpbiBvbmUgb2YgdGhlc2UgbGlmZSBjeWNsZXMuXG4gKi9cbnZhciBDb21wb25lbnRMaWZlQ3ljbGUgPSBrZXlNaXJyb3Ioe1xuICAvKipcbiAgICogTW91bnRlZCBjb21wb25lbnRzIGhhdmUgYSBET00gbm9kZSByZXByZXNlbnRhdGlvbiBhbmQgYXJlIGNhcGFibGUgb2ZcbiAgICogcmVjZWl2aW5nIG5ldyBwcm9wcy5cbiAgICovXG4gIE1PVU5URUQ6IG51bGwsXG4gIC8qKlxuICAgKiBVbm1vdW50ZWQgY29tcG9uZW50cyBhcmUgaW5hY3RpdmUgYW5kIGNhbm5vdCByZWNlaXZlIG5ldyBwcm9wcy5cbiAgICovXG4gIFVOTU9VTlRFRDogbnVsbFxufSk7XG5cbnZhciBpbmplY3RlZCA9IGZhbHNlO1xuXG4vKipcbiAqIE9wdGlvbmFsbHkgaW5qZWN0YWJsZSBlbnZpcm9ubWVudCBkZXBlbmRlbnQgY2xlYW51cCBob29rLiAoc2VydmVyIHZzLlxuICogYnJvd3NlciBldGMpLiBFeGFtcGxlOiBBIGJyb3dzZXIgc3lzdGVtIGNhY2hlcyBET00gbm9kZXMgYmFzZWQgb24gY29tcG9uZW50XG4gKiBJRCBhbmQgbXVzdCByZW1vdmUgdGhhdCBjYWNoZSBlbnRyeSB3aGVuIHRoaXMgaW5zdGFuY2UgaXMgdW5tb3VudGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1bm1vdW50SURGcm9tRW52aXJvbm1lbnQgPSBudWxsO1xuXG4vKipcbiAqIFRoZSBcImltYWdlXCIgb2YgYSBjb21wb25lbnQgdHJlZSwgaXMgdGhlIHBsYXRmb3JtIHNwZWNpZmljICh0eXBpY2FsbHlcbiAqIHNlcmlhbGl6ZWQpIGRhdGEgdGhhdCByZXByZXNlbnRzIGEgdHJlZSBvZiBsb3dlciBsZXZlbCBVSSBidWlsZGluZyBibG9ja3MuXG4gKiBPbiB0aGUgd2ViLCB0aGlzIFwiaW1hZ2VcIiBpcyBIVE1MIG1hcmt1cCB3aGljaCBkZXNjcmliZXMgYSBjb25zdHJ1Y3Rpb24gb2ZcbiAqIGxvdyBsZXZlbCBgZGl2YCBhbmQgYHNwYW5gIG5vZGVzLiBPdGhlciBwbGF0Zm9ybXMgbWF5IGhhdmUgZGlmZmVyZW50XG4gKiBlbmNvZGluZyBvZiB0aGlzIFwiaW1hZ2VcIi4gVGhpcyBtdXN0IGJlIGluamVjdGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBtb3VudEltYWdlSW50b05vZGUgPSBudWxsO1xuXG4vKipcbiAqIENvbXBvbmVudHMgYXJlIHRoZSBiYXNpYyB1bml0cyBvZiBjb21wb3NpdGlvbiBpbiBSZWFjdC5cbiAqXG4gKiBFdmVyeSBjb21wb25lbnQgYWNjZXB0cyBhIHNldCBvZiBrZXllZCBpbnB1dCBwYXJhbWV0ZXJzIGtub3duIGFzIFwicHJvcHNcIiB0aGF0XG4gKiBhcmUgaW5pdGlhbGl6ZWQgYnkgdGhlIGNvbnN0cnVjdG9yLiBPbmNlIGEgY29tcG9uZW50IGlzIG1vdW50ZWQsIHRoZSBwcm9wc1xuICogY2FuIGJlIG11dGF0ZWQgdXNpbmcgYHNldFByb3BzYCBvciBgcmVwbGFjZVByb3BzYC5cbiAqXG4gKiBFdmVyeSBjb21wb25lbnQgaXMgY2FwYWJsZSBvZiB0aGUgZm9sbG93aW5nIG9wZXJhdGlvbnM6XG4gKlxuICogICBgbW91bnRDb21wb25lbnRgXG4gKiAgICAgSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICpcbiAqICAgYHJlY2VpdmVDb21wb25lbnRgXG4gKiAgICAgVXBkYXRlcyB0aGUgcmVuZGVyZWQgRE9NIG5vZGVzIHRvIG1hdGNoIHRoZSBnaXZlbiBjb21wb25lbnQuXG4gKlxuICogICBgdW5tb3VudENvbXBvbmVudGBcbiAqICAgICBSZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSB0aGlzIGNvbXBvbmVudC5cbiAqXG4gKiBDb21wb25lbnRzIGNhbiBhbHNvIGJlIFwib3duZWRcIiBieSBvdGhlciBjb21wb25lbnRzLiBCZWluZyBvd25lZCBieSBhbm90aGVyXG4gKiBjb21wb25lbnQgbWVhbnMgYmVpbmcgY29uc3RydWN0ZWQgYnkgdGhhdCBjb21wb25lbnQuIFRoaXMgaXMgZGlmZmVyZW50IGZyb21cbiAqIGJlaW5nIHRoZSBjaGlsZCBvZiBhIGNvbXBvbmVudCwgd2hpY2ggbWVhbnMgaGF2aW5nIGEgRE9NIHJlcHJlc2VudGF0aW9uIHRoYXRcbiAqIGlzIGEgY2hpbGQgb2YgdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiB0aGF0IGNvbXBvbmVudC5cbiAqXG4gKiBAY2xhc3MgUmVhY3RDb21wb25lbnRcbiAqL1xudmFyIFJlYWN0Q29tcG9uZW50ID0ge1xuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdEVudmlyb25tZW50OiBmdW5jdGlvbihSZWFjdENvbXBvbmVudEVudmlyb25tZW50KSB7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICAhaW5qZWN0ZWQsXG4gICAgICAgICdSZWFjdENvbXBvbmVudDogaW5qZWN0RW52aXJvbm1lbnQoKSBjYW4gb25seSBiZSBjYWxsZWQgb25jZS4nXG4gICAgICApIDogaW52YXJpYW50KCFpbmplY3RlZCkpO1xuICAgICAgbW91bnRJbWFnZUludG9Ob2RlID0gUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5tb3VudEltYWdlSW50b05vZGU7XG4gICAgICB1bm1vdW50SURGcm9tRW52aXJvbm1lbnQgPVxuICAgICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudDtcbiAgICAgIFJlYWN0Q29tcG9uZW50LkJhY2tlbmRJRE9wZXJhdGlvbnMgPVxuICAgICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LkJhY2tlbmRJRE9wZXJhdGlvbnM7XG4gICAgICBpbmplY3RlZCA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIExpZmVDeWNsZTogQ29tcG9uZW50TGlmZUN5Y2xlLFxuXG4gIC8qKlxuICAgKiBJbmplY3RlZCBtb2R1bGUgdGhhdCBwcm92aWRlcyBhYmlsaXR5IHRvIG11dGF0ZSBpbmRpdmlkdWFsIHByb3BlcnRpZXMuXG4gICAqIEluamVjdGVkIGludG8gdGhlIGJhc2UgY2xhc3MgYmVjYXVzZSBtYW55IGRpZmZlcmVudCBzdWJjbGFzc2VzIG5lZWQgYWNjZXNzXG4gICAqIHRvIHRoaXMuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgQmFja2VuZElET3BlcmF0aW9uczogbnVsbCxcblxuICAvKipcbiAgICogQmFzZSBmdW5jdGlvbmFsaXR5IGZvciBldmVyeSBSZWFjdENvbXBvbmVudCBjb25zdHJ1Y3Rvci4gTWl4ZWQgaW50byB0aGVcbiAgICogYFJlYWN0Q29tcG9uZW50YCBwcm90b3R5cGUsIGJ1dCBleHBvc2VkIHN0YXRpY2FsbHkgZm9yIGVhc3kgYWNjZXNzLlxuICAgKlxuICAgKiBAbGVuZHMge1JlYWN0Q29tcG9uZW50LnByb3RvdHlwZX1cbiAgICovXG4gIE1peGluOiB7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBmaW5hbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xpZmVDeWNsZVN0YXRlID09PSBDb21wb25lbnRMaWZlQ3ljbGUuTU9VTlRFRDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgcHJvcHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFByb3BzIFN1YnNldCBvZiB0aGUgbmV4dCBwcm9wcy5cbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHByb3BzIGFyZSB1cGRhdGVkLlxuICAgICAqIEBmaW5hbFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzZXRQcm9wczogZnVuY3Rpb24ocGFydGlhbFByb3BzLCBjYWxsYmFjaykge1xuICAgICAgLy8gTWVyZ2Ugd2l0aCB0aGUgcGVuZGluZyBlbGVtZW50IGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHdpdGggZXhpc3RpbmdcbiAgICAgIC8vIGVsZW1lbnQgcHJvcHMuXG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX3BlbmRpbmdFbGVtZW50IHx8IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgdGhpcy5yZXBsYWNlUHJvcHMoXG4gICAgICAgIGFzc2lnbih7fSwgZWxlbWVudC5wcm9wcywgcGFydGlhbFByb3BzKSxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgcHJvcHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgTmV3IHByb3BzLlxuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgcHJvcHMgYXJlIHVwZGF0ZWQuXG4gICAgICogQGZpbmFsXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHJlcGxhY2VQcm9wczogZnVuY3Rpb24ocHJvcHMsIGNhbGxiYWNrKSB7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICB0aGlzLmlzTW91bnRlZCgpLFxuICAgICAgICAncmVwbGFjZVByb3BzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgY29tcG9uZW50LidcbiAgICAgICkgOiBpbnZhcmlhbnQodGhpcy5pc01vdW50ZWQoKSkpO1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgdGhpcy5fbW91bnREZXB0aCA9PT0gMCxcbiAgICAgICAgJ3JlcGxhY2VQcm9wcyguLi4pOiBZb3UgY2FsbGVkIGBzZXRQcm9wc2Agb3IgYHJlcGxhY2VQcm9wc2Agb24gYSAnICtcbiAgICAgICAgJ2NvbXBvbmVudCB3aXRoIGEgcGFyZW50LiBUaGlzIGlzIGFuIGFudGktcGF0dGVybiBzaW5jZSBwcm9wcyB3aWxsICcgK1xuICAgICAgICAnZ2V0IHJlYWN0aXZlbHkgdXBkYXRlZCB3aGVuIHJlbmRlcmVkLiBJbnN0ZWFkLCBjaGFuZ2UgdGhlIG93bmVyXFwncyAnICtcbiAgICAgICAgJ2ByZW5kZXJgIG1ldGhvZCB0byBwYXNzIHRoZSBjb3JyZWN0IHZhbHVlIGFzIHByb3BzIHRvIHRoZSBjb21wb25lbnQgJyArXG4gICAgICAgICd3aGVyZSBpdCBpcyBjcmVhdGVkLidcbiAgICAgICkgOiBpbnZhcmlhbnQodGhpcy5fbW91bnREZXB0aCA9PT0gMCkpO1xuICAgICAgLy8gVGhpcyBpcyBhIGRlb3B0aW1pemVkIHBhdGguIFdlIG9wdGltaXplIGZvciBhbHdheXMgaGF2aW5nIGEgZWxlbWVudC5cbiAgICAgIC8vIFRoaXMgY3JlYXRlcyBhbiBleHRyYSBpbnRlcm5hbCBlbGVtZW50LlxuICAgICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlUHJvcHMoXG4gICAgICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50IHx8IHRoaXMuX2N1cnJlbnRFbGVtZW50LFxuICAgICAgICBwcm9wc1xuICAgICAgKTtcbiAgICAgIFJlYWN0VXBkYXRlcy5lbnF1ZXVlVXBkYXRlKHRoaXMsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGUgYSBwYXJ0aWFsIHVwZGF0ZSB0byB0aGUgcHJvcHMuIE9ubHkgdXNlZCBmb3IgaW50ZXJuYWwgdGVzdGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsUHJvcHMgU3Vic2V0IG9mIHRoZSBuZXh0IHByb3BzLlxuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgcHJvcHMgYXJlIHVwZGF0ZWQuXG4gICAgICogQGZpbmFsXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3NldFByb3BzSW50ZXJuYWw6IGZ1bmN0aW9uKHBhcnRpYWxQcm9wcywgY2FsbGJhY2spIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBkZW9wdGltaXplZCBwYXRoLiBXZSBvcHRpbWl6ZSBmb3IgYWx3YXlzIGhhdmluZyBhIGVsZW1lbnQuXG4gICAgICAvLyBUaGlzIGNyZWF0ZXMgYW4gZXh0cmEgaW50ZXJuYWwgZWxlbWVudC5cbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5fcGVuZGluZ0VsZW1lbnQgfHwgdGhpcy5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcyhcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgYXNzaWduKHt9LCBlbGVtZW50LnByb3BzLCBwYXJ0aWFsUHJvcHMpXG4gICAgICApO1xuICAgICAgUmVhY3RVcGRhdGVzLmVucXVldWVVcGRhdGUodGhpcywgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgUmVhY3QgY29tcG9uZW50cy5cbiAgICAgKlxuICAgICAqIFN1YmNsYXNzZXMgdGhhdCBvdmVycmlkZSB0aGlzIG1ldGhvZCBzaG91bGQgbWFrZSBzdXJlIHRvIGludm9rZVxuICAgICAqIGBSZWFjdENvbXBvbmVudC5NaXhpbi5jb25zdHJ1Y3QuY2FsbCh0aGlzLCAuLi4pYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBwdWJsaWMgZXhwb3NlZCBwcm9wcyBvYmplY3QgYWZ0ZXIgaXQgaGFzIGJlZW4gcHJvY2Vzc2VkXG4gICAgICAvLyB3aXRoIGRlZmF1bHQgcHJvcHMuIFRoZSBlbGVtZW50J3MgcHJvcHMgcmVwcmVzZW50cyB0aGUgdHJ1ZSBpbnRlcm5hbFxuICAgICAgLy8gc3RhdGUgb2YgdGhlIHByb3BzLlxuICAgICAgdGhpcy5wcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gICAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBjb21wb25lbnQuXG4gICAgICAvLyBUaGlzIGlzIGFjY2Vzc2libGUgdGhyb3VnaCB0aGUgZWxlbWVudCBidXQgd2UgbWFpbnRhaW4gYW4gZXh0cmFcbiAgICAgIC8vIGZpZWxkIGZvciBjb21wYXRpYmlsaXR5IHdpdGggZGV2dG9vbHMgYW5kIGFzIGEgd2F5IHRvIG1ha2UgYW5cbiAgICAgIC8vIGluY3JlbWVudGFsIHVwZGF0ZS4gVE9ETzogQ29uc2lkZXIgZGVwcmVjYXRpbmcgdGhpcyBmaWVsZC5cbiAgICAgIHRoaXMuX293bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgICAgIC8vIEFsbCBjb21wb25lbnRzIHN0YXJ0IHVubW91bnRlZC5cbiAgICAgIHRoaXMuX2xpZmVDeWNsZVN0YXRlID0gQ29tcG9uZW50TGlmZUN5Y2xlLlVOTU9VTlRFRDtcblxuICAgICAgLy8gU2VlIFJlYWN0VXBkYXRlcy5cbiAgICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuXG4gICAgICAvLyBXZSBrZWVwIHRoZSBvbGQgZWxlbWVudCBhbmQgYSByZWZlcmVuY2UgdG8gdGhlIHBlbmRpbmcgZWxlbWVudFxuICAgICAgLy8gdG8gdHJhY2sgdXBkYXRlcy5cbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBkb2VzIG5vdCBpbnNlcnQgYW55IG5vZGVzIGludG8gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIFN1YmNsYXNzZXMgdGhhdCBvdmVycmlkZSB0aGlzIG1ldGhvZCBzaG91bGQgbWFrZSBzdXJlIHRvIGludm9rZVxuICAgICAqIGBSZWFjdENvbXBvbmVudC5NaXhpbi5tb3VudENvbXBvbmVudC5jYWxsKHRoaXMsIC4uLilgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbW91bnREZXB0aCBudW1iZXIgb2YgY29tcG9uZW50cyBpbiB0aGUgb3duZXIgaGllcmFyY2h5LlxuICAgICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uKHJvb3RJRCwgdHJhbnNhY3Rpb24sIG1vdW50RGVwdGgpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgICF0aGlzLmlzTW91bnRlZCgpLFxuICAgICAgICAnbW91bnRDb21wb25lbnQoJXMsIC4uLik6IENhbiBvbmx5IG1vdW50IGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgK1xuICAgICAgICAnTWFrZSBzdXJlIHRvIGF2b2lkIHN0b3JpbmcgY29tcG9uZW50cyBiZXR3ZWVuIHJlbmRlcnMgb3IgcmV1c2luZyBhICcgK1xuICAgICAgICAnc2luZ2xlIGNvbXBvbmVudCBpbnN0YW5jZSBpbiBtdWx0aXBsZSBwbGFjZXMuJyxcbiAgICAgICAgcm9vdElEXG4gICAgICApIDogaW52YXJpYW50KCF0aGlzLmlzTW91bnRlZCgpKSk7XG4gICAgICB2YXIgcmVmID0gdGhpcy5fY3VycmVudEVsZW1lbnQucmVmO1xuICAgICAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICAgIHZhciBvd25lciA9IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgUmVhY3RPd25lci5hZGRDb21wb25lbnRBc1JlZlRvKHRoaXMsIHJlZiwgb3duZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcm9vdE5vZGVJRCA9IHJvb3RJRDtcbiAgICAgIHRoaXMuX2xpZmVDeWNsZVN0YXRlID0gQ29tcG9uZW50TGlmZUN5Y2xlLk1PVU5URUQ7XG4gICAgICB0aGlzLl9tb3VudERlcHRoID0gbW91bnREZXB0aDtcbiAgICAgIC8vIEVmZmVjdGl2ZWx5OiByZXR1cm4gJyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGRvZXMgbm90IHJlbW92ZSBhbnkgbm9kZXMgZnJvbSB0aGUgRE9NLlxuICAgICAqXG4gICAgICogU3ViY2xhc3NlcyB0aGF0IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHNob3VsZCBtYWtlIHN1cmUgdG8gaW52b2tlXG4gICAgICogYFJlYWN0Q29tcG9uZW50Lk1peGluLnVubW91bnRDb21wb25lbnQuY2FsbCh0aGlzKWAuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIHRoaXMuaXNNb3VudGVkKCksXG4gICAgICAgICd1bm1vdW50Q29tcG9uZW50KCk6IENhbiBvbmx5IHVubW91bnQgYSBtb3VudGVkIGNvbXBvbmVudC4nXG4gICAgICApIDogaW52YXJpYW50KHRoaXMuaXNNb3VudGVkKCkpKTtcbiAgICAgIHZhciByZWYgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5yZWY7XG4gICAgICBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgICAgUmVhY3RPd25lci5yZW1vdmVDb21wb25lbnRBc1JlZkZyb20odGhpcywgcmVmLCB0aGlzLl9vd25lcik7XG4gICAgICB9XG4gICAgICB1bm1vdW50SURGcm9tRW52aXJvbm1lbnQodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgICAgIHRoaXMuX2xpZmVDeWNsZVN0YXRlID0gQ29tcG9uZW50TGlmZUN5Y2xlLlVOTU9VTlRFRDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBuZXcgaW5zdGFuY2Ugb2YgdGhpcyBjb21wb25lbnQsIHVwZGF0ZXMgdGhlIHJlbmRlcmVkIERPTSBub2Rlc1xuICAgICAqIGFzIGlmIHRoYXQgaW5zdGFuY2Ugd2FzIHJlbmRlcmVkIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBTdWJjbGFzc2VzIHRoYXQgb3ZlcnJpZGUgdGhpcyBtZXRob2Qgc2hvdWxkIG1ha2Ugc3VyZSB0byBpbnZva2VcbiAgICAgKiBgUmVhY3RDb21wb25lbnQuTWl4aW4ucmVjZWl2ZUNvbXBvbmVudC5jYWxsKHRoaXMsIC4uLilgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5leHRDb21wb25lbnQgTmV4dCBzZXQgb2YgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24obmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICB0aGlzLmlzTW91bnRlZCgpLFxuICAgICAgICAncmVjZWl2ZUNvbXBvbmVudCguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIGNvbXBvbmVudC4nXG4gICAgICApIDogaW52YXJpYW50KHRoaXMuaXNNb3VudGVkKCkpKTtcbiAgICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgICB0aGlzLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSh0cmFuc2FjdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIGBfcGVuZGluZ0VsZW1lbnRgIGlzIHNldCwgdXBkYXRlIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBmdW5jdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdFbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZFbGVtZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSB0aGlzLl9wZW5kaW5nRWxlbWVudDtcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgICB0aGlzLnByb3BzID0gbmV4dEVsZW1lbnQucHJvcHM7XG4gICAgICB0aGlzLl9vd25lciA9IG5leHRFbGVtZW50Ll9vd25lcjtcbiAgICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGN1cnJlbnRseSBtb3VudGVkIHJlcHJlc2VudGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2RWxlbWVudFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24odHJhbnNhY3Rpb24sIHByZXZFbGVtZW50KSB7XG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcblxuICAgICAgLy8gSWYgZWl0aGVyIHRoZSBvd25lciBvciBhIGByZWZgIGhhcyBjaGFuZ2VkLCBtYWtlIHN1cmUgdGhlIG5ld2VzdCBvd25lclxuICAgICAgLy8gaGFzIHN0b3JlZCBhIHJlZmVyZW5jZSB0byBgdGhpc2AsIGFuZCB0aGUgcHJldmlvdXMgb3duZXIgKGlmIGRpZmZlcmVudClcbiAgICAgIC8vIGhhcyBmb3Jnb3R0ZW4gdGhlIHJlZmVyZW5jZSB0byBgdGhpc2AuIFdlIHVzZSB0aGUgZWxlbWVudCBpbnN0ZWFkXG4gICAgICAvLyBvZiB0aGUgcHVibGljIHRoaXMucHJvcHMgYmVjYXVzZSB0aGUgcG9zdCBwcm9jZXNzaW5nIGNhbm5vdCBkZXRlcm1pbmVcbiAgICAgIC8vIGEgcmVmLiBUaGUgcmVmIGNvbmNlcHR1YWxseSBsaXZlcyBvbiB0aGUgZWxlbWVudC5cblxuICAgICAgLy8gVE9ETzogU2hvdWxkIHRoaXMgZXZlbiBiZSBwb3NzaWJsZT8gVGhlIG93bmVyIGNhbm5vdCBjaGFuZ2UgYmVjYXVzZVxuICAgICAgLy8gaXQncyBmb3JiaWRkZW4gYnkgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuIFRoZSByZWYgY2FuIGNoYW5nZVxuICAgICAgLy8gaWYgeW91IHN3YXAgdGhlIGtleXMgb2YgYnV0IG5vdCB0aGUgcmVmcy4gUmVjb25zaWRlciB3aGVyZSB0aGlzIGNoZWNrXG4gICAgICAvLyBpcyBtYWRlLiBJdCBwcm9iYWJseSBiZWxvbmdzIHdoZXJlIHRoZSBrZXkgY2hlY2tpbmcgYW5kXG4gICAgICAvLyBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50IGlzIGRvbmUuXG5cbiAgICAgIGlmIChuZXh0RWxlbWVudC5fb3duZXIgIT09IHByZXZFbGVtZW50Ll9vd25lciB8fFxuICAgICAgICAgIG5leHRFbGVtZW50LnJlZiAhPT0gcHJldkVsZW1lbnQucmVmKSB7XG4gICAgICAgIGlmIChwcmV2RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgICAgIFJlYWN0T3duZXIucmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKFxuICAgICAgICAgICAgdGhpcywgcHJldkVsZW1lbnQucmVmLCBwcmV2RWxlbWVudC5fb3duZXJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvcnJlY3QsIGV2ZW4gaWYgdGhlIG93bmVyIGlzIHRoZSBzYW1lLCBhbmQgb25seSB0aGUgcmVmIGhhcyBjaGFuZ2VkLlxuICAgICAgICBpZiAobmV4dEVsZW1lbnQucmVmICE9IG51bGwpIHtcbiAgICAgICAgICBSZWFjdE93bmVyLmFkZENvbXBvbmVudEFzUmVmVG8oXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgbmV4dEVsZW1lbnQucmVmLFxuICAgICAgICAgICAgbmV4dEVsZW1lbnQuX293bmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3VudHMgdGhpcyBjb21wb25lbnQgYW5kIGluc2VydHMgaXQgaW50byB0aGUgRE9NLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgSWYgdHJ1ZSwgZG8gbm90IGluc2VydCBtYXJrdXBcbiAgICAgKiBAZmluYWxcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAc2VlIHtSZWFjdE1vdW50LnJlbmRlcn1cbiAgICAgKi9cbiAgICBtb3VudENvbXBvbmVudEludG9Ob2RlOiBmdW5jdGlvbihyb290SUQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXApIHtcbiAgICAgIHZhciB0cmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmdldFBvb2xlZCgpO1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShcbiAgICAgICAgdGhpcy5fbW91bnRDb21wb25lbnRJbnRvTm9kZSxcbiAgICAgICAgdGhpcyxcbiAgICAgICAgcm9vdElELFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBzaG91bGRSZXVzZU1hcmt1cFxuICAgICAgKTtcbiAgICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIG1vdW50IGludG8uXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgSWYgdHJ1ZSwgZG8gbm90IGluc2VydCBtYXJrdXBcbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tb3VudENvbXBvbmVudEludG9Ob2RlOiBmdW5jdGlvbihcbiAgICAgICAgcm9vdElELFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBzaG91bGRSZXVzZU1hcmt1cCkge1xuICAgICAgdmFyIG1hcmt1cCA9IHRoaXMubW91bnRDb21wb25lbnQocm9vdElELCB0cmFuc2FjdGlvbiwgMCk7XG4gICAgICBtb3VudEltYWdlSW50b05vZGUobWFya3VwLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoaXMgY29tcG9uZW50IGlzIG93bmVkIGJ5IHRoZSBzdXBwbGllZCBgb3duZXJgIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IG93bmVyIENvbXBvbmVudCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvd25lcnNgIG93bnMgdGhpcyBjb21wb25lbnQuXG4gICAgICogQGZpbmFsXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgaXNPd25lZEJ5OiBmdW5jdGlvbihvd25lcikge1xuICAgICAgcmV0dXJuIHRoaXMuX293bmVyID09PSBvd25lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbm90aGVyIGNvbXBvbmVudCwgdGhhdCBzaGFyZXMgdGhlIHNhbWUgb3duZXIgYXMgdGhpcyBvbmUsIGJ5IHJlZi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgb2YgYSBzaWJsaW5nIENvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJuIHs/UmVhY3RDb21wb25lbnR9IHRoZSBhY3R1YWwgc2libGluZyBDb21wb25lbnQuXG4gICAgICogQGZpbmFsXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0U2libGluZ0J5UmVmOiBmdW5jdGlvbihyZWYpIHtcbiAgICAgIHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuICAgICAgaWYgKCFvd25lciB8fCAhb3duZXIucmVmcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvd25lci5yZWZzW3JlZl07XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50XG4gKi9cblxuLypqc2xpbnQgZXZpbDogdHJ1ZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0gcmVxdWlyZShcIi4vUmVhY3RET01JRE9wZXJhdGlvbnNcIik7XG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHJlcXVpcmUoXCIuL1JlYWN0TWFya3VwQ2hlY2tzdW1cIik7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoXCIuL1JlYWN0TW91bnRcIik7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZShcIi4vUmVhY3RQZXJmXCIpO1xudmFyIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSByZXF1aXJlKFwiLi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXCIpO1xuXG52YXIgZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyID0gcmVxdWlyZShcIi4vZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKFwiLi9zZXRJbm5lckhUTUxcIik7XG5cblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcbnZhciBET0NfTk9ERV9UWVBFID0gOTtcblxuXG4vKipcbiAqIEFic3RyYWN0cyBhd2F5IGFsbCBmdW5jdGlvbmFsaXR5IG9mIGBSZWFjdENvbXBvbmVudGAgcmVxdWlyZXMga25vd2xlZGdlIG9mXG4gKiB0aGUgYnJvd3NlciBjb250ZXh0LlxuICovXG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSB7XG4gIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24sXG5cbiAgQmFja2VuZElET3BlcmF0aW9uczogUmVhY3RET01JRE9wZXJhdGlvbnMsXG5cbiAgLyoqXG4gICAqIElmIGEgcGFydGljdWxhciBlbnZpcm9ubWVudCByZXF1aXJlcyB0aGF0IHNvbWUgcmVzb3VyY2VzIGJlIGNsZWFuZWQgdXAsXG4gICAqIHNwZWNpZnkgdGhpcyBpbiB0aGUgaW5qZWN0ZWQgTWl4aW4uIEluIHRoZSBET00sIHdlIHdvdWxkIGxpa2VseSB3YW50IHRvXG4gICAqIHB1cmdlIGFueSBjYWNoZWQgbm9kZSBJRCBsb29rdXBzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdW5tb3VudElERnJvbUVudmlyb25tZW50OiBmdW5jdGlvbihyb290Tm9kZUlEKSB7XG4gICAgUmVhY3RNb3VudC5wdXJnZUlEKHJvb3ROb2RlSUQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCBzdHJpbmcgdG8gcGxhY2UgaW50byB0aGUgRE9NIEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBFbGVtZW50IHRvIGluc2VydCBtYXJrdXAgaW50by5cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBTaG91bGQgcmV1c2UgdGhlIGV4aXN0aW5nIG1hcmt1cCBpbiB0aGVcbiAgICogY29udGFpbmVyIGlmIHBvc3NpYmxlLlxuICAgKi9cbiAgbW91bnRJbWFnZUludG9Ob2RlOiBSZWFjdFBlcmYubWVhc3VyZShcbiAgICAnUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQnLFxuICAgICdtb3VudEltYWdlSW50b05vZGUnLFxuICAgIGZ1bmN0aW9uKG1hcmt1cCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCkge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgY29udGFpbmVyICYmIChcbiAgICAgICAgICBjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8XG4gICAgICAgICAgICBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEVcbiAgICAgICAgKSxcbiAgICAgICAgJ21vdW50Q29tcG9uZW50SW50b05vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgdmFsaWQuJ1xuICAgICAgKSA6IGludmFyaWFudChjb250YWluZXIgJiYgKFxuICAgICAgICBjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8XG4gICAgICAgICAgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFXG4gICAgICApKSk7XG5cbiAgICAgIGlmIChzaG91bGRSZXVzZU1hcmt1cCkge1xuICAgICAgICBpZiAoUmVhY3RNYXJrdXBDaGVja3N1bS5jYW5SZXVzZU1hcmt1cChcbiAgICAgICAgICBtYXJrdXAsXG4gICAgICAgICAgZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgICAgICBjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUsXG4gICAgICAgICAgICAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgdXNpbmcgJyArXG4gICAgICAgICAgICAnc2VydmVyIHJlbmRlcmluZyBidXQgdGhlIGNoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgJyArXG4gICAgICAgICAgICAnbWVhbnMgeW91IHJlbmRlcmVkIGEgZGlmZmVyZW50IGNvbXBvbmVudCB0eXBlIG9yIHByb3BzIG9uICcgK1xuICAgICAgICAgICAgJ3RoZSBjbGllbnQgZnJvbSB0aGUgb25lIG9uIHRoZSBzZXJ2ZXIsIG9yIHlvdXIgcmVuZGVyKCkgJyArXG4gICAgICAgICAgICAnbWV0aG9kcyBhcmUgaW1wdXJlLiBSZWFjdCBjYW5ub3QgaGFuZGxlIHRoaXMgY2FzZSBkdWUgdG8gJyArXG4gICAgICAgICAgICAnY3Jvc3MtYnJvd3NlciBxdWlya3MgYnkgcmVuZGVyaW5nIGF0IHRoZSBkb2N1bWVudCByb290LiBZb3UgJyArXG4gICAgICAgICAgICAnc2hvdWxkIGxvb2sgZm9yIGVudmlyb25tZW50IGRlcGVuZGVudCBjb2RlIGluIHlvdXIgY29tcG9uZW50cyAnICtcbiAgICAgICAgICAgICdhbmQgZW5zdXJlIHRoZSBwcm9wcyBhcmUgdGhlIHNhbWUgY2xpZW50IGFuZCBzZXJ2ZXIgc2lkZS4nXG4gICAgICAgICAgKSA6IGludmFyaWFudChjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUpKTtcblxuICAgICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ1JlYWN0IGF0dGVtcHRlZCB0byB1c2UgcmV1c2UgbWFya3VwIGluIGEgY29udGFpbmVyIGJ1dCB0aGUgJyArXG4gICAgICAgICAgICAgICdjaGVja3N1bSB3YXMgaW52YWxpZC4gVGhpcyBnZW5lcmFsbHkgbWVhbnMgdGhhdCB5b3UgYXJlICcgK1xuICAgICAgICAgICAgICAndXNpbmcgc2VydmVyIHJlbmRlcmluZyBhbmQgdGhlIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlICcgK1xuICAgICAgICAgICAgICAnc2VydmVyIHdhcyBub3Qgd2hhdCB0aGUgY2xpZW50IHdhcyBleHBlY3RpbmcuIFJlYWN0IGluamVjdGVkICcgK1xuICAgICAgICAgICAgICAnbmV3IG1hcmt1cCB0byBjb21wZW5zYXRlIHdoaWNoIHdvcmtzIGJ1dCB5b3UgaGF2ZSBsb3N0IG1hbnkgJyArXG4gICAgICAgICAgICAgICdvZiB0aGUgYmVuZWZpdHMgb2Ygc2VydmVyIHJlbmRlcmluZy4gSW5zdGVhZCwgZmlndXJlIG91dCAnICtcbiAgICAgICAgICAgICAgJ3doeSB0aGUgbWFya3VwIGJlaW5nIGdlbmVyYXRlZCBpcyBkaWZmZXJlbnQgb24gdGhlIGNsaWVudCAnICtcbiAgICAgICAgICAgICAgJ29yIHNlcnZlci4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICBjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUsXG4gICAgICAgICdZb3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIGEgY29tcG9uZW50IHRvIHRoZSBkb2N1bWVudCBidXQgJyArXG4gICAgICAgICAgJ3lvdSBkaWRuXFwndCB1c2Ugc2VydmVyIHJlbmRlcmluZy4gV2UgY2FuXFwndCBkbyB0aGlzICcgK1xuICAgICAgICAgICd3aXRob3V0IHVzaW5nIHNlcnZlciByZW5kZXJpbmcgZHVlIHRvIGNyb3NzLWJyb3dzZXIgcXVpcmtzLiAnICtcbiAgICAgICAgICAnU2VlIHJlbmRlckNvbXBvbmVudFRvU3RyaW5nKCkgZm9yIHNlcnZlciByZW5kZXJpbmcuJ1xuICAgICAgKSA6IGludmFyaWFudChjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUpKTtcblxuICAgICAgc2V0SW5uZXJIVE1MKGNvbnRhaW5lciwgbWFya3VwKTtcbiAgICB9XG4gIClcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQ7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb3NpdGVDb21wb25lbnRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RDb21wb25lbnRcIik7XG52YXIgUmVhY3RDb250ZXh0ID0gcmVxdWlyZShcIi4vUmVhY3RDb250ZXh0XCIpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZShcIi4vUmVhY3RDdXJyZW50T3duZXJcIik7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFZhbGlkYXRvclwiKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbXB0eUNvbXBvbmVudFwiKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKFwiLi9SZWFjdEVycm9yVXRpbHNcIik7XG52YXIgUmVhY3RMZWdhY3lFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RMZWdhY3lFbGVtZW50XCIpO1xudmFyIFJlYWN0T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdE93bmVyXCIpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0UGVyZlwiKTtcbnZhciBSZWFjdFByb3BUcmFuc2ZlcmVyID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHJhbnNmZXJlclwiKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uc1wiKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoXCIuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzXCIpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlc1wiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoXCIuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoXCIuL2tleU1pcnJvclwiKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoXCIuL2tleU9mXCIpO1xudmFyIG1vbml0b3JDb2RlVXNlID0gcmVxdWlyZShcIi4vbW9uaXRvckNvZGVVc2VcIik7XG52YXIgbWFwT2JqZWN0ID0gcmVxdWlyZShcIi4vbWFwT2JqZWN0XCIpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnRcIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbnZhciBNSVhJTlNfS0VZID0ga2V5T2Yoe21peGluczogbnVsbH0pO1xuXG4vKipcbiAqIFBvbGljaWVzIHRoYXQgZGVzY3JpYmUgbWV0aG9kcyBpbiBgUmVhY3RDb21wb3NpdGVDb21wb25lbnRJbnRlcmZhY2VgLlxuICovXG52YXIgU3BlY1BvbGljeSA9IGtleU1pcnJvcih7XG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIG1heSBiZSBkZWZpbmVkIG9ubHkgb25jZSBieSB0aGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBvciBtaXhpbi5cbiAgICovXG4gIERFRklORV9PTkNFOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgZGVmaW5lZCBieSBib3RoIHRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIGFuZCBtaXhpbnMuXG4gICAqIFN1YnNlcXVlbnQgZGVmaW5pdGlvbnMgd2lsbCBiZSBjaGFpbmVkLiBUaGVzZSBtZXRob2RzIG11c3QgcmV0dXJuIHZvaWQuXG4gICAqL1xuICBERUZJTkVfTUFOWTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgYXJlIG92ZXJyaWRpbmcgdGhlIGJhc2UgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgY2xhc3MuXG4gICAqL1xuICBPVkVSUklERV9CQVNFOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBhcmUgc2ltaWxhciB0byBERUZJTkVfTUFOWSwgZXhjZXB0IHdlIGFzc3VtZSB0aGV5IHJldHVyblxuICAgKiBvYmplY3RzLiBXZSB0cnkgdG8gbWVyZ2UgdGhlIGtleXMgb2YgdGhlIHJldHVybiB2YWx1ZXMgb2YgYWxsIHRoZSBtaXhlZCBpblxuICAgKiBmdW5jdGlvbnMuIElmIHRoZXJlIGlzIGEga2V5IGNvbmZsaWN0IHdlIHRocm93LlxuICAgKi9cbiAgREVGSU5FX01BTllfTUVSR0VEOiBudWxsXG59KTtcblxuXG52YXIgaW5qZWN0ZWRNaXhpbnMgPSBbXTtcblxuLyoqXG4gKiBDb21wb3NpdGUgY29tcG9uZW50cyBhcmUgaGlnaGVyLWxldmVsIGNvbXBvbmVudHMgdGhhdCBjb21wb3NlIG90aGVyIGNvbXBvc2l0ZVxuICogb3IgbmF0aXZlIGNvbXBvbmVudHMuXG4gKlxuICogVG8gY3JlYXRlIGEgbmV3IHR5cGUgb2YgYFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50YCwgcGFzcyBhIHNwZWNpZmljYXRpb24gb2ZcbiAqIHlvdXIgbmV3IGNsYXNzIHRvIGBSZWFjdC5jcmVhdGVDbGFzc2AuIFRoZSBvbmx5IHJlcXVpcmVtZW50IG9mIHlvdXIgY2xhc3NcbiAqIHNwZWNpZmljYXRpb24gaXMgdGhhdCB5b3UgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLlxuICpcbiAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gPGRpdj5IZWxsbyBXb3JsZDwvZGl2PjtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIHN1cHBvcnRzIGEgc3BlY2lmaWMgcHJvdG9jb2wgb2YgbWV0aG9kcyB0aGF0IGhhdmVcbiAqIHNwZWNpYWwgbWVhbmluZyAoZS5nLiBgcmVuZGVyYCkuIFNlZSBgUmVhY3RDb21wb3NpdGVDb21wb25lbnRJbnRlcmZhY2VgIGZvclxuICogbW9yZSB0aGUgY29tcHJlaGVuc2l2ZSBwcm90b2NvbC4gQW55IG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgaW4gdGhlXG4gKiBjbGFzcyBzcGVjaWZpY2F0aW9uIHdpbGwgYXZhaWxhYmxlIG9uIHRoZSBwcm90b3R5cGUuXG4gKlxuICogQGludGVyZmFjZSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudEludGVyZmFjZVxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudEludGVyZmFjZSA9IHtcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgTWl4aW4gb2JqZWN0cyB0byBpbmNsdWRlIHdoZW4gZGVmaW5pbmcgeW91ciBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHthcnJheX1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBtaXhpbnM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgdGhhdCBzaG91bGQgYmUgZGVmaW5lZCBvblxuICAgKiB0aGUgY29tcG9uZW50J3MgY29uc3RydWN0b3IgaW5zdGVhZCBvZiBpdHMgcHJvdG90eXBlIChzdGF0aWMgbWV0aG9kcykuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgc3RhdGljczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBwcm9wIHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBwcm9wVHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29udGV4dFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgdGhpcyBjb21wb25lbnQgc2V0cyBmb3IgaXRzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNoaWxkQ29udGV4dFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8vID09PT0gRGVmaW5pdGlvbiBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVmFsdWVzIGluIHRoZSBtYXBwaW5nIHdpbGwgYmUgc2V0IG9uXG4gICAqIGB0aGlzLnByb3BzYCBpZiB0aGF0IHByb3AgaXMgbm90IHNwZWNpZmllZCAoaS5lLiB1c2luZyBhbiBgaW5gIGNoZWNrKS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBiZWZvcmUgYGdldEluaXRpYWxTdGF0ZWAgYW5kIHRoZXJlZm9yZSBjYW5ub3QgcmVseVxuICAgKiBvbiBgdGhpcy5zdGF0ZWAgb3IgdXNlIGB0aGlzLnNldFN0YXRlYC5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZFxuICAgKiBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgdGhpcy5zdGF0ZWAuXG4gICAqXG4gICAqICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHJldHVybiB7XG4gICAqICAgICAgIGlzT246IGZhbHNlLFxuICAgKiAgICAgICBmb29CYXo6IG5ldyBCYXpGb28oKVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldEluaXRpYWxTdGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRDaGlsZENvbnRleHQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBVc2VzIHByb3BzIGZyb20gYHRoaXMucHJvcHNgIGFuZCBzdGF0ZSBmcm9tIGB0aGlzLnN0YXRlYCB0byByZW5kZXIgdGhlXG4gICAqIHN0cnVjdHVyZSBvZiB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBObyBndWFyYW50ZWVzIGFyZSBtYWRlIGFib3V0IHdoZW4gb3IgaG93IG9mdGVuIHRoaXMgbWV0aG9kIGlzIGludm9rZWQsIHNvXG4gICAqIGl0IG11c3Qgbm90IGhhdmUgc2lkZSBlZmZlY3RzLlxuICAgKlxuICAgKiAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAqICAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICogICAgIHJldHVybiA8ZGl2PkhlbGxvLCB7bmFtZX0hPC9kaXY+O1xuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gICAqIEBub3NpZGVlZmZlY3RzXG4gICAqIEByZXF1aXJlZFxuICAgKi9cbiAgcmVuZGVyOiBTcGVjUG9saWN5LkRFRklORV9PTkNFLFxuXG5cblxuICAvLyA9PT09IERlbGVnYXRlIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsbHkgY3JlYXRlZCBhbmQgYWJvdXQgdG8gYmUgbW91bnRlZC5cbiAgICogVGhpcyBtYXkgaGF2ZSBzaWRlIGVmZmVjdHMsIGJ1dCBhbnkgZXh0ZXJuYWwgc3Vic2NyaXB0aW9ucyBvciBkYXRhIGNyZWF0ZWRcbiAgICogYnkgdGhpcyBtZXRob2QgbXVzdCBiZSBjbGVhbmVkIHVwIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGAuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbE1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIGFuZCBoYXMgYSBET00gcmVwcmVzZW50YXRpb24uXG4gICAqIEhvd2V2ZXIsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBET00gbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gbW91bnRlZCAoaW5pdGlhbGl6ZWQgYW5kIHJlbmRlcmVkKSBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byByZWFjdCB0byBhIHByb3AgdHJhbnNpdGlvbiBieSB1cGRhdGluZyB0aGVcbiAgICogc3RhdGUgdXNpbmcgYHRoaXMuc2V0U3RhdGVgLiBDdXJyZW50IHByb3BzIGFyZSBhY2Nlc3NlZCB2aWEgYHRoaXMucHJvcHNgLlxuICAgKlxuICAgKiAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICogICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgKiAgICAgICBsaWtlc0luY3JlYXNpbmc6IG5leHRQcm9wcy5saWtlQ291bnQgPiB0aGlzLnByb3BzLmxpa2VDb3VudFxuICAgKiAgICAgfSk7XG4gICAqICAgfVxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBlcXVpdmFsZW50IGBjb21wb25lbnRXaWxsUmVjZWl2ZVN0YXRlYC4gQW4gaW5jb21pbmcgcHJvcFxuICAgKiB0cmFuc2l0aW9uIG1heSBjYXVzZSBhIHN0YXRlIGNoYW5nZSwgYnV0IHRoZSBvcHBvc2l0ZSBpcyBub3QgdHJ1ZS4gSWYgeW91XG4gICAqIG5lZWQgaXQsIHlvdSBhcmUgcHJvYmFibHkgbG9va2luZyBmb3IgYGNvbXBvbmVudFdpbGxVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGlsZSBkZWNpZGluZyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkIGFzIGEgcmVzdWx0IG9mXG4gICAqIHJlY2VpdmluZyBuZXcgcHJvcHMsIHN0YXRlIGFuZC9vciBjb250ZXh0LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBgcmV0dXJuIGZhbHNlYCB3aGVuIHlvdSdyZSBjZXJ0YWluIHRoYXQgdGhlXG4gICAqIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcy9zdGF0ZS9jb250ZXh0IHdpbGwgbm90IHJlcXVpcmUgYSBjb21wb25lbnRcbiAgICogdXBkYXRlLlxuICAgKlxuICAgKiAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICByZXR1cm4gIWVxdWFsKG5leHRQcm9wcywgdGhpcy5wcm9wcykgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgKiAgIH1cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgdXBkYXRlLlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfT05DRSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gdXBkYXRlIGR1ZSB0byBhIHRyYW5zaXRpb24gZnJvbVxuICAgKiBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAgdG8gYG5leHRQcm9wc2AsIGBuZXh0U3RhdGVgXG4gICAqIGFuZCBgbmV4dENvbnRleHRgLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBwZXJmb3JtIHByZXBhcmF0aW9uIGJlZm9yZSBhbiB1cGRhdGUgb2NjdXJzLlxuICAgKlxuICAgKiBOT1RFOiBZb3UgKipjYW5ub3QqKiB1c2UgYHRoaXMuc2V0U3RhdGUoKWAgaW4gdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQncyBET00gcmVwcmVzZW50YXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICogYmVlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJldlByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldlN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNvbnRleHRcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnREaWRVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIGJlIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IGFuZCBoYXZlXG4gICAqIGl0cyBET00gcmVwcmVzZW50YXRpb24gZGVzdHJveWVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBkZWFsbG9jYXRlIGFueSBleHRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGBjb21wb25lbnREaWRVbm1vdW50YCBzaW5jZSB5b3VyIGNvbXBvbmVudCB3aWxsIGhhdmUgYmVlblxuICAgKiBkZXN0cm95ZWQgYnkgdGhhdCBwb2ludC5cbiAgICpcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsVW5tb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuXG5cbiAgLy8gPT09PSBBZHZhbmNlZCBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50J3MgY3VycmVudGx5IG1vdW50ZWQgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0VcblxufTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gY2xhc3Mgc3BlY2lmaWNhdGlvbiBrZXlzIHRvIHNwZWNpYWwgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG4gKlxuICogQWx0aG91Z2ggdGhlc2UgYXJlIGRlY2xhcmVkIGxpa2UgaW5zdGFuY2UgcHJvcGVydGllcyBpbiB0aGUgc3BlY2lmaWNhdGlvblxuICogd2hlbiBkZWZpbmluZyBjbGFzc2VzIHVzaW5nIGBSZWFjdC5jcmVhdGVDbGFzc2AsIHRoZXkgYXJlIGFjdHVhbGx5IHN0YXRpY1xuICogYW5kIGFyZSBhY2Nlc3NpYmxlIG9uIHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIHRoZSBwcm90b3R5cGUuIERlc3BpdGVcbiAqIGJlaW5nIHN0YXRpYywgdGhleSBtdXN0IGJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgXCJzdGF0aWNzXCIga2V5IHVuZGVyXG4gKiB3aGljaCBhbGwgb3RoZXIgc3RhdGljIG1ldGhvZHMgYXJlIGRlZmluZWQuXG4gKi9cbnZhciBSRVNFUlZFRF9TUEVDX0tFWVMgPSB7XG4gIGRpc3BsYXlOYW1lOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgZGlzcGxheU5hbWUpIHtcbiAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICB9LFxuICBtaXhpbnM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBtaXhpbnMpIHtcbiAgICBpZiAobWl4aW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgbWl4aW5zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNoaWxkQ29udGV4dFR5cGVzOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICB2YWxpZGF0ZVR5cGVEZWYoXG4gICAgICBDb25zdHJ1Y3RvcixcbiAgICAgIGNoaWxkQ29udGV4dFR5cGVzLFxuICAgICAgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jaGlsZENvbnRleHRcbiAgICApO1xuICAgIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzID0gYXNzaWduKFxuICAgICAge30sXG4gICAgICBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyxcbiAgICAgIGNoaWxkQ29udGV4dFR5cGVzXG4gICAgKTtcbiAgfSxcbiAgY29udGV4dFR5cGVzOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzKSB7XG4gICAgdmFsaWRhdGVUeXBlRGVmKFxuICAgICAgQ29uc3RydWN0b3IsXG4gICAgICBjb250ZXh0VHlwZXMsXG4gICAgICBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNvbnRleHRcbiAgICApO1xuICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IGFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzLFxuICAgICAgY29udGV4dFR5cGVzXG4gICAgKTtcbiAgfSxcbiAgLyoqXG4gICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgKiBhdXRvbWF0aWMgbWVyZ2luZy5cbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGdldERlZmF1bHRQcm9wcykge1xuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKFxuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsXG4gICAgICAgIGdldERlZmF1bHRQcm9wc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gZ2V0RGVmYXVsdFByb3BzO1xuICAgIH1cbiAgfSxcbiAgcHJvcFR5cGVzOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzKSB7XG4gICAgdmFsaWRhdGVUeXBlRGVmKFxuICAgICAgQ29uc3RydWN0b3IsXG4gICAgICBwcm9wVHlwZXMsXG4gICAgICBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3BcbiAgICApO1xuICAgIENvbnN0cnVjdG9yLnByb3BUeXBlcyA9IGFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgQ29uc3RydWN0b3IucHJvcFR5cGVzLFxuICAgICAgcHJvcFR5cGVzXG4gICAgKTtcbiAgfSxcbiAgc3RhdGljczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpIHtcbiAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9vd25lciB8fCBudWxsO1xuICBpZiAob3duZXIgJiYgb3duZXIuY29uc3RydWN0b3IgJiYgb3duZXIuY29uc3RydWN0b3IuZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lICtcbiAgICAgICdgLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHR5cGVEZWYsIGxvY2F0aW9uKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHR5cGVEZWYpIHtcbiAgICBpZiAodHlwZURlZi5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICtcbiAgICAgICAgJ1JlYWN0LlByb3BUeXBlcy4nLFxuICAgICAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnLFxuICAgICAgICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sXG4gICAgICAgIHByb3BOYW1lXG4gICAgICApIDogaW52YXJpYW50KHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PSAnZnVuY3Rpb24nKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUocHJvdG8sIG5hbWUpIHtcbiAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudEludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgUmVhY3RDb21wb3NpdGVDb21wb25lbnRJbnRlcmZhY2VbbmFtZV0gOlxuICAgIG51bGw7XG5cbiAgLy8gRGlzYWxsb3cgb3ZlcnJpZGluZyBvZiBiYXNlIGNsYXNzIG1ldGhvZHMgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5PVkVSUklERV9CQVNFLFxuICAgICAgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50SW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gb3ZlcnJpZGUgJyArXG4gICAgICAnYCVzYCBmcm9tIHlvdXIgY2xhc3Mgc3BlY2lmaWNhdGlvbi4gRW5zdXJlIHRoYXQgeW91ciBtZXRob2QgbmFtZXMgJyArXG4gICAgICAnZG8gbm90IG92ZXJsYXAgd2l0aCBSZWFjdCBtZXRob2RzLicsXG4gICAgICBuYW1lXG4gICAgKSA6IGludmFyaWFudChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0UpKTtcbiAgfVxuXG4gIC8vIERpc2FsbG93IGRlZmluaW5nIG1ldGhvZHMgbW9yZSB0aGFuIG9uY2UgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkgfHxcbiAgICAgIHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuICAgICAgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50SW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgK1xuICAgICAgJ2Alc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSAnICtcbiAgICAgICd0byBhIG1peGluLicsXG4gICAgICBuYW1lXG4gICAgKSA6IGludmFyaWFudChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZIHx8XG4gICAgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUxpZmVDeWNsZU9uUmVwbGFjZVN0YXRlKGluc3RhbmNlKSB7XG4gIHZhciBjb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSA9IGluc3RhbmNlLl9jb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBpbnN0YW5jZS5pc01vdW50ZWQoKSB8fFxuICAgICAgY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgPT09IENvbXBvc2l0ZUxpZmVDeWNsZS5NT1VOVElORyxcbiAgICAncmVwbGFjZVN0YXRlKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LidcbiAgKSA6IGludmFyaWFudChpbnN0YW5jZS5pc01vdW50ZWQoKSB8fFxuICAgIGNvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlID09PSBDb21wb3NpdGVMaWZlQ3ljbGUuTU9VTlRJTkcpKTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsXG4gICAgJ3JlcGxhY2VTdGF0ZSguLi4pOiBDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uICcgK1xuICAgICcoc3VjaCBhcyB3aXRoaW4gYHJlbmRlcmApLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgK1xuICAgICdvZiBwcm9wcyBhbmQgc3RhdGUuJ1xuICApIDogaW52YXJpYW50KFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCkpO1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGNvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlICE9PSBDb21wb3NpdGVMaWZlQ3ljbGUuVU5NT1VOVElORyxcbiAgICAncmVwbGFjZVN0YXRlKC4uLik6IENhbm5vdCB1cGRhdGUgd2hpbGUgdW5tb3VudGluZyBjb21wb25lbnQuIFRoaXMgJyArXG4gICAgJ3VzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCBzZXRTdGF0ZSgpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJ1xuICApIDogaW52YXJpYW50KGNvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlICE9PSBDb21wb3NpdGVMaWZlQ3ljbGUuVU5NT1VOVElORykpO1xufVxuXG4vKipcbiAqIE1peGluIGhlbHBlciB3aGljaCBoYW5kbGVzIHBvbGljeSB2YWxpZGF0aW9uIGFuZCByZXNlcnZlZFxuICogc3BlY2lmaWNhdGlvbiBrZXlzIHdoZW4gYnVpbGRpbmcgYFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50YCBjbGFzc3Nlcy5cbiAqL1xuZnVuY3Rpb24gbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpIHtcbiAgaWYgKCFzcGVjKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAhUmVhY3RMZWdhY3lFbGVtZW50LmlzVmFsaWRGYWN0b3J5KHNwZWMpLFxuICAgICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogWW91XFwncmUgYXR0ZW1wdGluZyB0byAnICtcbiAgICAndXNlIGEgY29tcG9uZW50IGNsYXNzIGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJ1xuICApIDogaW52YXJpYW50KCFSZWFjdExlZ2FjeUVsZW1lbnQuaXNWYWxpZEZhY3Rvcnkoc3BlYykpKTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHNwZWMpLFxuICAgICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogWW91XFwncmUgYXR0ZW1wdGluZyB0byAnICtcbiAgICAndXNlIGEgY29tcG9uZW50IGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJ1xuICApIDogaW52YXJpYW50KCFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoc3BlYykpKTtcblxuICB2YXIgcHJvdG8gPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgLy8gQnkgaGFuZGxpbmcgbWl4aW5zIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcywgd2UgZW5zdXJlIHRoZSBzYW1lXG4gIC8vIGNoYWluaW5nIG9yZGVyIGlzIGFwcGxpZWQgdG8gbWV0aG9kcyB3aXRoIERFRklORV9NQU5ZIHBvbGljeSwgd2hldGhlclxuICAvLyBtaXhpbnMgYXJlIGxpc3RlZCBiZWZvcmUgb3IgYWZ0ZXIgdGhlc2UgbWV0aG9kcyBpbiB0aGUgc3BlYy5cbiAgaWYgKHNwZWMuaGFzT3duUHJvcGVydHkoTUlYSU5TX0tFWSkpIHtcbiAgICBSRVNFUlZFRF9TUEVDX0tFWVMubWl4aW5zKENvbnN0cnVjdG9yLCBzcGVjLm1peGlucyk7XG4gIH1cblxuICBmb3IgKHZhciBuYW1lIGluIHNwZWMpIHtcbiAgICBpZiAoIXNwZWMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSBNSVhJTlNfS0VZKSB7XG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgaGFuZGxlZCBtaXhpbnMgaW4gYSBzcGVjaWFsIGNhc2UgYWJvdmVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eSA9IHNwZWNbbmFtZV07XG4gICAgdmFsaWRhdGVNZXRob2RPdmVycmlkZShwcm90bywgbmFtZSk7XG5cbiAgICBpZiAoUkVTRVJWRURfU1BFQ19LRVlTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBSRVNFUlZFRF9TUEVDX0tFWVNbbmFtZV0oQ29uc3RydWN0b3IsIHByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0dXAgbWV0aG9kcyBvbiBwcm90b3R5cGU6XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG1lbWJlciBtZXRob2RzIHNob3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBib3VuZDpcbiAgICAgIC8vIDEuIEV4cGVjdGVkIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IG1ldGhvZHMgKGluIHRoZSBcImludGVyZmFjZVwiKS5cbiAgICAgIC8vIDIuIE92ZXJyaWRkZW4gbWV0aG9kcyAodGhhdCB3ZXJlIG1peGVkIGluKS5cbiAgICAgIHZhciBpc0NvbXBvc2l0ZUNvbXBvbmVudE1ldGhvZCA9XG4gICAgICAgIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50SW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgdmFyIGlzQWxyZWFkeURlZmluZWQgPSBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhciBtYXJrZWREb250QmluZCA9IHByb3BlcnR5ICYmIHByb3BlcnR5Ll9fcmVhY3REb250QmluZDtcbiAgICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nO1xuICAgICAgdmFyIHNob3VsZEF1dG9CaW5kID1cbiAgICAgICAgaXNGdW5jdGlvbiAmJlxuICAgICAgICAhaXNDb21wb3NpdGVDb21wb25lbnRNZXRob2QgJiZcbiAgICAgICAgIWlzQWxyZWFkeURlZmluZWQgJiZcbiAgICAgICAgIW1hcmtlZERvbnRCaW5kO1xuXG4gICAgICBpZiAoc2hvdWxkQXV0b0JpbmQpIHtcbiAgICAgICAgaWYgKCFwcm90by5fX3JlYWN0QXV0b0JpbmRNYXApIHtcbiAgICAgICAgICBwcm90by5fX3JlYWN0QXV0b0JpbmRNYXAgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBwcm90by5fX3JlYWN0QXV0b0JpbmRNYXBbbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudEludGVyZmFjZVtuYW1lXTtcblxuICAgICAgICAgIC8vIFRoZXNlIGNhc2VzIHNob3VsZCBhbHJlYWR5IGJlIGNhdWdodCBieSB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlXG4gICAgICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgICAgIGlzQ29tcG9zaXRlQ29tcG9uZW50TWV0aG9kICYmIChcbiAgICAgICAgICAgICAgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQgfHxcbiAgICAgICAgICAgICAgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogVW5leHBlY3RlZCBzcGVjIHBvbGljeSAlcyBmb3Iga2V5ICVzICcgK1xuICAgICAgICAgICAgJ3doZW4gbWl4aW5nIGluIGNvbXBvbmVudCBzcGVjcy4nLFxuICAgICAgICAgICAgc3BlY1BvbGljeSxcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICApIDogaW52YXJpYW50KGlzQ29tcG9zaXRlQ29tcG9uZW50TWV0aG9kICYmIChcbiAgICAgICAgICAgIHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEIHx8XG4gICAgICAgICAgICBzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZXG4gICAgICAgICAgKSkpO1xuXG4gICAgICAgICAgLy8gRm9yIG1ldGhvZHMgd2hpY2ggYXJlIGRlZmluZWQgbW9yZSB0aGFuIG9uY2UsIGNhbGwgdGhlIGV4aXN0aW5nXG4gICAgICAgICAgLy8gbWV0aG9kcyBiZWZvcmUgY2FsbGluZyB0aGUgbmV3IHByb3BlcnR5LCBtZXJnaW5nIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgIGlmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCkge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSkge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgICAvLyBBZGQgdmVyYm9zZSBkaXNwbGF5TmFtZSB0byB0aGUgZnVuY3Rpb24sIHdoaWNoIGhlbHBzIHdoZW4gbG9va2luZ1xuICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyAmJiBzcGVjLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdLmRpc3BsYXlOYW1lID0gc3BlYy5kaXNwbGF5TmFtZSArICdfJyArIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gIGlmICghc3RhdGljcykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBuYW1lIGluIHN0YXRpY3MpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBzdGF0aWNzW25hbWVdO1xuICAgIGlmICghc3RhdGljcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBuYW1lIGluIFJFU0VSVkVEX1NQRUNfS0VZUztcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgIWlzUmVzZXJ2ZWQsXG4gICAgICAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQ6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYSByZXNlcnZlZCAnICtcbiAgICAgICdwcm9wZXJ0eSwgYCVzYCwgdGhhdCBzaG91bGRuXFwndCBiZSBvbiB0aGUgXCJzdGF0aWNzXCIga2V5LiBEZWZpbmUgaXQgJyArXG4gICAgICAnYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgaW5zdGVhZDsgaXQgd2lsbCBzdGlsbCBiZSBhY2Nlc3NpYmxlIG9uIHRoZSAnICtcbiAgICAgICdjb25zdHJ1Y3Rvci4nLFxuICAgICAgbmFtZVxuICAgICkgOiBpbnZhcmlhbnQoIWlzUmVzZXJ2ZWQpKTtcblxuICAgIHZhciBpc0luaGVyaXRlZCA9IG5hbWUgaW4gQ29uc3RydWN0b3I7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICFpc0luaGVyaXRlZCxcbiAgICAgICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSAnICtcbiAgICAgICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSAnICtcbiAgICAgICdkdWUgdG8gYSBtaXhpbi4nLFxuICAgICAgbmFtZVxuICAgICkgOiBpbnZhcmlhbnQoIWlzSW5oZXJpdGVkKSk7XG4gICAgQ29uc3RydWN0b3JbbmFtZV0gPSBwcm9wZXJ0eTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvYmplY3RzLCBidXQgdGhyb3cgaWYgYm90aCBjb250YWluIHRoZSBzYW1lIGtleS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb25lIFRoZSBmaXJzdCBvYmplY3QsIHdoaWNoIGlzIG11dGF0ZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gdHdvIFRoZSBzZWNvbmQgb2JqZWN0XG4gKiBAcmV0dXJuIHtvYmplY3R9IG9uZSBhZnRlciBpdCBoYXMgYmVlbiBtdXRhdGVkIHRvIGNvbnRhaW4gZXZlcnl0aGluZyBpbiB0d28uXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0c1dpdGhOb0R1cGxpY2F0ZUtleXMob25lLCB0d28pIHtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBvbmUgJiYgdHdvICYmIHR5cGVvZiBvbmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0d28gPT09ICdvYmplY3QnLFxuICAgICdtZXJnZU9iamVjdHNXaXRoTm9EdXBsaWNhdGVLZXlzKCk6IENhbm5vdCBtZXJnZSBub24tb2JqZWN0cydcbiAgKSA6IGludmFyaWFudChvbmUgJiYgdHdvICYmIHR5cGVvZiBvbmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0d28gPT09ICdvYmplY3QnKSk7XG5cbiAgbWFwT2JqZWN0KHR3bywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBvbmVba2V5XSA9PT0gdW5kZWZpbmVkLFxuICAgICAgJ21lcmdlT2JqZWN0c1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogJyArXG4gICAgICAnVHJpZWQgdG8gbWVyZ2UgdHdvIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBrZXk6IGAlc2AuIFRoaXMgY29uZmxpY3QgJyArXG4gICAgICAnbWF5IGJlIGR1ZSB0byBhIG1peGluOyBpbiBwYXJ0aWN1bGFyLCB0aGlzIG1heSBiZSBjYXVzZWQgYnkgdHdvICcgK1xuICAgICAgJ2dldEluaXRpYWxTdGF0ZSgpIG9yIGdldERlZmF1bHRQcm9wcygpIG1ldGhvZHMgcmV0dXJuaW5nIG9iamVjdHMgJyArXG4gICAgICAnd2l0aCBjbGFzaGluZyBrZXlzLicsXG4gICAgICBrZXlcbiAgICApIDogaW52YXJpYW50KG9uZVtrZXldID09PSB1bmRlZmluZWQpKTtcbiAgICBvbmVba2V5XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIG9uZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIG1lcmdlcyB0aGVpciByZXR1cm4gdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkUmVzdWx0KCkge1xuICAgIHZhciBhID0gb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGIgPSB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9IGVsc2UgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZU9iamVjdHNXaXRoTm9EdXBsaWNhdGVLZXlzKGEsIGIpO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgaWdub3JlcyB0aGVpciByZXR1cm4gdmFsZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uKCkge1xuICAgIG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIGBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudGAgbWFpbnRhaW5zIGFuIGF1eGlsaWFyeSBsaWZlIGN5Y2xlIHN0YXRlIGluXG4gKiBgdGhpcy5fY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGVgICh3aGljaCBjYW4gYmUgbnVsbCkuXG4gKlxuICogVGhpcyBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgbGlmZSBjeWNsZSBzdGF0ZSBtYWludGFpbmVkIGJ5IGBSZWFjdENvbXBvbmVudGAgaW5cbiAqIGB0aGlzLl9saWZlQ3ljbGVTdGF0ZWAuIFRoZSBmb2xsb3dpbmcgZGlhZ3JhbSBzaG93cyBob3cgdGhlIHN0YXRlcyBvdmVybGFwIGluXG4gKiB0aW1lLiBUaGVyZSBhcmUgdGltZXMgd2hlbiB0aGUgQ29tcG9zaXRlTGlmZUN5Y2xlIGlzIG51bGwgLSBhdCB0aG9zZSB0aW1lcyBpdFxuICogaXMgb25seSBtZWFuaW5nZnVsIHRvIGxvb2sgYXQgQ29tcG9uZW50TGlmZUN5Y2xlIGFsb25lLlxuICpcbiAqIFRvcCBSb3c6IFJlYWN0Q29tcG9uZW50LkNvbXBvbmVudExpZmVDeWNsZVxuICogTG93IFJvdzogUmVhY3RDb21wb25lbnQuQ29tcG9zaXRlTGlmZUN5Y2xlXG4gKlxuICogKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tK1xuICogfCAgVU4gICB8ICAgICAgICAgICAgIE1PVU5URUQgICAgICAgICAgICAgfCAgIFVOICAgfFxuICogfE1PVU5URUR8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBNT1VOVEVEfFxuICogKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tK1xuICogfCAgICAgICBeLS0tLS0tLS0rICAgKy0tLS0tLS0rICAgKy0tLS0tLS0tXiAgICAgICAgfFxuICogfCAgICAgICB8ICAgICAgICB8ICAgfCAgICAgICB8ICAgfCAgICAgICAgfCAgICAgICAgfFxuICogfCAgICAwLS18TU9VTlRJTkd8LTAtfFJFQ0VJVkV8LTAtfCAgIFVOICAgfC0tLT4wICAgfFxuICogfCAgICAgICB8ICAgICAgICB8ICAgfFBST1BTICB8ICAgfE1PVU5USU5HfCAgICAgICAgfFxuICogfCAgICAgICB8ICAgICAgICB8ICAgfCAgICAgICB8ICAgfCAgICAgICAgfCAgICAgICAgfFxuICogfCAgICAgICB8ICAgICAgICB8ICAgfCAgICAgICB8ICAgfCAgICAgICAgfCAgICAgICAgfFxuICogfCAgICAgICArLS0tLS0tLS0rICAgKy0tLS0tLS0rICAgKy0tLS0tLS0tKyAgICAgICAgfFxuICogfCAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfFxuICogKy0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tK1xuICovXG52YXIgQ29tcG9zaXRlTGlmZUN5Y2xlID0ga2V5TWlycm9yKHtcbiAgLyoqXG4gICAqIENvbXBvbmVudHMgaW4gdGhlIHByb2Nlc3Mgb2YgYmVpbmcgbW91bnRlZCByZXNwb25kIHRvIHN0YXRlIGNoYW5nZXNcbiAgICogZGlmZmVyZW50bHkuXG4gICAqL1xuICBNT1VOVElORzogbnVsbCxcbiAgLyoqXG4gICAqIENvbXBvbmVudHMgaW4gdGhlIHByb2Nlc3Mgb2YgYmVpbmcgdW5tb3VudGVkIGFyZSBndWFyZGVkIGFnYWluc3Qgc3RhdGVcbiAgICogY2hhbmdlcy5cbiAgICovXG4gIFVOTU9VTlRJTkc6IG51bGwsXG4gIC8qKlxuICAgKiBDb21wb25lbnRzIHRoYXQgYXJlIG1vdW50ZWQgYW5kIHJlY2VpdmluZyBuZXcgcHJvcHMgcmVzcG9uZCB0byBzdGF0ZVxuICAgKiBjaGFuZ2VzIGRpZmZlcmVudGx5LlxuICAgKi9cbiAgUkVDRUlWSU5HX1BST1BTOiBudWxsXG59KTtcblxuLyoqXG4gKiBAbGVuZHMge1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LnByb3RvdHlwZX1cbiAqL1xudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIEJhc2UgY29uc3RydWN0b3IgZm9yIGFsbCBjb21wb3NpdGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAvLyBDaGlsZHJlbiBjYW4gYmUgZWl0aGVyIGFuIGFycmF5IG9yIG1vcmUgdGhhbiBvbmUgYXJndW1lbnRcbiAgICBSZWFjdENvbXBvbmVudC5NaXhpbi5jb25zdHJ1Y3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBSZWFjdE93bmVyLk1peGluLmNvbnN0cnVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlID0gbnVsbDtcblxuICAgIC8vIFRoaXMgaXMgdGhlIHB1YmxpYyBwb3N0LXByb2Nlc3NlZCBjb250ZXh0LiBUaGUgcmVhbCBjb250ZXh0IGFuZCBwZW5kaW5nXG4gICAgLy8gY29udGV4dCBsaXZlcyBvbiB0aGUgZWxlbWVudC5cbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuXG4gICAgdGhpcy5fY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUmVhY3RDb21wb25lbnQuTWl4aW4uaXNNb3VudGVkLmNhbGwodGhpcykgJiZcbiAgICAgIHRoaXMuX2NvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlICE9PSBDb21wb3NpdGVMaWZlQ3ljbGUuTU9VTlRJTkc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjb21wb25lbnQsIHJlbmRlcnMgbWFya3VwLCBhbmQgcmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtb3VudERlcHRoIG51bWJlciBvZiBjb21wb25lbnRzIGluIHRoZSBvd25lciBoaWVyYXJjaHlcbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IFJlYWN0UGVyZi5tZWFzdXJlKFxuICAgICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsXG4gICAgJ21vdW50Q29tcG9uZW50JyxcbiAgICBmdW5jdGlvbihyb290SUQsIHRyYW5zYWN0aW9uLCBtb3VudERlcHRoKSB7XG4gICAgICBSZWFjdENvbXBvbmVudC5NaXhpbi5tb3VudENvbXBvbmVudC5jYWxsKFxuICAgICAgICB0aGlzLFxuICAgICAgICByb290SUQsXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBtb3VudERlcHRoXG4gICAgICApO1xuICAgICAgdGhpcy5fY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgPSBDb21wb3NpdGVMaWZlQ3ljbGUuTU9VTlRJTkc7XG5cbiAgICAgIGlmICh0aGlzLl9fcmVhY3RBdXRvQmluZE1hcCkge1xuICAgICAgICB0aGlzLl9iaW5kQXV0b0JpbmRNZXRob2RzKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuX3Byb2Nlc3NDb250ZXh0KHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9jb250ZXh0KTtcbiAgICAgIHRoaXMucHJvcHMgPSB0aGlzLl9wcm9jZXNzUHJvcHModGhpcy5wcm9wcyk7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSA/IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCkgOiBudWxsO1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgdHlwZW9mIHRoaXMuc3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHRoaXMuc3RhdGUpLFxuICAgICAgICAnJXMuZ2V0SW5pdGlhbFN0YXRlKCk6IG11c3QgcmV0dXJuIGFuIG9iamVjdCBvciBudWxsJyxcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnXG4gICAgICApIDogaW52YXJpYW50KHR5cGVvZiB0aGlzLnN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh0aGlzLnN0YXRlKSkpO1xuXG4gICAgICB0aGlzLl9wZW5kaW5nU3RhdGUgPSBudWxsO1xuICAgICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudFdpbGxNb3VudCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgICAvLyBXaGVuIG1vdW50aW5nLCBjYWxscyB0byBgc2V0U3RhdGVgIGJ5IGBjb21wb25lbnRXaWxsTW91bnRgIHdpbGwgc2V0XG4gICAgICAgIC8vIGB0aGlzLl9wZW5kaW5nU3RhdGVgIHdpdGhvdXQgdHJpZ2dlcmluZyBhIHJlLXJlbmRlci5cbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZSkge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLl9wZW5kaW5nU3RhdGU7XG4gICAgICAgICAgdGhpcy5fcGVuZGluZ1N0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoXG4gICAgICAgIHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpLFxuICAgICAgICB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlIC8vIFRoZSB3cmFwcGluZyB0eXBlXG4gICAgICApO1xuXG4gICAgICAvLyBEb25lIHdpdGggbW91bnRpbmcsIGBzZXRTdGF0ZWAgd2lsbCBub3cgdHJpZ2dlciBVSSBjaGFuZ2VzLlxuICAgICAgdGhpcy5fY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgPSBudWxsO1xuICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50Lm1vdW50Q29tcG9uZW50KFxuICAgICAgICByb290SUQsXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBtb3VudERlcHRoICsgMVxuICAgICAgKTtcbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudERpZE1vdW50KSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodGhpcy5jb21wb25lbnREaWRNb3VudCwgdGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFya3VwO1xuICAgIH1cbiAgKSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgPSBDb21wb3NpdGVMaWZlQ3ljbGUuVU5NT1VOVElORztcbiAgICBpZiAodGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCkge1xuICAgICAgdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgIH1cbiAgICB0aGlzLl9jb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSA9IG51bGw7XG5cbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudC51bm1vdW50Q29tcG9uZW50KCk7XG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuXG4gICAgUmVhY3RDb21wb25lbnQuTWl4aW4udW5tb3VudENvbXBvbmVudC5jYWxsKHRoaXMpO1xuXG4gICAgLy8gU29tZSBleGlzdGluZyBjb21wb25lbnRzIHJlbHkgb24gdGhpcy5wcm9wcyBldmVuIGFmdGVyIHRoZXkndmUgYmVlblxuICAgIC8vIGRlc3Ryb3llZCAoaW4gZXZlbnQgaGFuZGxlcnMpLlxuICAgIC8vIFRPRE86IHRoaXMucHJvcHMgPSBudWxsO1xuICAgIC8vIFRPRE86IHRoaXMuc3RhdGUgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGByZXBsYWNlU3RhdGVgIHRvIG11dGF0ZVxuICAgKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gICAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICAgKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICAgKiBjb21wbGV0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBzZXRTdGF0ZTogZnVuY3Rpb24ocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCxcbiAgICAgICdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZS4nXG4gICAgKSA6IGludmFyaWFudCh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkpO1xuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpe1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoXG4gICAgICAgIHBhcnRpYWxTdGF0ZSAhPSBudWxsLFxuICAgICAgICAnc2V0U3RhdGUoLi4uKTogWW91IHBhc3NlZCBhbiB1bmRlZmluZWQgb3IgbnVsbCBzdGF0ZSBvYmplY3Q7ICcgK1xuICAgICAgICAnaW5zdGVhZCwgdXNlIGZvcmNlVXBkYXRlKCkuJ1xuICAgICAgKSA6IG51bGwpO1xuICAgIH1cbiAgICAvLyBNZXJnZSB3aXRoIGBfcGVuZGluZ1N0YXRlYCBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB3aXRoIGV4aXN0aW5nIHN0YXRlLlxuICAgIHRoaXMucmVwbGFjZVN0YXRlKFxuICAgICAgYXNzaWduKHt9LCB0aGlzLl9wZW5kaW5nU3RhdGUgfHwgdGhpcy5zdGF0ZSwgcGFydGlhbFN0YXRlKSxcbiAgICAgIGNhbGxiYWNrXG4gICAgKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICogQGZpbmFsXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHJlcGxhY2VTdGF0ZTogZnVuY3Rpb24oY29tcGxldGVTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICB2YWxpZGF0ZUxpZmVDeWNsZU9uUmVwbGFjZVN0YXRlKHRoaXMpO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZSA9IGNvbXBsZXRlU3RhdGU7XG4gICAgaWYgKHRoaXMuX2NvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlICE9PSBDb21wb3NpdGVMaWZlQ3ljbGUuTU9VTlRJTkcpIHtcbiAgICAgIC8vIElmIHdlJ3JlIGluIGEgY29tcG9uZW50V2lsbE1vdW50IGhhbmRsZXIsIGRvbid0IGVucXVldWUgYSByZXJlbmRlclxuICAgICAgLy8gYmVjYXVzZSBSZWFjdFVwZGF0ZXMgYXNzdW1lcyB3ZSdyZSBpbiBhIGJyb3dzZXIgY29udGV4dCAod2hpY2ggaXMgd3JvbmdcbiAgICAgIC8vIGZvciBzZXJ2ZXIgcmVuZGVyaW5nKSBhbmQgd2UncmUgYWJvdXQgdG8gZG8gYSByZW5kZXIgYW55d2F5LlxuICAgICAgLy8gVE9ETzogVGhlIGNhbGxiYWNrIGhlcmUgaXMgaWdub3JlZCB3aGVuIHNldFN0YXRlIGlzIGNhbGxlZCBmcm9tXG4gICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQuIEVpdGhlciBmaXggaXQgb3IgZGlzYWxsb3cgZG9pbmcgc28gY29tcGxldGVseSBpblxuICAgICAgLy8gZmF2b3Igb2YgZ2V0SW5pdGlhbFN0YXRlLlxuICAgICAgUmVhY3RVcGRhdGVzLmVucXVldWVVcGRhdGUodGhpcywgY2FsbGJhY2spO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgLCBhbmQgYXNzZXJ0cyB0aGF0IHRoZXkgYXJlIHZhbGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NDb250ZXh0OiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSBudWxsO1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSB0aGlzLmNvbnN0cnVjdG9yLmNvbnRleHRUeXBlcztcbiAgICBpZiAoY29udGV4dFR5cGVzKSB7XG4gICAgICBtYXNrZWRDb250ZXh0ID0ge307XG4gICAgICBmb3IgKHZhciBjb250ZXh0TmFtZSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICAgICAgbWFza2VkQ29udGV4dFtjb250ZXh0TmFtZV0gPSBjb250ZXh0W2NvbnRleHROYW1lXTtcbiAgICAgIH1cbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tQcm9wVHlwZXMoXG4gICAgICAgICAgY29udGV4dFR5cGVzLFxuICAgICAgICAgIG1hc2tlZENvbnRleHQsXG4gICAgICAgICAgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY3VycmVudENvbnRleHRcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NDaGlsZENvbnRleHQ6IGZ1bmN0aW9uKGN1cnJlbnRDb250ZXh0KSB7XG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IHRoaXMuZ2V0Q2hpbGRDb250ZXh0ICYmIHRoaXMuZ2V0Q2hpbGRDb250ZXh0KCk7XG4gICAgdmFyIGRpc3BsYXlOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnO1xuICAgIGlmIChjaGlsZENvbnRleHQpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0JyxcbiAgICAgICAgJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArXG4gICAgICAgICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJyxcbiAgICAgICAgZGlzcGxheU5hbWVcbiAgICAgICkgOiBpbnZhcmlhbnQodHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnKSk7XG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUHJvcFR5cGVzKFxuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMsXG4gICAgICAgICAgY2hpbGRDb250ZXh0LFxuICAgICAgICAgIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY2hpbGRDb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICAgIG5hbWUgaW4gdGhpcy5jb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyxcbiAgICAgICAgICAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJyxcbiAgICAgICAgICBkaXNwbGF5TmFtZSxcbiAgICAgICAgICBuYW1lXG4gICAgICAgICkgOiBpbnZhcmlhbnQobmFtZSBpbiB0aGlzLmNvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXNzaWduKHt9LCBjdXJyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgcHJvcHMgYnkgc2V0dGluZyBkZWZhdWx0IHZhbHVlcyBmb3IgdW5zcGVjaWZpZWQgcHJvcHMgYW5kXG4gICAqIGFzc2VydGluZyB0aGF0IHRoZSBwcm9wcyBhcmUgdmFsaWQuIERvZXMgbm90IG11dGF0ZSBpdHMgYXJndW1lbnQ7IHJldHVybnNcbiAgICogYSBuZXcgcHJvcHMgb2JqZWN0IHdpdGggZGVmYXVsdHMgbWVyZ2VkIGluLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV3UHJvcHNcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NQcm9wczogZnVuY3Rpb24obmV3UHJvcHMpIHtcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICB2YXIgcHJvcFR5cGVzID0gdGhpcy5jb25zdHJ1Y3Rvci5wcm9wVHlwZXM7XG4gICAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgbmV3UHJvcHMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdQcm9wcztcbiAgfSxcblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcFR5cGVzIE1hcCBvZiBwcm9wIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tQcm9wVHlwZXM6IGZ1bmN0aW9uKHByb3BUeXBlcywgcHJvcHMsIGxvY2F0aW9uKSB7XG4gICAgLy8gVE9ETzogU3RvcCB2YWxpZGF0aW5nIHByb3AgdHlwZXMgaGVyZSBhbmQgb25seSB1c2UgdGhlIGVsZW1lbnRcbiAgICAvLyB2YWxpZGF0aW9uLlxuICAgIHZhciBjb21wb25lbnROYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciA9XG4gICAgICAgICAgcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAvLyBXZSBtYXkgd2FudCB0byBleHRlbmQgdGhpcyBsb2dpYyBmb3Igc2ltaWxhciBlcnJvcnMgaW5cbiAgICAgICAgICAvLyByZW5kZXJDb21wb25lbnQgY2FsbHMsIHNvIEknbSBhYnN0cmFjdGluZyBpdCBhd2F5IGludG9cbiAgICAgICAgICAvLyBhIGZ1bmN0aW9uIHRvIG1pbmltaXplIHJlZmFjdG9yaW5nIGluIHRoZSBmdXR1cmVcbiAgICAgICAgICB2YXIgYWRkZW5kdW0gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0odGhpcyk7XG4gICAgICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsIGVycm9yLm1lc3NhZ2UgKyBhZGRlbmR1bSkgOiBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSWYgYW55IG9mIGBfcGVuZGluZ0VsZW1lbnRgLCBgX3BlbmRpbmdTdGF0ZWAsIG9yIGBfcGVuZGluZ0ZvcmNlVXBkYXRlYFxuICAgKiBpcyBzZXQsIHVwZGF0ZSB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBmdW5jdGlvbih0cmFuc2FjdGlvbikge1xuICAgIHZhciBjb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSA9IHRoaXMuX2NvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlO1xuICAgIC8vIERvIG5vdCB0cmlnZ2VyIGEgc3RhdGUgdHJhbnNpdGlvbiBpZiB3ZSBhcmUgaW4gdGhlIG1pZGRsZSBvZiBtb3VudGluZyBvclxuICAgIC8vIHJlY2VpdmluZyBwcm9wcyBiZWNhdXNlIGJvdGggb2YgdGhvc2Ugd2lsbCBhbHJlYWR5IGJlIGRvaW5nIHRoaXMuXG4gICAgaWYgKGNvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlID09PSBDb21wb3NpdGVMaWZlQ3ljbGUuTU9VTlRJTkcgfHxcbiAgICAgICAgY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgPT09IENvbXBvc2l0ZUxpZmVDeWNsZS5SRUNFSVZJTkdfUFJPUFMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGVuZGluZ0VsZW1lbnQgPT0gbnVsbCAmJlxuICAgICAgICB0aGlzLl9wZW5kaW5nU3RhdGUgPT0gbnVsbCAmJlxuICAgICAgICAhdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRDb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIHZhciBuZXh0UHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBuZXh0RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIGlmICh0aGlzLl9wZW5kaW5nRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICBuZXh0RWxlbWVudCA9IHRoaXMuX3BlbmRpbmdFbGVtZW50O1xuICAgICAgbmV4dENvbnRleHQgPSB0aGlzLl9wcm9jZXNzQ29udGV4dChuZXh0RWxlbWVudC5fY29udGV4dCk7XG4gICAgICBuZXh0UHJvcHMgPSB0aGlzLl9wcm9jZXNzUHJvcHMobmV4dEVsZW1lbnQucHJvcHMpO1xuICAgICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgICB0aGlzLl9jb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSA9IENvbXBvc2l0ZUxpZmVDeWNsZS5SRUNFSVZJTkdfUFJPUFM7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSA9IG51bGw7XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gdGhpcy5fcGVuZGluZ1N0YXRlIHx8IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlID0gbnVsbDtcblxuICAgIHZhciBzaG91bGRVcGRhdGUgPVxuICAgICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlIHx8XG4gICAgICAhdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgfHxcbiAgICAgIHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICBpZiAodHlwZW9mIHNob3VsZFVwZGF0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgKHRoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgK1xuICAgICAgICAgICcuc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk6IFJldHVybmVkIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgJyArXG4gICAgICAgICAgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG4gICAgICAvLyBXaWxsIHNldCBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAuXG4gICAgICB0aGlzLl9wZXJmb3JtQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICBuZXh0RWxlbWVudCxcbiAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICBuZXh0U3RhdGUsXG4gICAgICAgIG5leHRDb250ZXh0LFxuICAgICAgICB0cmFuc2FjdGlvblxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgaXQncyBkZXRlcm1pbmVkIHRoYXQgYSBjb21wb25lbnQgc2hvdWxkIG5vdCB1cGRhdGUsIHdlIHN0aWxsIHdhbnRcbiAgICAgIC8vIHRvIHNldCBwcm9wcyBhbmQgc3RhdGUuXG4gICAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgICAgdGhpcy5wcm9wcyA9IG5leHRQcm9wcztcbiAgICAgIHRoaXMuc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICB0aGlzLmNvbnRleHQgPSBuZXh0Q29udGV4dDtcblxuICAgICAgLy8gT3duZXIgY2Fubm90IGNoYW5nZSBiZWNhdXNlIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50IGRvZXNuJ3QgYWxsb3dcbiAgICAgIC8vIGl0LiBUT0RPOiBSZW1vdmUgdGhpcy5fb3duZXIgY29tcGxldGVseS5cbiAgICAgIHRoaXMuX293bmVyID0gbmV4dEVsZW1lbnQuX293bmVyO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTWVyZ2VzIG5ldyBwcm9wcyBhbmQgc3RhdGUsIG5vdGlmaWVzIGRlbGVnYXRlIG1ldGhvZHMgb2YgdXBkYXRlIGFuZFxuICAgKiBwZXJmb3JtcyB1cGRhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBOZXh0IGVsZW1lbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wcyBOZXh0IHB1YmxpYyBvYmplY3QgdG8gc2V0IGFzIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlIE5leHQgb2JqZWN0IHRvIHNldCBhcyBzdGF0ZS5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dCBOZXh0IHB1YmxpYyBvYmplY3QgdG8gc2V0IGFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wZXJmb3JtQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbihcbiAgICBuZXh0RWxlbWVudCxcbiAgICBuZXh0UHJvcHMsXG4gICAgbmV4dFN0YXRlLFxuICAgIG5leHRDb250ZXh0LFxuICAgIHRyYW5zYWN0aW9uXG4gICkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBwcmV2UHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwcmV2U3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBwcmV2Q29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgIGlmICh0aGlzLmNvbXBvbmVudFdpbGxVcGRhdGUpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgdGhpcy5wcm9wcyA9IG5leHRQcm9wcztcbiAgICB0aGlzLnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIHRoaXMuY29udGV4dCA9IG5leHRDb250ZXh0O1xuXG4gICAgLy8gT3duZXIgY2Fubm90IGNoYW5nZSBiZWNhdXNlIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50IGRvZXNuJ3QgYWxsb3dcbiAgICAvLyBpdC4gVE9ETzogUmVtb3ZlIHRoaXMuX293bmVyIGNvbXBsZXRlbHkuXG4gICAgdGhpcy5fb3duZXIgPSBuZXh0RWxlbWVudC5fb3duZXI7XG5cbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudChcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgcHJldkVsZW1lbnRcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuY29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKFxuICAgICAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZS5iaW5kKHRoaXMsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbikge1xuICAgIGlmIChuZXh0RWxlbWVudCA9PT0gdGhpcy5fY3VycmVudEVsZW1lbnQgJiZcbiAgICAgICAgbmV4dEVsZW1lbnQuX293bmVyICE9IG51bGwpIHtcbiAgICAgIC8vIFNpbmNlIGVsZW1lbnRzIGFyZSBpbW11dGFibGUgYWZ0ZXIgdGhlIG93bmVyIGlzIHJlbmRlcmVkLFxuICAgICAgLy8gd2UgY2FuIGRvIGEgY2hlYXAgaWRlbnRpdHkgY29tcGFyZSBoZXJlIHRvIGRldGVybWluZSBpZiB0aGlzIGlzIGFcbiAgICAgIC8vIHN1cGVyZmx1b3VzIHJlY29uY2lsZS4gSXQncyBwb3NzaWJsZSBmb3Igc3RhdGUgdG8gYmUgbXV0YWJsZSBidXQgc3VjaFxuICAgICAgLy8gY2hhbmdlIHNob3VsZCB0cmlnZ2VyIGFuIHVwZGF0ZSBvZiB0aGUgb3duZXIgd2hpY2ggd291bGQgcmVjcmVhdGVcbiAgICAgIC8vIHRoZSBlbGVtZW50LiBXZSBleHBsaWNpdGx5IGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIGFuIG93bmVyIHNpbmNlXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIGZvciBhIGVsZW1lbnQgY3JlYXRlZCBvdXRzaWRlIGEgY29tcG9zaXRlIHRvIGJlXG4gICAgICAvLyBkZWVwbHkgbXV0YXRlZCBhbmQgcmV1c2VkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIFJlYWN0Q29tcG9uZW50Lk1peGluLnJlY2VpdmVDb21wb25lbnQuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICBuZXh0RWxlbWVudCxcbiAgICAgIHRyYW5zYWN0aW9uXG4gICAgKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50J3MgY3VycmVudGx5IG1vdW50ZWQgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JyxcbiAgICAndXBkYXRlQ29tcG9uZW50JyxcbiAgICBmdW5jdGlvbih0cmFuc2FjdGlvbiwgcHJldlBhcmVudEVsZW1lbnQpIHtcbiAgICAgIFJlYWN0Q29tcG9uZW50Lk1peGluLnVwZGF0ZUNvbXBvbmVudC5jYWxsKFxuICAgICAgICB0aGlzLFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgcHJldlBhcmVudEVsZW1lbnRcbiAgICAgICk7XG5cbiAgICAgIHZhciBwcmV2Q29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLl9yZW5kZXJlZENvbXBvbmVudDtcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZDb21wb25lbnRJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIHByZXZDb21wb25lbnRJbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50KG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGVzZSB0d28gSURzIGFyZSBhY3R1YWxseSB0aGUgc2FtZSEgQnV0IG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhhdC5cbiAgICAgICAgdmFyIHRoaXNJRCA9IHRoaXMuX3Jvb3ROb2RlSUQ7XG4gICAgICAgIHZhciBwcmV2Q29tcG9uZW50SUQgPSBwcmV2Q29tcG9uZW50SW5zdGFuY2UuX3Jvb3ROb2RlSUQ7XG4gICAgICAgIHByZXZDb21wb25lbnRJbnN0YW5jZS51bm1vdW50Q29tcG9uZW50KCk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChcbiAgICAgICAgICBuZXh0RWxlbWVudCxcbiAgICAgICAgICB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlXG4gICAgICAgICk7XG4gICAgICAgIHZhciBuZXh0TWFya3VwID0gdGhpcy5fcmVuZGVyZWRDb21wb25lbnQubW91bnRDb21wb25lbnQoXG4gICAgICAgICAgdGhpc0lELFxuICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgIHRoaXMuX21vdW50RGVwdGggKyAxXG4gICAgICAgICk7XG4gICAgICAgIFJlYWN0Q29tcG9uZW50LkJhY2tlbmRJRE9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEKFxuICAgICAgICAgIHByZXZDb21wb25lbnRJRCxcbiAgICAgICAgICBuZXh0TWFya3VwXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICApLFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkVXBkYXRlQ29tcG9uZW50YCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICAgKiBAZmluYWxcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIGNvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlID0gdGhpcy5fY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGU7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIHRoaXMuaXNNb3VudGVkKCkgfHxcbiAgICAgICAgY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgPT09IENvbXBvc2l0ZUxpZmVDeWNsZS5NT1VOVElORyxcbiAgICAgICdmb3JjZVVwZGF0ZSguLi4pOiBDYW4gb25seSBmb3JjZSBhbiB1cGRhdGUgb24gbW91bnRlZCBvciBtb3VudGluZyAnICtcbiAgICAgICAgJ2NvbXBvbmVudHMuJ1xuICAgICkgOiBpbnZhcmlhbnQodGhpcy5pc01vdW50ZWQoKSB8fFxuICAgICAgY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgPT09IENvbXBvc2l0ZUxpZmVDeWNsZS5NT1VOVElORykpO1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBjb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSAhPT0gQ29tcG9zaXRlTGlmZUN5Y2xlLlVOTU9VTlRJTkcgJiZcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCxcbiAgICAgICdmb3JjZVVwZGF0ZSguLi4pOiBDYW5ub3QgZm9yY2UgYW4gdXBkYXRlIHdoaWxlIHVubW91bnRpbmcgY29tcG9uZW50ICcgK1xuICAgICAgJ29yIHdpdGhpbiBhIGByZW5kZXJgIGZ1bmN0aW9uLidcbiAgICApIDogaW52YXJpYW50KGNvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlICE9PSBDb21wb3NpdGVMaWZlQ3ljbGUuVU5NT1VOVElORyAmJlxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCkpO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgUmVhY3RVcGRhdGVzLmVucXVldWVVcGRhdGUodGhpcywgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudDogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JyxcbiAgICAnX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCcsXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgICB2YXIgcHJldmlvdXNDb250ZXh0ID0gUmVhY3RDb250ZXh0LmN1cnJlbnQ7XG4gICAgICBSZWFjdENvbnRleHQuY3VycmVudCA9IHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoXG4gICAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9jb250ZXh0XG4gICAgICApO1xuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XG4gICAgICB0cnkge1xuICAgICAgICByZW5kZXJlZENvbXBvbmVudCA9IHRoaXMucmVuZGVyKCk7XG4gICAgICAgIGlmIChyZW5kZXJlZENvbXBvbmVudCA9PT0gbnVsbCB8fCByZW5kZXJlZENvbXBvbmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZW5kZXJlZENvbXBvbmVudCA9IFJlYWN0RW1wdHlDb21wb25lbnQuZ2V0RW1wdHlDb21wb25lbnQoKTtcbiAgICAgICAgICBSZWFjdEVtcHR5Q29tcG9uZW50LnJlZ2lzdGVyTnVsbENvbXBvbmVudElEKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFJlYWN0RW1wdHlDb21wb25lbnQuZGVyZWdpc3Rlck51bGxDb21wb25lbnRJRCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDb250ZXh0LmN1cnJlbnQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHJlbmRlcmVkQ29tcG9uZW50KSxcbiAgICAgICAgJyVzLnJlbmRlcigpOiBBIHZhbGlkIFJlYWN0Q29tcG9uZW50IG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSAnICtcbiAgICAgICAgICAncmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50J1xuICAgICAgKSA6IGludmFyaWFudChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocmVuZGVyZWRDb21wb25lbnQpKSk7XG4gICAgICByZXR1cm4gcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgfVxuICApLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2JpbmRBdXRvQmluZE1ldGhvZHM6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGF1dG9CaW5kS2V5IGluIHRoaXMuX19yZWFjdEF1dG9CaW5kTWFwKSB7XG4gICAgICBpZiAoIXRoaXMuX19yZWFjdEF1dG9CaW5kTWFwLmhhc093blByb3BlcnR5KGF1dG9CaW5kS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtZXRob2QgPSB0aGlzLl9fcmVhY3RBdXRvQmluZE1hcFthdXRvQmluZEtleV07XG4gICAgICB0aGlzW2F1dG9CaW5kS2V5XSA9IHRoaXMuX2JpbmRBdXRvQmluZE1ldGhvZChSZWFjdEVycm9yVXRpbHMuZ3VhcmQoXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSArICcuJyArIGF1dG9CaW5kS2V5XG4gICAgICApKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJpbmRzIGEgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZXRob2QgdG8gYmUgYm91bmQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYmluZEF1dG9CaW5kTWV0aG9kOiBmdW5jdGlvbihtZXRob2QpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcztcbiAgICB2YXIgYm91bmRNZXRob2QgPSBtZXRob2QuYmluZChjb21wb25lbnQpO1xuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuY29uc3RydWN0b3IuZGlzcGxheU5hbWU7XG4gICAgICB2YXIgX2JpbmQgPSBib3VuZE1ldGhvZC5iaW5kO1xuICAgICAgYm91bmRNZXRob2QuYmluZCA9IGZ1bmN0aW9uKG5ld1RoaXMgKSB7Zm9yICh2YXIgYXJncz1bXSwkX18wPTEsJF9fMT1hcmd1bWVudHMubGVuZ3RoOyRfXzA8JF9fMTskX18wKyspIGFyZ3MucHVzaChhcmd1bWVudHNbJF9fMF0pO1xuICAgICAgICAvLyBVc2VyIGlzIHRyeWluZyB0byBiaW5kKCkgYW4gYXV0b2JvdW5kIG1ldGhvZDsgd2UgZWZmZWN0aXZlbHkgd2lsbFxuICAgICAgICAvLyBpZ25vcmUgdGhlIHZhbHVlIG9mIFwidGhpc1wiIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSwgc29cbiAgICAgICAgLy8gbGV0J3Mgd2Fybi5cbiAgICAgICAgaWYgKG5ld1RoaXMgIT09IGNvbXBvbmVudCAmJiBuZXdUaGlzICE9PSBudWxsKSB7XG4gICAgICAgICAgbW9uaXRvckNvZGVVc2UoJ3JlYWN0X2JpbmRfd2FybmluZycsIHsgY29tcG9uZW50OiBjb21wb25lbnROYW1lIH0pO1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdiaW5kKCk6IFJlYWN0IGNvbXBvbmVudCBtZXRob2RzIG1heSBvbmx5IGJlIGJvdW5kIHRvIHRoZSAnICtcbiAgICAgICAgICAgICdjb21wb25lbnQgaW5zdGFuY2UuIFNlZSAnICsgY29tcG9uZW50TmFtZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgbW9uaXRvckNvZGVVc2UoJ3JlYWN0X2JpbmRfd2FybmluZycsIHsgY29tcG9uZW50OiBjb21wb25lbnROYW1lIH0pO1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdiaW5kKCk6IFlvdSBhcmUgYmluZGluZyBhIGNvbXBvbmVudCBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC4gJyArXG4gICAgICAgICAgICAnUmVhY3QgZG9lcyB0aGlzIGZvciB5b3UgYXV0b21hdGljYWxseSBpbiBhIGhpZ2gtcGVyZm9ybWFuY2UgJyArXG4gICAgICAgICAgICAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJyArIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBib3VuZE1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVib3VuZE1ldGhvZCA9IF9iaW5kLmFwcGx5KGJvdW5kTWV0aG9kLCBhcmd1bWVudHMpO1xuICAgICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgIHJldHVybiByZWJvdW5kTWV0aG9kO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICB9XG59O1xuXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnRCYXNlID0gZnVuY3Rpb24oKSB7fTtcbmFzc2lnbihcbiAgUmVhY3RDb21wb3NpdGVDb21wb25lbnRCYXNlLnByb3RvdHlwZSxcbiAgUmVhY3RDb21wb25lbnQuTWl4aW4sXG4gIFJlYWN0T3duZXIuTWl4aW4sXG4gIFJlYWN0UHJvcFRyYW5zZmVyZXIuTWl4aW4sXG4gIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW5cbik7XG5cbi8qKlxuICogTW9kdWxlIGZvciBjcmVhdGluZyBjb21wb3NpdGUgY29tcG9uZW50cy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RDb21wb3NpdGVDb21wb25lbnRcbiAqIEBleHRlbmRzIFJlYWN0Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdE93bmVyXG4gKiBAZXh0ZW5kcyBSZWFjdFByb3BUcmFuc2ZlcmVyXG4gKi9cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHtcblxuICBMaWZlQ3ljbGU6IENvbXBvc2l0ZUxpZmVDeWNsZSxcblxuICBCYXNlOiBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudEJhc2UsXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgY29tcG9uZW50IGNsYXNzIGdpdmVuIGEgY2xhc3Mgc3BlY2lmaWNhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHNwZWMgQ2xhc3Mgc3BlY2lmaWNhdGlvbiAod2hpY2ggbXVzdCBkZWZpbmUgYHJlbmRlcmApLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gQ29tcG9uZW50IGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjcmVhdGVDbGFzczogZnVuY3Rpb24oc3BlYykge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICAvLyBUaGlzIGNvbnN0cnVjdG9yIGlzIG92ZXJyaWRkZW4gYnkgbW9ja3MuIFRoZSBhcmd1bWVudCBpcyB1c2VkXG4gICAgICAvLyBieSBtb2NrcyB0byBhc3NlcnQgb24gd2hhdCBnZXRzIG1vdW50ZWQuIFRoaXMgd2lsbCBsYXRlciBiZSB1c2VkXG4gICAgICAvLyBieSB0aGUgc3RhbmQtYWxvbmUgY2xhc3MgaW1wbGVtZW50YXRpb24uXG4gICAgfTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgUmVhY3RDb21wb3NpdGVDb21wb25lbnRCYXNlKCk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG5cbiAgICBpbmplY3RlZE1peGlucy5mb3JFYWNoKFxuICAgICAgbWl4U3BlY0ludG9Db21wb25lbnQuYmluZChudWxsLCBDb25zdHJ1Y3RvcilcbiAgICApO1xuXG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGVmYXVsdFByb3BzIHByb3BlcnR5IGFmdGVyIGFsbCBtaXhpbnMgaGF2ZSBiZWVuIG1lcmdlZFxuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcyA9IENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcygpO1xuICAgIH1cblxuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUucmVuZGVyLFxuICAgICAgJ2NyZWF0ZUNsYXNzKC4uLik6IENsYXNzIHNwZWNpZmljYXRpb24gbXVzdCBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuJ1xuICAgICkgOiBpbnZhcmlhbnQoQ29uc3RydWN0b3IucHJvdG90eXBlLnJlbmRlcikpO1xuXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgaWYgKENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRTaG91bGRVcGRhdGUpIHtcbiAgICAgICAgbW9uaXRvckNvZGVVc2UoXG4gICAgICAgICAgJ3JlYWN0X2NvbXBvbmVudF9zaG91bGRfdXBkYXRlX3dhcm5pbmcnLFxuICAgICAgICAgIHsgY29tcG9uZW50OiBzcGVjLmRpc3BsYXlOYW1lIH1cbiAgICAgICAgKTtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIChzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpICsgJyBoYXMgYSBtZXRob2QgY2FsbGVkICcgK1xuICAgICAgICAgICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICtcbiAgICAgICAgICAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgK1xuICAgICAgICAgICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nXG4gICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlZHVjZSB0aW1lIHNwZW50IGRvaW5nIGxvb2t1cHMgYnkgc2V0dGluZyB0aGVzZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gUmVhY3RDb21wb3NpdGVDb21wb25lbnRJbnRlcmZhY2UpIHtcbiAgICAgIGlmICghQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgcmV0dXJuIFJlYWN0TGVnYWN5RWxlbWVudC53cmFwRmFjdG9yeShcbiAgICAgICAgUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3RvcnkoQ29uc3RydWN0b3IpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY3RMZWdhY3lFbGVtZW50LndyYXBGYWN0b3J5KFxuICAgICAgUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkoQ29uc3RydWN0b3IpXG4gICAgKTtcbiAgfSxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RNaXhpbjogZnVuY3Rpb24obWl4aW4pIHtcbiAgICAgIGluamVjdGVkTWl4aW5zLnB1c2gobWl4aW4pO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29udGV4dFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBjb250ZXh0LlxuICpcbiAqIFRoZSBjb250ZXh0IGlzIGF1dG9tYXRpY2FsbHkgcGFzc2VkIGRvd24gdGhlIGNvbXBvbmVudCBvd25lcnNoaXAgaGllcmFyY2h5XG4gKiBhbmQgaXMgYWNjZXNzaWJsZSB2aWEgYHRoaXMuY29udGV4dGAgb24gUmVhY3RDb21wb3NpdGVDb21wb25lbnRzLlxuICovXG52YXIgUmVhY3RDb250ZXh0ID0ge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge29iamVjdH1cbiAgICovXG4gIGN1cnJlbnQ6IHt9LFxuXG4gIC8qKlxuICAgKiBUZW1wb3JhcmlseSBleHRlbmRzIHRoZSBjdXJyZW50IGNvbnRleHQgd2hpbGUgZXhlY3V0aW5nIHNjb3BlZENhbGxiYWNrLlxuICAgKlxuICAgKiBBIHR5cGljYWwgdXNlIGNhc2UgbWlnaHQgbG9vayBsaWtlXG4gICAqXG4gICAqICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgKiAgICB2YXIgY2hpbGRyZW4gPSBSZWFjdENvbnRleHQud2l0aENvbnRleHQoe2ZvbzogJ2Zvbyd9LCAoKSA9PiAoXG4gICAqXG4gICAqICAgICkpO1xuICAgKiAgICByZXR1cm4gPGRpdj57Y2hpbGRyZW59PC9kaXY+O1xuICAgKiAgfVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV3Q29udGV4dCBOZXcgY29udGV4dCB0byBtZXJnZSBpbnRvIHRoZSBleGlzdGluZyBjb250ZXh0XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHNjb3BlZENhbGxiYWNrIENhbGxiYWNrIHRvIHJ1biB3aXRoIHRoZSBuZXcgY29udGV4dFxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudHxhcnJheTxSZWFjdENvbXBvbmVudD59XG4gICAqL1xuICB3aXRoQ29udGV4dDogZnVuY3Rpb24obmV3Q29udGV4dCwgc2NvcGVkQ2FsbGJhY2spIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBwcmV2aW91c0NvbnRleHQgPSBSZWFjdENvbnRleHQuY3VycmVudDtcbiAgICBSZWFjdENvbnRleHQuY3VycmVudCA9IGFzc2lnbih7fSwgcHJldmlvdXNDb250ZXh0LCBuZXdDb250ZXh0KTtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gc2NvcGVkQ2FsbGJhY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDb250ZXh0LmN1cnJlbnQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbnRleHQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDdXJyZW50T3duZXJcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKlxuICogVGhlIGRlcHRoIGluZGljYXRlIGhvdyBtYW55IGNvbXBvc2l0ZSBjb21wb25lbnRzIGFyZSBhYm92ZSB0aGlzIHJlbmRlciBsZXZlbC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q3VycmVudE93bmVyO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3JcIik7XG52YXIgUmVhY3RMZWdhY3lFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RMZWdhY3lFbGVtZW50XCIpO1xuXG52YXIgbWFwT2JqZWN0ID0gcmVxdWlyZShcIi4vbWFwT2JqZWN0XCIpO1xuXG4vKipcbiAqIENyZWF0ZSBhIGZhY3RvcnkgdGhhdCBjcmVhdGVzIEhUTUwgdGFnIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGFnIG5hbWUgKGUuZy4gYGRpdmApLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRE9NRmFjdG9yeSh0YWcpIHtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIHJldHVybiBSZWFjdExlZ2FjeUVsZW1lbnQubWFya05vbkxlZ2FjeUZhY3RvcnkoXG4gICAgICBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeSh0YWcpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gUmVhY3RMZWdhY3lFbGVtZW50Lm1hcmtOb25MZWdhY3lGYWN0b3J5KFxuICAgIFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5KHRhZylcbiAgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwcGluZyBmcm9tIHN1cHBvcnRlZCBIVE1MIHRhZ3MgdG8gYFJlYWN0RE9NQ29tcG9uZW50YCBjbGFzc2VzLlxuICogVGhpcyBpcyBhbHNvIGFjY2Vzc2libGUgdmlhIGBSZWFjdC5ET01gLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlYWN0RE9NID0gbWFwT2JqZWN0KHtcbiAgYTogJ2EnLFxuICBhYmJyOiAnYWJicicsXG4gIGFkZHJlc3M6ICdhZGRyZXNzJyxcbiAgYXJlYTogJ2FyZWEnLFxuICBhcnRpY2xlOiAnYXJ0aWNsZScsXG4gIGFzaWRlOiAnYXNpZGUnLFxuICBhdWRpbzogJ2F1ZGlvJyxcbiAgYjogJ2InLFxuICBiYXNlOiAnYmFzZScsXG4gIGJkaTogJ2JkaScsXG4gIGJkbzogJ2JkbycsXG4gIGJpZzogJ2JpZycsXG4gIGJsb2NrcXVvdGU6ICdibG9ja3F1b3RlJyxcbiAgYm9keTogJ2JvZHknLFxuICBicjogJ2JyJyxcbiAgYnV0dG9uOiAnYnV0dG9uJyxcbiAgY2FudmFzOiAnY2FudmFzJyxcbiAgY2FwdGlvbjogJ2NhcHRpb24nLFxuICBjaXRlOiAnY2l0ZScsXG4gIGNvZGU6ICdjb2RlJyxcbiAgY29sOiAnY29sJyxcbiAgY29sZ3JvdXA6ICdjb2xncm91cCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0YWxpc3Q6ICdkYXRhbGlzdCcsXG4gIGRkOiAnZGQnLFxuICBkZWw6ICdkZWwnLFxuICBkZXRhaWxzOiAnZGV0YWlscycsXG4gIGRmbjogJ2RmbicsXG4gIGRpYWxvZzogJ2RpYWxvZycsXG4gIGRpdjogJ2RpdicsXG4gIGRsOiAnZGwnLFxuICBkdDogJ2R0JyxcbiAgZW06ICdlbScsXG4gIGVtYmVkOiAnZW1iZWQnLFxuICBmaWVsZHNldDogJ2ZpZWxkc2V0JyxcbiAgZmlnY2FwdGlvbjogJ2ZpZ2NhcHRpb24nLFxuICBmaWd1cmU6ICdmaWd1cmUnLFxuICBmb290ZXI6ICdmb290ZXInLFxuICBmb3JtOiAnZm9ybScsXG4gIGgxOiAnaDEnLFxuICBoMjogJ2gyJyxcbiAgaDM6ICdoMycsXG4gIGg0OiAnaDQnLFxuICBoNTogJ2g1JyxcbiAgaDY6ICdoNicsXG4gIGhlYWQ6ICdoZWFkJyxcbiAgaGVhZGVyOiAnaGVhZGVyJyxcbiAgaHI6ICdocicsXG4gIGh0bWw6ICdodG1sJyxcbiAgaTogJ2knLFxuICBpZnJhbWU6ICdpZnJhbWUnLFxuICBpbWc6ICdpbWcnLFxuICBpbnB1dDogJ2lucHV0JyxcbiAgaW5zOiAnaW5zJyxcbiAga2JkOiAna2JkJyxcbiAga2V5Z2VuOiAna2V5Z2VuJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxlZ2VuZDogJ2xlZ2VuZCcsXG4gIGxpOiAnbGknLFxuICBsaW5rOiAnbGluaycsXG4gIG1haW46ICdtYWluJyxcbiAgbWFwOiAnbWFwJyxcbiAgbWFyazogJ21hcmsnLFxuICBtZW51OiAnbWVudScsXG4gIG1lbnVpdGVtOiAnbWVudWl0ZW0nLFxuICBtZXRhOiAnbWV0YScsXG4gIG1ldGVyOiAnbWV0ZXInLFxuICBuYXY6ICduYXYnLFxuICBub3NjcmlwdDogJ25vc2NyaXB0JyxcbiAgb2JqZWN0OiAnb2JqZWN0JyxcbiAgb2w6ICdvbCcsXG4gIG9wdGdyb3VwOiAnb3B0Z3JvdXAnLFxuICBvcHRpb246ICdvcHRpb24nLFxuICBvdXRwdXQ6ICdvdXRwdXQnLFxuICBwOiAncCcsXG4gIHBhcmFtOiAncGFyYW0nLFxuICBwaWN0dXJlOiAncGljdHVyZScsXG4gIHByZTogJ3ByZScsXG4gIHByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICBxOiAncScsXG4gIHJwOiAncnAnLFxuICBydDogJ3J0JyxcbiAgcnVieTogJ3J1YnknLFxuICBzOiAncycsXG4gIHNhbXA6ICdzYW1wJyxcbiAgc2NyaXB0OiAnc2NyaXB0JyxcbiAgc2VjdGlvbjogJ3NlY3Rpb24nLFxuICBzZWxlY3Q6ICdzZWxlY3QnLFxuICBzbWFsbDogJ3NtYWxsJyxcbiAgc291cmNlOiAnc291cmNlJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzdHJvbmc6ICdzdHJvbmcnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3ViOiAnc3ViJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICBzdXA6ICdzdXAnLFxuICB0YWJsZTogJ3RhYmxlJyxcbiAgdGJvZHk6ICd0Ym9keScsXG4gIHRkOiAndGQnLFxuICB0ZXh0YXJlYTogJ3RleHRhcmVhJyxcbiAgdGZvb3Q6ICd0Zm9vdCcsXG4gIHRoOiAndGgnLFxuICB0aGVhZDogJ3RoZWFkJyxcbiAgdGltZTogJ3RpbWUnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHI6ICd0cicsXG4gIHRyYWNrOiAndHJhY2snLFxuICB1OiAndScsXG4gIHVsOiAndWwnLFxuICAndmFyJzogJ3ZhcicsXG4gIHZpZGVvOiAndmlkZW8nLFxuICB3YnI6ICd3YnInLFxuXG4gIC8vIFNWR1xuICBjaXJjbGU6ICdjaXJjbGUnLFxuICBkZWZzOiAnZGVmcycsXG4gIGVsbGlwc2U6ICdlbGxpcHNlJyxcbiAgZzogJ2cnLFxuICBsaW5lOiAnbGluZScsXG4gIGxpbmVhckdyYWRpZW50OiAnbGluZWFyR3JhZGllbnQnLFxuICBtYXNrOiAnbWFzaycsXG4gIHBhdGg6ICdwYXRoJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwb2x5Z29uOiAncG9seWdvbicsXG4gIHBvbHlsaW5lOiAncG9seWxpbmUnLFxuICByYWRpYWxHcmFkaWVudDogJ3JhZGlhbEdyYWRpZW50JyxcbiAgcmVjdDogJ3JlY3QnLFxuICBzdG9wOiAnc3RvcCcsXG4gIHN2ZzogJ3N2ZycsXG4gIHRleHQ6ICd0ZXh0JyxcbiAgdHNwYW46ICd0c3BhbidcblxufSwgY3JlYXRlRE9NRmFjdG9yeSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET007XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUJ1dHRvblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQXV0b0ZvY3VzTWl4aW4gPSByZXF1aXJlKFwiLi9BdXRvRm9jdXNNaXhpblwiKTtcbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXCIpO1xudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RDb21wb3NpdGVDb21wb25lbnRcIik7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZShcIi4vUmVhY3RET01cIik7XG5cbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKFwiLi9rZXlNaXJyb3JcIik7XG5cbi8vIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSA8YnV0dG9uPiBgUmVhY3RET01Db21wb25lbnRgLiBUT0RPOiB1c2Ugc3RyaW5nXG52YXIgYnV0dG9uID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkoUmVhY3RET00uYnV0dG9uLnR5cGUpO1xuXG52YXIgbW91c2VMaXN0ZW5lck5hbWVzID0ga2V5TWlycm9yKHtcbiAgb25DbGljazogdHJ1ZSxcbiAgb25Eb3VibGVDbGljazogdHJ1ZSxcbiAgb25Nb3VzZURvd246IHRydWUsXG4gIG9uTW91c2VNb3ZlOiB0cnVlLFxuICBvbk1vdXNlVXA6IHRydWUsXG4gIG9uQ2xpY2tDYXB0dXJlOiB0cnVlLFxuICBvbkRvdWJsZUNsaWNrQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZURvd25DYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlTW92ZUNhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VVcENhcHR1cmU6IHRydWVcbn0pO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8YnV0dG9uPiBuYXRpdmUgY29tcG9uZW50IHRoYXQgZG9lcyBub3QgcmVjZWl2ZSBtb3VzZSBldmVudHNcbiAqIHdoZW4gYGRpc2FibGVkYCBpcyBzZXQuXG4gKi9cbnZhciBSZWFjdERPTUJ1dHRvbiA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWFjdERPTUJ1dHRvbicsXG5cbiAgbWl4aW5zOiBbQXV0b0ZvY3VzTWl4aW4sIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwcm9wcyA9IHt9O1xuXG4gICAgLy8gQ29weSB0aGUgcHJvcHM7IGV4Y2VwdCB0aGUgbW91c2UgbGlzdGVuZXJzIGlmIHdlJ3JlIGRpc2FibGVkXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMucHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmhhc093blByb3BlcnR5KGtleSkgJiZcbiAgICAgICAgICAoIXRoaXMucHJvcHMuZGlzYWJsZWQgfHwgIW1vdXNlTGlzdGVuZXJOYW1lc1trZXldKSkge1xuICAgICAgICBwcm9wc1trZXldID0gdGhpcy5wcm9wc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidXR0b24ocHJvcHMsIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQnV0dG9uO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbXBvbmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoXCIuL0NTU1Byb3BlcnR5T3BlcmF0aW9uc1wiKTtcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5XCIpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5T3BlcmF0aW9uc1wiKTtcbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXCIpO1xudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RDb21wb25lbnRcIik7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXCIpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHJlcXVpcmUoXCIuL1JlYWN0TXVsdGlDaGlsZFwiKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKFwiLi9SZWFjdFBlcmZcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGVzY2FwZVRleHRGb3JCcm93c2VyID0gcmVxdWlyZShcIi4vZXNjYXBlVGV4dEZvckJyb3dzZXJcIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKFwiLi9pc0V2ZW50U3VwcG9ydGVkXCIpO1xudmFyIGtleU9mID0gcmVxdWlyZShcIi4va2V5T2ZcIik7XG52YXIgbW9uaXRvckNvZGVVc2UgPSByZXF1aXJlKFwiLi9tb25pdG9yQ29kZVVzZVwiKTtcblxudmFyIGRlbGV0ZUxpc3RlbmVyID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmRlbGV0ZUxpc3RlbmVyO1xudmFyIGxpc3RlblRvID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmxpc3RlblRvO1xudmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuXG4vLyBGb3IgcXVpY2tseSBtYXRjaGluZyBjaGlsZHJlbiB0eXBlLCB0byB0ZXN0IGlmIGNhbiBiZSB0cmVhdGVkIGFzIGNvbnRlbnQuXG52YXIgQ09OVEVOVF9UWVBFUyA9IHsnc3RyaW5nJzogdHJ1ZSwgJ251bWJlcic6IHRydWV9O1xuXG52YXIgU1RZTEUgPSBrZXlPZih7c3R5bGU6IG51bGx9KTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcblxuLyoqXG4gKiBAcGFyYW0gez9vYmplY3R9IHByb3BzXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHMocHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIHByb3BzLmNoaWxkcmVuID09IG51bGwgfHwgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCxcbiAgICAnQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJ1xuICApIDogaW52YXJpYW50KHByb3BzLmNoaWxkcmVuID09IG51bGwgfHwgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkpO1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgaWYgKHByb3BzLmNvbnRlbnRFZGl0YWJsZSAmJiBwcm9wcy5jaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgK1xuICAgICAgICAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgdGhvc2UgJytcbiAgICAgICAgJ25vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyBwcm9iYWJseSBub3QgJyArXG4gICAgICAgICdpbnRlbnRpb25hbC4nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JyxcbiAgICAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCAnICtcbiAgICAnbm90IGEgc3RyaW5nLidcbiAgKSA6IGludmFyaWFudChwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpKTtcbn1cblxuZnVuY3Rpb24gcHV0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyLCB0cmFuc2FjdGlvbikge1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgLy8gSUU4IGhhcyBubyBBUEkgZm9yIGV2ZW50IGNhcHR1cmluZyBhbmQgdGhlIGBvblNjcm9sbGAgZXZlbnQgZG9lc24ndFxuICAgIC8vIGJ1YmJsZS5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uU2Nyb2xsJyAmJlxuICAgICAgICAhaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSkpIHtcbiAgICAgIG1vbml0b3JDb2RlVXNlKCdyZWFjdF9ub19zY3JvbGxfZXZlbnQnKTtcbiAgICAgIGNvbnNvbGUud2FybignVGhpcyBicm93c2VyIGRvZXNuXFwndCBzdXBwb3J0IHRoZSBgb25TY3JvbGxgIGV2ZW50Jyk7XG4gICAgfVxuICB9XG4gIHZhciBjb250YWluZXIgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKGlkKTtcbiAgaWYgKGNvbnRhaW5lcikge1xuICAgIHZhciBkb2MgPSBjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFID9cbiAgICAgIGNvbnRhaW5lci5vd25lckRvY3VtZW50IDpcbiAgICAgIGNvbnRhaW5lcjtcbiAgICBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBkb2MpO1xuICB9XG4gIHRyYW5zYWN0aW9uLmdldFB1dExpc3RlbmVyUXVldWUoKS5lbnF1ZXVlUHV0TGlzdGVuZXIoXG4gICAgaWQsXG4gICAgcmVnaXN0cmF0aW9uTmFtZSxcbiAgICBsaXN0ZW5lclxuICApO1xufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBmb3Jcbi8vIHRob3NlIHNwZWNpYWwgY2FzZWQgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gICdhcmVhJzogdHJ1ZSxcbiAgJ2Jhc2UnOiB0cnVlLFxuICAnYnInOiB0cnVlLFxuICAnY29sJzogdHJ1ZSxcbiAgJ2VtYmVkJzogdHJ1ZSxcbiAgJ2hyJzogdHJ1ZSxcbiAgJ2ltZyc6IHRydWUsXG4gICdpbnB1dCc6IHRydWUsXG4gICdrZXlnZW4nOiB0cnVlLFxuICAnbGluayc6IHRydWUsXG4gICdtZXRhJzogdHJ1ZSxcbiAgJ3BhcmFtJzogdHJ1ZSxcbiAgJ3NvdXJjZSc6IHRydWUsXG4gICd0cmFjayc6IHRydWUsXG4gICd3YnInOiB0cnVlXG4gIC8vIE5PVEU6IG1lbnVpdGVtJ3MgY2xvc2UgdGFnIHNob3VsZCBiZSBvbWl0dGVkLCBidXQgdGhhdCBjYXVzZXMgcHJvYmxlbXMuXG59O1xuXG4vLyBXZSBhY2NlcHQgYW55IHRhZyB0byBiZSByZW5kZXJlZCBidXQgc2luY2UgdGhpcyBnZXRzIGluamVjdGVkIGludG8gYWJpdHJhcnlcbi8vIEhUTUwsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBhIHNhZmUgdGFnLlxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxuXG52YXIgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC87IC8vIFNpbXBsaWZpZWQgc3Vic2V0XG52YXIgdmFsaWRhdGVkVGFnQ2FjaGUgPSB7fTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpIHtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZFRhZ0NhY2hlLCB0YWcpKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpLCAnSW52YWxpZCB0YWc6ICVzJywgdGFnKSA6IGludmFyaWFudChWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpKSk7XG4gICAgdmFsaWRhdGVkVGFnQ2FjaGVbdGFnXSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFJlYWN0IGNsYXNzIHRoYXQgaXMgaWRlbXBvdGVudCBhbmQgY2FwYWJsZSBvZiBjb250YWluaW5nIG90aGVyXG4gKiBSZWFjdCBjb21wb25lbnRzLiBJdCBhY2NlcHRzIGV2ZW50IGxpc3RlbmVycyBhbmQgRE9NIHByb3BlcnRpZXMgdGhhdCBhcmVcbiAqIHZhbGlkIGFjY29yZGluZyB0byBgRE9NUHJvcGVydHlgLlxuICpcbiAqICAtIEV2ZW50IGxpc3RlbmVyczogYG9uQ2xpY2tgLCBgb25Nb3VzZURvd25gLCBldGMuXG4gKiAgLSBET00gcHJvcGVydGllczogYGNsYXNzTmFtZWAsIGBuYW1lYCwgYHRpdGxlYCwgZXRjLlxuICpcbiAqIFRoZSBgc3R5bGVgIHByb3BlcnR5IGZ1bmN0aW9ucyBkaWZmZXJlbnRseSBmcm9tIHRoZSBET00gQVBJLiBJdCBhY2NlcHRzIGFuXG4gKiBvYmplY3QgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgUmVhY3RET01Db21wb25lbnRcbiAqIEBleHRlbmRzIFJlYWN0Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdE11bHRpQ2hpbGRcbiAqL1xuZnVuY3Rpb24gUmVhY3RET01Db21wb25lbnQodGFnKSB7XG4gIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZyk7XG4gIHRoaXMuX3RhZyA9IHRhZztcbiAgdGhpcy50YWdOYW1lID0gdGFnLnRvVXBwZXJDYXNlKCk7XG59XG5cblJlYWN0RE9NQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ1JlYWN0RE9NQ29tcG9uZW50JztcblxuUmVhY3RET01Db21wb25lbnQuTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyByb290IHRhZyBtYXJrdXAgdGhlbiByZWN1cnNlcy4gVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBhbmRcbiAgICogaXMgbm90IGlkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIFRoZSByb290IERPTSBJRCBmb3IgdGhpcyBub2RlLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1vdW50RGVwdGggbnVtYmVyIG9mIGNvbXBvbmVudHMgaW4gdGhlIG93bmVyIGhpZXJhcmNoeVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb21wdXRlZCBtYXJrdXAuXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0RE9NQ29tcG9uZW50JyxcbiAgICAnbW91bnRDb21wb25lbnQnLFxuICAgIGZ1bmN0aW9uKHJvb3RJRCwgdHJhbnNhY3Rpb24sIG1vdW50RGVwdGgpIHtcbiAgICAgIFJlYWN0Q29tcG9uZW50Lk1peGluLm1vdW50Q29tcG9uZW50LmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHJvb3RJRCxcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIG1vdW50RGVwdGhcbiAgICAgICk7XG4gICAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMucHJvcHMpO1xuICAgICAgdmFyIGNsb3NlVGFnID0gb21pdHRlZENsb3NlVGFnc1t0aGlzLl90YWddID8gJycgOiAnPC8nICsgdGhpcy5fdGFnICsgJz4nO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5fY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVycyh0cmFuc2FjdGlvbikgK1xuICAgICAgICB0aGlzLl9jcmVhdGVDb250ZW50TWFya3VwKHRyYW5zYWN0aW9uKSArXG4gICAgICAgIGNsb3NlVGFnXG4gICAgICApO1xuICAgIH1cbiAgKSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBvcGVuIHRhZyBhbmQgYWxsIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYmVjYXVzZSBldmVudHMgZ2V0IHJlZ2lzdGVyZWQuXG4gICAqXG4gICAqIEl0ZXJhdGluZyBvdmVyIG9iamVjdCBwcm9wZXJ0aWVzIGlzIGZhc3RlciB0aGFuIGl0ZXJhdGluZyBvdmVyIGFycmF5cy5cbiAgICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9vYmotdnMtYXJyLWl0ZXJhdGlvblxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgb2Ygb3BlbmluZyB0YWcuXG4gICAqL1xuICBfY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVyczogZnVuY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciByZXQgPSAnPCcgKyB0aGlzLl90YWc7XG5cbiAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIHB1dExpc3RlbmVyKHRoaXMuX3Jvb3ROb2RlSUQsIHByb3BLZXksIHByb3BWYWx1ZSwgdHJhbnNhY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgICAgaWYgKHByb3BWYWx1ZSkge1xuICAgICAgICAgICAgcHJvcFZhbHVlID0gcHJvcHMuc3R5bGUgPSBhc3NpZ24oe30sIHByb3BzLnN0eWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvcFZhbHVlID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrdXAgPVxuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICBpZiAobWFya3VwKSB7XG4gICAgICAgICAgcmV0ICs9ICcgJyArIG1hcmt1cDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvciBzdGF0aWMgcGFnZXMsIG5vIG5lZWQgdG8gcHV0IFJlYWN0IElEIGFuZCBjaGVja3N1bS4gU2F2ZXMgbG90cyBvZlxuICAgIC8vIGJ5dGVzLlxuICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgcmV0dXJuIHJldCArICc+JztcbiAgICB9XG5cbiAgICB2YXIgbWFya3VwRm9ySUQgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9ySUQodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgcmV0dXJuIHJldCArICcgJyArIG1hcmt1cEZvcklEICsgJz4nO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGUgdGFncy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udGVudCBtYXJrdXAuXG4gICAqL1xuICBfY3JlYXRlQ29udGVudE1hcmt1cDogZnVuY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cbiAgICB2YXIgaW5uZXJIVE1MID0gdGhpcy5wcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlubmVySFRNTC5fX2h0bWw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPVxuICAgICAgICBDT05URU5UX1RZUEVTW3R5cGVvZiB0aGlzLnByb3BzLmNoaWxkcmVuXSA/IHRoaXMucHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNvbnRlbnRUb1VzZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcihjb250ZW50VG9Vc2UpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKFxuICAgICAgICAgIGNoaWxkcmVuVG9Vc2UsXG4gICAgICAgICAgdHJhbnNhY3Rpb25cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG1vdW50SW1hZ2VzLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH0sXG5cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24obmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKG5leHRFbGVtZW50ID09PSB0aGlzLl9jdXJyZW50RWxlbWVudCAmJlxuICAgICAgICBuZXh0RWxlbWVudC5fb3duZXIgIT0gbnVsbCkge1xuICAgICAgLy8gU2luY2UgZWxlbWVudHMgYXJlIGltbXV0YWJsZSBhZnRlciB0aGUgb3duZXIgaXMgcmVuZGVyZWQsXG4gICAgICAvLyB3ZSBjYW4gZG8gYSBjaGVhcCBpZGVudGl0eSBjb21wYXJlIGhlcmUgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYVxuICAgICAgLy8gc3VwZXJmbHVvdXMgcmVjb25jaWxlLiBJdCdzIHBvc3NpYmxlIGZvciBzdGF0ZSB0byBiZSBtdXRhYmxlIGJ1dCBzdWNoXG4gICAgICAvLyBjaGFuZ2Ugc2hvdWxkIHRyaWdnZXIgYW4gdXBkYXRlIG9mIHRoZSBvd25lciB3aGljaCB3b3VsZCByZWNyZWF0ZVxuICAgICAgLy8gdGhlIGVsZW1lbnQuIFdlIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gb3duZXIgc2luY2VcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIGEgZWxlbWVudCBjcmVhdGVkIG91dHNpZGUgYSBjb21wb3NpdGUgdG8gYmVcbiAgICAgIC8vIGRlZXBseSBtdXRhdGVkIGFuZCByZXVzZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgUmVhY3RDb21wb25lbnQuTWl4aW4ucmVjZWl2ZUNvbXBvbmVudC5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgIG5leHRFbGVtZW50LFxuICAgICAgdHJhbnNhY3Rpb25cbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgbmF0aXZlIERPTSBjb21wb25lbnQgYWZ0ZXIgaXQgaGFzIGFscmVhZHkgYmVlbiBhbGxvY2F0ZWQgYW5kXG4gICAqIGF0dGFjaGVkIHRvIHRoZSBET00uIFJlY29uY2lsZXMgdGhlIHJvb3QgRE9NIG5vZGUsIHRoZW4gcmVjdXJzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0RE9NQ29tcG9uZW50JyxcbiAgICAndXBkYXRlQ29tcG9uZW50JyxcbiAgICBmdW5jdGlvbih0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQpIHtcbiAgICAgIGFzc2VydFZhbGlkUHJvcHModGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHMpO1xuICAgICAgUmVhY3RDb21wb25lbnQuTWl4aW4udXBkYXRlQ29tcG9uZW50LmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBwcmV2RWxlbWVudFxuICAgICAgKTtcbiAgICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMocHJldkVsZW1lbnQucHJvcHMsIHRyYW5zYWN0aW9uKTtcbiAgICAgIHRoaXMuX3VwZGF0ZURPTUNoaWxkcmVuKHByZXZFbGVtZW50LnByb3BzLCB0cmFuc2FjdGlvbik7XG4gICAgfVxuICApLFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBwcm9wZXJ0aWVzIGJ5IGRldGVjdGluZyBkaWZmZXJlbmNlcyBpbiBwcm9wZXJ0eSB2YWx1ZXMgYW5kXG4gICAqIHVwZGF0aW5nIHRoZSBET00gYXMgbmVjZXNzYXJ5LiBUaGlzIGZ1bmN0aW9uIGlzIHByb2JhYmx5IHRoZSBzaW5nbGUgbW9zdFxuICAgKiBjcml0aWNhbCBwYXRoIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAqXG4gICAqIFRPRE86IEJlbmNobWFyayB3aGV0aGVyIGNoZWNraW5nIGZvciBjaGFuZ2VkIHZhbHVlcyBpbiBtZW1vcnkgYWN0dWFsbHlcbiAgICogICAgICAgaW1wcm92ZXMgcGVyZm9ybWFuY2UgKGVzcGVjaWFsbHkgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnRzKS5cbiAgICogVE9ETzogQmVuY2htYXJrIHRoZSBlZmZlY3RzIG9mIHB1dHRpbmcgdGhpcyBhdCB0aGUgdG9wIHNpbmNlIDk5JSBvZiBwcm9wc1xuICAgKiAgICAgICBkbyBub3QgY2hhbmdlIGZvciBhIGdpdmVuIHJlY29uY2lsaWF0aW9uLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgYXJlYXMgdGhhdCBjYW4gYmUgaW1wcm92ZWQgd2l0aCBjYWNoaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIF91cGRhdGVET01Qcm9wZXJ0aWVzOiBmdW5jdGlvbihsYXN0UHJvcHMsIHRyYW5zYWN0aW9uKSB7XG4gICAgdmFyIG5leHRQcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByb3BLZXk7XG4gICAgdmFyIHN0eWxlTmFtZTtcbiAgICB2YXIgc3R5bGVVcGRhdGVzO1xuICAgIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHxcbiAgICAgICAgICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgdmFyIGxhc3RTdHlsZSA9IGxhc3RQcm9wc1twcm9wS2V5XTtcbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFN0eWxlKSB7XG4gICAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBkZWxldGVMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5KTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgRE9NUHJvcGVydHkuaXNTdGFuZGFyZE5hbWVbcHJvcEtleV0gfHxcbiAgICAgICAgICBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShwcm9wS2V5KSkge1xuICAgICAgICBSZWFjdENvbXBvbmVudC5CYWNrZW5kSURPcGVyYXRpb25zLmRlbGV0ZVByb3BlcnR5QnlJRChcbiAgICAgICAgICB0aGlzLl9yb290Tm9kZUlELFxuICAgICAgICAgIHByb3BLZXlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgICAgdmFyIGxhc3RQcm9wID0gbGFzdFByb3BzW3Byb3BLZXldO1xuICAgICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIG5leHRQcm9wID0gbmV4dFByb3BzLnN0eWxlID0gYXNzaWduKHt9LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJlxuICAgICAgICAgICAgICAgICghbmV4dFByb3AgfHwgIW5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgICAgaWYgKG5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiZcbiAgICAgICAgICAgICAgICBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBwdXRMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5LCBuZXh0UHJvcCwgdHJhbnNhY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZVtwcm9wS2V5XSB8fFxuICAgICAgICAgIERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIFJlYWN0Q29tcG9uZW50LkJhY2tlbmRJRE9wZXJhdGlvbnMudXBkYXRlUHJvcGVydHlCeUlEKFxuICAgICAgICAgIHRoaXMuX3Jvb3ROb2RlSUQsXG4gICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICBuZXh0UHJvcFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgICBSZWFjdENvbXBvbmVudC5CYWNrZW5kSURPcGVyYXRpb25zLnVwZGF0ZVN0eWxlc0J5SUQoXG4gICAgICAgIHRoaXMuX3Jvb3ROb2RlSUQsXG4gICAgICAgIHN0eWxlVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY29uY2lsZXMgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHZhcmlvdXMgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0aGVcbiAgICogY2hpbGRyZW4gY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBfdXBkYXRlRE9NQ2hpbGRyZW46IGZ1bmN0aW9uKGxhc3RQcm9wcywgdHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgbmV4dFByb3BzID0gdGhpcy5wcm9wcztcblxuICAgIHZhciBsYXN0Q29udGVudCA9XG4gICAgICBDT05URU5UX1RZUEVTW3R5cGVvZiBsYXN0UHJvcHMuY2hpbGRyZW5dID8gbGFzdFByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICB2YXIgbmV4dENvbnRlbnQgPVxuICAgICAgQ09OVEVOVF9UWVBFU1t0eXBlb2YgbmV4dFByb3BzLmNoaWxkcmVuXSA/IG5leHRQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG5cbiAgICB2YXIgbGFzdEh0bWwgPVxuICAgICAgbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmXG4gICAgICBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuICAgIHZhciBuZXh0SHRtbCA9XG4gICAgICBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiZcbiAgICAgIG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG5cbiAgICAvLyBOb3RlIHRoZSB1c2Ugb2YgYCE9YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICAgIHZhciBsYXN0Q2hpbGRyZW4gPSBsYXN0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IGxhc3RQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBuZXh0UHJvcHMuY2hpbGRyZW47XG5cbiAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBjaGlsZHJlbiB0byBjb250ZW50L2h0bWwgb3IgdmljZSB2ZXJzYSwgcmVtb3ZlXG4gICAgLy8gdGhlIG9sZCBjb250ZW50XG4gICAgdmFyIGxhc3RIYXNDb250ZW50T3JIdG1sID0gbGFzdENvbnRlbnQgIT0gbnVsbCB8fCBsYXN0SHRtbCAhPSBudWxsO1xuICAgIHZhciBuZXh0SGFzQ29udGVudE9ySHRtbCA9IG5leHRDb250ZW50ICE9IG51bGwgfHwgbmV4dEh0bWwgIT0gbnVsbDtcbiAgICBpZiAobGFzdENoaWxkcmVuICE9IG51bGwgJiYgbmV4dENoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obnVsbCwgdHJhbnNhY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAobGFzdEhhc0NvbnRlbnRPckh0bWwgJiYgIW5leHRIYXNDb250ZW50T3JIdG1sKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RDb250ZW50ICE9PSBuZXh0Q29udGVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnICsgbmV4dENvbnRlbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICBSZWFjdENvbXBvbmVudC5CYWNrZW5kSURPcGVyYXRpb25zLnVwZGF0ZUlubmVySFRNTEJ5SUQoXG4gICAgICAgICAgdGhpcy5fcm9vdE5vZGVJRCxcbiAgICAgICAgICBuZXh0SHRtbFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS4gRG9lcyBub3QgcmVtb3ZlIGZyb21cbiAgICogdGhlIERPTS4gVGhhdCBtdXN0IGJlIGRvbmUgYnkgdGhlIHBhcmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVubW91bnRDaGlsZHJlbigpO1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5kZWxldGVBbGxMaXN0ZW5lcnModGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgUmVhY3RDb21wb25lbnQuTWl4aW4udW5tb3VudENvbXBvbmVudC5jYWxsKHRoaXMpO1xuICB9XG5cbn07XG5cbmFzc2lnbihcbiAgUmVhY3RET01Db21wb25lbnQucHJvdG90eXBlLFxuICBSZWFjdENvbXBvbmVudC5NaXhpbixcbiAgUmVhY3RET01Db21wb25lbnQuTWl4aW4sXG4gIFJlYWN0TXVsdGlDaGlsZC5NaXhpbixcbiAgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5cbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnQ7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUZvcm1cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgTG9jYWxFdmVudFRyYXBNaXhpbiA9IHJlcXVpcmUoXCIuL0xvY2FsRXZlbnRUcmFwTWl4aW5cIik7XG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblwiKTtcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NXCIpO1xuXG4vLyBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgPGZvcm0+IGBSZWFjdERPTUNvbXBvbmVudGAuIFRPRE86IHVzZSBzdHJpbmdcbnZhciBmb3JtID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkoUmVhY3RET00uZm9ybS50eXBlKTtcblxuLyoqXG4gKiBTaW5jZSBvblN1Ym1pdCBkb2Vzbid0IGJ1YmJsZSBPUiBjYXB0dXJlIG9uIHRoZSB0b3AgbGV2ZWwgaW4gSUU4LCB3ZSBuZWVkXG4gKiB0byBjYXB0dXJlIGl0IG9uIHRoZSA8Zm9ybT4gZWxlbWVudCBpdHNlbGYuIFRoZXJlIGFyZSBsb3RzIG9mIGhhY2tzIHdlIGNvdWxkXG4gKiBkbyB0byBhY2NvbXBsaXNoIHRoaXMsIGJ1dCB0aGUgbW9zdCByZWxpYWJsZSBpcyB0byBtYWtlIDxmb3JtPiBhXG4gKiBjb21wb3NpdGUgY29tcG9uZW50IGFuZCB1c2UgYGNvbXBvbmVudERpZE1vdW50YCB0byBhdHRhY2ggdGhlIGV2ZW50IGhhbmRsZXJzLlxuICovXG52YXIgUmVhY3RET01Gb3JtID0gUmVhY3RDb21wb3NpdGVDb21wb25lbnQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlYWN0RE9NRm9ybScsXG5cbiAgbWl4aW5zOiBbUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4sIExvY2FsRXZlbnRUcmFwTWl4aW5dLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ETzogSW5zdGVhZCBvZiB1c2luZyBgUmVhY3RET01gIGRpcmVjdGx5LCB3ZSBzaG91bGQgdXNlIEpTWC4gSG93ZXZlcixcbiAgICAvLyBganNoaW50YCBmYWlscyB0byBwYXJzZSBKU1ggc28gaW4gb3JkZXIgZm9yIGxpbnRpbmcgdG8gd29yayBpbiB0aGUgb3BlblxuICAgIC8vIHNvdXJjZSByZXBvLCB3ZSBuZWVkIHRvIGp1c3QgdXNlIGBSZWFjdERPTS5mb3JtYC5cbiAgICByZXR1cm4gZm9ybSh0aGlzLnByb3BzKTtcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wUmVzZXQsICdyZXNldCcpO1xuICAgIHRoaXMudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcFN1Ym1pdCwgJ3N1Ym1pdCcpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZvcm07XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NSURPcGVyYXRpb25zXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbi8qanNsaW50IGV2aWw6IHRydWUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnNcIik7XG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZShcIi4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zXCIpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5T3BlcmF0aW9uc1wiKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKFwiLi9SZWFjdFBlcmZcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZShcIi4vc2V0SW5uZXJIVE1MXCIpO1xuXG4vKipcbiAqIEVycm9ycyBmb3IgcHJvcGVydGllcyB0aGF0IHNob3VsZCBub3QgYmUgdXBkYXRlZCB3aXRoIGB1cGRhdGVQcm9wZXJ0eUJ5SWQoKWAuXG4gKlxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBJTlZBTElEX1BST1BFUlRZX0VSUk9SUyA9IHtcbiAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6XG4gICAgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBzZXQgdXNpbmcgYHVwZGF0ZUlubmVySFRNTEJ5SUQoKWAuJyxcbiAgc3R5bGU6ICdgc3R5bGVgIG11c3QgYmUgc2V0IHVzaW5nIGB1cGRhdGVTdHlsZXNCeUlEKClgLidcbn07XG5cbi8qKlxuICogT3BlcmF0aW9ucyB1c2VkIHRvIHByb2Nlc3MgdXBkYXRlcyB0byBET00gbm9kZXMuIFRoaXMgaXMgbWFkZSBpbmplY3RhYmxlIHZpYVxuICogYFJlYWN0Q29tcG9uZW50LkJhY2tlbmRJRE9wZXJhdGlvbnNgLlxuICovXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBET00gbm9kZSB3aXRoIG5ldyBwcm9wZXJ0eSB2YWx1ZXMuIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCB0b1xuICAgKiB1cGRhdGUgRE9NIHByb3BlcnRpZXMgaW4gYERPTVByb3BlcnR5YC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBub2RlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSB2YWxpZCBwcm9wZXJ0eSBuYW1lLCBzZWUgYERPTVByb3BlcnR5YC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVwZGF0ZVByb3BlcnR5QnlJRDogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0RE9NSURPcGVyYXRpb25zJyxcbiAgICAndXBkYXRlUHJvcGVydHlCeUlEJyxcbiAgICBmdW5jdGlvbihpZCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgICFJTlZBTElEX1BST1BFUlRZX0VSUk9SUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSxcbiAgICAgICAgJ3VwZGF0ZVByb3BlcnR5QnlJRCguLi4pOiAlcycsXG4gICAgICAgIElOVkFMSURfUFJPUEVSVFlfRVJST1JTW25hbWVdXG4gICAgICApIDogaW52YXJpYW50KCFJTlZBTElEX1BST1BFUlRZX0VSUk9SUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkpO1xuXG4gICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgIC8vIGZyb20gdGhlIERPTSBub2RlIGluc3RlYWQgb2YgaW5hZHZlcnRhbnRseSBzZXR0aW5nIHRvIGEgc3RyaW5nLiBUaGlzXG4gICAgICAvLyBicmluZ3MgdXMgaW4gbGluZSB3aXRoIHRoZSBzYW1lIGJlaGF2aW9yIHdlIGhhdmUgb24gaW5pdGlhbCByZW5kZXIuXG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICksXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBET00gbm9kZSB0byByZW1vdmUgYSBwcm9wZXJ0eS4gVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIHRvIHJlbW92ZVxuICAgKiBET00gcHJvcGVydGllcyBpbiBgRE9NUHJvcGVydHlgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIG5vZGUgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIHByb3BlcnR5IG5hbWUgdG8gcmVtb3ZlLCBzZWUgYERPTVByb3BlcnR5YC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkZWxldGVQcm9wZXJ0eUJ5SUQ6IFJlYWN0UGVyZi5tZWFzdXJlKFxuICAgICdSZWFjdERPTUlET3BlcmF0aW9ucycsXG4gICAgJ2RlbGV0ZVByb3BlcnR5QnlJRCcsXG4gICAgZnVuY3Rpb24oaWQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpZCk7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICAhSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlMuaGFzT3duUHJvcGVydHkobmFtZSksXG4gICAgICAgICd1cGRhdGVQcm9wZXJ0eUJ5SUQoLi4uKTogJXMnLFxuICAgICAgICBJTlZBTElEX1BST1BFUlRZX0VSUk9SU1tuYW1lXVxuICAgICAgKSA6IGludmFyaWFudCghSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlMuaGFzT3duUHJvcGVydHkobmFtZSkpKTtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICksXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBET00gbm9kZSB3aXRoIG5ldyBzdHlsZSB2YWx1ZXMuIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzICcnLFxuICAgKiB0aGUgY29ycmVzcG9uZGluZyBzdHlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVuc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIG5vZGUgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzIE1hcHBpbmcgZnJvbSBzdHlsZXMgdG8gdmFsdWVzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVwZGF0ZVN0eWxlc0J5SUQ6IFJlYWN0UGVyZi5tZWFzdXJlKFxuICAgICdSZWFjdERPTUlET3BlcmF0aW9ucycsXG4gICAgJ3VwZGF0ZVN0eWxlc0J5SUQnLFxuICAgIGZ1bmN0aW9uKGlkLCBzdHlsZXMpIHtcbiAgICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICAgIENTU1Byb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclN0eWxlcyhub2RlLCBzdHlsZXMpO1xuICAgIH1cbiAgKSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIERPTSBub2RlJ3MgaW5uZXJIVE1MLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIG5vZGUgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbCBBbiBIVE1MIHN0cmluZy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVJbm5lckhUTUxCeUlEOiBSZWFjdFBlcmYubWVhc3VyZShcbiAgICAnUmVhY3RET01JRE9wZXJhdGlvbnMnLFxuICAgICd1cGRhdGVJbm5lckhUTUxCeUlEJyxcbiAgICBmdW5jdGlvbihpZCwgaHRtbCkge1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUoaWQpO1xuICAgICAgc2V0SW5uZXJIVE1MKG5vZGUsIGh0bWwpO1xuICAgIH1cbiAgKSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIERPTSBub2RlJ3MgdGV4dCBjb250ZW50IHNldCBieSBgcHJvcHMuY29udGVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgbm9kZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IFRleHQgY29udGVudC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVUZXh0Q29udGVudEJ5SUQ6IFJlYWN0UGVyZi5tZWFzdXJlKFxuICAgICdSZWFjdERPTUlET3BlcmF0aW9ucycsXG4gICAgJ3VwZGF0ZVRleHRDb250ZW50QnlJRCcsXG4gICAgZnVuY3Rpb24oaWQsIGNvbnRlbnQpIHtcbiAgICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy51cGRhdGVUZXh0Q29udGVudChub2RlLCBjb250ZW50KTtcbiAgICB9XG4gICksXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGEgRE9NIG5vZGUgdGhhdCBleGlzdHMgaW4gdGhlIGRvY3VtZW50IHdpdGggbWFya3VwLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgY2hpbGQgdG8gYmUgcmVwbGFjZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgRGFuZ2Vyb3VzIG1hcmt1cCB0byBpbmplY3QgaW4gcGxhY2Ugb2YgY2hpbGQuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXB9XG4gICAqL1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6IFJlYWN0UGVyZi5tZWFzdXJlKFxuICAgICdSZWFjdERPTUlET3BlcmF0aW9ucycsXG4gICAgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCcsXG4gICAgZnVuY3Rpb24oaWQsIG1hcmt1cCkge1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUoaWQpO1xuICAgICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKG5vZGUsIG1hcmt1cCk7XG4gICAgfVxuICApLFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gbWFya3VwIExpc3Qgb2YgbWFya3VwIHN0cmluZ3MuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBSZWFjdFBlcmYubWVhc3VyZShcbiAgICAnUmVhY3RET01JRE9wZXJhdGlvbnMnLFxuICAgICdkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMnLFxuICAgIGZ1bmN0aW9uKHVwZGF0ZXMsIG1hcmt1cCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVwZGF0ZXNbaV0ucGFyZW50Tm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh1cGRhdGVzW2ldLnBhcmVudElEKTtcbiAgICAgIH1cbiAgICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5wcm9jZXNzVXBkYXRlcyh1cGRhdGVzLCBtYXJrdXApO1xuICAgIH1cbiAgKVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlET3BlcmF0aW9ucztcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NSW1nXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xudmFyIExvY2FsRXZlbnRUcmFwTWl4aW4gPSByZXF1aXJlKFwiLi9Mb2NhbEV2ZW50VHJhcE1peGluXCIpO1xudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5cIik7XG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudFwiKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKFwiLi9SZWFjdERPTVwiKTtcblxuLy8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIDxpbWc+IGBSZWFjdERPTUNvbXBvbmVudGAuIFRPRE86IHVzZSBzdHJpbmdcbnZhciBpbWcgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeShSZWFjdERPTS5pbWcudHlwZSk7XG5cbi8qKlxuICogU2luY2Ugb25Mb2FkIGRvZXNuJ3QgYnViYmxlIE9SIGNhcHR1cmUgb24gdGhlIHRvcCBsZXZlbCBpbiBJRTgsIHdlIG5lZWQgdG9cbiAqIGNhcHR1cmUgaXQgb24gdGhlIDxpbWc+IGVsZW1lbnQgaXRzZWxmLiBUaGVyZSBhcmUgbG90cyBvZiBoYWNrcyB3ZSBjb3VsZCBkb1xuICogdG8gYWNjb21wbGlzaCB0aGlzLCBidXQgdGhlIG1vc3QgcmVsaWFibGUgaXMgdG8gbWFrZSA8aW1nPiBhIGNvbXBvc2l0ZVxuICogY29tcG9uZW50IGFuZCB1c2UgYGNvbXBvbmVudERpZE1vdW50YCB0byBhdHRhY2ggdGhlIGV2ZW50IGhhbmRsZXJzLlxuICovXG52YXIgUmVhY3RET01JbWcgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RET01JbWcnLFxuICB0YWdOYW1lOiAnSU1HJyxcblxuICBtaXhpbnM6IFtSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiwgTG9jYWxFdmVudFRyYXBNaXhpbl0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaW1nKHRoaXMucHJvcHMpO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BMb2FkLCAnbG9hZCcpO1xuICAgIHRoaXMudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcEVycm9yLCAnZXJyb3InKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JbWc7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NSW5wdXRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEF1dG9Gb2N1c01peGluID0gcmVxdWlyZShcIi4vQXV0b0ZvY3VzTWl4aW5cIik7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlPcGVyYXRpb25zXCIpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKFwiLi9MaW5rZWRWYWx1ZVV0aWxzXCIpO1xudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5cIik7XG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudFwiKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKFwiLi9SZWFjdERPTVwiKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKFwiLi9SZWFjdFVwZGF0ZXNcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLy8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIDxpbnB1dD4gYFJlYWN0RE9NQ29tcG9uZW50YC4gVE9ETzogdXNlIHN0cmluZ1xudmFyIGlucHV0ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkoUmVhY3RET00uaW5wdXQudHlwZSk7XG5cbnZhciBpbnN0YW5jZXNCeVJlYWN0SUQgPSB7fTtcblxuZnVuY3Rpb24gZm9yY2VVcGRhdGVJZk1vdW50ZWQoKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIGlmICh0aGlzLmlzTW91bnRlZCgpKSB7XG4gICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8aW5wdXQ+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEyL1dELWh0bWw1LTIwMTIxMDI1L3RoZS1pbnB1dC1lbGVtZW50Lmh0bWxcbiAqL1xudmFyIFJlYWN0RE9NSW5wdXQgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RET01JbnB1dCcsXG5cbiAgbWl4aW5zOiBbQXV0b0ZvY3VzTWl4aW4sIExpbmtlZFZhbHVlVXRpbHMuTWl4aW4sIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSB0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5pdGlhbENoZWNrZWQ6IHRoaXMucHJvcHMuZGVmYXVsdENoZWNrZWQgfHwgZmFsc2UsXG4gICAgICBpbml0aWFsVmFsdWU6IGRlZmF1bHRWYWx1ZSAhPSBudWxsID8gZGVmYXVsdFZhbHVlIDogbnVsbFxuICAgIH07XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAvLyBDbG9uZSBgdGhpcy5wcm9wc2Agc28gd2UgZG9uJ3QgbXV0YXRlIHRoZSBpbnB1dC5cbiAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIHRoaXMucHJvcHMpO1xuXG4gICAgcHJvcHMuZGVmYXVsdENoZWNrZWQgPSBudWxsO1xuICAgIHByb3BzLmRlZmF1bHRWYWx1ZSA9IG51bGw7XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHRoaXMpO1xuICAgIHByb3BzLnZhbHVlID0gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogdGhpcy5zdGF0ZS5pbml0aWFsVmFsdWU7XG5cbiAgICB2YXIgY2hlY2tlZCA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0Q2hlY2tlZCh0aGlzKTtcbiAgICBwcm9wcy5jaGVja2VkID0gY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IHRoaXMuc3RhdGUuaW5pdGlhbENoZWNrZWQ7XG5cbiAgICBwcm9wcy5vbkNoYW5nZSA9IHRoaXMuX2hhbmRsZUNoYW5nZTtcblxuICAgIHJldHVybiBpbnB1dChwcm9wcywgdGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZCA9IFJlYWN0TW91bnQuZ2V0SUQodGhpcy5nZXRET01Ob2RlKCkpO1xuICAgIGluc3RhbmNlc0J5UmVhY3RJRFtpZF0gPSB0aGlzO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcm9vdE5vZGUgPSB0aGlzLmdldERPTU5vZGUoKTtcbiAgICB2YXIgaWQgPSBSZWFjdE1vdW50LmdldElEKHJvb3ROb2RlKTtcbiAgICBkZWxldGUgaW5zdGFuY2VzQnlSZWFjdElEW2lkXTtcbiAgfSxcblxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uKHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCkge1xuICAgIHZhciByb290Tm9kZSA9IHRoaXMuZ2V0RE9NTm9kZSgpO1xuICAgIGlmICh0aGlzLnByb3BzLmNoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkoXG4gICAgICAgIHJvb3ROb2RlLFxuICAgICAgICAnY2hlY2tlZCcsXG4gICAgICAgIHRoaXMucHJvcHMuY2hlY2tlZCB8fCBmYWxzZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHRoaXMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkocm9vdE5vZGUsICd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBfaGFuZGxlQ2hhbmdlOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB2YXIgb25DaGFuZ2UgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldE9uQ2hhbmdlKHRoaXMpO1xuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBvbkNoYW5nZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gICAgLy8gSGVyZSB3ZSB1c2UgYXNhcCB0byB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2hcbiAgICAvLyBpcyBpbXBvcnRhbnQgd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG5cbiAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICBpZiAodGhpcy5wcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5hbWUgIT0gbnVsbCkge1xuICAgICAgdmFyIHJvb3ROb2RlID0gdGhpcy5nZXRET01Ob2RlKCk7XG4gICAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICAgIHdoaWxlIChxdWVyeVJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYHJvb3ROb2RlLmZvcm1gIHdhcyBub24tbnVsbCwgdGhlbiB3ZSBjb3VsZCB0cnkgYGZvcm0uZWxlbWVudHNgLFxuICAgICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAgIC8vIGFuZCB3b24ndCBpbmNsdWRlIGlucHV0cyB0aGF0IHVzZSB0aGUgSFRNTDUgYGZvcm09YCBhdHRyaWJ1dGUuIFNpbmNlXG4gICAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLCBsZXQncyBqdXN0IHVzZSB0aGUgZ2xvYmFsXG4gICAgICAvLyBgcXVlcnlTZWxlY3RvckFsbGAgdG8gZW5zdXJlIHdlIGRvbid0IG1pc3MgYW55dGhpbmcuXG4gICAgICB2YXIgZ3JvdXAgPSBxdWVyeVJvb3QucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGdyb3VwTGVuID0gZ3JvdXAubGVuZ3RoOyBpIDwgZ3JvdXBMZW47IGkrKykge1xuICAgICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8XG4gICAgICAgICAgICBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdGhlcklEID0gUmVhY3RNb3VudC5nZXRJRChvdGhlck5vZGUpO1xuICAgICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICAgIG90aGVySUQsXG4gICAgICAgICAgJ1JlYWN0RE9NSW5wdXQ6IE1peGluZyBSZWFjdCBhbmQgbm9uLVJlYWN0IHJhZGlvIGlucHV0cyB3aXRoIHRoZSAnICtcbiAgICAgICAgICAnc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nXG4gICAgICAgICkgOiBpbnZhcmlhbnQob3RoZXJJRCkpO1xuICAgICAgICB2YXIgb3RoZXJJbnN0YW5jZSA9IGluc3RhbmNlc0J5UmVhY3RJRFtvdGhlcklEXTtcbiAgICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgICBvdGhlckluc3RhbmNlLFxuICAgICAgICAgICdSZWFjdERPTUlucHV0OiBVbmtub3duIHJhZGlvIGJ1dHRvbiBJRCAlcy4nLFxuICAgICAgICAgIG90aGVySURcbiAgICAgICAgKSA6IGludmFyaWFudChvdGhlckluc3RhbmNlKSk7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgICAvLyBhcyBhcHByb3ByaWF0ZS5cbiAgICAgICAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIG90aGVySW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlucHV0O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NT3B0aW9uXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXCIpO1xudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RDb21wb3NpdGVDb21wb25lbnRcIik7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZShcIi4vUmVhY3RET01cIik7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxuLy8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIDxvcHRpb24+IGBSZWFjdERPTUNvbXBvbmVudGAuIFRPRE86IHVzZSBzdHJpbmdcbnZhciBvcHRpb24gPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeShSZWFjdERPTS5vcHRpb24udHlwZSk7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBuYXRpdmUgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xudmFyIFJlYWN0RE9NT3B0aW9uID0gUmVhY3RDb21wb3NpdGVDb21wb25lbnQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlYWN0RE9NT3B0aW9uJyxcblxuICBtaXhpbnM6IFtSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbl0sXG5cbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhcbiAgICAgICAgdGhpcy5wcm9wcy5zZWxlY3RlZCA9PSBudWxsLFxuICAgICAgICAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJyArXG4gICAgICAgICdzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJ1xuICAgICAgKSA6IG51bGwpO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBvcHRpb24odGhpcy5wcm9wcywgdGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01PcHRpb247XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlbGVjdFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQXV0b0ZvY3VzTWl4aW4gPSByZXF1aXJlKFwiLi9BdXRvRm9jdXNNaXhpblwiKTtcbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZShcIi4vTGlua2VkVmFsdWVVdGlsc1wiKTtcbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXCIpO1xudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RDb21wb3NpdGVDb21wb25lbnRcIik7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZShcIi4vUmVhY3RET01cIik7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZShcIi4vUmVhY3RVcGRhdGVzXCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcblxuLy8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIDxzZWxlY3Q+IGBSZWFjdERPTUNvbXBvbmVudGAuIFRPRE86IHVzZSBzdHJpbmdcbnZhciBzZWxlY3QgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeShSZWFjdERPTS5zZWxlY3QudHlwZSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVdpdGhQZW5kaW5nVmFsdWVJZk1vdW50ZWQoKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIGlmICh0aGlzLmlzTW91bnRlZCgpKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7dmFsdWU6IHRoaXMuX3BlbmRpbmdWYWx1ZX0pO1xuICAgIHRoaXMuX3BlbmRpbmdWYWx1ZSA9IDA7XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdFZhbHVlVHlwZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9wcy5tdWx0aXBsZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAoXCJUaGUgYFwiICsgcHJvcE5hbWUgKyBcImAgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmIFwiKSArXG4gICAgICAgIChcImBtdWx0aXBsZWAgaXMgdHJ1ZS5cIilcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgIChcIlRoZSBgXCIgKyBwcm9wTmFtZSArIFwiYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgXCIpICtcbiAgICAgICAgKFwidmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS5cIilcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCwgdXBkYXRlcyA8b3B0aW9uPiBlbGVtZW50cyBvbiBtb3VudCBhbmQgdXBkYXRlLlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IEluc3RhbmNlIG9mIFJlYWN0RE9NU2VsZWN0XG4gKiBAcGFyYW0gez8qfSBwcm9wVmFsdWUgRm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLCBudWxsL3VuZGVmaW5lZC4gRm9yXG4gKiBjb250cm9sbGVkIGNvbXBvbmVudHMsIGEgc3RyaW5nIChvciB3aXRoIGBtdWx0aXBsZWAsIGEgbGlzdCBvZiBzdHJpbmdzKS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMoY29tcG9uZW50LCBwcm9wVmFsdWUpIHtcbiAgdmFyIG11bHRpcGxlID0gY29tcG9uZW50LnByb3BzLm11bHRpcGxlO1xuICB2YXIgdmFsdWUgPSBwcm9wVmFsdWUgIT0gbnVsbCA/IHByb3BWYWx1ZSA6IGNvbXBvbmVudC5zdGF0ZS52YWx1ZTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wb25lbnQuZ2V0RE9NTm9kZSgpLm9wdGlvbnM7XG4gIHZhciBzZWxlY3RlZFZhbHVlLCBpLCBsO1xuICBpZiAobXVsdGlwbGUpIHtcbiAgICBzZWxlY3RlZFZhbHVlID0ge307XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgc2VsZWN0ZWRWYWx1ZVsnJyArIHZhbHVlW2ldXSA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNlbGVjdGVkVmFsdWUgPSAnJyArIHZhbHVlO1xuICB9XG4gIGZvciAoaSA9IDAsIGwgPSBvcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBzZWxlY3RlZCA9IG11bHRpcGxlID9cbiAgICAgIHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkob3B0aW9uc1tpXS52YWx1ZSkgOlxuICAgICAgb3B0aW9uc1tpXS52YWx1ZSA9PT0gc2VsZWN0ZWRWYWx1ZTtcblxuICAgIGlmIChzZWxlY3RlZCAhPT0gb3B0aW9uc1tpXS5zZWxlY3RlZCkge1xuICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBuYXRpdmUgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZy4gSWYgYG11bHRpcGxlYCBpcyB0cnVlLCB0aGUgcHJvcCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gUmVhY3RDb21wb3NpdGVDb21wb25lbnQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlYWN0RE9NU2VsZWN0JyxcblxuICBtaXhpbnM6IFtBdXRvRm9jdXNNaXhpbiwgTGlua2VkVmFsdWVVdGlscy5NaXhpbiwgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5dLFxuXG4gIHByb3BUeXBlczoge1xuICAgIGRlZmF1bHRWYWx1ZTogc2VsZWN0VmFsdWVUeXBlLFxuICAgIHZhbHVlOiBzZWxlY3RWYWx1ZVR5cGVcbiAgfSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7dmFsdWU6IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlIHx8ICh0aGlzLnByb3BzLm11bHRpcGxlID8gW10gOiAnJyl9O1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcGVuZGluZ1ZhbHVlID0gbnVsbDtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMpIHtcbiAgICBpZiAoIXRoaXMucHJvcHMubXVsdGlwbGUgJiYgbmV4dFByb3BzLm11bHRpcGxlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHt2YWx1ZTogW3RoaXMuc3RhdGUudmFsdWVdfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLm11bHRpcGxlICYmICFuZXh0UHJvcHMubXVsdGlwbGUpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe3ZhbHVlOiB0aGlzLnN0YXRlLnZhbHVlWzBdfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2xvbmUgYHRoaXMucHJvcHNgIHNvIHdlIGRvbid0IG11dGF0ZSB0aGUgaW5wdXQuXG4gICAgdmFyIHByb3BzID0gYXNzaWduKHt9LCB0aGlzLnByb3BzKTtcblxuICAgIHByb3BzLm9uQ2hhbmdlID0gdGhpcy5faGFuZGxlQ2hhbmdlO1xuICAgIHByb3BzLnZhbHVlID0gbnVsbDtcblxuICAgIHJldHVybiBzZWxlY3QocHJvcHMsIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICB1cGRhdGVPcHRpb25zKHRoaXMsIExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUodGhpcykpO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24ocHJldlByb3BzKSB7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZSh0aGlzKTtcbiAgICB2YXIgcHJldk11bHRpcGxlID0gISFwcmV2UHJvcHMubXVsdGlwbGU7XG4gICAgdmFyIG11bHRpcGxlID0gISF0aGlzLnByb3BzLm11bHRpcGxlO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsIHx8IHByZXZNdWx0aXBsZSAhPT0gbXVsdGlwbGUpIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnModGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBfaGFuZGxlQ2hhbmdlOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB2YXIgb25DaGFuZ2UgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldE9uQ2hhbmdlKHRoaXMpO1xuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBvbkNoYW5nZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZTtcbiAgICBpZiAodGhpcy5wcm9wcy5tdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWRWYWx1ZSA9IFtdO1xuICAgICAgdmFyIG9wdGlvbnMgPSBldmVudC50YXJnZXQub3B0aW9ucztcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKG9wdGlvbnNbaV0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICBzZWxlY3RlZFZhbHVlLnB1c2gob3B0aW9uc1tpXS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0ZWRWYWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLl9wZW5kaW5nVmFsdWUgPSBzZWxlY3RlZFZhbHVlO1xuICAgIFJlYWN0VXBkYXRlcy5hc2FwKHVwZGF0ZVdpdGhQZW5kaW5nVmFsdWVJZk1vdW50ZWQsIHRoaXMpO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlbGVjdGlvblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxudmFyIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQgPSByZXF1aXJlKFwiLi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0XCIpO1xudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKFwiLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yXCIpO1xuXG4vKipcbiAqIFdoaWxlIGBpc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG9uIHRoZSBTZWxlY3Rpb24gb2JqZWN0IGFuZCBgY29sbGFwc2VkYFxuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBSYW5nZSBvYmplY3QsIElFMTEgc29tZXRpbWVzIGdldHMgdGhlbSB3cm9uZy5cbiAqIElmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYW5kIG9mZnNldHMgYXJlIHRoZSBzYW1lLCB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLlxuICovXG5mdW5jdGlvbiBpc0NvbGxhcHNlZChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgcmV0dXJuIGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSAmJiBhbmNob3JPZmZzZXQgPT09IGZvY3VzT2Zmc2V0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgYXBwcm9wcmlhdGUgYW5jaG9yIGFuZCBmb2N1cyBub2RlL29mZnNldCBwYWlycyBmb3IgSUUuXG4gKlxuICogVGhlIGNhdGNoIGhlcmUgaXMgdGhhdCBJRSdzIHNlbGVjdGlvbiBBUEkgZG9lc24ndCBwcm92aWRlIGluZm9ybWF0aW9uXG4gKiBhYm91dCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgZm9yd2FyZCBvciBiYWNrd2FyZCwgc28gd2UgaGF2ZSB0b1xuICogYmVoYXZlIGFzIHRob3VnaCBpdCdzIGFsd2F5cyBmb3J3YXJkLlxuICpcbiAqIElFIHRleHQgZGlmZmVycyBmcm9tIG1vZGVybiBzZWxlY3Rpb24gaW4gdGhhdCBpdCBiZWhhdmVzIGFzIHRob3VnaFxuICogYmxvY2sgZWxlbWVudHMgZW5kIHdpdGggYSBuZXcgbGluZS4gVGhpcyBtZWFucyBjaGFyYWN0ZXIgb2Zmc2V0cyB3aWxsXG4gKiBkaWZmZXIgYmV0d2VlbiB0aGUgdHdvIEFQSXMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldElFT2Zmc2V0cyhub2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5zZWxlY3Rpb247XG4gIHZhciBzZWxlY3RlZFJhbmdlID0gc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gIHZhciBzZWxlY3RlZExlbmd0aCA9IHNlbGVjdGVkUmFuZ2UudGV4dC5sZW5ndGg7XG5cbiAgLy8gRHVwbGljYXRlIHNlbGVjdGlvbiBzbyB3ZSBjYW4gbW92ZSByYW5nZSB3aXRob3V0IGJyZWFraW5nIHVzZXIgc2VsZWN0aW9uLlxuICB2YXIgZnJvbVN0YXJ0ID0gc2VsZWN0ZWRSYW5nZS5kdXBsaWNhdGUoKTtcbiAgZnJvbVN0YXJ0Lm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xuICBmcm9tU3RhcnQuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCBzZWxlY3RlZFJhbmdlKTtcblxuICB2YXIgc3RhcnRPZmZzZXQgPSBmcm9tU3RhcnQudGV4dC5sZW5ndGg7XG4gIHZhciBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIHNlbGVjdGVkTGVuZ3RoO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0T2Zmc2V0LFxuICAgIGVuZDogZW5kT2Zmc2V0XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gJiYgd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICB2YXIgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgdmFyIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGU7XG4gIHZhciBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICB2YXIgY3VycmVudFJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG5cbiAgLy8gSWYgdGhlIG5vZGUgYW5kIG9mZnNldCB2YWx1ZXMgYXJlIHRoZSBzYW1lLCB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZC5cbiAgLy8gYFNlbGVjdGlvbi5pc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5LCBidXQgSUUgc29tZXRpbWVzIGdldHNcbiAgLy8gdGhpcyB2YWx1ZSB3cm9uZy5cbiAgdmFyIGlzU2VsZWN0aW9uQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQoXG4gICAgc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgIHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICApO1xuXG4gIHZhciByYW5nZUxlbmd0aCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkID8gMCA6IGN1cnJlbnRSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcblxuICB2YXIgdGVtcFJhbmdlID0gY3VycmVudFJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgdGVtcFJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgdGVtcFJhbmdlLnNldEVuZChjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXIsIGN1cnJlbnRSYW5nZS5zdGFydE9mZnNldCk7XG5cbiAgdmFyIGlzVGVtcFJhbmdlQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQoXG4gICAgdGVtcFJhbmdlLnN0YXJ0Q29udGFpbmVyLFxuICAgIHRlbXBSYW5nZS5zdGFydE9mZnNldCxcbiAgICB0ZW1wUmFuZ2UuZW5kQ29udGFpbmVyLFxuICAgIHRlbXBSYW5nZS5lbmRPZmZzZXRcbiAgKTtcblxuICB2YXIgc3RhcnQgPSBpc1RlbXBSYW5nZUNvbGxhcHNlZCA/IDAgOiB0ZW1wUmFuZ2UudG9TdHJpbmcoKS5sZW5ndGg7XG4gIHZhciBlbmQgPSBzdGFydCArIHJhbmdlTGVuZ3RoO1xuXG4gIC8vIERldGVjdCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgYmFja3dhcmQuXG4gIHZhciBkZXRlY3Rpb25SYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGRldGVjdGlvblJhbmdlLnNldFN0YXJ0KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gIGRldGVjdGlvblJhbmdlLnNldEVuZChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KTtcbiAgdmFyIGlzQmFja3dhcmQgPSBkZXRlY3Rpb25SYW5nZS5jb2xsYXBzZWQ7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogaXNCYWNrd2FyZCA/IGVuZCA6IHN0YXJ0LFxuICAgIGVuZDogaXNCYWNrd2FyZCA/IHN0YXJ0IDogZW5kXG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRJRU9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS5kdXBsaWNhdGUoKTtcbiAgdmFyIHN0YXJ0LCBlbmQ7XG5cbiAgaWYgKHR5cGVvZiBvZmZzZXRzLmVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gIH0gZWxzZSBpZiAob2Zmc2V0cy5zdGFydCA+IG9mZnNldHMuZW5kKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLmVuZDtcbiAgICBlbmQgPSBvZmZzZXRzLnN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICBlbmQgPSBvZmZzZXRzLmVuZDtcbiAgfVxuXG4gIHJhbmdlLm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xuICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgcmFuZ2Uuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCByYW5nZSk7XG4gIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcbiAgcmFuZ2Uuc2VsZWN0KCk7XG59XG5cbi8qKlxuICogSW4gbW9kZXJuIG5vbi1JRSBicm93c2Vycywgd2UgY2FuIHN1cHBvcnQgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZFxuICogc2VsZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBJRTEwKyBzdXBwb3J0cyB0aGUgU2VsZWN0aW9uIG9iamVjdCwgYnV0IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXG4gKiB0byBwcm9ncmFtYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldE1vZGVybk9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICBpZiAoIXdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICB2YXIgbGVuZ3RoID0gbm9kZVtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldLmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IHR5cGVvZiBvZmZzZXRzLmVuZCA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgICAgc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcblxuICAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHVzZUlFT2Zmc2V0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiBkb2N1bWVudC5zZWxlY3Rpb247XG5cbnZhciBSZWFjdERPTVNlbGVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKi9cbiAgZ2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gZ2V0SUVPZmZzZXRzIDogZ2V0TW9kZXJuT2Zmc2V0cyxcblxuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gICAqL1xuICBzZXRPZmZzZXRzOiB1c2VJRU9mZnNldHMgPyBzZXRJRU9mZnNldHMgOiBzZXRNb2Rlcm5PZmZzZXRzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0aW9uO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVRleHRhcmVhXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBBdXRvRm9jdXNNaXhpbiA9IHJlcXVpcmUoXCIuL0F1dG9Gb2N1c01peGluXCIpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5T3BlcmF0aW9uc1wiKTtcbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZShcIi4vTGlua2VkVmFsdWVVdGlsc1wiKTtcbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXCIpO1xudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RDb21wb3NpdGVDb21wb25lbnRcIik7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZShcIi4vUmVhY3RET01cIik7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZShcIi4vUmVhY3RVcGRhdGVzXCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxuLy8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIDx0ZXh0YXJlYT4gYFJlYWN0RE9NQ29tcG9uZW50YC4gVE9ETzogdXNlIHN0cmluZ1xudmFyIHRleHRhcmVhID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkoUmVhY3RET00udGV4dGFyZWEudHlwZSk7XG5cbmZ1bmN0aW9uIGZvcmNlVXBkYXRlSWZNb3VudGVkKCkge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICBpZiAodGhpcy5pc01vdW50ZWQoKSkge1xuICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG52YXIgUmVhY3RET01UZXh0YXJlYSA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWFjdERPTVRleHRhcmVhJyxcblxuICBtaXhpbnM6IFtBdXRvRm9jdXNNaXhpbiwgTGlua2VkVmFsdWVVdGlscy5NaXhpbiwgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5dLFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICtcbiAgICAgICAgICAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nXG4gICAgICAgICkgOiBudWxsKTtcbiAgICAgIH1cbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9PSBudWxsLFxuICAgICAgICAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLidcbiAgICAgICkgOiBpbnZhcmlhbnQoZGVmYXVsdFZhbHVlID09IG51bGwpKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICAgIGNoaWxkcmVuLmxlbmd0aCA8PSAxLFxuICAgICAgICAgICc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJ1xuICAgICAgICApIDogaW52YXJpYW50KGNoaWxkcmVuLmxlbmd0aCA8PSAxKSk7XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnICsgY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUodGhpcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFdlIHNhdmUgdGhlIGluaXRpYWwgdmFsdWUgc28gdGhhdCBgUmVhY3RET01Db21wb25lbnRgIGRvZXNuJ3QgdXBkYXRlXG4gICAgICAvLyBgdGV4dENvbnRlbnRgICh1bm5lY2Vzc2FyeSBzaW5jZSB3ZSB1cGRhdGUgdmFsdWUpLlxuICAgICAgLy8gVGhlIGluaXRpYWwgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzXG4gICAgICAvLyBmb3JjZWQgdG8gYmUgYSBzdHJpbmcuXG4gICAgICBpbml0aWFsVmFsdWU6ICcnICsgKHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZSlcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2xvbmUgYHRoaXMucHJvcHNgIHNvIHdlIGRvbid0IG11dGF0ZSB0aGUgaW5wdXQuXG4gICAgdmFyIHByb3BzID0gYXNzaWduKHt9LCB0aGlzLnByb3BzKTtcblxuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsLFxuICAgICAgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LidcbiAgICApIDogaW52YXJpYW50KHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpKTtcblxuICAgIHByb3BzLmRlZmF1bHRWYWx1ZSA9IG51bGw7XG4gICAgcHJvcHMudmFsdWUgPSBudWxsO1xuICAgIHByb3BzLm9uQ2hhbmdlID0gdGhpcy5faGFuZGxlQ2hhbmdlO1xuXG4gICAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLlxuICAgIHJldHVybiB0ZXh0YXJlYShwcm9wcywgdGhpcy5zdGF0ZS5pbml0aWFsVmFsdWUpO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24ocHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZSh0aGlzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFyIHJvb3ROb2RlID0gdGhpcy5nZXRET01Ob2RlKCk7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkocm9vdE5vZGUsICd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBfaGFuZGxlQ2hhbmdlOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB2YXIgb25DaGFuZ2UgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldE9uQ2hhbmdlKHRoaXMpO1xuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBvbkNoYW5nZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gICAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRhcmVhO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZShcIi4vUmVhY3RVcGRhdGVzXCIpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZShcIi4vVHJhbnNhY3Rpb25cIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xuXG52YXIgUkVTRVRfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICB9XG59O1xuXG52YXIgRkxVU0hfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogUmVhY3RVcGRhdGVzLmZsdXNoQmF0Y2hlZFVwZGF0ZXMuYmluZChSZWFjdFVwZGF0ZXMpXG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbRkxVU0hfQkFUQ0hFRF9VUERBVEVTLCBSRVNFVF9CQVRDSEVEX1VQREFURVNdO1xuXG5mdW5jdGlvbiBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbn1cblxuYXNzaWduKFxuICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24ucHJvdG90eXBlLFxuICBUcmFuc2FjdGlvbi5NaXhpbixcbiAge1xuICAgIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICAgIH1cbiAgfVxuKTtcblxudmFyIHRyYW5zYWN0aW9uID0gbmV3IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpO1xuXG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHtcbiAgaXNCYXRjaGluZ1VwZGF0ZXM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpbiBhIGNvbnRleHQgd2l0aGluIHdoaWNoIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAgICogYW5kIGZyaWVuZHMgYXJlIGJhdGNoZWQgc3VjaCB0aGF0IGNvbXBvbmVudHMgYXJlbid0IHVwZGF0ZWQgdW5uZWNlc3NhcmlseS5cbiAgICovXG4gIGJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbihjYWxsYmFjaywgYSwgYikge1xuICAgIHZhciBhbHJlYWR5QmF0Y2hpbmdVcGRhdGVzID0gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcztcblxuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuXG4gICAgLy8gVGhlIGNvZGUgaXMgd3JpdHRlbiB0aGlzIHdheSB0byBhdm9pZCBleHRyYSBhbGxvY2F0aW9uc1xuICAgIGlmIChhbHJlYWR5QmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICBjYWxsYmFjayhhLCBiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShjYWxsYmFjaywgbnVsbCwgYSwgYik7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3k7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdEluamVjdGlvblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHJlcXVpcmUoXCIuL0JlZm9yZUlucHV0RXZlbnRQbHVnaW5cIik7XG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSByZXF1aXJlKFwiLi9DaGFuZ2VFdmVudFBsdWdpblwiKTtcbnZhciBDbGllbnRSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoXCIuL0NsaWVudFJlYWN0Um9vdEluZGV4XCIpO1xudmFyIENvbXBvc2l0aW9uRXZlbnRQbHVnaW4gPSByZXF1aXJlKFwiLi9Db21wb3NpdGlvbkV2ZW50UGx1Z2luXCIpO1xudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gcmVxdWlyZShcIi4vRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXJcIik7XG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0gcmVxdWlyZShcIi4vRW50ZXJMZWF2ZUV2ZW50UGx1Z2luXCIpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZShcIi4vSFRNTERPTVByb3BlcnR5Q29uZmlnXCIpO1xudmFyIE1vYmlsZVNhZmFyaUNsaWNrRXZlbnRQbHVnaW4gPSByZXF1aXJlKFwiLi9Nb2JpbGVTYWZhcmlDbGlja0V2ZW50UGx1Z2luXCIpO1xudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5cIik7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPVxuICByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudFwiKTtcbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0gcmVxdWlyZShcIi4vUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVwiKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0RE9NQnV0dG9uID0gcmVxdWlyZShcIi4vUmVhY3RET01CdXR0b25cIik7XG52YXIgUmVhY3RET01Gb3JtID0gcmVxdWlyZShcIi4vUmVhY3RET01Gb3JtXCIpO1xudmFyIFJlYWN0RE9NSW1nID0gcmVxdWlyZShcIi4vUmVhY3RET01JbWdcIik7XG52YXIgUmVhY3RET01JbnB1dCA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NSW5wdXRcIik7XG52YXIgUmVhY3RET01PcHRpb24gPSByZXF1aXJlKFwiLi9SZWFjdERPTU9wdGlvblwiKTtcbnZhciBSZWFjdERPTVNlbGVjdCA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NU2VsZWN0XCIpO1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSByZXF1aXJlKFwiLi9SZWFjdERPTVRleHRhcmVhXCIpO1xudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoXCIuL1JlYWN0RXZlbnRMaXN0ZW5lclwiKTtcbnZhciBSZWFjdEluamVjdGlvbiA9IHJlcXVpcmUoXCIuL1JlYWN0SW5qZWN0aW9uXCIpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZShcIi4vUmVhY3RJbnN0YW5jZUhhbmRsZXNcIik7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoXCIuL1JlYWN0TW91bnRcIik7XG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSByZXF1aXJlKFwiLi9TZWxlY3RFdmVudFBsdWdpblwiKTtcbnZhciBTZXJ2ZXJSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoXCIuL1NlcnZlclJlYWN0Um9vdEluZGV4XCIpO1xudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0gcmVxdWlyZShcIi4vU2ltcGxlRXZlbnRQbHVnaW5cIik7XG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKFwiLi9TVkdET01Qcm9wZXJ0eUNvbmZpZ1wiKTtcblxudmFyIGNyZWF0ZUZ1bGxQYWdlQ29tcG9uZW50ID0gcmVxdWlyZShcIi4vY3JlYXRlRnVsbFBhZ2VDb21wb25lbnRcIik7XG5cbmZ1bmN0aW9uIGluamVjdCgpIHtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRFbWl0dGVyLmluamVjdFJlYWN0RXZlbnRMaXN0ZW5lcihcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXJcbiAgKTtcblxuICAvKipcbiAgICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKERlZmF1bHRFdmVudFBsdWdpbk9yZGVyKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0SW5zdGFuY2VIYW5kbGUoUmVhY3RJbnN0YW5jZUhhbmRsZXMpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RNb3VudChSZWFjdE1vdW50KTtcblxuICAvKipcbiAgICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gICAqIHRoZW0pLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXG4gICAgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBFbnRlckxlYXZlRXZlbnRQbHVnaW4sXG4gICAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICAgIENvbXBvc2l0aW9uRXZlbnRQbHVnaW46IENvbXBvc2l0aW9uRXZlbnRQbHVnaW4sXG4gICAgTW9iaWxlU2FmYXJpQ2xpY2tFdmVudFBsdWdpbjogTW9iaWxlU2FmYXJpQ2xpY2tFdmVudFBsdWdpbixcbiAgICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gICAgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICB9KTtcblxuICBSZWFjdEluamVjdGlvbi5OYXRpdmVDb21wb25lbnQuaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzKFxuICAgIFJlYWN0RE9NQ29tcG9uZW50XG4gICk7XG5cbiAgUmVhY3RJbmplY3Rpb24uTmF0aXZlQ29tcG9uZW50LmluamVjdENvbXBvbmVudENsYXNzZXMoe1xuICAgICdidXR0b24nOiBSZWFjdERPTUJ1dHRvbixcbiAgICAnZm9ybSc6IFJlYWN0RE9NRm9ybSxcbiAgICAnaW1nJzogUmVhY3RET01JbWcsXG4gICAgJ2lucHV0JzogUmVhY3RET01JbnB1dCxcbiAgICAnb3B0aW9uJzogUmVhY3RET01PcHRpb24sXG4gICAgJ3NlbGVjdCc6IFJlYWN0RE9NU2VsZWN0LFxuICAgICd0ZXh0YXJlYSc6IFJlYWN0RE9NVGV4dGFyZWEsXG5cbiAgICAnaHRtbCc6IGNyZWF0ZUZ1bGxQYWdlQ29tcG9uZW50KCdodG1sJyksXG4gICAgJ2hlYWQnOiBjcmVhdGVGdWxsUGFnZUNvbXBvbmVudCgnaGVhZCcpLFxuICAgICdib2R5JzogY3JlYXRlRnVsbFBhZ2VDb21wb25lbnQoJ2JvZHknKVxuICB9KTtcblxuICAvLyBUaGlzIG5lZWRzIHRvIGhhcHBlbiBhZnRlciBjcmVhdGVGdWxsUGFnZUNvbXBvbmVudCgpIG90aGVyd2lzZSB0aGUgbWl4aW5cbiAgLy8gZ2V0cyBkb3VibGUgaW5qZWN0ZWQuXG4gIFJlYWN0SW5qZWN0aW9uLkNvbXBvc2l0ZUNvbXBvbmVudC5pbmplY3RNaXhpbihSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbik7XG5cbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoSFRNTERPTVByb3BlcnR5Q29uZmlnKTtcbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoU1ZHRE9NUHJvcGVydHlDb25maWcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkVtcHR5Q29tcG9uZW50LmluamVjdEVtcHR5Q29tcG9uZW50KCdub3NjcmlwdCcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oXG4gICAgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvblxuICApO1xuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koXG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVxuICApO1xuXG4gIFJlYWN0SW5qZWN0aW9uLlJvb3RJbmRleC5pbmplY3RDcmVhdGVSZWFjdFJvb3RJbmRleChcbiAgICBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gP1xuICAgICAgQ2xpZW50UmVhY3RSb290SW5kZXguY3JlYXRlUmVhY3RSb290SW5kZXggOlxuICAgICAgU2VydmVyUmVhY3RSb290SW5kZXguY3JlYXRlUmVhY3RSb290SW5kZXhcbiAgKTtcblxuICBSZWFjdEluamVjdGlvbi5Db21wb25lbnQuaW5qZWN0RW52aXJvbm1lbnQoUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQpO1xuXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICB2YXIgdXJsID0gKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cubG9jYXRpb24uaHJlZikgfHwgJyc7XG4gICAgaWYgKCgvWz8mXXJlYWN0X3BlcmZcXGIvKS50ZXN0KHVybCkpIHtcbiAgICAgIHZhciBSZWFjdERlZmF1bHRQZXJmID0gcmVxdWlyZShcIi4vUmVhY3REZWZhdWx0UGVyZlwiKTtcbiAgICAgIFJlYWN0RGVmYXVsdFBlcmYuc3RhcnQoKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluamVjdDogaW5qZWN0XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0UGVyZlxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlcIik7XG52YXIgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzID0gcmVxdWlyZShcIi4vUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzXCIpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0UGVyZlwiKTtcblxudmFyIHBlcmZvcm1hbmNlTm93ID0gcmVxdWlyZShcIi4vcGVyZm9ybWFuY2VOb3dcIik7XG5cbmZ1bmN0aW9uIHJvdW5kRmxvYXQodmFsKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKHZhbCAqIDEwMCkgLyAxMDA7XG59XG5cbmZ1bmN0aW9uIGFkZFZhbHVlKG9iaiwga2V5LCB2YWwpIHtcbiAgb2JqW2tleV0gPSAob2JqW2tleV0gfHwgMCkgKyB2YWw7XG59XG5cbnZhciBSZWFjdERlZmF1bHRQZXJmID0ge1xuICBfYWxsTWVhc3VyZW1lbnRzOiBbXSwgLy8gbGFzdCBpdGVtIGluIHRoZSBsaXN0IGlzIHRoZSBjdXJyZW50IG9uZVxuICBfbW91bnRTdGFjazogWzBdLFxuICBfaW5qZWN0ZWQ6IGZhbHNlLFxuXG4gIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIVJlYWN0RGVmYXVsdFBlcmYuX2luamVjdGVkKSB7XG4gICAgICBSZWFjdFBlcmYuaW5qZWN0aW9uLmluamVjdE1lYXN1cmUoUmVhY3REZWZhdWx0UGVyZi5tZWFzdXJlKTtcbiAgICB9XG5cbiAgICBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoID0gMDtcbiAgICBSZWFjdFBlcmYuZW5hYmxlTWVhc3VyZSA9IHRydWU7XG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgUmVhY3RQZXJmLmVuYWJsZU1lYXN1cmUgPSBmYWxzZTtcbiAgfSxcblxuICBnZXRMYXN0TWVhc3VyZW1lbnRzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICB9LFxuXG4gIHByaW50RXhjbHVzaXZlOiBmdW5jdGlvbihtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEV4Y2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzKTtcbiAgICBjb25zb2xlLnRhYmxlKHN1bW1hcnkubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdDb21wb25lbnQgY2xhc3MgbmFtZSc6IGl0ZW0uY29tcG9uZW50TmFtZSxcbiAgICAgICAgJ1RvdGFsIGluY2x1c2l2ZSB0aW1lIChtcyknOiByb3VuZEZsb2F0KGl0ZW0uaW5jbHVzaXZlKSxcbiAgICAgICAgJ0V4Y2x1c2l2ZSBtb3VudCB0aW1lIChtcyknOiByb3VuZEZsb2F0KGl0ZW0uZXhjbHVzaXZlKSxcbiAgICAgICAgJ0V4Y2x1c2l2ZSByZW5kZXIgdGltZSAobXMpJzogcm91bmRGbG9hdChpdGVtLnJlbmRlciksXG4gICAgICAgICdNb3VudCB0aW1lIHBlciBpbnN0YW5jZSAobXMpJzogcm91bmRGbG9hdChpdGVtLmV4Y2x1c2l2ZSAvIGl0ZW0uY291bnQpLFxuICAgICAgICAnUmVuZGVyIHRpbWUgcGVyIGluc3RhbmNlIChtcyknOiByb3VuZEZsb2F0KGl0ZW0ucmVuZGVyIC8gaXRlbS5jb3VudCksXG4gICAgICAgICdJbnN0YW5jZXMnOiBpdGVtLmNvdW50XG4gICAgICB9O1xuICAgIH0pKTtcbiAgICAvLyBUT0RPOiBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKCkgZG9lcyBub3QgcmV0dXJuIHRoZSBjb3JyZWN0XG4gICAgLy8gbnVtYmVyLlxuICB9LFxuXG4gIHByaW50SW5jbHVzaXZlOiBmdW5jdGlvbihtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEluY2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzKTtcbiAgICBjb25zb2xlLnRhYmxlKHN1bW1hcnkubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdPd25lciA+IGNvbXBvbmVudCc6IGl0ZW0uY29tcG9uZW50TmFtZSxcbiAgICAgICAgJ0luY2x1c2l2ZSB0aW1lIChtcyknOiByb3VuZEZsb2F0KGl0ZW0udGltZSksXG4gICAgICAgICdJbnN0YW5jZXMnOiBpdGVtLmNvdW50XG4gICAgICB9O1xuICAgIH0pKTtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgICdUb3RhbCB0aW1lOicsXG4gICAgICBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykudG9GaXhlZCgyKSArICcgbXMnXG4gICAgKTtcbiAgfSxcblxuICBnZXRNZWFzdXJlbWVudHNTdW1tYXJ5TWFwOiBmdW5jdGlvbihtZWFzdXJlbWVudHMpIHtcbiAgICB2YXIgc3VtbWFyeSA9IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRJbmNsdXNpdmVTdW1tYXJ5KFxuICAgICAgbWVhc3VyZW1lbnRzLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgcmV0dXJuIHN1bW1hcnkubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdPd25lciA+IGNvbXBvbmVudCc6IGl0ZW0uY29tcG9uZW50TmFtZSxcbiAgICAgICAgJ1dhc3RlZCB0aW1lIChtcyknOiBpdGVtLnRpbWUsXG4gICAgICAgICdJbnN0YW5jZXMnOiBpdGVtLmNvdW50XG4gICAgICB9O1xuICAgIH0pO1xuICB9LFxuXG4gIHByaW50V2FzdGVkOiBmdW5jdGlvbihtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIGNvbnNvbGUudGFibGUoUmVhY3REZWZhdWx0UGVyZi5nZXRNZWFzdXJlbWVudHNTdW1tYXJ5TWFwKG1lYXN1cmVtZW50cykpO1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgJ1RvdGFsIHRpbWU6JyxcbiAgICAgIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRUb3RhbFRpbWUobWVhc3VyZW1lbnRzKS50b0ZpeGVkKDIpICsgJyBtcydcbiAgICApO1xuICB9LFxuXG4gIHByaW50RE9NOiBmdW5jdGlvbihtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldERPTVN1bW1hcnkobWVhc3VyZW1lbnRzKTtcbiAgICBjb25zb2xlLnRhYmxlKHN1bW1hcnkubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIHJlc3VsdFtET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRV0gPSBpdGVtLmlkO1xuICAgICAgcmVzdWx0Wyd0eXBlJ10gPSBpdGVtLnR5cGU7XG4gICAgICByZXN1bHRbJ2FyZ3MnXSA9IEpTT04uc3RyaW5naWZ5KGl0ZW0uYXJncyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pKTtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgICdUb3RhbCB0aW1lOicsXG4gICAgICBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykudG9GaXhlZCgyKSArICcgbXMnXG4gICAgKTtcbiAgfSxcblxuICBfcmVjb3JkV3JpdGU6IGZ1bmN0aW9uKGlkLCBmbk5hbWUsIHRvdGFsVGltZSwgYXJncykge1xuICAgIC8vIFRPRE86IHRvdGFsVGltZSBpc24ndCB0aGF0IHVzZWZ1bCBzaW5jZSBpdCBkb2Vzbid0IGNvdW50IHBhaW50cy9yZWZsb3dzXG4gICAgdmFyIHdyaXRlcyA9XG4gICAgICBSZWFjdERlZmF1bHRQZXJmXG4gICAgICAgIC5fYWxsTWVhc3VyZW1lbnRzW1JlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cy5sZW5ndGggLSAxXVxuICAgICAgICAud3JpdGVzO1xuICAgIHdyaXRlc1tpZF0gPSB3cml0ZXNbaWRdIHx8IFtdO1xuICAgIHdyaXRlc1tpZF0ucHVzaCh7XG4gICAgICB0eXBlOiBmbk5hbWUsXG4gICAgICB0aW1lOiB0b3RhbFRpbWUsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfSk7XG4gIH0sXG5cbiAgbWVhc3VyZTogZnVuY3Rpb24obW9kdWxlTmFtZSwgZm5OYW1lLCBmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge2ZvciAodmFyIGFyZ3M9W10sJF9fMD0wLCRfXzE9YXJndW1lbnRzLmxlbmd0aDskX18wPCRfXzE7JF9fMCsrKSBhcmdzLnB1c2goYXJndW1lbnRzWyRfXzBdKTtcbiAgICAgIHZhciB0b3RhbFRpbWU7XG4gICAgICB2YXIgcnY7XG4gICAgICB2YXIgc3RhcnQ7XG5cbiAgICAgIGlmIChmbk5hbWUgPT09ICdfcmVuZGVyTmV3Um9vdENvbXBvbmVudCcgfHxcbiAgICAgICAgICBmbk5hbWUgPT09ICdmbHVzaEJhdGNoZWRVcGRhdGVzJykge1xuICAgICAgICAvLyBBIFwibWVhc3VyZW1lbnRcIiBpcyBhIHNldCBvZiBtZXRyaWNzIHJlY29yZGVkIGZvciBlYWNoIGZsdXNoLiBXZSB3YW50XG4gICAgICAgIC8vIHRvIGdyb3VwIHRoZSBtZXRyaWNzIGZvciBhIGdpdmVuIGZsdXNoIHRvZ2V0aGVyIHNvIHdlIGNhbiBsb29rIGF0IHRoZVxuICAgICAgICAvLyBjb21wb25lbnRzIHRoYXQgcmVuZGVyZWQgYW5kIHRoZSBET00gb3BlcmF0aW9ucyB0aGF0IGFjdHVhbGx5XG4gICAgICAgIC8vIGhhcHBlbmVkIHRvIGRldGVybWluZSB0aGUgYW1vdW50IG9mIFwid2FzdGVkIHdvcmtcIiBwZXJmb3JtZWQuXG4gICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cy5wdXNoKHtcbiAgICAgICAgICBleGNsdXNpdmU6IHt9LFxuICAgICAgICAgIGluY2x1c2l2ZToge30sXG4gICAgICAgICAgcmVuZGVyOiB7fSxcbiAgICAgICAgICBjb3VudHM6IHt9LFxuICAgICAgICAgIHdyaXRlczoge30sXG4gICAgICAgICAgZGlzcGxheU5hbWVzOiB7fSxcbiAgICAgICAgICB0b3RhbFRpbWU6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgcnYgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHNbXG4gICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFcbiAgICAgICAgXS50b3RhbFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpIC0gc3RhcnQ7XG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH0gZWxzZSBpZiAobW9kdWxlTmFtZSA9PT0gJ1JlYWN0RE9NSURPcGVyYXRpb25zJyB8fFxuICAgICAgICBtb2R1bGVOYW1lID09PSAnUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQnKSB7XG4gICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgcnYgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB0b3RhbFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpIC0gc3RhcnQ7XG5cbiAgICAgICAgaWYgKGZuTmFtZSA9PT0gJ21vdW50SW1hZ2VJbnRvTm9kZScpIHtcbiAgICAgICAgICB2YXIgbW91bnRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoYXJnc1sxXSk7XG4gICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fcmVjb3JkV3JpdGUobW91bnRJRCwgZm5OYW1lLCB0b3RhbFRpbWUsIGFyZ3NbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGZuTmFtZSA9PT0gJ2Rhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcycpIHtcbiAgICAgICAgICAvLyBzcGVjaWFsIGZvcm1hdFxuICAgICAgICAgIGFyZ3NbMF0uZm9yRWFjaChmdW5jdGlvbih1cGRhdGUpIHtcbiAgICAgICAgICAgIHZhciB3cml0ZUFyZ3MgPSB7fTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZnJvbUluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdyaXRlQXJncy5mcm9tSW5kZXggPSB1cGRhdGUuZnJvbUluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZS50b0luZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdyaXRlQXJncy50b0luZGV4ID0gdXBkYXRlLnRvSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLnRleHRDb250ZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdyaXRlQXJncy50ZXh0Q29udGVudCA9IHVwZGF0ZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGUubWFya3VwSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLm1hcmt1cCA9IGFyZ3NbMV1bdXBkYXRlLm1hcmt1cEluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX3JlY29yZFdyaXRlKFxuICAgICAgICAgICAgICB1cGRhdGUucGFyZW50SUQsXG4gICAgICAgICAgICAgIHVwZGF0ZS50eXBlLFxuICAgICAgICAgICAgICB0b3RhbFRpbWUsXG4gICAgICAgICAgICAgIHdyaXRlQXJnc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBiYXNpYyBmb3JtYXRcbiAgICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9yZWNvcmRXcml0ZShcbiAgICAgICAgICAgIGFyZ3NbMF0sXG4gICAgICAgICAgICBmbk5hbWUsXG4gICAgICAgICAgICB0b3RhbFRpbWUsXG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSBlbHNlIGlmIChtb2R1bGVOYW1lID09PSAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnICYmIChcbiAgICAgICAgZm5OYW1lID09PSAnbW91bnRDb21wb25lbnQnIHx8XG4gICAgICAgIGZuTmFtZSA9PT0gJ3VwZGF0ZUNvbXBvbmVudCcgfHwgLy8gVE9ETzogcmVjZWl2ZUNvbXBvbmVudCgpP1xuICAgICAgICBmbk5hbWUgPT09ICdfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50JykpIHtcblxuICAgICAgICB2YXIgcm9vdE5vZGVJRCA9IGZuTmFtZSA9PT0gJ21vdW50Q29tcG9uZW50JyA/XG4gICAgICAgICAgYXJnc1swXSA6XG4gICAgICAgICAgdGhpcy5fcm9vdE5vZGVJRDtcbiAgICAgICAgdmFyIGlzUmVuZGVyID0gZm5OYW1lID09PSAnX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCc7XG4gICAgICAgIHZhciBpc01vdW50ID0gZm5OYW1lID09PSAnbW91bnRDb21wb25lbnQnO1xuXG4gICAgICAgIHZhciBtb3VudFN0YWNrID0gUmVhY3REZWZhdWx0UGVyZi5fbW91bnRTdGFjaztcbiAgICAgICAgdmFyIGVudHJ5ID0gUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzW1xuICAgICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cy5sZW5ndGggLSAxXG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKGlzUmVuZGVyKSB7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuY291bnRzLCByb290Tm9kZUlELCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdW50KSB7XG4gICAgICAgICAgbW91bnRTdGFjay5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBydiA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHRvdGFsVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSBzdGFydDtcblxuICAgICAgICBpZiAoaXNSZW5kZXIpIHtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5yZW5kZXIsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VudCkge1xuICAgICAgICAgIHZhciBzdWJNb3VudFRpbWUgPSBtb3VudFN0YWNrLnBvcCgpO1xuICAgICAgICAgIG1vdW50U3RhY2tbbW91bnRTdGFjay5sZW5ndGggLSAxXSArPSB0b3RhbFRpbWU7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuZXhjbHVzaXZlLCByb290Tm9kZUlELCB0b3RhbFRpbWUgLSBzdWJNb3VudFRpbWUpO1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LmluY2x1c2l2ZSwgcm9vdE5vZGVJRCwgdG90YWxUaW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5pbmNsdXNpdmUsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbnRyeS5kaXNwbGF5TmFtZXNbcm9vdE5vZGVJRF0gPSB7XG4gICAgICAgICAgY3VycmVudDogdGhpcy5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSxcbiAgICAgICAgICBvd25lcjogdGhpcy5fb3duZXIgPyB0aGlzLl9vd25lci5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSA6ICc8cm9vdD4nXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRQZXJmO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpc1xuICovXG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xuXG4vLyBEb24ndCB0cnkgdG8gc2F2ZSB1c2VycyBsZXNzIHRoYW4gMS4ybXMgKGEgbnVtYmVyIEkgbWFkZSB1cClcbnZhciBET05UX0NBUkVfVEhSRVNIT0xEID0gMS4yO1xudmFyIERPTV9PUEVSQVRJT05fVFlQRVMgPSB7XG4gICdtb3VudEltYWdlSW50b05vZGUnOiAnc2V0IGlubmVySFRNTCcsXG4gIElOU0VSVF9NQVJLVVA6ICdzZXQgaW5uZXJIVE1MJyxcbiAgTU9WRV9FWElTVElORzogJ21vdmUnLFxuICBSRU1PVkVfTk9ERTogJ3JlbW92ZScsXG4gIFRFWFRfQ09OVEVOVDogJ3NldCB0ZXh0Q29udGVudCcsXG4gICd1cGRhdGVQcm9wZXJ0eUJ5SUQnOiAndXBkYXRlIGF0dHJpYnV0ZScsXG4gICdkZWxldGVQcm9wZXJ0eUJ5SUQnOiAnZGVsZXRlIGF0dHJpYnV0ZScsXG4gICd1cGRhdGVTdHlsZXNCeUlEJzogJ3VwZGF0ZSBzdHlsZXMnLFxuICAndXBkYXRlSW5uZXJIVE1MQnlJRCc6ICdzZXQgaW5uZXJIVE1MJyxcbiAgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCc6ICdyZXBsYWNlJ1xufTtcblxuZnVuY3Rpb24gZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykge1xuICAvLyBUT0RPOiByZXR1cm4gbnVtYmVyIG9mIERPTSBvcHM/IGNvdWxkIGJlIG1pc2xlYWRpbmcuXG4gIC8vIFRPRE86IG1lYXN1cmUgZHJvcHBlZCBmcmFtZXMgYWZ0ZXIgcmVjb25jaWxlP1xuICAvLyBUT0RPOiBsb2cgdG90YWwgdGltZSBvZiBlYWNoIHJlY29uY2lsZSBhbmQgdGhlIHRvcC1sZXZlbCBjb21wb25lbnRcbiAgLy8gY2xhc3MgdGhhdCB0cmlnZ2VyZWQgaXQuXG4gIHZhciB0b3RhbFRpbWUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB0b3RhbFRpbWUgKz0gbWVhc3VyZW1lbnQudG90YWxUaW1lO1xuICB9XG4gIHJldHVybiB0b3RhbFRpbWU7XG59XG5cbmZ1bmN0aW9uIGdldERPTVN1bW1hcnkobWVhc3VyZW1lbnRzKSB7XG4gIHZhciBpdGVtcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB2YXIgaWQ7XG5cbiAgICBmb3IgKGlkIGluIG1lYXN1cmVtZW50LndyaXRlcykge1xuICAgICAgbWVhc3VyZW1lbnQud3JpdGVzW2lkXS5mb3JFYWNoKGZ1bmN0aW9uKHdyaXRlKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICB0eXBlOiBET01fT1BFUkFUSU9OX1RZUEVTW3dyaXRlLnR5cGVdIHx8IHdyaXRlLnR5cGUsXG4gICAgICAgICAgYXJnczogd3JpdGUuYXJnc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG5cbmZ1bmN0aW9uIGdldEV4Y2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzKSB7XG4gIHZhciBjYW5kaWRhdGVzID0ge307XG4gIHZhciBkaXNwbGF5TmFtZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB2YXIgYWxsSURzID0gYXNzaWduKFxuICAgICAge30sXG4gICAgICBtZWFzdXJlbWVudC5leGNsdXNpdmUsXG4gICAgICBtZWFzdXJlbWVudC5pbmNsdXNpdmVcbiAgICApO1xuXG4gICAgZm9yICh2YXIgaWQgaW4gYWxsSURzKSB7XG4gICAgICBkaXNwbGF5TmFtZSA9IG1lYXN1cmVtZW50LmRpc3BsYXlOYW1lc1tpZF0uY3VycmVudDtcblxuICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0gPSBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXSB8fCB7XG4gICAgICAgIGNvbXBvbmVudE5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICBpbmNsdXNpdmU6IDAsXG4gICAgICAgIGV4Y2x1c2l2ZTogMCxcbiAgICAgICAgcmVuZGVyOiAwLFxuICAgICAgICBjb3VudDogMFxuICAgICAgfTtcbiAgICAgIGlmIChtZWFzdXJlbWVudC5yZW5kZXJbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLnJlbmRlciArPSBtZWFzdXJlbWVudC5yZW5kZXJbaWRdO1xuICAgICAgfVxuICAgICAgaWYgKG1lYXN1cmVtZW50LmV4Y2x1c2l2ZVtpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0uZXhjbHVzaXZlICs9IG1lYXN1cmVtZW50LmV4Y2x1c2l2ZVtpZF07XG4gICAgICB9XG4gICAgICBpZiAobWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5pbmNsdXNpdmUgKz0gbWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWFzdXJlbWVudC5jb3VudHNbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLmNvdW50ICs9IG1lYXN1cmVtZW50LmNvdW50c1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTm93IG1ha2UgYSBzb3J0ZWQgYXJyYXkgd2l0aCB0aGUgcmVzdWx0cy5cbiAgdmFyIGFyciA9IFtdO1xuICBmb3IgKGRpc3BsYXlOYW1lIGluIGNhbmRpZGF0ZXMpIHtcbiAgICBpZiAoY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0uZXhjbHVzaXZlID49IERPTlRfQ0FSRV9USFJFU0hPTEQpIHtcbiAgICAgIGFyci5wdXNoKGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdKTtcbiAgICB9XG4gIH1cblxuICBhcnIuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGIuZXhjbHVzaXZlIC0gYS5leGNsdXNpdmU7XG4gIH0pO1xuXG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIGdldEluY2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzLCBvbmx5Q2xlYW4pIHtcbiAgdmFyIGNhbmRpZGF0ZXMgPSB7fTtcbiAgdmFyIGluY2x1c2l2ZUtleTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB2YXIgYWxsSURzID0gYXNzaWduKFxuICAgICAge30sXG4gICAgICBtZWFzdXJlbWVudC5leGNsdXNpdmUsXG4gICAgICBtZWFzdXJlbWVudC5pbmNsdXNpdmVcbiAgICApO1xuICAgIHZhciBjbGVhbkNvbXBvbmVudHM7XG5cbiAgICBpZiAob25seUNsZWFuKSB7XG4gICAgICBjbGVhbkNvbXBvbmVudHMgPSBnZXRVbmNoYW5nZWRDb21wb25lbnRzKG1lYXN1cmVtZW50KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpZCBpbiBhbGxJRHMpIHtcbiAgICAgIGlmIChvbmx5Q2xlYW4gJiYgIWNsZWFuQ29tcG9uZW50c1tpZF0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IG1lYXN1cmVtZW50LmRpc3BsYXlOYW1lc1tpZF07XG5cbiAgICAgIC8vIEluY2x1c2l2ZSB0aW1lIGlzIG5vdCB1c2VmdWwgZm9yIG1hbnkgY29tcG9uZW50cyB3aXRob3V0IGtub3dpbmcgd2hlcmVcbiAgICAgIC8vIHRoZXkgYXJlIGluc3RhbnRpYXRlZC4gU28gd2UgYWdncmVnYXRlIGluY2x1c2l2ZSB0aW1lIHdpdGggYm90aCB0aGVcbiAgICAgIC8vIG93bmVyIGFuZCBjdXJyZW50IGRpc3BsYXlOYW1lIGFzIHRoZSBrZXkuXG4gICAgICBpbmNsdXNpdmVLZXkgPSBkaXNwbGF5TmFtZS5vd25lciArICcgPiAnICsgZGlzcGxheU5hbWUuY3VycmVudDtcblxuICAgICAgY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldID0gY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldIHx8IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogaW5jbHVzaXZlS2V5LFxuICAgICAgICB0aW1lOiAwLFxuICAgICAgICBjb3VudDogMFxuICAgICAgfTtcblxuICAgICAgaWYgKG1lYXN1cmVtZW50LmluY2x1c2l2ZVtpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldLnRpbWUgKz0gbWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWFzdXJlbWVudC5jb3VudHNbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XS5jb3VudCArPSBtZWFzdXJlbWVudC5jb3VudHNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE5vdyBtYWtlIGEgc29ydGVkIGFycmF5IHdpdGggdGhlIHJlc3VsdHMuXG4gIHZhciBhcnIgPSBbXTtcbiAgZm9yIChpbmNsdXNpdmVLZXkgaW4gY2FuZGlkYXRlcykge1xuICAgIGlmIChjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0udGltZSA+PSBET05UX0NBUkVfVEhSRVNIT0xEKSB7XG4gICAgICBhcnIucHVzaChjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0pO1xuICAgIH1cbiAgfVxuXG4gIGFyci5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYi50aW1lIC0gYS50aW1lO1xuICB9KTtcblxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBnZXRVbmNoYW5nZWRDb21wb25lbnRzKG1lYXN1cmVtZW50KSB7XG4gIC8vIEZvciBhIGdpdmVuIHJlY29uY2lsZSwgbG9vayBhdCB3aGljaCBjb21wb25lbnRzIGRpZCBub3QgYWN0dWFsbHlcbiAgLy8gcmVuZGVyIGFueXRoaW5nIHRvIHRoZSBET00gYW5kIHJldHVybiBhIG1hcHBpbmcgb2YgdGhlaXIgSUQgdG9cbiAgLy8gdGhlIGFtb3VudCBvZiB0aW1lIGl0IHRvb2sgdG8gcmVuZGVyIHRoZSBlbnRpcmUgc3VidHJlZS5cbiAgdmFyIGNsZWFuQ29tcG9uZW50cyA9IHt9O1xuICB2YXIgZGlydHlMZWFmSURzID0gT2JqZWN0LmtleXMobWVhc3VyZW1lbnQud3JpdGVzKTtcbiAgdmFyIGFsbElEcyA9IGFzc2lnbih7fSwgbWVhc3VyZW1lbnQuZXhjbHVzaXZlLCBtZWFzdXJlbWVudC5pbmNsdXNpdmUpO1xuXG4gIGZvciAodmFyIGlkIGluIGFsbElEcykge1xuICAgIHZhciBpc0RpcnR5ID0gZmFsc2U7XG4gICAgLy8gRm9yIGVhY2ggY29tcG9uZW50IHRoYXQgcmVuZGVyZWQsIHNlZSBpZiBhIGNvbXBvbmVudCB0aGF0IHRyaWdnZXJlZFxuICAgIC8vIGEgRE9NIG9wIGlzIGluIGl0cyBzdWJ0cmVlLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlydHlMZWFmSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZGlydHlMZWFmSURzW2ldLmluZGV4T2YoaWQpID09PSAwKSB7XG4gICAgICAgIGlzRGlydHkgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0RpcnR5ICYmIG1lYXN1cmVtZW50LmNvdW50c1tpZF0gPiAwKSB7XG4gICAgICBjbGVhbkNvbXBvbmVudHNbaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsZWFuQ29tcG9uZW50cztcbn1cblxudmFyIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcyA9IHtcbiAgZ2V0RXhjbHVzaXZlU3VtbWFyeTogZ2V0RXhjbHVzaXZlU3VtbWFyeSxcbiAgZ2V0SW5jbHVzaXZlU3VtbWFyeTogZ2V0SW5jbHVzaXZlU3VtbWFyeSxcbiAgZ2V0RE9NU3VtbWFyeTogZ2V0RE9NU3VtbWFyeSxcbiAgZ2V0VG90YWxUaW1lOiBnZXRUb3RhbFRpbWVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbGVtZW50XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdENvbnRleHQgPSByZXF1aXJlKFwiLi9SZWFjdENvbnRleHRcIik7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdEN1cnJlbnRPd25lclwiKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlXG59O1xuXG4vKipcbiAqIFdhcm4gZm9yIG11dGF0aW9ucy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuZnVuY3Rpb24gZGVmaW5lV2FybmluZ1Byb3BlcnR5KG9iamVjdCwga2V5KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fc3RvcmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fc3RvcmVba2V5XTtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnRG9uXFwndCBzZXQgdGhlICcgKyBrZXkgKyAnIHByb3BlcnR5IG9mIHRoZSBjb21wb25lbnQuICcgK1xuICAgICAgICAnTXV0YXRlIHRoZSBleGlzdGluZyBwcm9wcyBvYmplY3QgaW5zdGVhZC4nXG4gICAgICApIDogbnVsbCk7XG4gICAgICB0aGlzLl9zdG9yZVtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gIH0pO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgdXBkYXRlZCB0byB0cnVlIGlmIHRoZSBtZW1icmFuZSBpcyBzdWNjZXNzZnVsbHkgY3JlYXRlZC5cbiAqL1xudmFyIHVzZU11dGF0aW9uTWVtYnJhbmUgPSBmYWxzZTtcblxuLyoqXG4gKiBXYXJuIGZvciBtdXRhdGlvbnMuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiBkZWZpbmVNdXRhdGlvbk1lbWJyYW5lKHByb3RvdHlwZSkge1xuICB0cnkge1xuICAgIHZhciBwc2V1ZG9Gcm96ZW5Qcm9wZXJ0aWVzID0ge1xuICAgICAgcHJvcHM6IHRydWVcbiAgICB9O1xuICAgIGZvciAodmFyIGtleSBpbiBwc2V1ZG9Gcm96ZW5Qcm9wZXJ0aWVzKSB7XG4gICAgICBkZWZpbmVXYXJuaW5nUHJvcGVydHkocHJvdG90eXBlLCBrZXkpO1xuICAgIH1cbiAgICB1c2VNdXRhdGlvbk1lbWJyYW5lID0gdHJ1ZTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIElFIHdpbGwgZmFpbCBvbiBkZWZpbmVQcm9wZXJ0eVxuICB9XG59XG5cbi8qKlxuICogQmFzZSBjb25zdHJ1Y3RvciBmb3IgYWxsIFJlYWN0IGVsZW1lbnRzLiBUaGlzIGlzIG9ubHkgdXNlZCB0byBtYWtlIHRoaXNcbiAqIHdvcmsgd2l0aCBhIGR5bmFtaWMgaW5zdGFuY2VvZiBjaGVjay4gTm90aGluZyBzaG91bGQgbGl2ZSBvbiB0aGlzIHByb3RvdHlwZS5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbih0eXBlLCBrZXksIHJlZiwgb3duZXIsIGNvbnRleHQsIHByb3BzKSB7XG4gIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMucmVmID0gcmVmO1xuXG4gIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gIHRoaXMuX293bmVyID0gb3duZXI7XG5cbiAgLy8gVE9ETzogRGVwcmVjYXRlIHdpdGhDb250ZXh0LCBhbmQgdGhlbiB0aGUgY29udGV4dCBiZWNvbWVzIGFjY2Vzc2libGVcbiAgLy8gdGhyb3VnaCB0aGUgb3duZXIuXG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGFuZCBwcm9wcyBhcmUgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgdGhlbSBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIHRoaXMuX3N0b3JlID0geyB2YWxpZGF0ZWQ6IGZhbHNlLCBwcm9wczogcHJvcHMgfTtcblxuICAgIC8vIFdlJ3JlIG5vdCBhbGxvd2VkIHRvIHNldCBwcm9wcyBkaXJlY3RseSBvbiB0aGUgb2JqZWN0IHNvIHdlIGVhcmx5XG4gICAgLy8gcmV0dXJuIGFuZCByZWx5IG9uIHRoZSBwcm90b3R5cGUgbWVtYnJhbmUgdG8gZm9yd2FyZCB0byB0aGUgYmFja2luZ1xuICAgIC8vIHN0b3JlLlxuICAgIGlmICh1c2VNdXRhdGlvbk1lbWJyYW5lKSB7XG4gICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbn07XG5cbi8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgZXhwb3NlIHRoZSBmdW5jdGlvbiBvbiB0aGUgY29uc3RydWN0b3IgcHJvcGVydHkuXG4vLyBSZWFjdEVsZW1lbnQgc2hvdWxkIGJlIGluZGlzdGluZ3Vpc2hhYmxlIGZyb20gYSBwbGFpbiBvYmplY3QuXG5SZWFjdEVsZW1lbnQucHJvdG90eXBlID0ge1xuICBfaXNSZWFjdEVsZW1lbnQ6IHRydWVcbn07XG5cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgZGVmaW5lTXV0YXRpb25NZW1icmFuZShSZWFjdEVsZW1lbnQucHJvdG90eXBlKTtcbn1cblxuUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbih0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICByZWYgPSBjb25maWcucmVmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLnJlZjtcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhcbiAgICAgICAgY29uZmlnLmtleSAhPT0gbnVsbCxcbiAgICAgICAgJ2NyZWF0ZUVsZW1lbnQoLi4uKTogRW5jb3VudGVyZWQgY29tcG9uZW50IHdpdGggYSBga2V5YCBvZiBudWxsLiBJbiAnICtcbiAgICAgICAgJ2EgZnV0dXJlIHZlcnNpb24sIHRoaXMgd2lsbCBiZSB0cmVhdGVkIGFzIGVxdWl2YWxlbnQgdG8gdGhlIHN0cmluZyAnICtcbiAgICAgICAgJ1xcJ251bGxcXCc7IGluc3RlYWQsIHByb3ZpZGUgYW4gZXhwbGljaXQga2V5IG9yIHVzZSB1bmRlZmluZWQuJ1xuICAgICAgKSA6IG51bGwpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBDaGFuZ2UgdGhpcyBiYWNrIHRvIGBjb25maWcua2V5ID09PSB1bmRlZmluZWRgXG4gICAga2V5ID0gY29uZmlnLmtleSA9PSBudWxsID8gbnVsbCA6ICcnICsgY29uZmlnLmtleTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmXG4gICAgICAgICAgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHNbcHJvcE5hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgUmVhY3RFbGVtZW50KFxuICAgIHR5cGUsXG4gICAga2V5LFxuICAgIHJlZixcbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LFxuICAgIFJlYWN0Q29udGV4dC5jdXJyZW50LFxuICAgIHByb3BzXG4gICk7XG59O1xuXG5SZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAvLyBFeHBvc2UgdGhlIHR5cGUgb24gdGhlIGZhY3RvcnkgYW5kIHRoZSBwcm90b3R5cGUgc28gdGhhdCBpdCBjYW4gYmVcbiAgLy8gZWFzaWx5IGFjY2Vzc2VkIG9uIGVsZW1lbnRzLiBFLmcuIDxGb28gLz4udHlwZSA9PT0gRm9vLnR5cGUuXG4gIC8vIFRoaXMgc2hvdWxkIG5vdCBiZSBuYW1lZCBgY29uc3RydWN0b3JgIHNpbmNlIHRoaXMgbWF5IG5vdCBiZSB0aGUgZnVuY3Rpb25cbiAgLy8gdGhhdCBjcmVhdGVkIHRoZSBlbGVtZW50LCBhbmQgaXQgbWF5IG5vdCBldmVuIGJlIGEgY29uc3RydWN0b3IuXG4gIGZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIHJldHVybiBmYWN0b3J5O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZVByb3BzID0gZnVuY3Rpb24ob2xkRWxlbWVudCwgbmV3UHJvcHMpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBuZXcgUmVhY3RFbGVtZW50KFxuICAgIG9sZEVsZW1lbnQudHlwZSxcbiAgICBvbGRFbGVtZW50LmtleSxcbiAgICBvbGRFbGVtZW50LnJlZixcbiAgICBvbGRFbGVtZW50Ll9vd25lcixcbiAgICBvbGRFbGVtZW50Ll9jb250ZXh0LFxuICAgIG5ld1Byb3BzXG4gICk7XG5cbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIC8vIElmIHRoZSBrZXkgb24gdGhlIG9yaWdpbmFsIGlzIHZhbGlkLCB0aGVuIHRoZSBjbG9uZSBpcyB2YWxpZFxuICAgIG5ld0VsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IG9sZEVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZDtcbiAgfVxuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gIC8vIFJlYWN0VGVzdFV0aWxzIGlzIG9mdGVuIHVzZWQgb3V0c2lkZSBvZiBiZWZvcmVFYWNoIHdoZXJlIGFzIFJlYWN0IGlzXG4gIC8vIHdpdGhpbiBpdC4gVGhpcyBsZWFkcyB0byB0d28gZGlmZmVyZW50IGluc3RhbmNlcyBvZiBSZWFjdCBvbiB0aGUgc2FtZVxuICAvLyBwYWdlLiBUbyBpZGVudGlmeSBhIGVsZW1lbnQgZnJvbSBhIGRpZmZlcmVudCBSZWFjdCBpbnN0YW5jZSB3ZSB1c2VcbiAgLy8gYSBmbGFnIGluc3RlYWQgb2YgYW4gaW5zdGFuY2VvZiBjaGVjay5cbiAgdmFyIGlzRWxlbWVudCA9ICEhKG9iamVjdCAmJiBvYmplY3QuX2lzUmVhY3RFbGVtZW50KTtcbiAgLy8gaWYgKGlzRWxlbWVudCAmJiAhKG9iamVjdCBpbnN0YW5jZW9mIFJlYWN0RWxlbWVudCkpIHtcbiAgLy8gVGhpcyBpcyBhbiBpbmRpY2F0b3IgdGhhdCB5b3UncmUgdXNpbmcgbXVsdGlwbGUgdmVyc2lvbnMgb2YgUmVhY3QgYXQgdGhlXG4gIC8vIHNhbWUgdGltZS4gVGhpcyB3aWxsIHNjcmV3IHdpdGggb3duZXJzaGlwIGFuZCBzdHVmZi4gRml4IGl0LCBwbGVhc2UuXG4gIC8vIFRPRE86IFdlIGNvdWxkIHBvc3NpYmx5IHdhcm4gaGVyZS5cbiAgLy8gfVxuICByZXR1cm4gaXNFbGVtZW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnQ7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbGVtZW50VmFsaWRhdG9yXG4gKi9cblxuLyoqXG4gKiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgcHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBhIGVsZW1lbnQgZmFjdG9yeVxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXG4gKiB0aGF0IHN1cHBvcnQgaXQuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoXCIuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnNcIik7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdEN1cnJlbnRPd25lclwiKTtcblxudmFyIG1vbml0b3JDb2RlVXNlID0gcmVxdWlyZShcIi4vbW9uaXRvckNvZGVVc2VcIik7XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge1xuICAncmVhY3Rfa2V5X3dhcm5pbmcnOiB7fSxcbiAgJ3JlYWN0X251bWVyaWNfa2V5X3dhcm5pbmcnOiB7fVxufTtcbnZhciBvd25lckhhc01vbml0b3JlZE9iamVjdE1hcCA9IHt9O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cbnZhciBOVU1FUklDX1BST1BFUlRZX1JFR0VYID0gL15cXGQrJC87XG5cbi8qKlxuICogR2V0cyB0aGUgY3VycmVudCBvd25lcidzIGRpc3BsYXlOYW1lIGZvciB1c2UgaW4gd2FybmluZ3MuXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBEaXNwbGF5IG5hbWUgb3IgdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGdldEN1cnJlbnRPd25lckRpc3BsYXlOYW1lKCkge1xuICB2YXIgY3VycmVudCA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gIHJldHVybiBjdXJyZW50ICYmIGN1cnJlbnQuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGNvbXBvbmVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBjb21wb25lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgY29tcG9uZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShjb21wb25lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKGNvbXBvbmVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb21wb25lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgd2FybkFuZE1vbml0b3JGb3JLZXlVc2UoXG4gICAgJ3JlYWN0X2tleV93YXJuaW5nJyxcbiAgICAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyxcbiAgICBjb21wb25lbnQsXG4gICAgcGFyZW50VHlwZVxuICApO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGtleSBpcyBiZWluZyBkZWZpbmVkIGFzIGFuIG9iamVjdCBwcm9wZXJ0eSBidXQgaGFzIGFuIGluY29ycmVjdFxuICogdmFsdWUuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBQcm9wZXJ0eSBuYW1lIG9mIHRoZSBrZXkuXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgY29tcG9uZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eUtleShuYW1lLCBjb21wb25lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFOVU1FUklDX1BST1BFUlRZX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybkFuZE1vbml0b3JGb3JLZXlVc2UoXG4gICAgJ3JlYWN0X251bWVyaWNfa2V5X3dhcm5pbmcnLFxuICAgICdDaGlsZCBvYmplY3RzIHNob3VsZCBoYXZlIG5vbi1udW1lcmljIGtleXMgc28gb3JkZXJpbmcgaXMgcHJlc2VydmVkLicsXG4gICAgY29tcG9uZW50LFxuICAgIHBhcmVudFR5cGVcbiAgKTtcbn1cblxuLyoqXG4gKiBTaGFyZWQgd2FybmluZyBhbmQgbW9uaXRvcmluZyBjb2RlIGZvciB0aGUga2V5IHdhcm5pbmdzLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtzdHJpbmd9IHdhcm5pbmdJRCBUaGUgaWQgdXNlZCB3aGVuIGxvZ2dpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgYmFzZSB3YXJuaW5nIHRoYXQgZ2V0cyBvdXRwdXQuXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgY29tcG9uZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gd2FybkFuZE1vbml0b3JGb3JLZXlVc2Uod2FybmluZ0lELCBtZXNzYWdlLCBjb21wb25lbnQsIHBhcmVudFR5cGUpIHtcbiAgdmFyIG93bmVyTmFtZSA9IGdldEN1cnJlbnRPd25lckRpc3BsYXlOYW1lKCk7XG4gIHZhciBwYXJlbnROYW1lID0gcGFyZW50VHlwZS5kaXNwbGF5TmFtZTtcblxuICB2YXIgdXNlTmFtZSA9IG93bmVyTmFtZSB8fCBwYXJlbnROYW1lO1xuICB2YXIgbWVtb2l6ZXIgPSBvd25lckhhc0tleVVzZVdhcm5pbmdbd2FybmluZ0lEXTtcbiAgaWYgKG1lbW9pemVyLmhhc093blByb3BlcnR5KHVzZU5hbWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG1lbW9pemVyW3VzZU5hbWVdID0gdHJ1ZTtcblxuICBtZXNzYWdlICs9IG93bmVyTmFtZSA/XG4gICAgKFwiIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIFwiICsgb3duZXJOYW1lICsgXCIuXCIpIDpcbiAgICAoXCIgQ2hlY2sgdGhlIHJlbmRlckNvbXBvbmVudCBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCIpO1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICB2YXIgY2hpbGRPd25lck5hbWUgPSBudWxsO1xuICBpZiAoY29tcG9uZW50Ll9vd25lciAmJiBjb21wb25lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gTmFtZSBvZiB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lck5hbWUgPSBjb21wb25lbnQuX293bmVyLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lO1xuXG4gICAgbWVzc2FnZSArPSAoXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBjaGlsZE93bmVyTmFtZSArIFwiLlwiKTtcbiAgfVxuXG4gIG1lc3NhZ2UgKz0gJyBTZWUgaHR0cDovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nO1xuICBtb25pdG9yQ29kZVVzZSh3YXJuaW5nSUQsIHtcbiAgICBjb21wb25lbnQ6IHVzZU5hbWUsXG4gICAgY29tcG9uZW50T3duZXI6IGNoaWxkT3duZXJOYW1lXG4gIH0pO1xuICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG59XG5cbi8qKlxuICogTG9nIHRoYXQgd2UncmUgdXNpbmcgYW4gb2JqZWN0IG1hcC4gV2UncmUgY29uc2lkZXJpbmcgZGVwcmVjYXRpbmcgdGhpc1xuICogZmVhdHVyZSBhbmQgcmVwbGFjZSBpdCB3aXRoIHByb3BlciBNYXAgYW5kIEltbXV0YWJsZU1hcCBkYXRhIHN0cnVjdHVyZXMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG1vbml0b3JVc2VPZk9iamVjdE1hcCgpIHtcbiAgdmFyIGN1cnJlbnROYW1lID0gZ2V0Q3VycmVudE93bmVyRGlzcGxheU5hbWUoKSB8fCAnJztcbiAgaWYgKG93bmVySGFzTW9uaXRvcmVkT2JqZWN0TWFwLmhhc093blByb3BlcnR5KGN1cnJlbnROYW1lKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBvd25lckhhc01vbml0b3JlZE9iamVjdE1hcFtjdXJyZW50TmFtZV0gPSB0cnVlO1xuICBtb25pdG9yQ29kZVVzZSgncmVhY3Rfb2JqZWN0X21hcF9jaGlsZHJlbicpO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGNvbXBvbmVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGNvbXBvbmVudCdzIHBhcmVudCdzIHR5cGUuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhjb21wb25lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29tcG9uZW50KSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjb21wb25lbnRbaV07XG4gICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNvbXBvbmVudCkpIHtcbiAgICAvLyBUaGlzIGNvbXBvbmVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgY29tcG9uZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0Jykge1xuICAgIG1vbml0b3JVc2VPZk9iamVjdE1hcCgpO1xuICAgIGZvciAodmFyIG5hbWUgaW4gY29tcG9uZW50KSB7XG4gICAgICB2YWxpZGF0ZVByb3BlcnR5S2V5KG5hbWUsIGNvbXBvbmVudFtuYW1lXSwgcGFyZW50VHlwZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcFR5cGVzIE1hcCBvZiBwcm9wIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKGNvbXBvbmVudE5hbWUsIHByb3BUeXBlcywgcHJvcHMsIGxvY2F0aW9uKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICB2YXIgZXJyb3I7XG4gICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAvLyBUaGlzIHdpbGwgc29vbiB1c2UgdGhlIHdhcm5pbmcgbW9kdWxlXG4gICAgICAgIG1vbml0b3JDb2RlVXNlKFxuICAgICAgICAgICdyZWFjdF9mYWlsZWRfZGVzY3JpcHRvcl90eXBlX2NoZWNrJyxcbiAgICAgICAgICB7IG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0ge1xuXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgIH1cblxuICAgIHZhciBuYW1lID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICBpZiAodHlwZS5wcm9wVHlwZXMpIHtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKFxuICAgICAgICBuYW1lLFxuICAgICAgICB0eXBlLnByb3BUeXBlcyxcbiAgICAgICAgZWxlbWVudC5wcm9wcyxcbiAgICAgICAgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodHlwZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKFxuICAgICAgICBuYW1lLFxuICAgICAgICB0eXBlLmNvbnRleHRUeXBlcyxcbiAgICAgICAgZWxlbWVudC5fY29udGV4dCxcbiAgICAgICAgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICBjcmVhdGVGYWN0b3J5OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudC5iaW5kKFxuICAgICAgbnVsbCxcbiAgICAgIHR5cGVcbiAgICApO1xuICAgIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG4gICAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3I7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVtcHR5Q29tcG9uZW50XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbnZhciBjb21wb25lbnQ7XG4vLyBUaGlzIHJlZ2lzdHJ5IGtlZXBzIHRyYWNrIG9mIHRoZSBSZWFjdCBJRHMgb2YgdGhlIGNvbXBvbmVudHMgdGhhdCByZW5kZXJlZCB0b1xuLy8gYG51bGxgIChpbiByZWFsaXR5IGEgcGxhY2Vob2xkZXIgc3VjaCBhcyBgbm9zY3JpcHRgKVxudmFyIG51bGxDb21wb25lbnRJZHNSZWdpc3RyeSA9IHt9O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgaW5qZWN0RW1wdHlDb21wb25lbnQ6IGZ1bmN0aW9uKGVtcHR5Q29tcG9uZW50KSB7XG4gICAgY29tcG9uZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkoZW1wdHlDb21wb25lbnQpO1xuICB9XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgVGhlIGluamVjdGVkIGVtcHR5IGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RW1wdHlDb21wb25lbnQoKSB7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgY29tcG9uZW50LFxuICAgICdUcnlpbmcgdG8gcmV0dXJuIG51bGwgZnJvbSBhIHJlbmRlciwgYnV0IG5vIG51bGwgcGxhY2Vob2xkZXIgY29tcG9uZW50ICcgK1xuICAgICd3YXMgaW5qZWN0ZWQuJ1xuICApIDogaW52YXJpYW50KGNvbXBvbmVudCkpO1xuICByZXR1cm4gY29tcG9uZW50KCk7XG59XG5cbi8qKlxuICogTWFyayB0aGUgY29tcG9uZW50IGFzIGhhdmluZyByZW5kZXJlZCB0byBudWxsLlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIENvbXBvbmVudCdzIGBfcm9vdE5vZGVJRGAuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyTnVsbENvbXBvbmVudElEKGlkKSB7XG4gIG51bGxDb21wb25lbnRJZHNSZWdpc3RyeVtpZF0gPSB0cnVlO1xufVxuXG4vKipcbiAqIFVubWFyayB0aGUgY29tcG9uZW50IGFzIGhhdmluZyByZW5kZXJlZCB0byBudWxsOiBpdCByZW5kZXJzIHRvIHNvbWV0aGluZyBub3cuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQ29tcG9uZW50J3MgYF9yb290Tm9kZUlEYC5cbiAqL1xuZnVuY3Rpb24gZGVyZWdpc3Rlck51bGxDb21wb25lbnRJRChpZCkge1xuICBkZWxldGUgbnVsbENvbXBvbmVudElkc1JlZ2lzdHJ5W2lkXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQ29tcG9uZW50J3MgYF9yb290Tm9kZUlEYC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZW5kZXJlZCB0byBudWxsLlxuICovXG5mdW5jdGlvbiBpc051bGxDb21wb25lbnRJRChpZCkge1xuICByZXR1cm4gbnVsbENvbXBvbmVudElkc1JlZ2lzdHJ5W2lkXTtcbn1cblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSB7XG4gIGRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQ6IGRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQsXG4gIGdldEVtcHR5Q29tcG9uZW50OiBnZXRFbXB0eUNvbXBvbmVudCxcbiAgaW5qZWN0aW9uOiBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uLFxuICBpc051bGxDb21wb25lbnRJRDogaXNOdWxsQ29tcG9uZW50SUQsXG4gIHJlZ2lzdGVyTnVsbENvbXBvbmVudElEOiByZWdpc3Rlck51bGxDb21wb25lbnRJRFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVtcHR5Q29tcG9uZW50O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFcnJvclV0aWxzXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIGd1YXJkZWQgdmVyc2lvbiBvZiBhIGZ1bmN0aW9uLiBUaGlzIGlzIHN1cHBvc2VkIHRvIG1ha2UgZGVidWdnaW5nXG4gICAqIG9mIGV2ZW50IGhhbmRsZXJzIGVhc2llci4gVG8gYWlkIGRlYnVnZ2luZyB3aXRoIHRoZSBicm93c2VyJ3MgZGVidWdnZXIsXG4gICAqIHRoaXMgY3VycmVudGx5IHNpbXBseSByZXR1cm5zIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBGdW5jdGlvbiB0byBiZSBleGVjdXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZ3VhcmRcbiAgICogQHJldHVybiB7ZnVuY3Rpb259XG4gICAqL1xuICBndWFyZDogZnVuY3Rpb24oZnVuYywgbmFtZSkge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXJyb3JVdGlscztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEV2ZW50RW1pdHRlck1peGluXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luSHViXCIpO1xuXG5mdW5jdGlvbiBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpIHtcbiAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudHMpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZSgpO1xufVxuXG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHtcblxuICAvKipcbiAgICogU3RyZWFtcyBhIGZpcmVkIHRvcC1sZXZlbCBldmVudCB0byBgRXZlbnRQbHVnaW5IdWJgIHdoZXJlIHBsdWdpbnMgaGF2ZSB0aGVcbiAgICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGVudmlyb25tZW50IGV2ZW50LlxuICAgKi9cbiAgaGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uKFxuICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgbmF0aXZlRXZlbnQpIHtcbiAgICB2YXIgZXZlbnRzID0gRXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50cyhcbiAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgIHRvcExldmVsVGFyZ2V0LFxuICAgICAgdG9wTGV2ZWxUYXJnZXRJRCxcbiAgICAgIG5hdGl2ZUV2ZW50XG4gICAgKTtcblxuICAgIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudEVtaXR0ZXJNaXhpbjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZShcIi4vRXZlbnRMaXN0ZW5lclwiKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZShcIi4vUG9vbGVkQ2xhc3NcIik7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKFwiLi9SZWFjdEluc3RhbmNlSGFuZGxlc1wiKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKFwiLi9SZWFjdFVwZGF0ZXNcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZShcIi4vZ2V0RXZlbnRUYXJnZXRcIik7XG52YXIgZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24gPSByZXF1aXJlKFwiLi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvblwiKTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgcGFyZW50IFJlYWN0IGNvbXBvbmVudCBvZiBgbm9kZWAuXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRXZlbnRUYXJnZXR9IFBhcmVudCBjb250YWluZXIsIG9yIGBudWxsYCBpZiB0aGUgc3BlY2lmaWVkIG5vZGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgbm90IG5lc3RlZC5cbiAqL1xuZnVuY3Rpb24gZmluZFBhcmVudChub2RlKSB7XG4gIC8vIFRPRE86IEl0IG1heSBiZSBhIGdvb2QgaWRlYSB0byBjYWNoZSB0aGlzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgRE9NXG4gIC8vIHRyYXZlcnNhbCwgYnV0IGNhY2hpbmcgaXMgZGlmZmljdWx0IHRvIGRvIGNvcnJlY3RseSB3aXRob3V0IHVzaW5nIGFcbiAgLy8gbXV0YXRpb24gb2JzZXJ2ZXIgdG8gbGlzdGVuIGZvciBhbGwgRE9NIGNoYW5nZXMuXG4gIHZhciBub2RlSUQgPSBSZWFjdE1vdW50LmdldElEKG5vZGUpO1xuICB2YXIgcm9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKG5vZGVJRCk7XG4gIHZhciBjb250YWluZXIgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKHJvb3RJRCk7XG4gIHZhciBwYXJlbnQgPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET00oY29udGFpbmVyKTtcbiAgcmV0dXJuIHBhcmVudDtcbn1cblxuLy8gVXNlZCB0byBzdG9yZSBhbmNlc3RvciBoaWVyYXJjaHkgaW4gdG9wIGxldmVsIGNhbGxiYWNrXG5mdW5jdGlvbiBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICB0aGlzLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICB0aGlzLmFuY2VzdG9ycyA9IFtdO1xufVxuYXNzaWduKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50b3BMZXZlbFR5cGUgPSBudWxsO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBudWxsO1xuICAgIHRoaXMuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIH1cbn0pO1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFxuICBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcsXG4gIFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyXG4pO1xuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbEltcGwoYm9va0tlZXBpbmcpIHtcbiAgdmFyIHRvcExldmVsVGFyZ2V0ID0gUmVhY3RNb3VudC5nZXRGaXJzdFJlYWN0RE9NKFxuICAgIGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KVxuICApIHx8IHdpbmRvdztcblxuICAvLyBMb29wIHRocm91Z2ggdGhlIGhpZXJhcmNoeSwgaW4gY2FzZSB0aGVyZSdzIGFueSBuZXN0ZWQgY29tcG9uZW50cy5cbiAgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBidWlsZCB0aGUgYXJyYXkgb2YgYW5jZXN0b3JzIGJlZm9yZSBjYWxsaW5nIGFueVxuICAvLyBldmVudCBoYW5kbGVycywgYmVjYXVzZSBldmVudCBoYW5kbGVycyBjYW4gbW9kaWZ5IHRoZSBET00sIGxlYWRpbmcgdG9cbiAgLy8gaW5jb25zaXN0ZW5jaWVzIHdpdGggUmVhY3RNb3VudCdzIG5vZGUgY2FjaGUuIFNlZSAjMTEwNS5cbiAgdmFyIGFuY2VzdG9yID0gdG9wTGV2ZWxUYXJnZXQ7XG4gIHdoaWxlIChhbmNlc3Rvcikge1xuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICBhbmNlc3RvciA9IGZpbmRQYXJlbnQoYW5jZXN0b3IpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBib29rS2VlcGluZy5hbmNlc3RvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdG9wTGV2ZWxUYXJnZXQgPSBib29rS2VlcGluZy5hbmNlc3RvcnNbaV07XG4gICAgdmFyIHRvcExldmVsVGFyZ2V0SUQgPSBSZWFjdE1vdW50LmdldElEKHRvcExldmVsVGFyZ2V0KSB8fCAnJztcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsKFxuICAgICAgYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLFxuICAgICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgYm9va0tlZXBpbmcubmF0aXZlRXZlbnRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFZhbHVlTW9uaXRvcihjYikge1xuICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbih3aW5kb3cpO1xuICBjYihzY3JvbGxQb3NpdGlvbik7XG59XG5cbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSB7XG4gIF9lbmFibGVkOiB0cnVlLFxuICBfaGFuZGxlVG9wTGV2ZWw6IG51bGwsXG5cbiAgV0lORE9XX0hBTkRMRTogRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gd2luZG93IDogbnVsbCxcblxuICBzZXRIYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24oaGFuZGxlVG9wTGV2ZWwpIHtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsID0gaGFuZGxlVG9wTGV2ZWw7XG4gIH0sXG5cbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCA9ICEhZW5hYmxlZDtcbiAgfSxcblxuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQ7XG4gIH0sXG5cblxuICAvKipcbiAgICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZSBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGhhbmRsZTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIubGlzdGVuKFxuICAgICAgZWxlbWVudCxcbiAgICAgIGhhbmRsZXJCYXNlTmFtZSxcbiAgICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKVxuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZSBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbih0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBoYW5kbGU7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoXG4gICAgICBlbGVtZW50LFxuICAgICAgaGFuZGxlckJhc2VOYW1lLFxuICAgICAgUmVhY3RFdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpXG4gICAgKTtcbiAgfSxcblxuICBtb25pdG9yU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uKHJlZnJlc2gpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBzY3JvbGxWYWx1ZU1vbml0b3IuYmluZChudWxsLCByZWZyZXNoKTtcbiAgICBFdmVudExpc3RlbmVyLmxpc3Rlbih3aW5kb3csICdzY3JvbGwnLCBjYWxsYmFjayk7XG4gICAgRXZlbnRMaXN0ZW5lci5saXN0ZW4od2luZG93LCAncmVzaXplJywgY2FsbGJhY2spO1xuICB9LFxuXG4gIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIVJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBib29rS2VlcGluZyA9IFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5nZXRQb29sZWQoXG4gICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICBuYXRpdmVFdmVudFxuICAgICk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEV2ZW50IHF1ZXVlIGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgc2FtZSBjeWNsZSBhbGxvd3NcbiAgICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWxJbXBsLCBib29rS2VlcGluZyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5yZWxlYXNlKGJvb2tLZWVwaW5nKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudExpc3RlbmVyO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5qZWN0aW9uXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5XCIpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZShcIi4vRXZlbnRQbHVnaW5IdWJcIik7XG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudFwiKTtcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVtcHR5Q29tcG9uZW50XCIpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlclwiKTtcbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0TmF0aXZlQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0UGVyZlwiKTtcbnZhciBSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoXCIuL1JlYWN0Um9vdEluZGV4XCIpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlc1wiKTtcblxudmFyIFJlYWN0SW5qZWN0aW9uID0ge1xuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50LmluamVjdGlvbixcbiAgQ29tcG9zaXRlQ29tcG9uZW50OiBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5pbmplY3Rpb24sXG4gIERPTVByb3BlcnR5OiBET01Qcm9wZXJ0eS5pbmplY3Rpb24sXG4gIEVtcHR5Q29tcG9uZW50OiBSZWFjdEVtcHR5Q29tcG9uZW50LmluamVjdGlvbixcbiAgRXZlbnRQbHVnaW5IdWI6IEV2ZW50UGx1Z2luSHViLmluamVjdGlvbixcbiAgRXZlbnRFbWl0dGVyOiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaW5qZWN0aW9uLFxuICBOYXRpdmVDb21wb25lbnQ6IFJlYWN0TmF0aXZlQ29tcG9uZW50LmluamVjdGlvbixcbiAgUGVyZjogUmVhY3RQZXJmLmluamVjdGlvbixcbiAgUm9vdEluZGV4OiBSZWFjdFJvb3RJbmRleC5pbmplY3Rpb24sXG4gIFVwZGF0ZXM6IFJlYWN0VXBkYXRlcy5pbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbmplY3Rpb247XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnB1dFNlbGVjdGlvblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSByZXF1aXJlKFwiLi9SZWFjdERPTVNlbGVjdGlvblwiKTtcblxudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoXCIuL2NvbnRhaW5zTm9kZVwiKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKFwiLi9mb2N1c05vZGVcIik7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoXCIuL2dldEFjdGl2ZUVsZW1lbnRcIik7XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBjb250YWluc05vZGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0ge1xuXG4gIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllczogZnVuY3Rpb24oZWxlbSkge1xuICAgIHJldHVybiBlbGVtICYmIChcbiAgICAgIChlbGVtLm5vZGVOYW1lID09PSAnSU5QVVQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnKSB8fFxuICAgICAgZWxlbS5ub2RlTmFtZSA9PT0gJ1RFWFRBUkVBJyB8fFxuICAgICAgZWxlbS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJ1xuICAgICk7XG4gIH0sXG5cbiAgZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgZm9jdXNlZEVsZW06IGZvY3VzZWRFbGVtLFxuICAgICAgc2VsZWN0aW9uUmFuZ2U6XG4gICAgICAgICAgUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZm9jdXNlZEVsZW0pID9cbiAgICAgICAgICBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbihmb2N1c2VkRWxlbSkgOlxuICAgICAgICAgIG51bGxcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAgICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXG4gICAqIG5vZGVzIGFuZCBwbGFjZSB0aGVtIGJhY2sgaW4sIHJlc3VsdGluZyBpbiBmb2N1cyBiZWluZyBsb3N0LlxuICAgKi9cbiAgcmVzdG9yZVNlbGVjdGlvbjogZnVuY3Rpb24ocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICAgIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gICAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICAgIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJlxuICAgICAgICBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIGlmIChSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgICBSZWFjdElucHV0U2VsZWN0aW9uLnNldFNlbGVjdGlvbihcbiAgICAgICAgICBwcmlvckZvY3VzZWRFbGVtLFxuICAgICAgICAgIHByaW9yU2VsZWN0aW9uUmFuZ2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICAgKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAgICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAgICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gICAqL1xuICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgdmFyIHNlbGVjdGlvbjtcblxuICAgIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgICAgc2VsZWN0aW9uID0ge1xuICAgICAgICBzdGFydDogaW5wdXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGlucHV0Lm5vZGVOYW1lID09PSAnSU5QVVQnKSB7XG4gICAgICAvLyBJRTggaW5wdXQuXG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBzZWxlY3Rpb24gcGVyIGRvY3VtZW50IGluIElFLCBzbyBpdCBtdXN0XG4gICAgICAvLyBiZSBpbiBvdXIgZWxlbWVudC5cbiAgICAgIGlmIChyYW5nZS5wYXJlbnRFbGVtZW50KCkgPT09IGlucHV0KSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgICBzdGFydDogLXJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgZW5kOiAtcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSBSZWFjdERPTVNlbGVjdGlvbi5nZXRPZmZzZXRzKGlucHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0aW9uIHx8IHtzdGFydDogMCwgZW5kOiAwfTtcbiAgfSxcblxuICAvKipcbiAgICogQHNldFNlbGVjdGlvbjogU2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIHRleHRhcmVhIG9yIGlucHV0IGFuZCBmb2N1c2VzXG4gICAqIHRoZSBpbnB1dC5cbiAgICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICAgKiAtQG9mZnNldHMgICBPYmplY3Qgb2Ygc2FtZSBmb3JtIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSBnZXQqXG4gICAqL1xuICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uKGlucHV0LCBvZmZzZXRzKSB7XG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgdmFyIHJhbmdlID0gaW5wdXQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RE9NU2VsZWN0aW9uLnNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdElucHV0U2VsZWN0aW9uO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluc3RhbmNlSGFuZGxlc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0Um9vdEluZGV4ID0gcmVxdWlyZShcIi4vUmVhY3RSb290SW5kZXhcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU0VQQVJBVE9SX0xFTkdUSCA9IFNFUEFSQVRPUi5sZW5ndGg7XG5cbi8qKlxuICogTWF4aW11bSBkZXB0aCBvZiB0cmF2ZXJzYWxzIGJlZm9yZSB3ZSBjb25zaWRlciB0aGUgcG9zc2liaWxpdHkgb2YgYSBiYWQgSUQuXG4gKi9cbnZhciBNQVhfVFJFRV9ERVBUSCA9IDEwMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgRE9NIElEIHByZWZpeCB0byB1c2Ugd2hlbiBtb3VudGluZyBSZWFjdCBjb21wb25lbnRzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBBIHVuaXF1ZSBpbnRlZ2VyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJlYWN0IHJvb3QgSUQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0UmVhY3RSb290SURTdHJpbmcoaW5kZXgpIHtcbiAgcmV0dXJuIFNFUEFSQVRPUiArIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBjaGFyYWN0ZXIgaW4gdGhlIHN1cHBsaWVkIElEIGlzIGEgc2VwYXJhdG9yIG9yIHRoZSBlbmQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIEEgUmVhY3QgRE9NIElELlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjaGFyYWN0ZXIgaXMgYSBzZXBhcmF0b3Igb3IgZW5kIG9mIHRoZSBJRC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzQm91bmRhcnkoaWQsIGluZGV4KSB7XG4gIHJldHVybiBpZC5jaGFyQXQoaW5kZXgpID09PSBTRVBBUkFUT1IgfHwgaW5kZXggPT09IGlkLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHN1cHBsaWVkIHN0cmluZyBpcyBhIHZhbGlkIFJlYWN0IERPTSBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQSBSZWFjdCBET00gSUQsIG1heWJlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgUmVhY3QgRE9NIElELlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZElEKGlkKSB7XG4gIHJldHVybiBpZCA9PT0gJycgfHwgKFxuICAgIGlkLmNoYXJBdCgwKSA9PT0gU0VQQVJBVE9SICYmIGlkLmNoYXJBdChpZC5sZW5ndGggLSAxKSAhPT0gU0VQQVJBVE9SXG4gICk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBmaXJzdCBJRCBpcyBhbiBhbmNlc3RvciBvZiBvciBlcXVhbCB0byB0aGUgc2Vjb25kIElELlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbmNlc3RvcklEXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzY2VuZGFudElEXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBhbmNlc3RvcklEYCBpcyBhbiBhbmNlc3RvciBvZiBgZGVzY2VuZGFudElEYC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc0FuY2VzdG9ySURPZihhbmNlc3RvcklELCBkZXNjZW5kYW50SUQpIHtcbiAgcmV0dXJuIChcbiAgICBkZXNjZW5kYW50SUQuaW5kZXhPZihhbmNlc3RvcklEKSA9PT0gMCAmJlxuICAgIGlzQm91bmRhcnkoZGVzY2VuZGFudElELCBhbmNlc3RvcklELmxlbmd0aClcbiAgKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBwYXJlbnQgSUQgb2YgdGhlIHN1cHBsaWVkIFJlYWN0IERPTSBJRCwgYGlkYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgYSBjb21wb25lbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEIG9mIHRoZSBwYXJlbnQsIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudElEKGlkKSB7XG4gIHJldHVybiBpZCA/IGlkLnN1YnN0cigwLCBpZC5sYXN0SW5kZXhPZihTRVBBUkFUT1IpKSA6ICcnO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5leHQgRE9NIElEIG9uIHRoZSB0cmVlIHBhdGggZnJvbSB0aGUgc3VwcGxpZWQgYGFuY2VzdG9ySURgIHRvIHRoZVxuICogc3VwcGxpZWQgYGRlc3RpbmF0aW9uSURgLiBJZiB0aGV5IGFyZSBlcXVhbCwgdGhlIElEIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbmNlc3RvcklEIElEIG9mIGFuIGFuY2VzdG9yIG5vZGUgb2YgYGRlc3RpbmF0aW9uSURgLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3RpbmF0aW9uSUQgSUQgb2YgdGhlIGRlc3RpbmF0aW9uIG5vZGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5leHQgSUQgb24gdGhlIHBhdGggZnJvbSBgYW5jZXN0b3JJRGAgdG8gYGRlc3RpbmF0aW9uSURgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0TmV4dERlc2NlbmRhbnRJRChhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSB7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgaXNWYWxpZElEKGFuY2VzdG9ySUQpICYmIGlzVmFsaWRJRChkZXN0aW5hdGlvbklEKSxcbiAgICAnZ2V0TmV4dERlc2NlbmRhbnRJRCglcywgJXMpOiBSZWNlaXZlZCBhbiBpbnZhbGlkIFJlYWN0IERPTSBJRC4nLFxuICAgIGFuY2VzdG9ySUQsXG4gICAgZGVzdGluYXRpb25JRFxuICApIDogaW52YXJpYW50KGlzVmFsaWRJRChhbmNlc3RvcklEKSAmJiBpc1ZhbGlkSUQoZGVzdGluYXRpb25JRCkpKTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBpc0FuY2VzdG9ySURPZihhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSxcbiAgICAnZ2V0TmV4dERlc2NlbmRhbnRJRCguLi4pOiBSZWFjdCBoYXMgbWFkZSBhbiBpbnZhbGlkIGFzc3VtcHRpb24gYWJvdXQgJyArXG4gICAgJ3RoZSBET00gaGllcmFyY2h5LiBFeHBlY3RlZCBgJXNgIHRvIGJlIGFuIGFuY2VzdG9yIG9mIGAlc2AuJyxcbiAgICBhbmNlc3RvcklELFxuICAgIGRlc3RpbmF0aW9uSURcbiAgKSA6IGludmFyaWFudChpc0FuY2VzdG9ySURPZihhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSkpO1xuICBpZiAoYW5jZXN0b3JJRCA9PT0gZGVzdGluYXRpb25JRCkge1xuICAgIHJldHVybiBhbmNlc3RvcklEO1xuICB9XG4gIC8vIFNraXAgb3ZlciB0aGUgYW5jZXN0b3IgYW5kIHRoZSBpbW1lZGlhdGUgc2VwYXJhdG9yLiBUcmF2ZXJzZSB1bnRpbCB3ZSBoaXRcbiAgLy8gYW5vdGhlciBzZXBhcmF0b3Igb3Igd2UgcmVhY2ggdGhlIGVuZCBvZiBgZGVzdGluYXRpb25JRGAuXG4gIHZhciBzdGFydCA9IGFuY2VzdG9ySUQubGVuZ3RoICsgU0VQQVJBVE9SX0xFTkdUSDtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZGVzdGluYXRpb25JRC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpc0JvdW5kYXJ5KGRlc3RpbmF0aW9uSUQsIGkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlc3RpbmF0aW9uSUQuc3Vic3RyKDAsIGkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIElEIG9mIHR3byBJRHMuXG4gKlxuICogVXNpbmcgdGhpcyBJRCBzY2hlbWUsIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBJRCBpcyB0aGUgbG9uZ2VzdCBjb21tb25cbiAqIHByZWZpeCBvZiB0aGUgdHdvIElEcyB0aGF0IGltbWVkaWF0ZWx5IHByZWNlZGVkIGEgXCJtYXJrZXJcIiBpbiBib3RoIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG9uZUlEXG4gKiBAcGFyYW0ge3N0cmluZ30gdHdvSURcbiAqIEByZXR1cm4ge3N0cmluZ30gTmVhcmVzdCBjb21tb24gYW5jZXN0b3IgSUQsIG9yIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm9uZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRChvbmVJRCwgdHdvSUQpIHtcbiAgdmFyIG1pbkxlbmd0aCA9IE1hdGgubWluKG9uZUlELmxlbmd0aCwgdHdvSUQubGVuZ3RoKTtcbiAgaWYgKG1pbkxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICB2YXIgbGFzdENvbW1vbk1hcmtlckluZGV4ID0gMDtcbiAgLy8gVXNlIGA8PWAgdG8gdHJhdmVyc2UgdW50aWwgdGhlIFwiRU9MXCIgb2YgdGhlIHNob3J0ZXIgc3RyaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8PSBtaW5MZW5ndGg7IGkrKykge1xuICAgIGlmIChpc0JvdW5kYXJ5KG9uZUlELCBpKSAmJiBpc0JvdW5kYXJ5KHR3b0lELCBpKSkge1xuICAgICAgbGFzdENvbW1vbk1hcmtlckluZGV4ID0gaTtcbiAgICB9IGVsc2UgaWYgKG9uZUlELmNoYXJBdChpKSAhPT0gdHdvSUQuY2hhckF0KGkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIGxvbmdlc3RDb21tb25JRCA9IG9uZUlELnN1YnN0cigwLCBsYXN0Q29tbW9uTWFya2VySW5kZXgpO1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIGlzVmFsaWRJRChsb25nZXN0Q29tbW9uSUQpLFxuICAgICdnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQoJXMsICVzKTogRXhwZWN0ZWQgYSB2YWxpZCBSZWFjdCBET00gSUQ6ICVzJyxcbiAgICBvbmVJRCxcbiAgICB0d29JRCxcbiAgICBsb25nZXN0Q29tbW9uSURcbiAgKSA6IGludmFyaWFudChpc1ZhbGlkSUQobG9uZ2VzdENvbW1vbklEKSkpO1xuICByZXR1cm4gbG9uZ2VzdENvbW1vbklEO1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyB0aGUgcGFyZW50IHBhdGggYmV0d2VlbiB0d28gSURzIChlaXRoZXIgdXAgb3IgZG93bikuIFRoZSBJRHMgbXVzdFxuICogbm90IGJlIHRoZSBzYW1lLCBhbmQgdGhlcmUgbXVzdCBleGlzdCBhIHBhcmVudCBwYXRoIGJldHdlZW4gdGhlbS4gSWYgdGhlXG4gKiBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAsIHRyYXZlcnNhbCBpcyBzdG9wcGVkLlxuICpcbiAqIEBwYXJhbSB7P3N0cmluZ30gc3RhcnQgSUQgYXQgd2hpY2ggdG8gc3RhcnQgdHJhdmVyc2FsLlxuICogQHBhcmFtIHs/c3RyaW5nfSBzdG9wIElEIGF0IHdoaWNoIHRvIGVuZCB0cmF2ZXJzYWwuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBpbnZva2UgZWFjaCBJRCB3aXRoLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gc2tpcEZpcnN0IFdoZXRoZXIgb3Igbm90IHRvIHNraXAgdGhlIGZpcnN0IG5vZGUuXG4gKiBAcGFyYW0gez9ib29sZWFufSBza2lwTGFzdCBXaGV0aGVyIG9yIG5vdCB0byBza2lwIHRoZSBsYXN0IG5vZGUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVBhcmVudFBhdGgoc3RhcnQsIHN0b3AsIGNiLCBhcmcsIHNraXBGaXJzdCwgc2tpcExhc3QpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAnJztcbiAgc3RvcCA9IHN0b3AgfHwgJyc7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgc3RhcnQgIT09IHN0b3AsXG4gICAgJ3RyYXZlcnNlUGFyZW50UGF0aCguLi4pOiBDYW5ub3QgdHJhdmVyc2UgZnJvbSBhbmQgdG8gdGhlIHNhbWUgSUQsIGAlc2AuJyxcbiAgICBzdGFydFxuICApIDogaW52YXJpYW50KHN0YXJ0ICE9PSBzdG9wKSk7XG4gIHZhciB0cmF2ZXJzZVVwID0gaXNBbmNlc3RvcklET2Yoc3RvcCwgc3RhcnQpO1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIHRyYXZlcnNlVXAgfHwgaXNBbmNlc3RvcklET2Yoc3RhcnQsIHN0b3ApLFxuICAgICd0cmF2ZXJzZVBhcmVudFBhdGgoJXMsICVzLCAuLi4pOiBDYW5ub3QgdHJhdmVyc2UgZnJvbSB0d28gSURzIHRoYXQgZG8gJyArXG4gICAgJ25vdCBoYXZlIGEgcGFyZW50IHBhdGguJyxcbiAgICBzdGFydCxcbiAgICBzdG9wXG4gICkgOiBpbnZhcmlhbnQodHJhdmVyc2VVcCB8fCBpc0FuY2VzdG9ySURPZihzdGFydCwgc3RvcCkpKTtcbiAgLy8gVHJhdmVyc2UgZnJvbSBgc3RhcnRgIHRvIGBzdG9wYCBvbmUgZGVwdGggYXQgYSB0aW1lLlxuICB2YXIgZGVwdGggPSAwO1xuICB2YXIgdHJhdmVyc2UgPSB0cmF2ZXJzZVVwID8gZ2V0UGFyZW50SUQgOiBnZXROZXh0RGVzY2VuZGFudElEO1xuICBmb3IgKHZhciBpZCA9IHN0YXJ0OyAvKiB1bnRpbCBicmVhayAqLzsgaWQgPSB0cmF2ZXJzZShpZCwgc3RvcCkpIHtcbiAgICB2YXIgcmV0O1xuICAgIGlmICgoIXNraXBGaXJzdCB8fCBpZCAhPT0gc3RhcnQpICYmICghc2tpcExhc3QgfHwgaWQgIT09IHN0b3ApKSB7XG4gICAgICByZXQgPSBjYihpZCwgdHJhdmVyc2VVcCwgYXJnKTtcbiAgICB9XG4gICAgaWYgKHJldCA9PT0gZmFsc2UgfHwgaWQgPT09IHN0b3ApIHtcbiAgICAgIC8vIE9ubHkgYnJlYWsgLy9hZnRlci8vIHZpc2l0aW5nIGBzdG9wYC5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgZGVwdGgrKyA8IE1BWF9UUkVFX0RFUFRILFxuICAgICAgJ3RyYXZlcnNlUGFyZW50UGF0aCglcywgJXMsIC4uLik6IERldGVjdGVkIGFuIGluZmluaXRlIGxvb3Agd2hpbGUgJyArXG4gICAgICAndHJhdmVyc2luZyB0aGUgUmVhY3QgRE9NIElEIHRyZWUuIFRoaXMgbWF5IGJlIGR1ZSB0byBtYWxmb3JtZWQgSURzOiAlcycsXG4gICAgICBzdGFydCwgc3RvcFxuICAgICkgOiBpbnZhcmlhbnQoZGVwdGgrKyA8IE1BWF9UUkVFX0RFUFRIKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBJRHMgYXNzaWduZWQgdG8gRE9NIHJlcHJlc2VudGF0aW9ucyBvZiBSZWFjdCBjb21wb25lbnRzLiBUaGlzXG4gKiB1c2VzIGEgc3BlY2lmaWMgc2NoZW1lIGluIG9yZGVyIHRvIHRyYXZlcnNlIHRoZSBET00gZWZmaWNpZW50bHkgKGUuZy4gaW5cbiAqIG9yZGVyIHRvIHNpbXVsYXRlIGV2ZW50cykuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIFJlYWN0IHJvb3QgSURcbiAgICogQHJldHVybiB7c3RyaW5nfSBBIFJlYWN0IHJvb3QgSUQuXG4gICAqL1xuICBjcmVhdGVSZWFjdFJvb3RJRDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdldFJlYWN0Um9vdElEU3RyaW5nKFJlYWN0Um9vdEluZGV4LmNyZWF0ZVJlYWN0Um9vdEluZGV4KCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgUmVhY3QgSUQgYnkgam9pbmluZyBhIHJvb3QgSUQgd2l0aCBhIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgUm9vdCBJRCBvZiBhIHBhcmVudCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgY29tcG9uZW50J3MgbmFtZSAoYXMgZmxhdHRlbmVkIGNoaWxkcmVuKS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBBIFJlYWN0IElELlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNyZWF0ZVJlYWN0SUQ6IGZ1bmN0aW9uKHJvb3RJRCwgbmFtZSkge1xuICAgIHJldHVybiByb290SUQgKyBuYW1lO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBET00gSUQgb2YgdGhlIFJlYWN0IGNvbXBvbmVudCB0aGF0IGlzIHRoZSByb290IG9mIHRoZSB0cmVlIHRoYXRcbiAgICogY29udGFpbnMgdGhlIFJlYWN0IGNvbXBvbmVudCB3aXRoIHRoZSBzdXBwbGllZCBET00gSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBET00gSUQgb2YgYSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IERPTSBJRCBvZiB0aGUgUmVhY3QgY29tcG9uZW50IHRoYXQgaXMgdGhlIHJvb3QuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEOiBmdW5jdGlvbihpZCkge1xuICAgIGlmIChpZCAmJiBpZC5jaGFyQXQoMCkgPT09IFNFUEFSQVRPUiAmJiBpZC5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgaW5kZXggPSBpZC5pbmRleE9mKFNFUEFSQVRPUiwgMSk7XG4gICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGlkLnN1YnN0cigwLCBpbmRleCkgOiBpZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlcyB0aGUgSUQgaGllcmFyY2h5IGFuZCBpbnZva2VzIHRoZSBzdXBwbGllZCBgY2JgIG9uIGFueSBJRHMgdGhhdFxuICAgKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gICAqXG4gICAqIE5PVEU6IERvZXMgbm90IGludm9rZSB0aGUgY2FsbGJhY2sgb24gdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2VcbiAgICogbm90aGluZyBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZWF2ZUlEIElEIGJlaW5nIGxlZnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRlcklEIElEIGJlaW5nIGVudGVyZWQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZSBvbiBlYWNoIGVudGVyZWQvbGVmdCBJRC5cbiAgICogQHBhcmFtIHsqfSB1cEFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggb24gbGVmdCBJRHMuXG4gICAqIEBwYXJhbSB7Kn0gZG93bkFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggb24gZW50ZXJlZCBJRHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhdmVyc2VFbnRlckxlYXZlOiBmdW5jdGlvbihsZWF2ZUlELCBlbnRlcklELCBjYiwgdXBBcmcsIGRvd25BcmcpIHtcbiAgICB2YXIgYW5jZXN0b3JJRCA9IGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRChsZWF2ZUlELCBlbnRlcklEKTtcbiAgICBpZiAoYW5jZXN0b3JJRCAhPT0gbGVhdmVJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKGxlYXZlSUQsIGFuY2VzdG9ySUQsIGNiLCB1cEFyZywgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoYW5jZXN0b3JJRCAhPT0gZW50ZXJJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKGFuY2VzdG9ySUQsIGVudGVySUQsIGNiLCBkb3duQXJnLCB0cnVlLCBmYWxzZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgdHJhdmVyc2FsIGhhcHBlbnMgb24gSURzIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldElEIElEIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IGFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhdmVyc2VUd29QaGFzZTogZnVuY3Rpb24odGFyZ2V0SUQsIGNiLCBhcmcpIHtcbiAgICBpZiAodGFyZ2V0SUQpIHtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aCgnJywgdGFyZ2V0SUQsIGNiLCBhcmcsIHRydWUsIGZhbHNlKTtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aCh0YXJnZXRJRCwgJycsIGNiLCBhcmcsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlIGEgbm9kZSBJRCwgY2FsbGluZyB0aGUgc3VwcGxpZWQgYGNiYCBmb3IgZWFjaCBhbmNlc3RvciBJRC4gRm9yXG4gICAqIGV4YW1wbGUsIHBhc3NpbmcgYC4wLiRyb3ctMC4xYCB3b3VsZCByZXN1bHQgaW4gYGNiYCBnZXR0aW5nIGNhbGxlZFxuICAgKiB3aXRoIGAuMGAsIGAuMC4kcm93LTBgLCBhbmQgYC4wLiRyb3ctMC4xYC5cbiAgICpcbiAgICogTk9URTogVGhpcyB0cmF2ZXJzYWwgaGFwcGVucyBvbiBJRHMgd2l0aG91dCB0b3VjaGluZyB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0SUQgSUQgb2YgdGhlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBpbnZva2UuXG4gICAqIEBwYXJhbSB7Kn0gYXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmF2ZXJzZUFuY2VzdG9yczogZnVuY3Rpb24odGFyZ2V0SUQsIGNiLCBhcmcpIHtcbiAgICB0cmF2ZXJzZVBhcmVudFBhdGgoJycsIHRhcmdldElELCBjYiwgYXJnLCB0cnVlLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQ6IGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRCxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldE5leHREZXNjZW5kYW50SUQ6IGdldE5leHREZXNjZW5kYW50SUQsXG5cbiAgaXNBbmNlc3RvcklET2Y6IGlzQW5jZXN0b3JJRE9mLFxuXG4gIFNFUEFSQVRPUjogU0VQQVJBVE9SXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnN0YW5jZUhhbmRsZXM7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TGVnYWN5RWxlbWVudFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdEN1cnJlbnRPd25lclwiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBtb25pdG9yQ29kZVVzZSA9IHJlcXVpcmUoXCIuL21vbml0b3JDb2RlVXNlXCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG52YXIgbGVnYWN5RmFjdG9yeUxvZ3MgPSB7fTtcbmZ1bmN0aW9uIHdhcm5Gb3JMZWdhY3lGYWN0b3J5Q2FsbCgpIHtcbiAgaWYgKCFSZWFjdExlZ2FjeUVsZW1lbnRGYWN0b3J5Ll9pc0xlZ2FjeUNhbGxXYXJuaW5nRW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICB2YXIgbmFtZSA9IG93bmVyICYmIG93bmVyLmNvbnN0cnVjdG9yID8gb3duZXIuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgOiAnJztcbiAgaWYgKCFuYW1lKSB7XG4gICAgbmFtZSA9ICdTb21ldGhpbmcnO1xuICB9XG4gIGlmIChsZWdhY3lGYWN0b3J5TG9ncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZWdhY3lGYWN0b3J5TG9nc1tuYW1lXSA9IHRydWU7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFxuICAgIGZhbHNlLFxuICAgIG5hbWUgKyAnIGlzIGNhbGxpbmcgYSBSZWFjdCBjb21wb25lbnQgZGlyZWN0bHkuICcgK1xuICAgICdVc2UgYSBmYWN0b3J5IG9yIEpTWCBpbnN0ZWFkLiBTZWU6IGh0dHA6Ly9mYi5tZS9yZWFjdC1sZWdhY3lmYWN0b3J5J1xuICApIDogbnVsbCk7XG4gIG1vbml0b3JDb2RlVXNlKCdyZWFjdF9sZWdhY3lfZmFjdG9yeV9jYWxsJywgeyB2ZXJzaW9uOiAzLCBuYW1lOiBuYW1lIH0pO1xufVxuXG5mdW5jdGlvbiB3YXJuRm9yUGxhaW5GdW5jdGlvblR5cGUodHlwZSkge1xuICB2YXIgaXNSZWFjdENsYXNzID1cbiAgICB0eXBlLnByb3RvdHlwZSAmJlxuICAgIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nO1xuICBpZiAoaXNSZWFjdENsYXNzKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgICdEaWQgbm90IGV4cGVjdCB0byBnZXQgYSBSZWFjdCBjbGFzcyBoZXJlLiBVc2UgYENvbXBvbmVudGAgaW5zdGVhZCAnICtcbiAgICAgICdvZiBgQ29tcG9uZW50LnR5cGVgIG9yIGB0aGlzLmNvbnN0cnVjdG9yYC4nXG4gICAgKSA6IG51bGwpO1xuICB9IGVsc2Uge1xuICAgIGlmICghdHlwZS5fcmVhY3RXYXJuZWRGb3JUaGlzVHlwZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHlwZS5fcmVhY3RXYXJuZWRGb3JUaGlzVHlwZSA9IHRydWU7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGp1c3QgaW5jYXNlIHRoaXMgaXMgYSBmcm96ZW4gb2JqZWN0IG9yIHNvbWUgc3BlY2lhbCBvYmplY3RcbiAgICAgIH1cbiAgICAgIG1vbml0b3JDb2RlVXNlKFxuICAgICAgICAncmVhY3Rfbm9uX2NvbXBvbmVudF9pbl9qc3gnLFxuICAgICAgICB7IHZlcnNpb246IDMsIG5hbWU6IHR5cGUubmFtZSB9XG4gICAgICApO1xuICAgIH1cbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhcbiAgICAgIGZhbHNlLFxuICAgICAgJ1RoaXMgSlNYIHVzZXMgYSBwbGFpbiBmdW5jdGlvbi4gT25seSBSZWFjdCBjb21wb25lbnRzIGFyZSAnICtcbiAgICAgICd2YWxpZCBpbiBSZWFjdFxcJ3MgSlNYIHRyYW5zZm9ybS4nXG4gICAgKSA6IG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JOb25MZWdhY3lGYWN0b3J5KHR5cGUpIHtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoXG4gICAgZmFsc2UsXG4gICAgJ0RvIG5vdCBwYXNzIFJlYWN0LkRPTS4nICsgdHlwZS50eXBlICsgJyB0byBKU1ggb3IgY3JlYXRlRmFjdG9yeS4gJyArXG4gICAgJ1VzZSB0aGUgc3RyaW5nIFwiJyArIHR5cGUudHlwZSArICdcIiBpbnN0ZWFkLidcbiAgKSA6IG51bGwpO1xufVxuXG4vKipcbiAqIFRyYW5zZmVyIHN0YXRpYyBwcm9wZXJ0aWVzIGZyb20gdGhlIHNvdXJjZSB0byB0aGUgdGFyZ2V0LiBGdW5jdGlvbnMgYXJlXG4gKiByZWJvdW5kIHRvIGhhdmUgdGhpcyByZWZsZWN0IHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKi9cbmZ1bmN0aW9uIHByb3h5U3RhdGljTWV0aG9kcyh0YXJnZXQsIHNvdXJjZSkge1xuICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGJvdW5kID0gdmFsdWUuYmluZChzb3VyY2UpO1xuICAgICAgICAvLyBDb3B5IGFueSBwcm9wZXJ0aWVzIGRlZmluZWQgb24gdGhlIGZ1bmN0aW9uLCBzdWNoIGFzIGBpc1JlcXVpcmVkYCBvblxuICAgICAgICAvLyBhIFByb3BUeXBlcyB2YWxpZGF0b3IuXG4gICAgICAgIGZvciAodmFyIGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgIGJvdW5kW2tdID0gdmFsdWVba107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhcmdldFtrZXldID0gYm91bmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBXZSB1c2UgYW4gb2JqZWN0IGluc3RlYWQgb2YgYSBib29sZWFuIGJlY2F1c2UgYm9vbGVhbnMgYXJlIGlnbm9yZWQgYnkgb3VyXG4vLyBtb2NraW5nIGxpYnJhcmllcyB3aGVuIHRoZXNlIGZhY3RvcmllcyBnZXRzIG1vY2tlZC5cbnZhciBMRUdBQ1lfTUFSS0VSID0ge307XG52YXIgTk9OX0xFR0FDWV9NQVJLRVIgPSB7fTtcblxudmFyIFJlYWN0TGVnYWN5RWxlbWVudEZhY3RvcnkgPSB7fTtcblxuUmVhY3RMZWdhY3lFbGVtZW50RmFjdG9yeS53cmFwQ3JlYXRlRmFjdG9yeSA9IGZ1bmN0aW9uKGNyZWF0ZUZhY3RvcnkpIHtcbiAgdmFyIGxlZ2FjeUNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBOb24tZnVuY3Rpb24gdHlwZXMgY2Fubm90IGJlIGxlZ2FjeSBmYWN0b3JpZXNcbiAgICAgIHJldHVybiBjcmVhdGVGYWN0b3J5KHR5cGUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlLmlzUmVhY3ROb25MZWdhY3lGYWN0b3J5KSB7XG4gICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgZmFjdG9yeSBjcmVhdGVkIGJ5IFJlYWN0RE9NIHdlIHVud3JhcCBpdCB0byBnZXQgdG9cbiAgICAgIC8vIHRoZSB1bmRlcmx5aW5nIHN0cmluZyB0eXBlLiBJdCBzaG91bGRuJ3QgaGF2ZSBiZWVuIHBhc3NlZCBoZXJlIHNvIHdlXG4gICAgICAvLyB3YXJuLlxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICB3YXJuRm9yTm9uTGVnYWN5RmFjdG9yeSh0eXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVGYWN0b3J5KHR5cGUudHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUuaXNSZWFjdExlZ2FjeUZhY3RvcnkpIHtcbiAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYSBsZWdhY3kgZmFjdG9yeSBjcmVhdGVkIGJ5IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50LlxuICAgICAgLy8gV2UgdW53cmFwIGl0IHRvIGdldCB0byB0aGUgdW5kZXJseWluZyBjbGFzcy5cbiAgICAgIHJldHVybiBjcmVhdGVGYWN0b3J5KHR5cGUudHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgd2FybkZvclBsYWluRnVuY3Rpb25UeXBlKHR5cGUpO1xuICAgIH1cblxuICAgIC8vIFVubGVzcyBpdCdzIGEgbGVnYWN5IGZhY3RvcnksIHRoZW4gdGhpcyBpcyBwcm9iYWJseSBhIHBsYWluIGZ1bmN0aW9uLFxuICAgIC8vIHRoYXQgaXMgZXhwZWN0aW5nIHRvIGJlIGludm9rZWQgYnkgSlNYLiBXZSBjYW4ganVzdCByZXR1cm4gaXQgYXMgaXMuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH07XG4gIHJldHVybiBsZWdhY3lDcmVhdGVGYWN0b3J5O1xufTtcblxuUmVhY3RMZWdhY3lFbGVtZW50RmFjdG9yeS53cmFwQ3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKGNyZWF0ZUVsZW1lbnQpIHtcbiAgdmFyIGxlZ2FjeUNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIE5vbi1mdW5jdGlvbiB0eXBlcyBjYW5ub3QgYmUgbGVnYWN5IGZhY3Rvcmllc1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICB2YXIgYXJncztcblxuICAgIGlmICh0eXBlLmlzUmVhY3ROb25MZWdhY3lGYWN0b3J5KSB7XG4gICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgZmFjdG9yeSBjcmVhdGVkIGJ5IFJlYWN0RE9NIHdlIHVud3JhcCBpdCB0byBnZXQgdG9cbiAgICAgIC8vIHRoZSB1bmRlcmx5aW5nIHN0cmluZyB0eXBlLiBJdCBzaG91bGRuJ3QgaGF2ZSBiZWVuIHBhc3NlZCBoZXJlIHNvIHdlXG4gICAgICAvLyB3YXJuLlxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICB3YXJuRm9yTm9uTGVnYWN5RmFjdG9yeSh0eXBlKTtcbiAgICAgIH1cbiAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgYXJnc1swXSA9IHR5cGUudHlwZTtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cblxuICAgIGlmICh0eXBlLmlzUmVhY3RMZWdhY3lGYWN0b3J5KSB7XG4gICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgbGVnYWN5IGZhY3RvcnkgY3JlYXRlZCBieSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5cbiAgICAgIC8vIFdlIHVud3JhcCBpdCB0byBnZXQgdG8gdGhlIHVuZGVybHlpbmcgY2xhc3MuXG4gICAgICBpZiAodHlwZS5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG1vY2sgZnVuY3Rpb24sIHBlb3BsZSB3aWxsIGV4cGVjdCBpdCB0byBiZSBjYWxsZWQuIFdlXG4gICAgICAgIC8vIHdpbGwgYWN0dWFsbHkgY2FsbCB0aGUgb3JpZ2luYWwgbW9jayBmYWN0b3J5IGZ1bmN0aW9uIGluc3RlYWQuIFRoaXNcbiAgICAgICAgLy8gZnV0dXJlIHByb29mcyB1bml0IHRlc3RpbmcgdGhhdCBhc3N1bWUgdGhhdCB0aGVzZSBhcmUgY2xhc3Nlcy5cbiAgICAgICAgdHlwZS50eXBlLl9tb2NrZWRSZWFjdENsYXNzQ29uc3RydWN0b3IgPSB0eXBlO1xuICAgICAgfVxuICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICBhcmdzWzBdID0gdHlwZS50eXBlO1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgd2FybkZvclBsYWluRnVuY3Rpb25UeXBlKHR5cGUpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgYmVpbmcgY2FsbGVkIHdpdGggYSBwbGFpbiBmdW5jdGlvbiB3ZSBzaG91bGQgaW52b2tlIGl0XG4gICAgLy8gaW1tZWRpYXRlbHkgYXMgaWYgdGhpcyB3YXMgdXNlZCB3aXRoIGxlZ2FjeSBKU1guXG4gICAgcmV0dXJuIHR5cGUuYXBwbHkobnVsbCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH07XG4gIHJldHVybiBsZWdhY3lDcmVhdGVFbGVtZW50O1xufTtcblxuUmVhY3RMZWdhY3lFbGVtZW50RmFjdG9yeS53cmFwRmFjdG9yeSA9IGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICB0eXBlb2YgZmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAnVGhpcyBpcyBzdXBwb3NlIHRvIGFjY2VwdCBhIGVsZW1lbnQgZmFjdG9yeSdcbiAgKSA6IGludmFyaWFudCh0eXBlb2YgZmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJykpO1xuICB2YXIgbGVnYWN5RWxlbWVudEZhY3RvcnkgPSBmdW5jdGlvbihjb25maWcsIGNoaWxkcmVuKSB7XG4gICAgLy8gVGhpcyBmYWN0b3J5IHNob3VsZCBub3QgYmUgY2FsbGVkIHdoZW4gSlNYIGlzIHVzZWQuIFVzZSBKU1ggaW5zdGVhZC5cbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICB3YXJuRm9yTGVnYWN5RmFjdG9yeUNhbGwoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhY3RvcnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgcHJveHlTdGF0aWNNZXRob2RzKGxlZ2FjeUVsZW1lbnRGYWN0b3J5LCBmYWN0b3J5LnR5cGUpO1xuICBsZWdhY3lFbGVtZW50RmFjdG9yeS5pc1JlYWN0TGVnYWN5RmFjdG9yeSA9IExFR0FDWV9NQVJLRVI7XG4gIGxlZ2FjeUVsZW1lbnRGYWN0b3J5LnR5cGUgPSBmYWN0b3J5LnR5cGU7XG4gIHJldHVybiBsZWdhY3lFbGVtZW50RmFjdG9yeTtcbn07XG5cbi8vIFRoaXMgaXMgdXNlZCB0byBtYXJrIGEgZmFjdG9yeSB0aGF0IHdpbGwgcmVtYWluLiBFLmcuIHdlJ3JlIGFsbG93ZWQgdG8gY2FsbFxuLy8gaXQgYXMgYSBmdW5jdGlvbi4gSG93ZXZlciwgeW91J3JlIG5vdCBzdXBwb3NlIHRvIHBhc3MgaXQgdG8gY3JlYXRlRWxlbWVudFxuLy8gb3IgY3JlYXRlRmFjdG9yeSwgc28gaXQgd2lsbCB3YXJuIHlvdSBpZiB5b3UgZG8uXG5SZWFjdExlZ2FjeUVsZW1lbnRGYWN0b3J5Lm1hcmtOb25MZWdhY3lGYWN0b3J5ID0gZnVuY3Rpb24oZmFjdG9yeSkge1xuICBmYWN0b3J5LmlzUmVhY3ROb25MZWdhY3lGYWN0b3J5ID0gTk9OX0xFR0FDWV9NQVJLRVI7XG4gIHJldHVybiBmYWN0b3J5O1xufTtcblxuLy8gQ2hlY2tzIGlmIGEgZmFjdG9yeSBmdW5jdGlvbiBpcyBhY3R1YWxseSBhIGxlZ2FjeSBmYWN0b3J5IHByZXRlbmRpbmcgdG9cbi8vIGJlIGEgY2xhc3MuXG5SZWFjdExlZ2FjeUVsZW1lbnRGYWN0b3J5LmlzVmFsaWRGYWN0b3J5ID0gZnVuY3Rpb24oZmFjdG9yeSkge1xuICAvLyBUT0RPOiBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBhbmQgbW92ZWQgaW50byBhIGNsYXNzIHZhbGlkYXRvciBvciBzb21ldGhpbmcuXG4gIHJldHVybiB0eXBlb2YgZmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGZhY3RvcnkuaXNSZWFjdExlZ2FjeUZhY3RvcnkgPT09IExFR0FDWV9NQVJLRVI7XG59O1xuXG5SZWFjdExlZ2FjeUVsZW1lbnRGYWN0b3J5LmlzVmFsaWRDbGFzcyA9IGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFxuICAgICAgZmFsc2UsXG4gICAgICAnaXNWYWxpZENsYXNzIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiAnICtcbiAgICAgICdVc2UgYSBtb3JlIHNwZWNpZmljIHZhbGlkYXRvciBpbnN0ZWFkLidcbiAgICApIDogbnVsbCk7XG4gIH1cbiAgcmV0dXJuIFJlYWN0TGVnYWN5RWxlbWVudEZhY3RvcnkuaXNWYWxpZEZhY3RvcnkoZmFjdG9yeSk7XG59O1xuXG5SZWFjdExlZ2FjeUVsZW1lbnRGYWN0b3J5Ll9pc0xlZ2FjeUNhbGxXYXJuaW5nRW5hYmxlZCA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RMZWdhY3lFbGVtZW50RmFjdG9yeTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TWFya3VwQ2hlY2tzdW1cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFkbGVyMzIgPSByZXF1aXJlKFwiLi9hZGxlcjMyXCIpO1xuXG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHtcbiAgQ0hFQ0tTVU1fQVRUUl9OQU1FOiAnZGF0YS1yZWFjdC1jaGVja3N1bScsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcgd2l0aCBjaGVja3N1bSBhdHRyaWJ1dGUgYXR0YWNoZWRcbiAgICovXG4gIGFkZENoZWNrc3VtVG9NYXJrdXA6IGZ1bmN0aW9uKG1hcmt1cCkge1xuICAgIHZhciBjaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcbiAgICByZXR1cm4gbWFya3VwLnJlcGxhY2UoXG4gICAgICAnPicsXG4gICAgICAnICcgKyBSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSArICc9XCInICsgY2hlY2tzdW0gKyAnXCI+J1xuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgdG8gdXNlXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCByb290IFJlYWN0IGVsZW1lbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBtYXJrdXAgaXMgdGhlIHNhbWVcbiAgICovXG4gIGNhblJldXNlTWFya3VwOiBmdW5jdGlvbihtYXJrdXAsIGVsZW1lbnQpIHtcbiAgICB2YXIgZXhpc3RpbmdDaGVja3N1bSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFxuICAgICAgUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUVcbiAgICApO1xuICAgIGV4aXN0aW5nQ2hlY2tzdW0gPSBleGlzdGluZ0NoZWNrc3VtICYmIHBhcnNlSW50KGV4aXN0aW5nQ2hlY2tzdW0sIDEwKTtcbiAgICB2YXIgbWFya3VwQ2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG4gICAgcmV0dXJuIG1hcmt1cENoZWNrc3VtID09PSBleGlzdGluZ0NoZWNrc3VtO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TWFya3VwQ2hlY2tzdW07XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TW91bnRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlcIik7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXCIpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZShcIi4vUmVhY3RDdXJyZW50T3duZXJcIik7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xudmFyIFJlYWN0TGVnYWN5RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0TGVnYWN5RWxlbWVudFwiKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VIYW5kbGVzXCIpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0UGVyZlwiKTtcblxudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoXCIuL2NvbnRhaW5zTm9kZVwiKTtcbnZhciBkZXByZWNhdGVkID0gcmVxdWlyZShcIi4vZGVwcmVjYXRlZFwiKTtcbnZhciBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIgPSByZXF1aXJlKFwiLi9nZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXJcIik7XG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoXCIuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnRcIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbnZhciBjcmVhdGVFbGVtZW50ID0gUmVhY3RMZWdhY3lFbGVtZW50LndyYXBDcmVhdGVFbGVtZW50KFxuICBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudFxuKTtcblxudmFyIFNFUEFSQVRPUiA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLlNFUEFSQVRPUjtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIG5vZGVDYWNoZSA9IHt9O1xuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xudmFyIERPQ19OT0RFX1RZUEUgPSA5O1xuXG4vKiogTWFwcGluZyBmcm9tIHJlYWN0Um9vdElEIHRvIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZS4gKi9cbnZhciBpbnN0YW5jZXNCeVJlYWN0Um9vdElEID0ge307XG5cbi8qKiBNYXBwaW5nIGZyb20gcmVhY3RSb290SUQgdG8gYGNvbnRhaW5lcmAgbm9kZXMuICovXG52YXIgY29udGFpbmVyc0J5UmVhY3RSb290SUQgPSB7fTtcblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAvKiogX19ERVZfXy1vbmx5IG1hcHBpbmcgZnJvbSByZWFjdFJvb3RJRCB0byByb290IGVsZW1lbnRzLiAqL1xuICB2YXIgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRCA9IHt9O1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGJyZWFkdGgtZmlyc3Qgc2VhcmNoIHN0YXRlIGluIGZpbmRDb21wb25lbnRSb290LlxudmFyIGZpbmRDb21wb25lbnRSb290UmV1c2FibGVBcnJheSA9IFtdO1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgbWF5IGNvbnRhaW4gYSBSZWFjdCBjb21wb25lbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBBIFwicmVhY3RSb290XCIgSUQsIGlmIGEgUmVhY3QgY29tcG9uZW50IGlzIHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RJRChjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiByb290RWxlbWVudCAmJiBSZWFjdE1vdW50LmdldElEKHJvb3RFbGVtZW50KTtcbn1cblxuLyoqXG4gKiBBY2Nlc3Npbmcgbm9kZVtBVFRSX05BTUVdIG9yIGNhbGxpbmcgZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgb24gYSBmb3JtXG4gKiBlbGVtZW50IGNhbiByZXR1cm4gaXRzIGNvbnRyb2wgd2hvc2UgbmFtZSBvciBJRCBlcXVhbHMgQVRUUl9OQU1FLiBBbGxcbiAqIERPTSBub2RlcyBzdXBwb3J0IGBnZXRBdHRyaWJ1dGVOb2RlYCBidXQgdGhpcyBjYW4gYWxzbyBnZXQgY2FsbGVkIG9uXG4gKiBvdGhlciBvYmplY3RzIHNvIGp1c3QgcmV0dXJuICcnIGlmIHdlJ3JlIGdpdmVuIHNvbWV0aGluZyBvdGhlciB0aGFuIGFcbiAqIERPTSBub2RlIChzdWNoIGFzIHdpbmRvdykuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudHxET01XaW5kb3d8RE9NRG9jdW1lbnR8RE9NVGV4dE5vZGV9IG5vZGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEIG9mIHRoZSBzdXBwbGllZCBgZG9tTm9kZWAuXG4gKi9cbmZ1bmN0aW9uIGdldElEKG5vZGUpIHtcbiAgdmFyIGlkID0gaW50ZXJuYWxHZXRJRChub2RlKTtcbiAgaWYgKGlkKSB7XG4gICAgaWYgKG5vZGVDYWNoZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIHZhciBjYWNoZWQgPSBub2RlQ2FjaGVbaWRdO1xuICAgICAgaWYgKGNhY2hlZCAhPT0gbm9kZSkge1xuICAgICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICAgICFpc1ZhbGlkKGNhY2hlZCwgaWQpLFxuICAgICAgICAgICdSZWFjdE1vdW50OiBUd28gdmFsaWQgYnV0IHVuZXF1YWwgbm9kZXMgd2l0aCB0aGUgc2FtZSBgJXNgOiAlcycsXG4gICAgICAgICAgQVRUUl9OQU1FLCBpZFxuICAgICAgICApIDogaW52YXJpYW50KCFpc1ZhbGlkKGNhY2hlZCwgaWQpKSk7XG5cbiAgICAgICAgbm9kZUNhY2hlW2lkXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVDYWNoZVtpZF0gPSBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxHZXRJRChub2RlKSB7XG4gIC8vIElmIG5vZGUgaXMgc29tZXRoaW5nIGxpa2UgYSB3aW5kb3csIGRvY3VtZW50LCBvciB0ZXh0IG5vZGUsIG5vbmUgb2ZcbiAgLy8gd2hpY2ggc3VwcG9ydCBhdHRyaWJ1dGVzIG9yIGEgLmdldEF0dHJpYnV0ZSBtZXRob2QsIGdyYWNlZnVsbHkgcmV0dXJuXG4gIC8vIHRoZSBlbXB0eSBzdHJpbmcsIGFzIGlmIHRoZSBhdHRyaWJ1dGUgd2VyZSBtaXNzaW5nLlxuICByZXR1cm4gbm9kZSAmJiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShBVFRSX05BTUUpIHx8ICcnO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIFJlYWN0LXNwZWNpZmljIElEIG9mIHRoZSBnaXZlbiBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBUaGUgRE9NIG5vZGUgd2hvc2UgSUQgd2lsbCBiZSBzZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIHZhbHVlIG9mIHRoZSBJRCBhdHRyaWJ1dGUuXG4gKi9cbmZ1bmN0aW9uIHNldElEKG5vZGUsIGlkKSB7XG4gIHZhciBvbGRJRCA9IGludGVybmFsR2V0SUQobm9kZSk7XG4gIGlmIChvbGRJRCAhPT0gaWQpIHtcbiAgICBkZWxldGUgbm9kZUNhY2hlW29sZElEXTtcbiAgfVxuICBub2RlLnNldEF0dHJpYnV0ZShBVFRSX05BTUUsIGlkKTtcbiAgbm9kZUNhY2hlW2lkXSA9IG5vZGU7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgUmVhY3QtZ2VuZXJhdGVkIERPTSBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQSBSZWFjdC1nZW5lcmF0ZWQgRE9NIElELlxuICogQHJldHVybiB7RE9NRWxlbWVudH0gRE9NIG5vZGUgd2l0aCB0aGUgc3VwcGxlZCBgaWRgLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGUoaWQpIHtcbiAgaWYgKCFub2RlQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpIHx8ICFpc1ZhbGlkKG5vZGVDYWNoZVtpZF0sIGlkKSkge1xuICAgIG5vZGVDYWNoZVtpZF0gPSBSZWFjdE1vdW50LmZpbmRSZWFjdE5vZGVCeUlEKGlkKTtcbiAgfVxuICByZXR1cm4gbm9kZUNhY2hlW2lkXTtcbn1cblxuLyoqXG4gKiBBIG5vZGUgaXMgXCJ2YWxpZFwiIGlmIGl0IGlzIGNvbnRhaW5lZCBieSBhIGN1cnJlbnRseSBtb3VudGVkIGNvbnRhaW5lci5cbiAqXG4gKiBUaGlzIG1lYW5zIHRoYXQgdGhlIG5vZGUgZG9lcyBub3QgaGF2ZSB0byBiZSBjb250YWluZWQgYnkgYSBkb2N1bWVudCBpblxuICogb3JkZXIgdG8gYmUgY29uc2lkZXJlZCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGV4cGVjdGVkIElEIG9mIHRoZSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgbm9kZSBpcyBjb250YWluZWQgYnkgYSBtb3VudGVkIGNvbnRhaW5lci5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZChub2RlLCBpZCkge1xuICBpZiAobm9kZSkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBpbnRlcm5hbEdldElEKG5vZGUpID09PSBpZCxcbiAgICAgICdSZWFjdE1vdW50OiBVbmV4cGVjdGVkIG1vZGlmaWNhdGlvbiBvZiBgJXNgJyxcbiAgICAgIEFUVFJfTkFNRVxuICAgICkgOiBpbnZhcmlhbnQoaW50ZXJuYWxHZXRJRChub2RlKSA9PT0gaWQpKTtcblxuICAgIHZhciBjb250YWluZXIgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKGlkKTtcbiAgICBpZiAoY29udGFpbmVyICYmIGNvbnRhaW5zTm9kZShjb250YWluZXIsIG5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2F1c2VzIHRoZSBjYWNoZSB0byBmb3JnZXQgYWJvdXQgb25lIFJlYWN0LXNwZWNpZmljIElELlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgdG8gZm9yZ2V0LlxuICovXG5mdW5jdGlvbiBwdXJnZUlEKGlkKSB7XG4gIGRlbGV0ZSBub2RlQ2FjaGVbaWRdO1xufVxuXG52YXIgZGVlcGVzdE5vZGVTb0ZhciA9IG51bGw7XG5mdW5jdGlvbiBmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9ySW1wbChhbmNlc3RvcklEKSB7XG4gIHZhciBhbmNlc3RvciA9IG5vZGVDYWNoZVthbmNlc3RvcklEXTtcbiAgaWYgKGFuY2VzdG9yICYmIGlzVmFsaWQoYW5jZXN0b3IsIGFuY2VzdG9ySUQpKSB7XG4gICAgZGVlcGVzdE5vZGVTb0ZhciA9IGFuY2VzdG9yO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgbm9kZSBpc24ndCBwb3B1bGF0ZWQgaW4gdGhlIGNhY2hlLCBzbyBwcmVzdW1hYmx5IG5vbmUgb2YgaXRzXG4gICAgLy8gZGVzY2VuZGFudHMgYXJlLiBCcmVhayBvdXQgb2YgdGhlIGxvb3AuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBkZWVwZXN0IGNhY2hlZCBub2RlIHdob3NlIElEIGlzIGEgcHJlZml4IG9mIGB0YXJnZXRJRGAuXG4gKi9cbmZ1bmN0aW9uIGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3IodGFyZ2V0SUQpIHtcbiAgZGVlcGVzdE5vZGVTb0ZhciA9IG51bGw7XG4gIFJlYWN0SW5zdGFuY2VIYW5kbGVzLnRyYXZlcnNlQW5jZXN0b3JzKFxuICAgIHRhcmdldElELFxuICAgIGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3JJbXBsXG4gICk7XG5cbiAgdmFyIGZvdW5kTm9kZSA9IGRlZXBlc3ROb2RlU29GYXI7XG4gIGRlZXBlc3ROb2RlU29GYXIgPSBudWxsO1xuICByZXR1cm4gZm91bmROb2RlO1xufVxuXG4vKipcbiAqIE1vdW50aW5nIGlzIHRoZSBwcm9jZXNzIG9mIGluaXRpYWxpemluZyBhIFJlYWN0IGNvbXBvbmVudCBieSBjcmVhdGluZ3MgaXRzXG4gKiByZXByZXNlbnRhdGl2ZSBET00gZWxlbWVudHMgYW5kIGluc2VydGluZyB0aGVtIGludG8gYSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAqIEFueSBwcmlvciBjb250ZW50IGluc2lkZSBgY29udGFpbmVyYCBpcyBkZXN0cm95ZWQgaW4gdGhlIHByb2Nlc3MuXG4gKlxuICogICBSZWFjdE1vdW50LnJlbmRlcihcbiAqICAgICBjb21wb25lbnQsXG4gKiAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpXG4gKiAgICk7XG4gKlxuICogICA8ZGl2IGlkPVwiY29udGFpbmVyXCI+ICAgICAgICAgICAgICAgICAgIDwtLSBTdXBwbGllZCBgY29udGFpbmVyYC5cbiAqICAgICA8ZGl2IGRhdGEtcmVhY3RpZD1cIi4zXCI+ICAgICAgICAgICAgICA8LS0gUmVuZGVyZWQgcmVhY3RSb290IG9mIFJlYWN0XG4gKiAgICAgICAvLyAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuXG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvZGl2PlxuICpcbiAqIEluc2lkZSBvZiBgY29udGFpbmVyYCwgdGhlIGZpcnN0IGVsZW1lbnQgcmVuZGVyZWQgaXMgdGhlIFwicmVhY3RSb290XCIuXG4gKi9cbnZhciBSZWFjdE1vdW50ID0ge1xuICAvKiogRXhwb3NlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzICoqL1xuICBfaW5zdGFuY2VzQnlSZWFjdFJvb3RJRDogaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCxcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhvb2sgcHJvdmlkZWQgdG8gc3VwcG9ydCByZW5kZXJpbmcgUmVhY3QgY29tcG9uZW50cyB3aGlsZVxuICAgKiBlbnN1cmluZyB0aGF0IHRoZSBhcHBhcmVudCBzY3JvbGwgcG9zaXRpb24gb2YgaXRzIGBjb250YWluZXJgIGRvZXMgbm90XG4gICAqIGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgVGhlIGBjb250YWluZXJgIGJlaW5nIHJlbmRlcmVkIGludG8uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlbmRlckNhbGxiYWNrIFRoaXMgbXVzdCBiZSBjYWxsZWQgb25jZSB0byBkbyB0aGUgcmVuZGVyLlxuICAgKi9cbiAgc2Nyb2xsTW9uaXRvcjogZnVuY3Rpb24oY29udGFpbmVyLCByZW5kZXJDYWxsYmFjaykge1xuICAgIHJlbmRlckNhbGxiYWNrKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRha2UgYSBjb21wb25lbnQgdGhhdCdzIGFscmVhZHkgbW91bnRlZCBpbnRvIHRoZSBET00gYW5kIHJlcGxhY2UgaXRzIHByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHByZXZDb21wb25lbnQgY29tcG9uZW50IGluc3RhbmNlIGFscmVhZHkgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50IGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKi9cbiAgX3VwZGF0ZVJvb3RDb21wb25lbnQ6IGZ1bmN0aW9uKFxuICAgICAgcHJldkNvbXBvbmVudCxcbiAgICAgIG5leHRDb21wb25lbnQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBjYWxsYmFjaykge1xuICAgIHZhciBuZXh0UHJvcHMgPSBuZXh0Q29tcG9uZW50LnByb3BzO1xuICAgIFJlYWN0TW91bnQuc2Nyb2xsTW9uaXRvcihjb250YWluZXIsIGZ1bmN0aW9uKCkge1xuICAgICAgcHJldkNvbXBvbmVudC5yZXBsYWNlUHJvcHMobmV4dFByb3BzLCBjYWxsYmFjayk7XG4gICAgfSk7XG5cbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAvLyBSZWNvcmQgdGhlIHJvb3QgZWxlbWVudCBpbiBjYXNlIGl0IGxhdGVyIGdldHMgdHJhbnNwbGFudGVkLlxuICAgICAgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtnZXRSZWFjdFJvb3RJRChjb250YWluZXIpXSA9XG4gICAgICAgIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcmV2Q29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNvbXBvbmVudCBpbnRvIHRoZSBpbnN0YW5jZSBtYXAgYW5kIHN0YXJ0cyBzY3JvbGwgdmFsdWVcbiAgICogbW9uaXRvcmluZ1xuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50IGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEByZXR1cm4ge3N0cmluZ30gcmVhY3RSb290IElEIHByZWZpeFxuICAgKi9cbiAgX3JlZ2lzdGVyQ29tcG9uZW50OiBmdW5jdGlvbihuZXh0Q29tcG9uZW50LCBjb250YWluZXIpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgY29udGFpbmVyICYmIChcbiAgICAgICAgY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSB8fFxuICAgICAgICBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEVcbiAgICAgICksXG4gICAgICAnX3JlZ2lzdGVyQ29tcG9uZW50KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJ1xuICAgICkgOiBpbnZhcmlhbnQoY29udGFpbmVyICYmIChcbiAgICAgIGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHxcbiAgICAgIGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRVxuICAgICkpKTtcblxuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5lbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3JpbmcoKTtcblxuICAgIHZhciByZWFjdFJvb3RJRCA9IFJlYWN0TW91bnQucmVnaXN0ZXJDb250YWluZXIoY29udGFpbmVyKTtcbiAgICBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSA9IG5leHRDb21wb25lbnQ7XG4gICAgcmV0dXJuIHJlYWN0Um9vdElEO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBuZXcgY29tcG9uZW50IGludG8gdGhlIERPTS5cbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gbmV4dENvbXBvbmVudCBjb21wb25lbnQgaW5zdGFuY2UgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIGlmIHdlIHNob3VsZCBza2lwIHRoZSBtYXJrdXAgaW5zZXJ0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50XG4gICAqL1xuICBfcmVuZGVyTmV3Um9vdENvbXBvbmVudDogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0TW91bnQnLFxuICAgICdfcmVuZGVyTmV3Um9vdENvbXBvbmVudCcsXG4gICAgZnVuY3Rpb24oXG4gICAgICAgIG5leHRDb21wb25lbnQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgc2hvdWxkUmV1c2VNYXJrdXApIHtcbiAgICAgIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAgICAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gICAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuXG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhcbiAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLFxuICAgICAgICAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSAnICtcbiAgICAgICAgJ3JlbmRlciBpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgK1xuICAgICAgICAnY29tcG9uZW50RGlkVXBkYXRlLidcbiAgICAgICkgOiBudWxsKTtcblxuICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0Q29tcG9uZW50LCBudWxsKTtcbiAgICAgIHZhciByZWFjdFJvb3RJRCA9IFJlYWN0TW91bnQuX3JlZ2lzdGVyQ29tcG9uZW50KFxuICAgICAgICBjb21wb25lbnRJbnN0YW5jZSxcbiAgICAgICAgY29udGFpbmVyXG4gICAgICApO1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UubW91bnRDb21wb25lbnRJbnRvTm9kZShcbiAgICAgICAgcmVhY3RSb290SUQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgc2hvdWxkUmV1c2VNYXJrdXBcbiAgICAgICk7XG5cbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgLy8gUmVjb3JkIHRoZSByb290IGVsZW1lbnQgaW4gY2FzZSBpdCBsYXRlciBnZXRzIHRyYW5zcGxhbnRlZC5cbiAgICAgICAgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPVxuICAgICAgICAgIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29tcG9uZW50SW5zdGFuY2U7XG4gICAgfVxuICApLFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgQ29tcG9uZW50IGVsZW1lbnQgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBDb21wb25lbnQgaW5zdGFuY2UgcmVuZGVyZWQgaW4gYGNvbnRhaW5lcmAuXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uKG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChuZXh0RWxlbWVudCksXG4gICAgICAncmVuZGVyQ29tcG9uZW50KCk6IEludmFsaWQgY29tcG9uZW50IGVsZW1lbnQuJXMnLFxuICAgICAgKFxuICAgICAgICB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAnIEluc3RlYWQgb2YgcGFzc2luZyBhbiBlbGVtZW50IHN0cmluZywgbWFrZSBzdXJlIHRvIGluc3RhbnRpYXRlICcgK1xuICAgICAgICAgICdpdCBieSBwYXNzaW5nIGl0IHRvIFJlYWN0LmNyZWF0ZUVsZW1lbnQuJyA6XG4gICAgICAgIFJlYWN0TGVnYWN5RWxlbWVudC5pc1ZhbGlkRmFjdG9yeShuZXh0RWxlbWVudCkgP1xuICAgICAgICAgICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY29tcG9uZW50IGNsYXNzLCBtYWtlIHN1cmUgdG8gaW5zdGFudGlhdGUgJyArXG4gICAgICAgICAgJ2l0IGJ5IHBhc3NpbmcgaXQgdG8gUmVhY3QuY3JlYXRlRWxlbWVudC4nIDpcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQgcXVhY2tzIGxpa2UgYSBlbGVtZW50XG4gICAgICAgIHR5cGVvZiBuZXh0RWxlbWVudC5wcm9wcyAhPT0gXCJ1bmRlZmluZWRcIiA/XG4gICAgICAgICAgJyBUaGlzIG1heSBiZSBjYXVzZWQgYnkgdW5pbnRlbnRpb25hbGx5IGxvYWRpbmcgdHdvIGluZGVwZW5kZW50ICcgK1xuICAgICAgICAgICdjb3BpZXMgb2YgUmVhY3QuJyA6XG4gICAgICAgICAgJydcbiAgICAgIClcbiAgICApIDogaW52YXJpYW50KFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChuZXh0RWxlbWVudCkpKTtcblxuICAgIHZhciBwcmV2Q29tcG9uZW50ID0gaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtnZXRSZWFjdFJvb3RJRChjb250YWluZXIpXTtcblxuICAgIGlmIChwcmV2Q29tcG9uZW50KSB7XG4gICAgICB2YXIgcHJldkVsZW1lbnQgPSBwcmV2Q29tcG9uZW50Ll9jdXJyZW50RWxlbWVudDtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBSZWFjdE1vdW50Ll91cGRhdGVSb290Q29tcG9uZW50KFxuICAgICAgICAgIHByZXZDb21wb25lbnQsXG4gICAgICAgICAgbmV4dEVsZW1lbnQsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVhY3RSb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIHZhciBjb250YWluZXJIYXNSZWFjdE1hcmt1cCA9XG4gICAgICByZWFjdFJvb3RFbGVtZW50ICYmIFJlYWN0TW91bnQuaXNSZW5kZXJlZEJ5UmVhY3QocmVhY3RSb290RWxlbWVudCk7XG5cbiAgICB2YXIgc2hvdWxkUmV1c2VNYXJrdXAgPSBjb250YWluZXJIYXNSZWFjdE1hcmt1cCAmJiAhcHJldkNvbXBvbmVudDtcblxuICAgIHZhciBjb21wb25lbnQgPSBSZWFjdE1vdW50Ll9yZW5kZXJOZXdSb290Q29tcG9uZW50KFxuICAgICAgbmV4dEVsZW1lbnQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBzaG91bGRSZXVzZU1hcmt1cFxuICAgICk7XG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChjb21wb25lbnQpO1xuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBjb21wb25lbnQgaW5zdGFuY2Ugb2YgYGNvbnN0cnVjdG9yYCB3aXRoIGBpbml0aWFsUHJvcHNgIGFuZFxuICAgKiByZW5kZXJzIGl0IGludG8gdGhlIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBSZWFjdCBjb21wb25lbnQgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJvcHMgSW5pdGlhbCBwcm9wcyBvZiB0aGUgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIGNvbnN0cnVjdEFuZFJlbmRlckNvbXBvbmVudDogZnVuY3Rpb24oY29uc3RydWN0b3IsIHByb3BzLCBjb250YWluZXIpIHtcbiAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoY29uc3RydWN0b3IsIHByb3BzKTtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5yZW5kZXIoZWxlbWVudCwgY29udGFpbmVyKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIGNvbXBvbmVudCBpbnN0YW5jZSBvZiBgY29uc3RydWN0b3JgIHdpdGggYGluaXRpYWxQcm9wc2AgYW5kXG4gICAqIHJlbmRlcnMgaXQgaW50byBhIGNvbnRhaW5lciBub2RlIGlkZW50aWZpZWQgYnkgc3VwcGxpZWQgYGlkYC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcG9uZW50Q29uc3RydWN0b3IgUmVhY3QgY29tcG9uZW50IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJvcHMgSW5pdGlhbCBwcm9wcyBvZiB0aGUgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIHRoZSBjb250YWluZXIgbm9kZS5cbiAgICovXG4gIGNvbnN0cnVjdEFuZFJlbmRlckNvbXBvbmVudEJ5SUQ6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBwcm9wcywgaWQpIHtcbiAgICB2YXIgZG9tTm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgZG9tTm9kZSxcbiAgICAgICdUcmllZCB0byBnZXQgZWxlbWVudCB3aXRoIGlkIG9mIFwiJXNcIiBidXQgaXQgaXMgbm90IHByZXNlbnQgb24gdGhlIHBhZ2UuJyxcbiAgICAgIGlkXG4gICAgKSA6IGludmFyaWFudChkb21Ob2RlKSk7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuY29uc3RydWN0QW5kUmVuZGVyQ29tcG9uZW50KGNvbnN0cnVjdG9yLCBwcm9wcywgZG9tTm9kZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNvbnRhaW5lciBub2RlIGludG8gd2hpY2ggUmVhY3QgY29tcG9uZW50cyB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKiBUaGlzIGFsc28gY3JlYXRlcyB0aGUgXCJyZWFjdFJvb3RcIiBJRCB0aGF0IHdpbGwgYmUgYXNzaWduZWQgdG8gdGhlIGVsZW1lbnRcbiAgICogcmVuZGVyZWQgd2l0aGluLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZWdpc3RlciBhcyBhIGNvbnRhaW5lci5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgXCJyZWFjdFJvb3RcIiBJRCBvZiBlbGVtZW50cyByZW5kZXJlZCB3aXRoaW4uXG4gICAqL1xuICByZWdpc3RlckNvbnRhaW5lcjogZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgdmFyIHJlYWN0Um9vdElEID0gZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKTtcbiAgICBpZiAocmVhY3RSb290SUQpIHtcbiAgICAgIC8vIElmIG9uZSBleGlzdHMsIG1ha2Ugc3VyZSBpdCBpcyBhIHZhbGlkIFwicmVhY3RSb290XCIgSUQuXG4gICAgICByZWFjdFJvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChyZWFjdFJvb3RJRCk7XG4gICAgfVxuICAgIGlmICghcmVhY3RSb290SUQpIHtcbiAgICAgIC8vIE5vIHZhbGlkIFwicmVhY3RSb290XCIgSUQgZm91bmQsIGNyZWF0ZSBvbmUuXG4gICAgICByZWFjdFJvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0Um9vdElEKCk7XG4gICAgfVxuICAgIGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSA9IGNvbnRhaW5lcjtcbiAgICByZXR1cm4gcmVhY3RSb290SUQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGFuZCBkZXN0cm95cyB0aGUgUmVhY3QgY29tcG9uZW50IHJlbmRlcmVkIGluIHRoZSBgY29udGFpbmVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgY29udGFpbmluZyBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIGNvbXBvbmVudCB3YXMgZm91bmQgaW4gYW5kIHVubW91bnRlZCBmcm9tXG4gICAqICAgICAgICAgICAgICAgICAgIGBjb250YWluZXJgXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChTdHJpY3RseSBzcGVha2luZywgdW5tb3VudGluZyB3b24ndCBjYXVzZSBhXG4gICAgLy8gcmVuZGVyIGJ1dCB3ZSBzdGlsbCBkb24ndCBleHBlY3QgdG8gYmUgaW4gYSByZW5kZXIgY2FsbCBoZXJlLilcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCxcbiAgICAgICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgJyArXG4gICAgICAncHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciBpcyAnICtcbiAgICAgICdub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgK1xuICAgICAgJ2NvbXBvbmVudERpZFVwZGF0ZS4nXG4gICAgKSA6IG51bGwpO1xuXG4gICAgdmFyIHJlYWN0Um9vdElEID0gZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKTtcbiAgICB2YXIgY29tcG9uZW50ID0gaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50RnJvbU5vZGUoY29tcG9uZW50LCBjb250YWluZXIpO1xuICAgIGRlbGV0ZSBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICBkZWxldGUgY29udGFpbmVyc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIGRlbGV0ZSByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGEgY29tcG9uZW50IGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW5zdGFuY2UgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byB1bm1vdW50IGZyb20uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7UmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlfVxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudEZyb21Ob2RlOiBmdW5jdGlvbihpbnN0YW5jZSwgY29udGFpbmVyKSB7XG4gICAgaW5zdGFuY2UudW5tb3VudENvbXBvbmVudCgpO1xuXG4gICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9lbXB0eWluZy1hLW5vZGVcbiAgICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIFJlYWN0IGNvbXBvbmVudCB0byB3aGljaCB0aGVcbiAgICogc3VwcGxpZWQgRE9NIGBpZGAgYmVsb25ncy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiBhbiBlbGVtZW50IHJlbmRlcmVkIGJ5IGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHs/RE9NRWxlbWVudH0gRE9NIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgYGlkYC5cbiAgICovXG4gIGZpbmRSZWFjdENvbnRhaW5lckZvcklEOiBmdW5jdGlvbihpZCkge1xuICAgIHZhciByZWFjdFJvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChpZCk7XG4gICAgdmFyIGNvbnRhaW5lciA9IGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcblxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIHZhciByb290RWxlbWVudCA9IHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgICAgaWYgKHJvb3RFbGVtZW50ICYmIHJvb3RFbGVtZW50LnBhcmVudE5vZGUgIT09IGNvbnRhaW5lcikge1xuICAgICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICAgIC8vIENhbGwgaW50ZXJuYWxHZXRJRCBoZXJlIGJlY2F1c2UgZ2V0SUQgY2FsbHMgaXNWYWxpZCB3aGljaCBjYWxsc1xuICAgICAgICAgIC8vIGZpbmRSZWFjdENvbnRhaW5lckZvcklEICh0aGlzIGZ1bmN0aW9uKS5cbiAgICAgICAgICBpbnRlcm5hbEdldElEKHJvb3RFbGVtZW50KSA9PT0gcmVhY3RSb290SUQsXG4gICAgICAgICAgJ1JlYWN0TW91bnQ6IFJvb3QgZWxlbWVudCBJRCBkaWZmZXJlZCBmcm9tIHJlYWN0Um9vdElELidcbiAgICAgICAgKSA6IGludmFyaWFudCgvLyBDYWxsIGludGVybmFsR2V0SUQgaGVyZSBiZWNhdXNlIGdldElEIGNhbGxzIGlzVmFsaWQgd2hpY2ggY2FsbHNcbiAgICAgICAgLy8gZmluZFJlYWN0Q29udGFpbmVyRm9ySUQgKHRoaXMgZnVuY3Rpb24pLlxuICAgICAgICBpbnRlcm5hbEdldElEKHJvb3RFbGVtZW50KSA9PT0gcmVhY3RSb290SUQpKTtcblxuICAgICAgICB2YXIgY29udGFpbmVyQ2hpbGQgPSBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGNvbnRhaW5lckNoaWxkICYmXG4gICAgICAgICAgICByZWFjdFJvb3RJRCA9PT0gaW50ZXJuYWxHZXRJRChjb250YWluZXJDaGlsZCkpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgY29udGFpbmVyIGhhcyBhIG5ldyBjaGlsZCB3aXRoIHRoZSBzYW1lIElEIGFzIHRoZSBvbGRcbiAgICAgICAgICAvLyByb290IGVsZW1lbnQsIHRoZW4gcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gaXNcbiAgICAgICAgICAvLyBqdXN0IHN0YWxlIGFuZCBuZWVkcyB0byBiZSB1cGRhdGVkLiBUaGUgY2FzZSB0aGF0IGRlc2VydmVzIGFcbiAgICAgICAgICAvLyB3YXJuaW5nIGlzIHdoZW4gdGhlIGNvbnRhaW5lciBpcyBlbXB0eS5cbiAgICAgICAgICByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSA9IGNvbnRhaW5lckNoaWxkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdSZWFjdE1vdW50OiBSb290IGVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIGl0cyBvcmlnaW5hbCAnICtcbiAgICAgICAgICAgICdjb250YWluZXIuIE5ldyBjb250YWluZXI6Jywgcm9vdEVsZW1lbnQucGFyZW50Tm9kZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbiBlbGVtZW50IHJlbmRlcmVkIGJ5IFJlYWN0IHdpdGggdGhlIHN1cHBsaWVkIElELlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgYSBET00gbm9kZSBpbiB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSBSb290IERPTSBub2RlIG9mIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAqL1xuICBmaW5kUmVhY3ROb2RlQnlJRDogZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgcmVhY3RSb290ID0gUmVhY3RNb3VudC5maW5kUmVhY3RDb250YWluZXJGb3JJRChpZCk7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuZmluZENvbXBvbmVudFJvb3QocmVhY3RSb290LCBpZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIGBub2RlYCBpcyByZW5kZXJlZCBieSBSZWFjdC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBub2RlIERPTSBFbGVtZW50IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gRWxlbWVudCBhcHBlYXJzIHRvIGJlIHJlbmRlcmVkIGJ5IFJlYWN0LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGlzUmVuZGVyZWRCeVJlYWN0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgIC8vIE5vdCBhIERPTUVsZW1lbnQsIHRoZXJlZm9yZSBub3QgYSBSZWFjdCBjb21wb25lbnRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGlkID0gUmVhY3RNb3VudC5nZXRJRChub2RlKTtcbiAgICByZXR1cm4gaWQgPyBpZC5jaGFyQXQoMCkgPT09IFNFUEFSQVRPUiA6IGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZXMgdXAgdGhlIGFuY2VzdG9ycyBvZiB0aGUgc3VwcGxpZWQgbm9kZSB0byBmaW5kIGEgbm9kZSB0aGF0IGlzIGFcbiAgICogRE9NIHJlcHJlc2VudGF0aW9uIG9mIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IG5vZGVcbiAgICogQHJldHVybiB7P0RPTUV2ZW50VGFyZ2V0fVxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldEZpcnN0UmVhY3RET006IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgY3VycmVudCA9IG5vZGU7XG4gICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC5wYXJlbnROb2RlICE9PSBjdXJyZW50KSB7XG4gICAgICBpZiAoUmVhY3RNb3VudC5pc1JlbmRlcmVkQnlSZWFjdChjdXJyZW50KSkge1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyBhIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgYHRhcmdldElEYCBpbnNpZGUgb2YgdGhlIHN1cHBsaWVkXG4gICAqIGBhbmNlc3Rvck5vZGVgLiAgRXhwbG9pdHMgdGhlIElEIG5hbWluZyBzY2hlbWUgdG8gcGVyZm9ybSB0aGUgc2VhcmNoXG4gICAqIHF1aWNrbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IGFuY2VzdG9yTm9kZSBTZWFyY2ggZnJvbSB0aGlzIHJvb3QuXG4gICAqIEBwYXJhcm0ge3N0cmluZ30gdGFyZ2V0SUQgSUQgb2YgdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gRE9NIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgYHRhcmdldElEYC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBmaW5kQ29tcG9uZW50Um9vdDogZnVuY3Rpb24oYW5jZXN0b3JOb2RlLCB0YXJnZXRJRCkge1xuICAgIHZhciBmaXJzdENoaWxkcmVuID0gZmluZENvbXBvbmVudFJvb3RSZXVzYWJsZUFycmF5O1xuICAgIHZhciBjaGlsZEluZGV4ID0gMDtcblxuICAgIHZhciBkZWVwZXN0QW5jZXN0b3IgPSBmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9yKHRhcmdldElEKSB8fCBhbmNlc3Rvck5vZGU7XG5cbiAgICBmaXJzdENoaWxkcmVuWzBdID0gZGVlcGVzdEFuY2VzdG9yLmZpcnN0Q2hpbGQ7XG4gICAgZmlyc3RDaGlsZHJlbi5sZW5ndGggPSAxO1xuXG4gICAgd2hpbGUgKGNoaWxkSW5kZXggPCBmaXJzdENoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkID0gZmlyc3RDaGlsZHJlbltjaGlsZEluZGV4KytdO1xuICAgICAgdmFyIHRhcmdldENoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgdmFyIGNoaWxkSUQgPSBSZWFjdE1vdW50LmdldElEKGNoaWxkKTtcbiAgICAgICAgaWYgKGNoaWxkSUQpIHtcbiAgICAgICAgICAvLyBFdmVuIGlmIHdlIGZpbmQgdGhlIG5vZGUgd2UncmUgbG9va2luZyBmb3IsIHdlIGZpbmlzaCBsb29waW5nXG4gICAgICAgICAgLy8gdGhyb3VnaCBpdHMgc2libGluZ3MgdG8gZW5zdXJlIHRoZXkncmUgY2FjaGVkIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAgIC8vIHRvIHJldmlzaXQgdGhpcyBub2RlIGFnYWluLiBPdGhlcndpc2UsIHdlIG1ha2Ugbl4yIGNhbGxzIHRvIGdldElEXG4gICAgICAgICAgLy8gd2hlbiB2aXNpdGluZyB0aGUgbWFueSBjaGlsZHJlbiBvZiBhIHNpbmdsZSBub2RlIGluIG9yZGVyLlxuXG4gICAgICAgICAgaWYgKHRhcmdldElEID09PSBjaGlsZElEKSB7XG4gICAgICAgICAgICB0YXJnZXRDaGlsZCA9IGNoaWxkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoUmVhY3RJbnN0YW5jZUhhbmRsZXMuaXNBbmNlc3RvcklET2YoY2hpbGRJRCwgdGFyZ2V0SUQpKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBmaW5kIGEgY2hpbGQgd2hvc2UgSUQgaXMgYW4gYW5jZXN0b3Igb2YgdGhlIGdpdmVuIElELFxuICAgICAgICAgICAgLy8gdGhlbiB3ZSBjYW4gYmUgc3VyZSB0aGF0IHdlIG9ubHkgd2FudCB0byBzZWFyY2ggdGhlIHN1YnRyZWVcbiAgICAgICAgICAgIC8vIHJvb3RlZCBhdCB0aGlzIGNoaWxkLCBzbyB3ZSBjYW4gdGhyb3cgb3V0IHRoZSByZXN0IG9mIHRoZVxuICAgICAgICAgICAgLy8gc2VhcmNoIHN0YXRlLlxuICAgICAgICAgICAgZmlyc3RDaGlsZHJlbi5sZW5ndGggPSBjaGlsZEluZGV4ID0gMDtcbiAgICAgICAgICAgIGZpcnN0Q2hpbGRyZW4ucHVzaChjaGlsZC5maXJzdENoaWxkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGNoaWxkIGhhZCBubyBJRCwgdGhlbiB0aGVyZSdzIGEgY2hhbmNlIHRoYXQgaXQgd2FzXG4gICAgICAgICAgLy8gaW5qZWN0ZWQgYXV0b21hdGljYWxseSBieSB0aGUgYnJvd3NlciwgYXMgd2hlbiBhIGA8dGFibGU+YFxuICAgICAgICAgIC8vIGVsZW1lbnQgc3Byb3V0cyBhbiBleHRyYSBgPHRib2R5PmAgY2hpbGQgYXMgYSBzaWRlIGVmZmVjdCBvZlxuICAgICAgICAgIC8vIGAuaW5uZXJIVE1MYCBwYXJzaW5nLiBPcHRpbWlzdGljYWxseSBjb250aW51ZSBkb3duIHRoaXNcbiAgICAgICAgICAvLyBicmFuY2gsIGJ1dCBub3QgYmVmb3JlIGV4YW1pbmluZyB0aGUgb3RoZXIgc2libGluZ3MuXG4gICAgICAgICAgZmlyc3RDaGlsZHJlbi5wdXNoKGNoaWxkLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldENoaWxkKSB7XG4gICAgICAgIC8vIEVtcHR5aW5nIGZpcnN0Q2hpbGRyZW4vZmluZENvbXBvbmVudFJvb3RSZXVzYWJsZUFycmF5IGlzXG4gICAgICAgIC8vIG5vdCBuZWNlc3NhcnkgZm9yIGNvcnJlY3RuZXNzLCBidXQgaXQgaGVscHMgdGhlIEdDIHJlY2xhaW1cbiAgICAgICAgLy8gYW55IG5vZGVzIHRoYXQgd2VyZSBsZWZ0IGF0IHRoZSBlbmQgb2YgdGhlIHNlYXJjaC5cbiAgICAgICAgZmlyc3RDaGlsZHJlbi5sZW5ndGggPSAwO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXRDaGlsZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaXJzdENoaWxkcmVuLmxlbmd0aCA9IDA7XG5cbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgZmFsc2UsXG4gICAgICAnZmluZENvbXBvbmVudFJvb3QoLi4uLCAlcyk6IFVuYWJsZSB0byBmaW5kIGVsZW1lbnQuIFRoaXMgcHJvYmFibHkgJyArXG4gICAgICAnbWVhbnMgdGhlIERPTSB3YXMgdW5leHBlY3RlZGx5IG11dGF0ZWQgKGUuZy4sIGJ5IHRoZSBicm93c2VyKSwgJyArXG4gICAgICAndXN1YWxseSBkdWUgdG8gZm9yZ2V0dGluZyBhIDx0Ym9keT4gd2hlbiB1c2luZyB0YWJsZXMsIG5lc3RpbmcgdGFncyAnICtcbiAgICAgICdsaWtlIDxmb3JtPiwgPHA+LCBvciA8YT4sIG9yIHVzaW5nIG5vbi1TVkcgZWxlbWVudHMgaW4gYW4gPHN2Zz4gJyArXG4gICAgICAncGFyZW50LiAnICtcbiAgICAgICdUcnkgaW5zcGVjdGluZyB0aGUgY2hpbGQgbm9kZXMgb2YgdGhlIGVsZW1lbnQgd2l0aCBSZWFjdCBJRCBgJXNgLicsXG4gICAgICB0YXJnZXRJRCxcbiAgICAgIFJlYWN0TW91bnQuZ2V0SUQoYW5jZXN0b3JOb2RlKVxuICAgICkgOiBpbnZhcmlhbnQoZmFsc2UpKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBSZWFjdCBJRCB1dGlsaXRpZXMuXG4gICAqL1xuXG4gIGdldFJlYWN0Um9vdElEOiBnZXRSZWFjdFJvb3RJRCxcblxuICBnZXRJRDogZ2V0SUQsXG5cbiAgc2V0SUQ6IHNldElELFxuXG4gIGdldE5vZGU6IGdldE5vZGUsXG5cbiAgcHVyZ2VJRDogcHVyZ2VJRFxufTtcblxuLy8gRGVwcmVjYXRpb25zIChyZW1vdmUgZm9yIDAuMTMpXG5SZWFjdE1vdW50LnJlbmRlckNvbXBvbmVudCA9IGRlcHJlY2F0ZWQoXG4gICdSZWFjdE1vdW50JyxcbiAgJ3JlbmRlckNvbXBvbmVudCcsXG4gICdyZW5kZXInLFxuICB0aGlzLFxuICBSZWFjdE1vdW50LnJlbmRlclxuKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNdWx0aUNoaWxkXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudFwiKTtcbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IHJlcXVpcmUoXCIuL1JlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzXCIpO1xuXG52YXIgZmxhdHRlbkNoaWxkcmVuID0gcmVxdWlyZShcIi4vZmxhdHRlbkNoaWxkcmVuXCIpO1xudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XCIpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnRcIik7XG5cbi8qKlxuICogVXBkYXRpbmcgY2hpbGRyZW4gb2YgYSBjb21wb25lbnQgbWF5IHRyaWdnZXIgcmVjdXJzaXZlIHVwZGF0ZXMuIFRoZSBkZXB0aCBpc1xuICogdXNlZCB0byBiYXRjaCByZWN1cnNpdmUgdXBkYXRlcyB0byByZW5kZXIgbWFya3VwIG1vcmUgZWZmaWNpZW50bHkuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1cGRhdGVEZXB0aCA9IDA7XG5cbi8qKlxuICogUXVldWUgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb24gb2JqZWN0cy5cbiAqXG4gKiBFYWNoIG9iamVjdCBoYXMgYSBgdHlwZWAgcHJvcGVydHkgdGhhdCBpcyBpbiBgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXNgLlxuICpcbiAqIEB0eXBlIHthcnJheTxvYmplY3Q+fVxuICogQHByaXZhdGVcbiAqL1xudmFyIHVwZGF0ZVF1ZXVlID0gW107XG5cbi8qKlxuICogUXVldWUgb2YgbWFya3VwIHRvIGJlIHJlbmRlcmVkLlxuICpcbiAqIEB0eXBlIHthcnJheTxzdHJpbmc+fVxuICogQHByaXZhdGVcbiAqL1xudmFyIG1hcmt1cFF1ZXVlID0gW107XG5cbi8qKlxuICogRW5xdWV1ZXMgbWFya3VwIHRvIGJlIHJlbmRlcmVkIGFuZCBpbnNlcnRlZCBhdCBhIHN1cHBsaWVkIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRoYXQgcmVuZGVycyBpbnRvIGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVNYXJrdXAocGFyZW50SUQsIG1hcmt1cCwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLklOU0VSVF9NQVJLVVAsXG4gICAgbWFya3VwSW5kZXg6IG1hcmt1cFF1ZXVlLnB1c2gobWFya3VwKSAtIDEsXG4gICAgdGV4dENvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIHRvSW5kZXg6IHRvSW5kZXhcbiAgfSk7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgbW92aW5nIGFuIGV4aXN0aW5nIGVsZW1lbnQgdG8gYW5vdGhlciBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFNvdXJjZSBpbmRleCBvZiB0aGUgZXhpc3RpbmcgZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZU1vdmUocGFyZW50SUQsIGZyb21JbmRleCwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkcsXG4gICAgbWFya3VwSW5kZXg6IG51bGwsXG4gICAgdGV4dENvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBmcm9tSW5kZXgsXG4gICAgdG9JbmRleDogdG9JbmRleFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyByZW1vdmluZyBhbiBlbGVtZW50IGF0IGFuIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggSW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVJlbW92ZShwYXJlbnRJRCwgZnJvbUluZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuUkVNT1ZFX05PREUsXG4gICAgbWFya3VwSW5kZXg6IG51bGwsXG4gICAgdGV4dENvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBmcm9tSW5kZXgsXG4gICAgdG9JbmRleDogbnVsbFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBzZXR0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElEIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRDb250ZW50IFRleHQgY29udGVudCB0byBzZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlVGV4dENvbnRlbnQocGFyZW50SUQsIHRleHRDb250ZW50KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuVEVYVF9DT05URU5ULFxuICAgIG1hcmt1cEluZGV4OiBudWxsLFxuICAgIHRleHRDb250ZW50OiB0ZXh0Q29udGVudCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgdG9JbmRleDogbnVsbFxuICB9KTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzZXMgYW55IGVucXVldWVkIHVwZGF0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKCkge1xuICBpZiAodXBkYXRlUXVldWUubGVuZ3RoKSB7XG4gICAgUmVhY3RDb21wb25lbnQuQmFja2VuZElET3BlcmF0aW9ucy5kYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMoXG4gICAgICB1cGRhdGVRdWV1ZSxcbiAgICAgIG1hcmt1cFF1ZXVlXG4gICAgKTtcbiAgICBjbGVhclF1ZXVlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGVhcnMgYW55IGVucXVldWVkIHVwZGF0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJRdWV1ZSgpIHtcbiAgdXBkYXRlUXVldWUubGVuZ3RoID0gMDtcbiAgbWFya3VwUXVldWUubGVuZ3RoID0gMDtcbn1cblxuLyoqXG4gKiBSZWFjdE11bHRpQ2hpbGQgYXJlIGNhcGFibGUgb2YgcmVjb25jaWxpbmcgbXVsdGlwbGUgY2hpbGRyZW4uXG4gKlxuICogQGNsYXNzIFJlYWN0TXVsdGlDaGlsZFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdE11bHRpQ2hpbGQgPSB7XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciBjb21wb25lbnRzIHRoYXQgbXVzdCByZWNvbmNpbGUgbXVsdGlwbGVcbiAgICogY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCBieSBgUmVhY3RET01Db21wb25lbnRgIHRvIG1vdW50LCB1cGRhdGUsIGFuZFxuICAgKiB1bm1vdW50IGNoaWxkIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBsZW5kcyB7UmVhY3RNdWx0aUNoaWxkLnByb3RvdHlwZX1cbiAgICovXG4gIE1peGluOiB7XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxuICAgICAqIG9mIGBSZWFjdERPTUNvbXBvbmVudGAsIGEgbW91bnQgaW1hZ2UgaXMgYSBzdHJpbmcgb2YgbWFya3VwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZHJlbiBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgbW91bnRlZCByZXByZXNlbnRhdGlvbnMuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbW91bnRDaGlsZHJlbjogZnVuY3Rpb24obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4pO1xuICAgICAgdmFyIG1vdW50SW1hZ2VzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltuYW1lXTtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgLy8gVGhlIHJlbmRlcmVkIGNoaWxkcmVuIG11c3QgYmUgdHVybmVkIGludG8gaW5zdGFuY2VzIGFzIHRoZXkncmVcbiAgICAgICAgICAvLyBtb3VudGVkLlxuICAgICAgICAgIHZhciBjaGlsZEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChjaGlsZCwgbnVsbCk7XG4gICAgICAgICAgY2hpbGRyZW5bbmFtZV0gPSBjaGlsZEluc3RhbmNlO1xuICAgICAgICAgIC8vIElubGluZWQgZm9yIHBlcmZvcm1hbmNlLCBzZWUgYFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0SURgLlxuICAgICAgICAgIHZhciByb290SUQgPSB0aGlzLl9yb290Tm9kZUlEICsgbmFtZTtcbiAgICAgICAgICB2YXIgbW91bnRJbWFnZSA9IGNoaWxkSW5zdGFuY2UubW91bnRDb21wb25lbnQoXG4gICAgICAgICAgICByb290SUQsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgIHRoaXMuX21vdW50RGVwdGggKyAxXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjaGlsZEluc3RhbmNlLl9tb3VudEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgbW91bnRJbWFnZXMucHVzaChtb3VudEltYWdlKTtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbW91bnRJbWFnZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgdGV4dCBjb250ZW50IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0Q29udGVudCBTdHJpbmcgb2YgY29udGVudC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0Q29udGVudDogZnVuY3Rpb24obmV4dENvbnRlbnQpIHtcbiAgICAgIHVwZGF0ZURlcHRoKys7XG4gICAgICB2YXIgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fdW5tb3VudENoaWxkQnlOYW1lKHByZXZDaGlsZHJlbltuYW1lXSwgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBuZXcgdGV4dCBjb250ZW50LlxuICAgICAgICB0aGlzLnNldFRleHRDb250ZW50KG5leHRDb250ZW50KTtcbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVwZGF0ZURlcHRoLS07XG4gICAgICAgIGlmICghdXBkYXRlRGVwdGgpIHtcbiAgICAgICAgICBlcnJvclRocm93biA/IGNsZWFyUXVldWUoKSA6IHByb2Nlc3NRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggbmV3IGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW4gTmVzdGVkIGNoaWxkIG1hcHMuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbihuZXh0TmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uKSB7XG4gICAgICB1cGRhdGVEZXB0aCsrO1xuICAgICAgdmFyIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdXBkYXRlRGVwdGgtLTtcbiAgICAgICAgaWYgKCF1cGRhdGVEZXB0aCkge1xuICAgICAgICAgIGVycm9yVGhyb3duID8gY2xlYXJRdWV1ZSgpIDogcHJvY2Vzc1F1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW1wcm92ZSBwZXJmb3JtYW5jZSBieSBpc29sYXRpbmcgdGhpcyBob3QgY29kZSBwYXRoIGZyb20gdGhlIHRyeS9jYXRjaFxuICAgICAqIGJsb2NrIGluIGB1cGRhdGVDaGlsZHJlbmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbiBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGZpbmFsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF91cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24obmV4dE5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbikge1xuICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW4pO1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuYW1lO1xuICAgICAgLy8gYG5leHRJbmRleGAgd2lsbCBpbmNyZW1lbnQgZm9yIGVhY2ggY2hpbGQgaW4gYG5leHRDaGlsZHJlbmAsIGJ1dFxuICAgICAgLy8gYGxhc3RJbmRleGAgd2lsbCBiZSB0aGUgbGFzdCBpbmRleCB2aXNpdGVkIGluIGBwcmV2Q2hpbGRyZW5gLlxuICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuICYmIHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldkNoaWxkICYmIHByZXZDaGlsZC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICAgIHZhciBuZXh0RWxlbWVudCA9IG5leHRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkpIHtcbiAgICAgICAgICB0aGlzLm1vdmVDaGlsZChwcmV2Q2hpbGQsIG5leHRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgcHJldkNoaWxkLnJlY2VpdmVDb21wb25lbnQobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICBwcmV2Q2hpbGQuX21vdW50SW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHByZXZDaGlsZCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGBsYXN0SW5kZXhgIGJlZm9yZSBgX21vdW50SW5kZXhgIGdldHMgdW5zZXQgYnkgdW5tb3VudGluZy5cbiAgICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuX3VubW91bnRDaGlsZEJ5TmFtZShwcmV2Q2hpbGQsIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgICB2YXIgbmV4dENoaWxkSW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KFxuICAgICAgICAgICAgbmV4dEVsZW1lbnQsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLl9tb3VudENoaWxkQnlOYW1lQXRJbmRleChcbiAgICAgICAgICAgIG5leHRDaGlsZEluc3RhbmNlLCBuYW1lLCBuZXh0SW5kZXgsIHRyYW5zYWN0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBjaGlsZHJlbiB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudC5cbiAgICAgIGZvciAobmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJlxuICAgICAgICAgICAgIShuZXh0Q2hpbGRyZW4gJiYgbmV4dENoaWxkcmVuW25hbWVdKSkge1xuICAgICAgICAgIHRoaXMuX3VubW91bnRDaGlsZEJ5TmFtZShwcmV2Q2hpbGRyZW5bbmFtZV0sIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgICAqIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdW5tb3VudENoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZW5kZXJlZENoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcmVuZGVyZWRDaGlsZHJlbikge1xuICAgICAgICB2YXIgcmVuZGVyZWRDaGlsZCA9IHJlbmRlcmVkQ2hpbGRyZW5bbmFtZV07XG4gICAgICAgIC8vIFRPRE86IFdoZW4gaXMgdGhpcyBub3QgdHJ1ZT9cbiAgICAgICAgaWYgKHJlbmRlcmVkQ2hpbGQudW5tb3VudENvbXBvbmVudCkge1xuICAgICAgICAgIHJlbmRlcmVkQ2hpbGQudW5tb3VudENvbXBvbmVudCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYSBjaGlsZCBjb21wb25lbnQgdG8gdGhlIHN1cHBsaWVkIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhc3RJbmRleCBMYXN0IGluZGV4IHZpc2l0ZWQgb2YgdGhlIHNpYmxpbmdzIG9mIGBjaGlsZGAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG1vdmVDaGlsZDogZnVuY3Rpb24oY2hpbGQsIHRvSW5kZXgsIGxhc3RJbmRleCkge1xuICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIGBjaGlsZGAgaXMgbGVzcyB0aGFuIGBsYXN0SW5kZXhgLCB0aGVuIGl0IG5lZWRzIHRvXG4gICAgICAvLyBiZSBtb3ZlZC4gT3RoZXJ3aXNlLCB3ZSBkbyBub3QgbmVlZCB0byBtb3ZlIGl0IGJlY2F1c2UgYSBjaGlsZCB3aWxsIGJlXG4gICAgICAvLyBpbnNlcnRlZCBvciBtb3ZlZCBiZWZvcmUgYGNoaWxkYC5cbiAgICAgIGlmIChjaGlsZC5fbW91bnRJbmRleCA8IGxhc3RJbmRleCkge1xuICAgICAgICBlbnF1ZXVlTW92ZSh0aGlzLl9yb290Tm9kZUlELCBjaGlsZC5fbW91bnRJbmRleCwgdG9JbmRleCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gY3JlYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb3VudEltYWdlIE1hcmt1cCB0byBpbnNlcnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNyZWF0ZUNoaWxkOiBmdW5jdGlvbihjaGlsZCwgbW91bnRJbWFnZSkge1xuICAgICAgZW5xdWV1ZU1hcmt1cCh0aGlzLl9yb290Tm9kZUlELCBtb3VudEltYWdlLCBjaGlsZC5fbW91bnRJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDaGlsZCB0byByZW1vdmUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgZW5xdWV1ZVJlbW92ZSh0aGlzLl9yb290Tm9kZUlELCBjaGlsZC5fbW91bnRJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhpcyB0ZXh0IGNvbnRlbnQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRDb250ZW50IFRleHQgY29udGVudCB0byBzZXQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHNldFRleHRDb250ZW50OiBmdW5jdGlvbih0ZXh0Q29udGVudCkge1xuICAgICAgZW5xdWV1ZVRleHRDb250ZW50KHRoaXMuX3Jvb3ROb2RlSUQsIHRleHRDb250ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW91bnRzIGEgY2hpbGQgd2l0aCB0aGUgc3VwcGxpZWQgbmFtZS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgcGFydCBvZiBgdXBkYXRlQ2hpbGRyZW5gIGFuZCBpcyBoZXJlIGZvciByZWFkYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbW91bnRDaGlsZEJ5TmFtZUF0SW5kZXg6IGZ1bmN0aW9uKGNoaWxkLCBuYW1lLCBpbmRleCwgdHJhbnNhY3Rpb24pIHtcbiAgICAgIC8vIElubGluZWQgZm9yIHBlcmZvcm1hbmNlLCBzZWUgYFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0SURgLlxuICAgICAgdmFyIHJvb3RJRCA9IHRoaXMuX3Jvb3ROb2RlSUQgKyBuYW1lO1xuICAgICAgdmFyIG1vdW50SW1hZ2UgPSBjaGlsZC5tb3VudENvbXBvbmVudChcbiAgICAgICAgcm9vdElELFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgdGhpcy5fbW91bnREZXB0aCArIDFcbiAgICAgICk7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4O1xuICAgICAgdGhpcy5jcmVhdGVDaGlsZChjaGlsZCwgbW91bnRJbWFnZSk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiB8fCB7fTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW5bbmFtZV0gPSBjaGlsZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5tb3VudHMgYSByZW5kZXJlZCBjaGlsZCBieSBuYW1lLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBwYXJ0IG9mIGB1cGRhdGVDaGlsZHJlbmAgYW5kIGlzIGhlcmUgZm9yIHJlYWRhYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIHVubW91bnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgY2hpbGQgaW4gYHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW5gLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VubW91bnRDaGlsZEJ5TmFtZTogZnVuY3Rpb24oY2hpbGQsIG5hbWUpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBudWxsO1xuICAgICAgY2hpbGQudW5tb3VudENvbXBvbmVudCgpO1xuICAgICAgZGVsZXRlIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW5bbmFtZV07XG4gICAgfVxuXG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE11bHRpQ2hpbGQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXNcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoXCIuL2tleU1pcnJvclwiKTtcblxuLyoqXG4gKiBXaGVuIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYXJlIHVwZGF0ZWQsIGEgc2VyaWVzIG9mIHVwZGF0ZSBjb25maWd1cmF0aW9uXG4gKiBvYmplY3RzIGFyZSBjcmVhdGVkIGluIG9yZGVyIHRvIGJhdGNoIGFuZCBzZXJpYWxpemUgdGhlIHJlcXVpcmVkIGNoYW5nZXMuXG4gKlxuICogRW51bWVyYXRlcyBhbGwgdGhlIHBvc3NpYmxlIHR5cGVzIG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0ga2V5TWlycm9yKHtcbiAgSU5TRVJUX01BUktVUDogbnVsbCxcbiAgTU9WRV9FWElTVElORzogbnVsbCxcbiAgUkVNT1ZFX05PREU6IG51bGwsXG4gIFRFWFRfQ09OVEVOVDogbnVsbFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXM7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE5hdGl2ZUNvbXBvbmVudFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbnZhciBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBudWxsO1xuLy8gVGhpcyByZWdpc3RyeSBrZWVwcyB0cmFjayBvZiB3cmFwcGVyIGNsYXNzZXMgYXJvdW5kIG5hdGl2ZSB0YWdzXG52YXIgdGFnVG9Db21wb25lbnRDbGFzcyA9IHt9O1xuXG52YXIgUmVhY3ROYXRpdmVDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIC8vIFRoaXMgYWNjZXB0cyBhIGNsYXNzIHRoYXQgcmVjZWl2ZXMgdGhlIHRhZyBzdHJpbmcuIFRoaXMgaXMgYSBjYXRjaCBhbGxcbiAgLy8gdGhhdCBjYW4gcmVuZGVyIGFueSBraW5kIG9mIHRhZy5cbiAgaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzOiBmdW5jdGlvbihjb21wb25lbnRDbGFzcykge1xuICAgIGdlbmVyaWNDb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudENsYXNzO1xuICB9LFxuICAvLyBUaGlzIGFjY2VwdHMgYSBrZXllZCBvYmplY3Qgd2l0aCBjbGFzc2VzIGFzIHZhbHVlcy4gRWFjaCBrZXkgcmVwcmVzZW50cyBhXG4gIC8vIHRhZy4gVGhhdCBwYXJ0aWN1bGFyIHRhZyB3aWxsIHVzZSB0aGlzIGNsYXNzIGluc3RlYWQgb2YgdGhlIGdlbmVyaWMgb25lLlxuICBpbmplY3RDb21wb25lbnRDbGFzc2VzOiBmdW5jdGlvbihjb21wb25lbnRDbGFzc2VzKSB7XG4gICAgYXNzaWduKHRhZ1RvQ29tcG9uZW50Q2xhc3MsIGNvbXBvbmVudENsYXNzZXMpO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnRlcm5hbCBjbGFzcyBmb3IgYSBzcGVjaWZpYyB0YWcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgdGFnIGZvciB3aGljaCB0byBjcmVhdGUgYW4gaW50ZXJuYWwgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge2FueX0gcHJvcHMgVGhlIHByb3BzIHBhc3NlZCB0byB0aGUgaW5zdGFuY2UgY29uc3RydWN0b3IuXG4gKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IFRoZSBpbmplY3RlZCBlbXB0eSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlRm9yVGFnKHRhZywgcHJvcHMsIHBhcmVudFR5cGUpIHtcbiAgdmFyIGNvbXBvbmVudENsYXNzID0gdGFnVG9Db21wb25lbnRDbGFzc1t0YWddO1xuICBpZiAoY29tcG9uZW50Q2xhc3MgPT0gbnVsbCkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBnZW5lcmljQ29tcG9uZW50Q2xhc3MsXG4gICAgICAnVGhlcmUgaXMgbm8gcmVnaXN0ZXJlZCBjb21wb25lbnQgZm9yIHRoZSB0YWcgJXMnLFxuICAgICAgdGFnXG4gICAgKSA6IGludmFyaWFudChnZW5lcmljQ29tcG9uZW50Q2xhc3MpKTtcbiAgICByZXR1cm4gbmV3IGdlbmVyaWNDb21wb25lbnRDbGFzcyh0YWcsIHByb3BzKTtcbiAgfVxuICBpZiAocGFyZW50VHlwZSA9PT0gdGFnKSB7XG4gICAgLy8gQXZvaWQgcmVjdXJzaW9uXG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIGdlbmVyaWNDb21wb25lbnRDbGFzcyxcbiAgICAgICdUaGVyZSBpcyBubyByZWdpc3RlcmVkIGNvbXBvbmVudCBmb3IgdGhlIHRhZyAlcycsXG4gICAgICB0YWdcbiAgICApIDogaW52YXJpYW50KGdlbmVyaWNDb21wb25lbnRDbGFzcykpO1xuICAgIHJldHVybiBuZXcgZ2VuZXJpY0NvbXBvbmVudENsYXNzKHRhZywgcHJvcHMpO1xuICB9XG4gIC8vIFVud3JhcCBsZWdhY3kgZmFjdG9yaWVzXG4gIHJldHVybiBuZXcgY29tcG9uZW50Q2xhc3MudHlwZShwcm9wcyk7XG59XG5cbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudCA9IHtcbiAgY3JlYXRlSW5zdGFuY2VGb3JUYWc6IGNyZWF0ZUluc3RhbmNlRm9yVGFnLFxuICBpbmplY3Rpb246IFJlYWN0TmF0aXZlQ29tcG9uZW50SW5qZWN0aW9uLFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5hdGl2ZUNvbXBvbmVudDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE93bmVyXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoXCIuL2VtcHR5T2JqZWN0XCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBSZWFjdE93bmVycyBhcmUgY2FwYWJsZSBvZiBzdG9yaW5nIHJlZmVyZW5jZXMgdG8gb3duZWQgY29tcG9uZW50cy5cbiAqXG4gKiBBbGwgY29tcG9uZW50cyBhcmUgY2FwYWJsZSBvZiAvL2JlaW5nLy8gcmVmZXJlbmNlZCBieSBvd25lciBjb21wb25lbnRzLCBidXRcbiAqIG9ubHkgUmVhY3RPd25lciBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vcmVmZXJlbmNpbmcvLyBvd25lZCBjb21wb25lbnRzLlxuICogVGhlIG5hbWVkIHJlZmVyZW5jZSBpcyBrbm93biBhcyBhIFwicmVmXCIuXG4gKlxuICogUmVmcyBhcmUgYXZhaWxhYmxlIHdoZW4gbW91bnRlZCBhbmQgdXBkYXRlZCBkdXJpbmcgcmVjb25jaWxpYXRpb24uXG4gKlxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiAoXG4gKiAgICAgICAgIDxkaXYgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja30+XG4gKiAgICAgICAgICAgPEN1c3RvbUNvbXBvbmVudCByZWY9XCJjdXN0b21cIiAvPlxuICogICAgICAgICA8L2Rpdj5cbiAqICAgICAgICk7XG4gKiAgICAgfSxcbiAqICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmhhbmRsZUNsaWNrKCk7XG4gKiAgICAgfSxcbiAqICAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmluaXRpYWxpemUoKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFJlZnMgc2hvdWxkIHJhcmVseSBiZSB1c2VkLiBXaGVuIHJlZnMgYXJlIHVzZWQsIHRoZXkgc2hvdWxkIG9ubHkgYmUgZG9uZSB0b1xuICogY29udHJvbCBkYXRhIHRoYXQgaXMgbm90IGhhbmRsZWQgYnkgUmVhY3QncyBkYXRhIGZsb3cuXG4gKlxuICogQGNsYXNzIFJlYWN0T3duZXJcbiAqL1xudmFyIFJlYWN0T3duZXIgPSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBvd25lci5cbiAgICogQGZpbmFsXG4gICAqL1xuICBpc1ZhbGlkT3duZXI6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiAhIShcbiAgICAgIG9iamVjdCAmJlxuICAgICAgdHlwZW9mIG9iamVjdC5hdHRhY2hSZWYgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBvYmplY3QuZGV0YWNoUmVmID09PSAnZnVuY3Rpb24nXG4gICAgKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyBhIGNvbXBvbmVudCBieSByZWYgdG8gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIHJlZmVyZW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIGJ5IHdoaWNoIHRvIHJlZmVyIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRvIHJlY29yZCB0aGUgcmVmLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhZGRDb21wb25lbnRBc1JlZlRvOiBmdW5jdGlvbihjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgUmVhY3RPd25lci5pc1ZhbGlkT3duZXIob3duZXIpLFxuICAgICAgJ2FkZENvbXBvbmVudEFzUmVmVG8oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gVGhpcyAnICtcbiAgICAgICd1c3VhbGx5IG1lYW5zIHRoYXQgeW91XFwncmUgdHJ5aW5nIHRvIGFkZCBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0ICcgK1xuICAgICAgJ2RvZXNuXFwndCBoYXZlIGFuIG93bmVyICh0aGF0IGlzLCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIG9mIGFub3RoZXIgJyArXG4gICAgICAnY29tcG9uZW50XFwncyBgcmVuZGVyYCBtZXRob2QpLiBUcnkgcmVuZGVyaW5nIHRoaXMgY29tcG9uZW50IGluc2lkZSBvZiAnICtcbiAgICAgICdhIG5ldyB0b3AtbGV2ZWwgY29tcG9uZW50IHdoaWNoIHdpbGwgaG9sZCB0aGUgcmVmLidcbiAgICApIDogaW52YXJpYW50KFJlYWN0T3duZXIuaXNWYWxpZE93bmVyKG93bmVyKSkpO1xuICAgIG93bmVyLmF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjb21wb25lbnQgYnkgcmVmIGZyb20gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgb2YgdGhlIHJlZiB0byByZW1vdmUuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRoZSByZWYgaXMgcmVjb3JkZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbTogZnVuY3Rpb24oY29tcG9uZW50LCByZWYsIG93bmVyKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIFJlYWN0T3duZXIuaXNWYWxpZE93bmVyKG93bmVyKSxcbiAgICAgICdyZW1vdmVDb21wb25lbnRBc1JlZkZyb20oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gVGhpcyAnICtcbiAgICAgICd1c3VhbGx5IG1lYW5zIHRoYXQgeW91XFwncmUgdHJ5aW5nIHRvIHJlbW92ZSBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0ICcgK1xuICAgICAgJ2RvZXNuXFwndCBoYXZlIGFuIG93bmVyICh0aGF0IGlzLCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIG9mIGFub3RoZXIgJyArXG4gICAgICAnY29tcG9uZW50XFwncyBgcmVuZGVyYCBtZXRob2QpLiBUcnkgcmVuZGVyaW5nIHRoaXMgY29tcG9uZW50IGluc2lkZSBvZiAnICtcbiAgICAgICdhIG5ldyB0b3AtbGV2ZWwgY29tcG9uZW50IHdoaWNoIHdpbGwgaG9sZCB0aGUgcmVmLidcbiAgICApIDogaW52YXJpYW50KFJlYWN0T3duZXIuaXNWYWxpZE93bmVyKG93bmVyKSkpO1xuICAgIC8vIENoZWNrIHRoYXQgYGNvbXBvbmVudGAgaXMgc3RpbGwgdGhlIGN1cnJlbnQgcmVmIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG9cbiAgICAvLyBkZXRhY2ggdGhlIHJlZiBpZiBhbm90aGVyIGNvbXBvbmVudCBzdG9sZSBpdC5cbiAgICBpZiAob3duZXIucmVmc1tyZWZdID09PSBjb21wb25lbnQpIHtcbiAgICAgIG93bmVyLmRldGFjaFJlZihyZWYpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQSBSZWFjdENvbXBvbmVudCBtdXN0IG1peCB0aGlzIGluIHRvIGhhdmUgcmVmcy5cbiAgICpcbiAgICogQGxlbmRzIHtSZWFjdE93bmVyLnByb3RvdHlwZX1cbiAgICovXG4gIE1peGluOiB7XG5cbiAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExhemlseSBhbGxvY2F0ZXMgdGhlIHJlZnMgb2JqZWN0IGFuZCBzdG9yZXMgYGNvbXBvbmVudGAgYXMgYHJlZmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIFJlZmVyZW5jZSBuYW1lLlxuICAgICAqIEBwYXJhbSB7Y29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIHN0b3JlIGFzIGByZWZgLlxuICAgICAqIEBmaW5hbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXR0YWNoUmVmOiBmdW5jdGlvbihyZWYsIGNvbXBvbmVudCkge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgY29tcG9uZW50LmlzT3duZWRCeSh0aGlzKSxcbiAgICAgICAgJ2F0dGFjaFJlZiglcywgLi4uKTogT25seSBhIGNvbXBvbmVudFxcJ3Mgb3duZXIgY2FuIHN0b3JlIGEgcmVmIHRvIGl0LicsXG4gICAgICAgIHJlZlxuICAgICAgKSA6IGludmFyaWFudChjb21wb25lbnQuaXNPd25lZEJ5KHRoaXMpKSk7XG4gICAgICB2YXIgcmVmcyA9IHRoaXMucmVmcyA9PT0gZW1wdHlPYmplY3QgPyAodGhpcy5yZWZzID0ge30pIDogdGhpcy5yZWZzO1xuICAgICAgcmVmc1tyZWZdID0gY29tcG9uZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2hlcyBhIHJlZmVyZW5jZSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIHRvIGRlcmVmZXJlbmNlLlxuICAgICAqIEBmaW5hbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGV0YWNoUmVmOiBmdW5jdGlvbihyZWYpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbcmVmXTtcbiAgICB9XG5cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0T3duZXI7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQZXJmXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFJlYWN0UGVyZiBpcyBhIGdlbmVyYWwgQU9QIHN5c3RlbSBkZXNpZ25lZCB0byBtZWFzdXJlIHBlcmZvcm1hbmNlLiBUaGlzXG4gKiBtb2R1bGUgb25seSBoYXMgdGhlIGhvb2tzOiBzZWUgUmVhY3REZWZhdWx0UGVyZiBmb3IgdGhlIGFuYWx5c2lzIHRvb2wuXG4gKi9cbnZhciBSZWFjdFBlcmYgPSB7XG4gIC8qKlxuICAgKiBCb29sZWFuIHRvIGVuYWJsZS9kaXNhYmxlIG1lYXN1cmVtZW50LiBTZXQgdG8gZmFsc2UgYnkgZGVmYXVsdCB0byBwcmV2ZW50XG4gICAqIGFjY2lkZW50YWwgbG9nZ2luZyBhbmQgcGVyZiBsb3NzLlxuICAgKi9cbiAgZW5hYmxlTWVhc3VyZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEhvbGRzIG9udG8gdGhlIG1lYXN1cmUgZnVuY3Rpb24gaW4gdXNlLiBCeSBkZWZhdWx0LCBkb24ndCBtZWFzdXJlXG4gICAqIGFueXRoaW5nLCBidXQgd2UnbGwgb3ZlcnJpZGUgdGhpcyBpZiB3ZSBpbmplY3QgYSBtZWFzdXJlIGZ1bmN0aW9uLlxuICAgKi9cbiAgc3RvcmVkTWVhc3VyZTogX25vTWVhc3VyZSxcblxuICAvKipcbiAgICogVXNlIHRoaXMgdG8gd3JhcCBtZXRob2RzIHlvdSB3YW50IHRvIG1lYXN1cmUuIFplcm8gb3ZlcmhlYWQgaW4gcHJvZHVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9iak5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICAgKi9cbiAgbWVhc3VyZTogZnVuY3Rpb24ob2JqTmFtZSwgZm5OYW1lLCBmdW5jKSB7XG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgdmFyIG1lYXN1cmVkRnVuYyA9IG51bGw7XG4gICAgICB2YXIgd3JhcHBlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoUmVhY3RQZXJmLmVuYWJsZU1lYXN1cmUpIHtcbiAgICAgICAgICBpZiAoIW1lYXN1cmVkRnVuYykge1xuICAgICAgICAgICAgbWVhc3VyZWRGdW5jID0gUmVhY3RQZXJmLnN0b3JlZE1lYXN1cmUob2JqTmFtZSwgZm5OYW1lLCBmdW5jKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lYXN1cmVkRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgd3JhcHBlci5kaXNwbGF5TmFtZSA9IG9iak5hbWUgKyAnXycgKyBmbk5hbWU7XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWVhc3VyZVxuICAgICAqL1xuICAgIGluamVjdE1lYXN1cmU6IGZ1bmN0aW9uKG1lYXN1cmUpIHtcbiAgICAgIFJlYWN0UGVyZi5zdG9yZWRNZWFzdXJlID0gbWVhc3VyZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU2ltcGx5IHBhc3NlcyB0aHJvdWdoIHRoZSBtZWFzdXJlZCBmdW5jdGlvbiwgd2l0aG91dCBtZWFzdXJpbmcgaXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG9iak5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBfbm9NZWFzdXJlKG9iak5hbWUsIGZuTmFtZSwgZnVuYykge1xuICByZXR1cm4gZnVuYztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFBlcmY7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHJhbnNmZXJlclxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIgam9pbkNsYXNzZXMgPSByZXF1aXJlKFwiLi9qb2luQ2xhc3Nlc1wiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxudmFyIGRpZFdhcm4gPSBmYWxzZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNmZXIgc3RyYXRlZ3kgdGhhdCB3aWxsIG1lcmdlIHByb3AgdmFsdWVzIHVzaW5nIHRoZSBzdXBwbGllZFxuICogYG1lcmdlU3RyYXRlZ3lgLiBJZiBhIHByb3Agd2FzIHByZXZpb3VzbHkgdW5zZXQsIHRoaXMganVzdCBzZXRzIGl0LlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1lcmdlU3RyYXRlZ3lcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2ZlclN0cmF0ZWd5KG1lcmdlU3RyYXRlZ3kpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3BzLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BzW2tleV0gPSBtZXJnZVN0cmF0ZWd5KHByb3BzW2tleV0sIHZhbHVlKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciB0cmFuc2ZlclN0cmF0ZWd5TWVyZ2UgPSBjcmVhdGVUcmFuc2ZlclN0cmF0ZWd5KGZ1bmN0aW9uKGEsIGIpIHtcbiAgLy8gYG1lcmdlYCBvdmVycmlkZXMgdGhlIGZpcnN0IG9iamVjdCdzIChgcHJvcHNba2V5XWAgYWJvdmUpIGtleXMgdXNpbmcgdGhlXG4gIC8vIHNlY29uZCBvYmplY3QncyAoYHZhbHVlYCkga2V5cy4gQW4gb2JqZWN0J3Mgc3R5bGUncyBleGlzdGluZyBgcHJvcEFgIHdvdWxkXG4gIC8vIGdldCBvdmVycmlkZGVuLiBGbGlwIHRoZSBvcmRlciBoZXJlLlxuICByZXR1cm4gYXNzaWduKHt9LCBiLCBhKTtcbn0pO1xuXG4vKipcbiAqIFRyYW5zZmVyIHN0cmF0ZWdpZXMgZGljdGF0ZSBob3cgcHJvcHMgYXJlIHRyYW5zZmVycmVkIGJ5IGB0cmFuc2ZlclByb3BzVG9gLlxuICogTk9URTogaWYgeW91IGFkZCBhbnkgbW9yZSBleGNlcHRpb25zIHRvIHRoaXMgbGlzdCB5b3Ugc2hvdWxkIGJlIHN1cmUgdG9cbiAqIHVwZGF0ZSBgY2xvbmVXaXRoUHJvcHMoKWAgYWNjb3JkaW5nbHkuXG4gKi9cbnZhciBUcmFuc2ZlclN0cmF0ZWdpZXMgPSB7XG4gIC8qKlxuICAgKiBOZXZlciB0cmFuc2ZlciBgY2hpbGRyZW5gLlxuICAgKi9cbiAgY2hpbGRyZW46IGVtcHR5RnVuY3Rpb24sXG4gIC8qKlxuICAgKiBUcmFuc2ZlciB0aGUgYGNsYXNzTmFtZWAgcHJvcCBieSBtZXJnaW5nIHRoZW0uXG4gICAqL1xuICBjbGFzc05hbWU6IGNyZWF0ZVRyYW5zZmVyU3RyYXRlZ3koam9pbkNsYXNzZXMpLFxuICAvKipcbiAgICogVHJhbnNmZXIgdGhlIGBzdHlsZWAgcHJvcCAod2hpY2ggaXMgYW4gb2JqZWN0KSBieSBtZXJnaW5nIHRoZW0uXG4gICAqL1xuICBzdHlsZTogdHJhbnNmZXJTdHJhdGVneU1lcmdlXG59O1xuXG4vKipcbiAqIE11dGF0ZXMgdGhlIGZpcnN0IGFyZ3VtZW50IGJ5IHRyYW5zZmVycmluZyB0aGUgcHJvcGVydGllcyBmcm9tIHRoZSBzZWNvbmRcbiAqIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IG5ld1Byb3BzXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZmVySW50byhwcm9wcywgbmV3UHJvcHMpIHtcbiAgZm9yICh2YXIgdGhpc0tleSBpbiBuZXdQcm9wcykge1xuICAgIGlmICghbmV3UHJvcHMuaGFzT3duUHJvcGVydHkodGhpc0tleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2ZlclN0cmF0ZWd5ID0gVHJhbnNmZXJTdHJhdGVnaWVzW3RoaXNLZXldO1xuXG4gICAgaWYgKHRyYW5zZmVyU3RyYXRlZ3kgJiYgVHJhbnNmZXJTdHJhdGVnaWVzLmhhc093blByb3BlcnR5KHRoaXNLZXkpKSB7XG4gICAgICB0cmFuc2ZlclN0cmF0ZWd5KHByb3BzLCB0aGlzS2V5LCBuZXdQcm9wc1t0aGlzS2V5XSk7XG4gICAgfSBlbHNlIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkodGhpc0tleSkpIHtcbiAgICAgIHByb3BzW3RoaXNLZXldID0gbmV3UHJvcHNbdGhpc0tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wcztcbn1cblxuLyoqXG4gKiBSZWFjdFByb3BUcmFuc2ZlcmVyIGFyZSBjYXBhYmxlIG9mIHRyYW5zZmVycmluZyBwcm9wcyB0byBhbm90aGVyIGNvbXBvbmVudFxuICogdXNpbmcgYSBgdHJhbnNmZXJQcm9wc1RvYCBtZXRob2QuXG4gKlxuICogQGNsYXNzIFJlYWN0UHJvcFRyYW5zZmVyZXJcbiAqL1xudmFyIFJlYWN0UHJvcFRyYW5zZmVyZXIgPSB7XG5cbiAgVHJhbnNmZXJTdHJhdGVnaWVzOiBUcmFuc2ZlclN0cmF0ZWdpZXMsXG5cbiAgLyoqXG4gICAqIE1lcmdlIHR3byBwcm9wcyBvYmplY3RzIHVzaW5nIFRyYW5zZmVyU3RyYXRlZ2llcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9sZFByb3BzIG9yaWdpbmFsIHByb3BzICh0aGV5IHRha2UgcHJlY2VkZW5jZSlcbiAgICogQHBhcmFtIHtvYmplY3R9IG5ld1Byb3BzIG5ldyBwcm9wcyB0byBtZXJnZSBpblxuICAgKiBAcmV0dXJuIHtvYmplY3R9IGEgbmV3IG9iamVjdCBjb250YWluaW5nIGJvdGggc2V0cyBvZiBwcm9wcyBtZXJnZWQuXG4gICAqL1xuICBtZXJnZVByb3BzOiBmdW5jdGlvbihvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICByZXR1cm4gdHJhbnNmZXJJbnRvKGFzc2lnbih7fSwgb2xkUHJvcHMpLCBuZXdQcm9wcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBsZW5kcyB7UmVhY3RQcm9wVHJhbnNmZXJlci5wcm90b3R5cGV9XG4gICAqL1xuICBNaXhpbjoge1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNmZXIgcHJvcHMgZnJvbSB0aGlzIGNvbXBvbmVudCB0byBhIHRhcmdldCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBQcm9wcyB0aGF0IGRvIG5vdCBoYXZlIGFuIGV4cGxpY2l0IHRyYW5zZmVyIHN0cmF0ZWd5IHdpbGwgYmUgdHJhbnNmZXJyZWRcbiAgICAgKiBvbmx5IGlmIHRoZSB0YXJnZXQgY29tcG9uZW50IGRvZXMgbm90IGFscmVhZHkgaGF2ZSB0aGUgcHJvcCBzZXQuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzdWFsbHkgdXNlZCB0byBwYXNzIGRvd24gcHJvcHMgdG8gYSByZXR1cm5lZCByb290IGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IENvbXBvbmVudCByZWNlaXZpbmcgdGhlIHByb3BlcnRpZXMuXG4gICAgICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgc3VwcGxpZWQgYGNvbXBvbmVudGAuXG4gICAgICogQGZpbmFsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRyYW5zZmVyUHJvcHNUbzogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgZWxlbWVudC5fb3duZXIgPT09IHRoaXMsXG4gICAgICAgICclczogWW91IGNhblxcJ3QgY2FsbCB0cmFuc2ZlclByb3BzVG8oKSBvbiBhIGNvbXBvbmVudCB0aGF0IHlvdSAnICtcbiAgICAgICAgJ2RvblxcJ3Qgb3duLCAlcy4gVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBhcmUgY2FsbGluZyAnICtcbiAgICAgICAgJ3RyYW5zZmVyUHJvcHNUbygpIG9uIGEgY29tcG9uZW50IHBhc3NlZCBpbiBhcyBwcm9wcyBvciBjaGlsZHJlbi4nLFxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lLFxuICAgICAgICB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJyA/XG4gICAgICAgIGVsZW1lbnQudHlwZSA6XG4gICAgICAgIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZVxuICAgICAgKSA6IGludmFyaWFudChlbGVtZW50Ll9vd25lciA9PT0gdGhpcykpO1xuXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIGlmICghZGlkV2Fybikge1xuICAgICAgICAgIGRpZFdhcm4gPSB0cnVlO1xuICAgICAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAndHJhbnNmZXJQcm9wc1RvIGlzIGRlcHJlY2F0ZWQuICcgK1xuICAgICAgICAgICAgJ1NlZSBodHRwOi8vZmIubWUvcmVhY3QtdHJhbnNmZXJwcm9wc3RvIGZvciBtb3JlIGluZm9ybWF0aW9uLidcbiAgICAgICAgICApIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQmVjYXVzZSBlbGVtZW50cyBhcmUgaW1tdXRhYmxlIHdlIGhhdmUgdG8gbWVyZ2UgaW50byB0aGUgZXhpc3RpbmdcbiAgICAgIC8vIHByb3BzIG9iamVjdCByYXRoZXIgdGhhbiBjbG9uZSBpdC5cbiAgICAgIHRyYW5zZmVySW50byhlbGVtZW50LnByb3BzLCB0aGlzLnByb3BzKTtcblxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHJhbnNmZXJlcjtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7fTtcblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcbiAgICBwcm9wOiAncHJvcCcsXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXM7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlTG9jYXRpb25zXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKFwiLi9rZXlNaXJyb3JcIik7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0ga2V5TWlycm9yKHtcbiAgcHJvcDogbnVsbCxcbiAgY29udGV4dDogbnVsbCxcbiAgY2hpbGRDb250ZXh0OiBudWxsXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25zO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKFwiLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1wiKTtcblxudmFyIGRlcHJlY2F0ZWQgPSByZXF1aXJlKFwiLi9kZXByZWNhdGVkXCIpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICBwcm9wVHlwZXM6IHtcbiAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gKlxuICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICpcbiAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICogICAgIH0sXG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAqICAgfSk7XG4gKlxuICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICpcbiAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gKlxuICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICpcbiAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgcHJvcFR5cGVzOiB7XG4gKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gKiAgICAgICAgICApO1xuICogICAgICAgIH1cbiAqICAgICAgfVxuICogICAgfSxcbiAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICogIH0pO1xuICpcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbnZhciBlbGVtZW50VHlwZUNoZWNrZXIgPSBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKTtcbnZhciBub2RlVHlwZUNoZWNrZXIgPSBjcmVhdGVOb2RlQ2hlY2tlcigpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG5cbiAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gIGVsZW1lbnQ6IGVsZW1lbnRUeXBlQ2hlY2tlcixcbiAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgbm9kZTogbm9kZVR5cGVDaGVja2VyLFxuICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcblxuICBjb21wb25lbnQ6IGRlcHJlY2F0ZWQoXG4gICAgJ1JlYWN0LlByb3BUeXBlcycsXG4gICAgJ2NvbXBvbmVudCcsXG4gICAgJ2VsZW1lbnQnLFxuICAgIHRoaXMsXG4gICAgZWxlbWVudFR5cGVDaGVja2VyXG4gICksXG4gIHJlbmRlcmFibGU6IGRlcHJlY2F0ZWQoXG4gICAgJ1JlYWN0LlByb3BUeXBlcycsXG4gICAgJ3JlbmRlcmFibGUnLFxuICAgICdub2RlJyxcbiAgICB0aGlzLFxuICAgIG5vZGVUeXBlQ2hlY2tlclxuICApXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbikge1xuICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAgIChcIlJlcXVpcmVkIFwiICsgbG9jYXRpb25OYW1lICsgXCIgYFwiICsgcHJvcE5hbWUgKyBcImAgd2FzIG5vdCBzcGVjaWZpZWQgaW4gXCIpK1xuICAgICAgICAgIChcImBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAuXCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgIChcIkludmFsaWQgXCIgKyBsb2NhdGlvbk5hbWUgKyBcIiBgXCIgKyBwcm9wTmFtZSArIFwiYCBvZiB0eXBlIGBcIiArIHByZWNpc2VUeXBlICsgXCJgIFwiKSArXG4gICAgICAgIChcInN1cHBsaWVkIHRvIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGBcIiArIGV4cGVjdGVkVHlwZSArIFwiYC5cIilcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucygpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgIChcIkludmFsaWQgXCIgKyBsb2NhdGlvbk5hbWUgKyBcIiBgXCIgKyBwcm9wTmFtZSArIFwiYCBvZiB0eXBlIFwiKSArXG4gICAgICAgIChcImBcIiArIHByb3BUeXBlICsgXCJgIHN1cHBsaWVkIHRvIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGFuIGFycmF5LlwiKVxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pIHtcbiAgICBpZiAoIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgKFwiSW52YWxpZCBcIiArIGxvY2F0aW9uTmFtZSArIFwiIGBcIiArIHByb3BOYW1lICsgXCJgIHN1cHBsaWVkIHRvIFwiKSArXG4gICAgICAgIChcImBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGEgUmVhY3RFbGVtZW50LlwiKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pIHtcbiAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAoXCJJbnZhbGlkIFwiICsgbG9jYXRpb25OYW1lICsgXCIgYFwiICsgcHJvcE5hbWUgKyBcImAgc3VwcGxpZWQgdG8gXCIpICtcbiAgICAgICAgKFwiYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCwgZXhwZWN0ZWQgaW5zdGFuY2Ugb2YgYFwiICsgZXhwZWN0ZWRDbGFzc05hbWUgKyBcImAuXCIpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbikge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gZXhwZWN0ZWRWYWx1ZXNbaV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgKFwiSW52YWxpZCBcIiArIGxvY2F0aW9uTmFtZSArIFwiIGBcIiArIHByb3BOYW1lICsgXCJgIG9mIHZhbHVlIGBcIiArIHByb3BWYWx1ZSArIFwiYCBcIikgK1xuICAgICAgKFwic3VwcGxpZWQgdG8gYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCwgZXhwZWN0ZWQgb25lIG9mIFwiICsgdmFsdWVzU3RyaW5nICsgXCIuXCIpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgIChcIkludmFsaWQgXCIgKyBsb2NhdGlvbk5hbWUgKyBcIiBgXCIgKyBwcm9wTmFtZSArIFwiYCBvZiB0eXBlIFwiKSArXG4gICAgICAgIChcImBcIiArIHByb3BUeXBlICsgXCJgIHN1cHBsaWVkIHRvIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGFuIG9iamVjdC5cIilcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbikgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgKFwiSW52YWxpZCBcIiArIGxvY2F0aW9uTmFtZSArIFwiIGBcIiArIHByb3BOYW1lICsgXCJgIHN1cHBsaWVkIHRvIFwiKSArXG4gICAgICAoXCJgXCIgKyBjb21wb25lbnROYW1lICsgXCJgLlwiKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pIHtcbiAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgKFwiSW52YWxpZCBcIiArIGxvY2F0aW9uTmFtZSArIFwiIGBcIiArIHByb3BOYW1lICsgXCJgIHN1cHBsaWVkIHRvIFwiKSArXG4gICAgICAgIChcImBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLlwiKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgIChcIkludmFsaWQgXCIgKyBsb2NhdGlvbk5hbWUgKyBcIiBgXCIgKyBwcm9wTmFtZSArIFwiYCBvZiB0eXBlIGBcIiArIHByb3BUeXBlICsgXCJgIFwiKSArXG4gICAgICAgIChcInN1cHBsaWVkIHRvIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGBvYmplY3RgLlwiKVxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlLCAnZXhwZWN0ZWQgYG9iamVjdGAnKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICBzd2l0Y2godHlwZW9mIHByb3BWYWx1ZSkge1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgayBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc05vZGUocHJvcFZhbHVlW2tdKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG5mdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgIHJldHVybiAnYXJyYXknO1xuICB9XG4gIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgcmV0dXJuICdvYmplY3QnO1xuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cblxuLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG5mdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gJ2RhdGUnO1xuICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlcztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFB1dExpc3RlbmVyUXVldWVcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZShcIi4vUG9vbGVkQ2xhc3NcIik7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcIi4vT2JqZWN0LmFzc2lnblwiKTtcblxuZnVuY3Rpb24gUmVhY3RQdXRMaXN0ZW5lclF1ZXVlKCkge1xuICB0aGlzLmxpc3RlbmVyc1RvUHV0ID0gW107XG59XG5cbmFzc2lnbihSZWFjdFB1dExpc3RlbmVyUXVldWUucHJvdG90eXBlLCB7XG4gIGVucXVldWVQdXRMaXN0ZW5lcjogZnVuY3Rpb24ocm9vdE5vZGVJRCwgcHJvcEtleSwgcHJvcFZhbHVlKSB7XG4gICAgdGhpcy5saXN0ZW5lcnNUb1B1dC5wdXNoKHtcbiAgICAgIHJvb3ROb2RlSUQ6IHJvb3ROb2RlSUQsXG4gICAgICBwcm9wS2V5OiBwcm9wS2V5LFxuICAgICAgcHJvcFZhbHVlOiBwcm9wVmFsdWVcbiAgICB9KTtcbiAgfSxcblxuICBwdXRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0ZW5lcnNUb1B1dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmVyVG9QdXQgPSB0aGlzLmxpc3RlbmVyc1RvUHV0W2ldO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnB1dExpc3RlbmVyKFxuICAgICAgICBsaXN0ZW5lclRvUHV0LnJvb3ROb2RlSUQsXG4gICAgICAgIGxpc3RlbmVyVG9QdXQucHJvcEtleSxcbiAgICAgICAgbGlzdGVuZXJUb1B1dC5wcm9wVmFsdWVcbiAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmxpc3RlbmVyc1RvUHV0Lmxlbmd0aCA9IDA7XG4gIH0sXG5cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0UHV0TGlzdGVuZXJRdWV1ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQdXRMaXN0ZW5lclF1ZXVlO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZShcIi4vQ2FsbGJhY2tRdWV1ZVwiKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoXCIuL1Bvb2xlZENsYXNzXCIpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlclwiKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZShcIi4vUmVhY3RJbnB1dFNlbGVjdGlvblwiKTtcbnZhciBSZWFjdFB1dExpc3RlbmVyUXVldWUgPSByZXF1aXJlKFwiLi9SZWFjdFB1dExpc3RlbmVyUXVldWVcIik7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKFwiLi9UcmFuc2FjdGlvblwiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG5cbi8qKlxuICogRW5zdXJlcyB0aGF0LCB3aGVuIHBvc3NpYmxlLCB0aGUgc2VsZWN0aW9uIHJhbmdlIChjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dFxuICogaW5wdXQpIGlzIG5vdCBkaXN0dXJiZWQgYnkgcGVyZm9ybWluZyB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBTRUxFQ1RJT05fUkVTVE9SQVRJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFNlbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24sXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NlbGVjdGlvbn0gc2VsIFNlbGVjdGlvbiBpbmZvcm1hdGlvbiByZXR1cm5lZCBmcm9tIGBpbml0aWFsaXplYC5cbiAgICovXG4gIGNsb3NlOiBSZWFjdElucHV0U2VsZWN0aW9uLnJlc3RvcmVTZWxlY3Rpb25cbn07XG5cbi8qKlxuICogU3VwcHJlc3NlcyBldmVudHMgKGJsdXIvZm9jdXMpIHRoYXQgY291bGQgYmUgaW5hZHZlcnRlbnRseSBkaXNwYXRjaGVkIGR1ZSB0b1xuICogaGlnaCBsZXZlbCBET00gbWFuaXB1bGF0aW9ucyAobGlrZSB0ZW1wb3JhcmlseSByZW1vdmluZyBhIHRleHQgaW5wdXQgZnJvbSB0aGVcbiAqIERPTSkuXG4gKi9cbnZhciBFVkVOVF9TVVBQUkVTU0lPTiA9IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBlbmFibGVkIHN0YXR1cyBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmVcbiAgICogdGhlIHJlY29uY2lsaWF0aW9uLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1cnJlbnRseUVuYWJsZWQgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaXNFbmFibGVkKCk7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnNldEVuYWJsZWQoZmFsc2UpO1xuICAgIHJldHVybiBjdXJyZW50bHlFbmFibGVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByZXZpb3VzbHlFbmFibGVkIEVuYWJsZWQgc3RhdHVzIG9mXG4gICAqICAgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlIHRoZSByZWNvbmNpbGlhdGlvbiBvY2N1cmVkLiBgY2xvc2VgXG4gICAqICAgcmVzdG9yZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uKHByZXZpb3VzbHlFbmFibGVkKSB7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnNldEVuYWJsZWQocHJldmlvdXNseUVuYWJsZWQpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgcXVldWUgZm9yIGNvbGxlY3RpbmcgYGNvbXBvbmVudERpZE1vdW50YCBhbmRcbiAqIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBkdXJpbmcgdGhlIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIE9OX0RPTV9SRUFEWV9RVUVVRUlORyA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBgb25ET01SZWFkeWAgcXVldWUuXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yZXNldCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZnRlciBET00gaXMgZmx1c2hlZCwgaW52b2tlIGFsbCByZWdpc3RlcmVkIGBvbkRPTVJlYWR5YCBjYWxsYmFja3MuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbnZhciBQVVRfTElTVEVORVJfUVVFVUVJTkcgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucHV0TGlzdGVuZXJRdWV1ZS5yZXNldCgpO1xuICB9LFxuXG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnB1dExpc3RlbmVyUXVldWUucHV0TGlzdGVuZXJzKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhlY3V0ZWQgd2l0aGluIHRoZSBzY29wZSBvZiB0aGUgYFRyYW5zYWN0aW9uYCBpbnN0YW5jZS4gQ29uc2lkZXIgdGhlc2UgYXNcbiAqIGJlaW5nIG1lbWJlciBtZXRob2RzLCBidXQgd2l0aCBhbiBpbXBsaWVkIG9yZGVyaW5nIHdoaWxlIGJlaW5nIGlzb2xhdGVkIGZyb21cbiAqIGVhY2ggb3RoZXIuXG4gKi9cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtcbiAgUFVUX0xJU1RFTkVSX1FVRVVFSU5HLFxuICBTRUxFQ1RJT05fUkVTVE9SQVRJT04sXG4gIEVWRU5UX1NVUFBSRVNTSU9OLFxuICBPTl9ET01fUkVBRFlfUVVFVUVJTkdcbl07XG5cbi8qKlxuICogQ3VycmVudGx5OlxuICogLSBUaGUgb3JkZXIgdGhhdCB0aGVzZSBhcmUgbGlzdGVkIGluIHRoZSB0cmFuc2FjdGlvbiBpcyBjcml0aWNhbDpcbiAqIC0gU3VwcHJlc3NlcyBldmVudHMuXG4gKiAtIFJlc3RvcmVzIHNlbGVjdGlvbiByYW5nZS5cbiAqXG4gKiBGdXR1cmU6XG4gKiAtIFJlc3RvcmUgZG9jdW1lbnQvb3ZlcmZsb3cgc2Nyb2xsIHBvc2l0aW9ucyB0aGF0IHdlcmUgdW5pbnRlbnRpb25hbGx5XG4gKiAgIG1vZGlmaWVkIHZpYSBET00gaW5zZXJ0aW9ucyBhYm92ZSB0aGUgdG9wIHZpZXdwb3J0IGJvdW5kYXJ5LlxuICogLSBJbXBsZW1lbnQvaW50ZWdyYXRlIHdpdGggY3VzdG9taXplZCBjb25zdHJhaW50IGJhc2VkIGxheW91dCBzeXN0ZW0gYW5kIGtlZXBcbiAqICAgdHJhY2sgb2Ygd2hpY2ggZGltZW5zaW9ucyBtdXN0IGJlIHJlbWVhc3VyZWQuXG4gKlxuICogQGNsYXNzIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cbiAqL1xuZnVuY3Rpb24gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICAvLyBPbmx5IHNlcnZlci1zaWRlIHJlbmRlcmluZyByZWFsbHkgbmVlZHMgdGhpcyBvcHRpb24gKHNlZVxuICAvLyBgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdgKSwgYnV0IHNlcnZlci1zaWRlIHVzZXNcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25gIGluc3RlYWQuIFRoaXMgb3B0aW9uIGlzIGhlcmUgc28gdGhhdCBpdCdzXG4gIC8vIGFjY2Vzc2libGUgYW5kIGRlZmF1bHRzIHRvIGZhbHNlIHdoZW4gYFJlYWN0RE9NQ29tcG9uZW50YCBhbmRcbiAgLy8gYFJlYWN0VGV4dENvbXBvbmVudGAgY2hlY2tzIGl0IGluIGBtb3VudENvbXBvbmVudGAuYFxuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gZmFsc2U7XG4gIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQobnVsbCk7XG4gIHRoaXMucHV0TGlzdGVuZXJRdWV1ZSA9IFJlYWN0UHV0TGlzdGVuZXJRdWV1ZS5nZXRQb29sZWQoKTtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5PG9iamVjdD59IExpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VlZHVyZXMuXG4gICAqICAgVE9ETzogY29udmVydCB0byBhcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+XG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHk7XG4gIH0sXG5cbiAgZ2V0UHV0TGlzdGVuZXJRdWV1ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHV0TGlzdGVuZXJRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmVzdXNlZC5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLnJlYWN0TW91bnRSZWFkeSk7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBudWxsO1xuXG4gICAgUmVhY3RQdXRMaXN0ZW5lclF1ZXVlLnJlbGVhc2UodGhpcy5wdXRMaXN0ZW5lclF1ZXVlKTtcbiAgICB0aGlzLnB1dExpc3RlbmVyUXVldWUgPSBudWxsO1xuICB9XG59O1xuXG5cbmFzc2lnbihSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIE1peGluKTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb247XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSb290SW5kZXhcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdFJvb3RJbmRleEluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IF9jcmVhdGVSZWFjdFJvb3RJbmRleFxuICAgKi9cbiAgaW5qZWN0Q3JlYXRlUmVhY3RSb290SW5kZXg6IGZ1bmN0aW9uKF9jcmVhdGVSZWFjdFJvb3RJbmRleCkge1xuICAgIFJlYWN0Um9vdEluZGV4LmNyZWF0ZVJlYWN0Um9vdEluZGV4ID0gX2NyZWF0ZVJlYWN0Um9vdEluZGV4O1xuICB9XG59O1xuXG52YXIgUmVhY3RSb290SW5kZXggPSB7XG4gIGNyZWF0ZVJlYWN0Um9vdEluZGV4OiBudWxsLFxuICBpbmplY3Rpb246IFJlYWN0Um9vdEluZGV4SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Um9vdEluZGV4O1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKFwiLi9SZWFjdEluc3RhbmNlSGFuZGxlc1wiKTtcbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0gcmVxdWlyZShcIi4vUmVhY3RNYXJrdXBDaGVja3N1bVwiKTtcbnZhciBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uID1cbiAgcmVxdWlyZShcIi4vUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvblwiKTtcblxudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgSFRNTCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gcmVuZGVyVG9TdHJpbmcoZWxlbWVudCkge1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSxcbiAgICAncmVuZGVyVG9TdHJpbmcoKTogWW91IG11c3QgcGFzcyBhIHZhbGlkIFJlYWN0RWxlbWVudC4nXG4gICkgOiBpbnZhcmlhbnQoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSk7XG5cbiAgdmFyIHRyYW5zYWN0aW9uO1xuICB0cnkge1xuICAgIHZhciBpZCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0Um9vdElEKCk7XG4gICAgdHJhbnNhY3Rpb24gPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmdldFBvb2xlZChmYWxzZSk7XG5cbiAgICByZXR1cm4gdHJhbnNhY3Rpb24ucGVyZm9ybShmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoZWxlbWVudCwgbnVsbCk7XG4gICAgICB2YXIgbWFya3VwID0gY29tcG9uZW50SW5zdGFuY2UubW91bnRDb21wb25lbnQoaWQsIHRyYW5zYWN0aW9uLCAwKTtcbiAgICAgIHJldHVybiBSZWFjdE1hcmt1cENoZWNrc3VtLmFkZENoZWNrc3VtVG9NYXJrdXAobWFya3VwKTtcbiAgICB9LCBudWxsKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIEhUTUwgbWFya3VwLCB3aXRob3V0IHRoZSBleHRyYSBSZWFjdCBJRCBhbmQgY2hlY2tzdW1cbiAqIChmb3IgZ2VuZXJhdGluZyBzdGF0aWMgcGFnZXMpXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclRvU3RhdGljTWFya3VwKGVsZW1lbnQpIHtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCksXG4gICAgJ3JlbmRlclRvU3RhdGljTWFya3VwKCk6IFlvdSBtdXN0IHBhc3MgYSB2YWxpZCBSZWFjdEVsZW1lbnQuJ1xuICApIDogaW52YXJpYW50KFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkpO1xuXG4gIHZhciB0cmFuc2FjdGlvbjtcbiAgdHJ5IHtcbiAgICB2YXIgaWQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdFJvb3RJRCgpO1xuICAgIHRyYW5zYWN0aW9uID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5nZXRQb29sZWQodHJ1ZSk7XG5cbiAgICByZXR1cm4gdHJhbnNhY3Rpb24ucGVyZm9ybShmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoZWxlbWVudCwgbnVsbCk7XG4gICAgICByZXR1cm4gY29tcG9uZW50SW5zdGFuY2UubW91bnRDb21wb25lbnQoaWQsIHRyYW5zYWN0aW9uLCAwKTtcbiAgICB9LCBudWxsKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZW5kZXJUb1N0cmluZzogcmVuZGVyVG9TdHJpbmcsXG4gIHJlbmRlclRvU3RhdGljTWFya3VwOiByZW5kZXJUb1N0YXRpY01hcmt1cFxufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKFwiLi9Qb29sZWRDbGFzc1wiKTtcbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZShcIi4vQ2FsbGJhY2tRdWV1ZVwiKTtcbnZhciBSZWFjdFB1dExpc3RlbmVyUXVldWUgPSByZXF1aXJlKFwiLi9SZWFjdFB1dExpc3RlbmVyUXVldWVcIik7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKFwiLi9UcmFuc2FjdGlvblwiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2VtcHR5RnVuY3Rpb25cIik7XG5cbi8qKlxuICogUHJvdmlkZXMgYSBgQ2FsbGJhY2tRdWV1ZWAgcXVldWUgZm9yIGNvbGxlY3RpbmcgYG9uRE9NUmVhZHlgIGNhbGxiYWNrc1xuICogZHVyaW5nIHRoZSBwZXJmb3JtaW5nIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIE9OX0RPTV9SRUFEWV9RVUVVRUlORyA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBgb25ET01SZWFkeWAgcXVldWUuXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yZXNldCgpO1xuICB9LFxuXG4gIGNsb3NlOiBlbXB0eUZ1bmN0aW9uXG59O1xuXG52YXIgUFVUX0xJU1RFTkVSX1FVRVVFSU5HID0ge1xuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnB1dExpc3RlbmVyUXVldWUucmVzZXQoKTtcbiAgfSxcblxuICBjbG9zZTogZW1wdHlGdW5jdGlvblxufTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW1xuICBQVVRfTElTVEVORVJfUVVFVUVJTkcsXG4gIE9OX0RPTV9SRUFEWV9RVUVVRUlOR1xuXTtcblxuLyoqXG4gKiBAY2xhc3MgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvblxuICogQHBhcmFtIHtib29sZWFufSByZW5kZXJUb1N0YXRpY01hcmt1cFxuICovXG5mdW5jdGlvbiBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKHJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgdGhpcy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IHJlbmRlclRvU3RhdGljTWFya3VwO1xuICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKG51bGwpO1xuICB0aGlzLnB1dExpc3RlbmVyUXVldWUgPSBSZWFjdFB1dExpc3RlbmVyUXVldWUuZ2V0UG9vbGVkKCk7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheX0gRW1wdHkgbGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWVkdXJlcy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWN0TW91bnRSZWFkeTtcbiAgfSxcblxuICBnZXRQdXRMaXN0ZW5lclF1ZXVlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wdXRMaXN0ZW5lclF1ZXVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXN1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMucmVhY3RNb3VudFJlYWR5KTtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IG51bGw7XG5cbiAgICBSZWFjdFB1dExpc3RlbmVyUXVldWUucmVsZWFzZSh0aGlzLnB1dExpc3RlbmVyUXVldWUpO1xuICAgIHRoaXMucHV0TGlzdGVuZXJRdWV1ZSA9IG51bGw7XG4gIH1cbn07XG5cblxuYXNzaWduKFxuICBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnByb3RvdHlwZSxcbiAgVHJhbnNhY3Rpb24uTWl4aW4sXG4gIE1peGluXG4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFRleHRDb21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnNcIik7XG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudFwiKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGVzY2FwZVRleHRGb3JCcm93c2VyID0gcmVxdWlyZShcIi4vZXNjYXBlVGV4dEZvckJyb3dzZXJcIik7XG5cbi8qKlxuICogVGV4dCBub2RlcyB2aW9sYXRlIGEgY291cGxlIGFzc3VtcHRpb25zIHRoYXQgUmVhY3QgbWFrZXMgYWJvdXQgY29tcG9uZW50czpcbiAqXG4gKiAgLSBXaGVuIG1vdW50aW5nIHRleHQgaW50byB0aGUgRE9NLCBhZGphY2VudCB0ZXh0IG5vZGVzIGFyZSBtZXJnZWQuXG4gKiAgLSBUZXh0IG5vZGVzIGNhbm5vdCBiZSBhc3NpZ25lZCBhIFJlYWN0IHJvb3QgSUQuXG4gKlxuICogVGhpcyBjb21wb25lbnQgaXMgdXNlZCB0byB3cmFwIHN0cmluZ3MgaW4gZWxlbWVudHMgc28gdGhhdCB0aGV5IGNhbiB1bmRlcmdvXG4gKiB0aGUgc2FtZSByZWNvbmNpbGlhdGlvbiB0aGF0IGlzIGFwcGxpZWQgdG8gZWxlbWVudHMuXG4gKlxuICogVE9ETzogSW52ZXN0aWdhdGUgcmVwcmVzZW50aW5nIFJlYWN0IGNvbXBvbmVudHMgaW4gdGhlIERPTSB3aXRoIHRleHQgbm9kZXMuXG4gKlxuICogQGNsYXNzIFJlYWN0VGV4dENvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RDb21wb25lbnRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RUZXh0Q29tcG9uZW50ID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgLy8gVGhpcyBjb25zdHJ1Y3RvciBhbmQgaXQncyBhcmd1bWVudCBpcyBjdXJyZW50bHkgdXNlZCBieSBtb2Nrcy5cbn07XG5cbmFzc2lnbihSZWFjdFRleHRDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENvbXBvbmVudC5NaXhpbiwge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBtYXJrdXAgZm9yIHRoaXMgdGV4dCBub2RlLiBUaGlzIG5vZGUgaXMgbm90IGludGVuZGVkIHRvIGhhdmVcbiAgICogYW55IGZlYXR1cmVzIGJlc2lkZXMgY29udGFpbmluZyB0ZXh0IGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gbW91bnREZXB0aCBudW1iZXIgb2YgY29tcG9uZW50cyBpbiB0aGUgb3duZXIgaGllcmFyY2h5XG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24ocm9vdElELCB0cmFuc2FjdGlvbiwgbW91bnREZXB0aCkge1xuICAgIFJlYWN0Q29tcG9uZW50Lk1peGluLm1vdW50Q29tcG9uZW50LmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgcm9vdElELFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICBtb3VudERlcHRoXG4gICAgKTtcblxuICAgIHZhciBlc2NhcGVkVGV4dCA9IGVzY2FwZVRleHRGb3JCcm93c2VyKHRoaXMucHJvcHMpO1xuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSdkIHdyYXAgdGhpcyBpbiBhIGBzcGFuYCBmb3IgdGhlIHJlYXNvbnMgc3RhdGVkIGFib3ZlLCBidXRcbiAgICAgIC8vIHNpbmNlIHRoaXMgaXMgYSBzaXR1YXRpb24gd2hlcmUgUmVhY3Qgd29uJ3QgdGFrZSBvdmVyIChzdGF0aWMgcGFnZXMpLFxuICAgICAgLy8gd2UgY2FuIHNpbXBseSByZXR1cm4gdGhlIHRleHQgYXMgaXQgaXMuXG4gICAgICByZXR1cm4gZXNjYXBlZFRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICc8c3BhbiAnICsgRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvcklEKHJvb3RJRCkgKyAnPicgK1xuICAgICAgICBlc2NhcGVkVGV4dCArXG4gICAgICAnPC9zcGFuPidcbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgY29tcG9uZW50IGJ5IHVwZGF0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0Q29tcG9uZW50IENvbnRhaW5zIHRoZSBuZXh0IHRleHQgY29udGVudC5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uKG5leHRDb21wb25lbnQsIHRyYW5zYWN0aW9uKSB7XG4gICAgdmFyIG5leHRQcm9wcyA9IG5leHRDb21wb25lbnQucHJvcHM7XG4gICAgaWYgKG5leHRQcm9wcyAhPT0gdGhpcy5wcm9wcykge1xuICAgICAgdGhpcy5wcm9wcyA9IG5leHRQcm9wcztcbiAgICAgIFJlYWN0Q29tcG9uZW50LkJhY2tlbmRJRE9wZXJhdGlvbnMudXBkYXRlVGV4dENvbnRlbnRCeUlEKFxuICAgICAgICB0aGlzLl9yb290Tm9kZUlELFxuICAgICAgICBuZXh0UHJvcHNcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbn0pO1xuXG52YXIgUmVhY3RUZXh0Q29tcG9uZW50RmFjdG9yeSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgLy8gQnlwYXNzIHZhbGlkYXRpb24gYW5kIGNvbmZpZ3VyYXRpb25cbiAgcmV0dXJuIG5ldyBSZWFjdEVsZW1lbnQoUmVhY3RUZXh0Q29tcG9uZW50LCBudWxsLCBudWxsLCBudWxsLCBudWxsLCB0ZXh0KTtcbn07XG5cblJlYWN0VGV4dENvbXBvbmVudEZhY3RvcnkudHlwZSA9IFJlYWN0VGV4dENvbXBvbmVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFRleHRDb21wb25lbnRGYWN0b3J5O1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFVwZGF0ZXNcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKFwiLi9DYWxsYmFja1F1ZXVlXCIpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZShcIi4vUG9vbGVkQ2xhc3NcIik7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdEN1cnJlbnRPd25lclwiKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKFwiLi9SZWFjdFBlcmZcIik7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKFwiLi9UcmFuc2FjdGlvblwiKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG52YXIgZGlydHlDb21wb25lbnRzID0gW107XG52YXIgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xudmFyIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuXG52YXIgYmF0Y2hpbmdTdHJhdGVneSA9IG51bGw7XG5cbmZ1bmN0aW9uIGVuc3VyZUluamVjdGVkKCkge1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uICYmIGJhdGNoaW5nU3RyYXRlZ3ksXG4gICAgJ1JlYWN0VXBkYXRlczogbXVzdCBpbmplY3QgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MgYW5kIGJhdGNoaW5nICcgK1xuICAgICdzdHJhdGVneSdcbiAgKSA6IGludmFyaWFudChSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiAmJiBiYXRjaGluZ1N0cmF0ZWd5KSk7XG59XG5cbnZhciBORVNURURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoICE9PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBBZGRpdGlvbmFsIHVwZGF0ZXMgd2VyZSBlbnF1ZXVlZCBieSBjb21wb25lbnREaWRVcGRhdGUgaGFuZGxlcnMgb3JcbiAgICAgIC8vIHNpbWlsYXI7IGJlZm9yZSBvdXIgb3duIFVQREFURV9RVUVVRUlORyB3cmFwcGVyIGNsb3Nlcywgd2Ugd2FudCB0byBydW5cbiAgICAgIC8vIHRoZXNlIG5ldyB1cGRhdGVzIHNvIHRoYXQgaWYgQSdzIGNvbXBvbmVudERpZFVwZGF0ZSBjYWxscyBzZXRTdGF0ZSBvblxuICAgICAgLy8gQiwgQiB3aWxsIHVwZGF0ZSBiZWZvcmUgdGhlIGNhbGxiYWNrIEEncyB1cGRhdGVyIHByb3ZpZGVkIHdoZW4gY2FsbGluZ1xuICAgICAgLy8gc2V0U3RhdGUuXG4gICAgICBkaXJ0eUNvbXBvbmVudHMuc3BsaWNlKDAsIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoKTtcbiAgICAgIGZsdXNoQmF0Y2hlZFVwZGF0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlydHlDb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG59O1xuXG52YXIgVVBEQVRFX1FVRVVFSU5HID0ge1xuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUucmVzZXQoKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZS5ub3RpZnlBbGwoKTtcbiAgfVxufTtcblxudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW05FU1RFRF9VUERBVEVTLCBVUERBVEVfUVVFVUVJTkddO1xuXG5mdW5jdGlvbiBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gbnVsbDtcbiAgdGhpcy5jYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbiAgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiA9XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKCk7XG59XG5cbmFzc2lnbihcbiAgUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5wcm90b3R5cGUsXG4gIFRyYW5zYWN0aW9uLk1peGluLCB7XG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICBkZXN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMuY2FsbGJhY2tRdWV1ZSk7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlID0gbnVsbDtcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuICAgIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBudWxsO1xuICB9LFxuXG4gIHBlcmZvcm06IGZ1bmN0aW9uKG1ldGhvZCwgc2NvcGUsIGEpIHtcbiAgICAvLyBFc3NlbnRpYWxseSBjYWxscyBgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtKG1ldGhvZCwgc2NvcGUsIGEpYFxuICAgIC8vIHdpdGggdGhpcyB0cmFuc2FjdGlvbidzIHdyYXBwZXJzIGFyb3VuZCBpdC5cbiAgICByZXR1cm4gVHJhbnNhY3Rpb24uTWl4aW4ucGVyZm9ybS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24ucGVyZm9ybSxcbiAgICAgIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24sXG4gICAgICBtZXRob2QsXG4gICAgICBzY29wZSxcbiAgICAgIGFcbiAgICApO1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24pO1xuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYikge1xuICBlbnN1cmVJbmplY3RlZCgpO1xuICBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiKTtcbn1cblxuLyoqXG4gKiBBcnJheSBjb21wYXJhdG9yIGZvciBSZWFjdENvbXBvbmVudHMgYnkgb3duZXIgZGVwdGhcbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMSBmaXJzdCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gYzIgc2Vjb25kIGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJldHVybiB2YWx1ZSB1c2FibGUgYnkgQXJyYXkucHJvdG90eXBlLnNvcnQoKS5cbiAqL1xuZnVuY3Rpb24gbW91bnREZXB0aENvbXBhcmF0b3IoYzEsIGMyKSB7XG4gIHJldHVybiBjMS5fbW91bnREZXB0aCAtIGMyLl9tb3VudERlcHRoO1xufVxuXG5mdW5jdGlvbiBydW5CYXRjaGVkVXBkYXRlcyh0cmFuc2FjdGlvbikge1xuICB2YXIgbGVuID0gdHJhbnNhY3Rpb24uZGlydHlDb21wb25lbnRzTGVuZ3RoO1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIGxlbiA9PT0gZGlydHlDb21wb25lbnRzLmxlbmd0aCxcbiAgICAnRXhwZWN0ZWQgZmx1c2ggdHJhbnNhY3Rpb25cXCdzIHN0b3JlZCBkaXJ0eS1jb21wb25lbnRzIGxlbmd0aCAoJXMpIHRvICcgK1xuICAgICdtYXRjaCBkaXJ0eS1jb21wb25lbnRzIGFycmF5IGxlbmd0aCAoJXMpLicsXG4gICAgbGVuLFxuICAgIGRpcnR5Q29tcG9uZW50cy5sZW5ndGhcbiAgKSA6IGludmFyaWFudChsZW4gPT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpKTtcblxuICAvLyBTaW5jZSByZWNvbmNpbGluZyBhIGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIG93bmVyIGhpZXJhcmNoeSB1c3VhbGx5IChub3RcbiAgLy8gYWx3YXlzIC0tIHNlZSBzaG91bGRDb21wb25lbnRVcGRhdGUoKSkgd2lsbCByZWNvbmNpbGUgY2hpbGRyZW4sIHJlY29uY2lsZVxuICAvLyB0aGVtIGJlZm9yZSB0aGVpciBjaGlsZHJlbiBieSBzb3J0aW5nIHRoZSBhcnJheS5cbiAgZGlydHlDb21wb25lbnRzLnNvcnQobW91bnREZXB0aENvbXBhcmF0b3IpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAvLyBJZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgYmVmb3JlIHBlbmRpbmcgY2hhbmdlcyBhcHBseSwgaWdub3JlIHRoZW1cbiAgICAvLyBUT0RPOiBRdWV1ZSB1bm1vdW50cyBpbiB0aGUgc2FtZSBsaXN0IHRvIGF2b2lkIHRoaXMgaGFwcGVuaW5nIGF0IGFsbFxuICAgIHZhciBjb21wb25lbnQgPSBkaXJ0eUNvbXBvbmVudHNbaV07XG4gICAgaWYgKGNvbXBvbmVudC5pc01vdW50ZWQoKSkge1xuICAgICAgLy8gSWYgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGhhcHBlbnMgdG8gZW5xdWV1ZSBhbnkgbmV3IHVwZGF0ZXMsIHdlXG4gICAgICAvLyBzaG91bGRuJ3QgZXhlY3V0ZSB0aGUgY2FsbGJhY2tzIHVudGlsIHRoZSBuZXh0IHJlbmRlciBoYXBwZW5zLCBzb1xuICAgICAgLy8gc3Rhc2ggdGhlIGNhbGxiYWNrcyBmaXJzdFxuICAgICAgdmFyIGNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcztcbiAgICAgIGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG4gICAgICBjb21wb25lbnQucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KHRyYW5zYWN0aW9uLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcblxuICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNhbGxiYWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmNhbGxiYWNrUXVldWUuZW5xdWV1ZShcbiAgICAgICAgICAgIGNhbGxiYWNrc1tqXSxcbiAgICAgICAgICAgIGNvbXBvbmVudFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGZsdXNoQmF0Y2hlZFVwZGF0ZXMgPSBSZWFjdFBlcmYubWVhc3VyZShcbiAgJ1JlYWN0VXBkYXRlcycsXG4gICdmbHVzaEJhdGNoZWRVcGRhdGVzJyxcbiAgZnVuY3Rpb24oKSB7XG4gICAgLy8gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbidzIHdyYXBwZXJzIHdpbGwgY2xlYXIgdGhlIGRpcnR5Q29tcG9uZW50c1xuICAgIC8vIGFycmF5IGFuZCBwZXJmb3JtIGFueSB1cGRhdGVzIGVucXVldWVkIGJ5IG1vdW50LXJlYWR5IGhhbmRsZXJzIChpLmUuLFxuICAgIC8vIGNvbXBvbmVudERpZFVwZGF0ZSkgYnV0IHdlIG5lZWQgdG8gY2hlY2sgaGVyZSB0b28gaW4gb3JkZXIgdG8gY2F0Y2hcbiAgICAvLyB1cGRhdGVzIGVucXVldWVkIGJ5IHNldFN0YXRlIGNhbGxiYWNrcyBhbmQgYXNhcCBjYWxscy5cbiAgICB3aGlsZSAoZGlydHlDb21wb25lbnRzLmxlbmd0aCB8fCBhc2FwRW5xdWV1ZWQpIHtcbiAgICAgIGlmIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKCk7XG4gICAgICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0ocnVuQmF0Y2hlZFVwZGF0ZXMsIG51bGwsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFzYXBFbnF1ZXVlZCkge1xuICAgICAgICBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHF1ZXVlID0gYXNhcENhbGxiYWNrUXVldWU7XG4gICAgICAgIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbiAgICAgICAgcXVldWUubm90aWZ5QWxsKCk7XG4gICAgICAgIENhbGxiYWNrUXVldWUucmVsZWFzZShxdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4pO1xuXG4vKipcbiAqIE1hcmsgYSBjb21wb25lbnQgYXMgbmVlZGluZyBhIHJlcmVuZGVyLCBhZGRpbmcgYW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gYVxuICogbGlzdCBvZiBmdW5jdGlvbnMgd2hpY2ggd2lsbCBiZSBleGVjdXRlZCBvbmNlIHRoZSByZXJlbmRlciBvY2N1cnMuXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoY29tcG9uZW50LCBjYWxsYmFjaykge1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIixcbiAgICAnZW5xdWV1ZVVwZGF0ZSguLi4pOiBZb3UgY2FsbGVkIGBzZXRQcm9wc2AsIGByZXBsYWNlUHJvcHNgLCAnICtcbiAgICAnYHNldFN0YXRlYCwgYHJlcGxhY2VTdGF0ZWAsIG9yIGBmb3JjZVVwZGF0ZWAgd2l0aCBhIGNhbGxiYWNrIHRoYXQgJyArXG4gICAgJ2lzblxcJ3QgY2FsbGFibGUuJ1xuICApIDogaW52YXJpYW50KCFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikpO1xuICBlbnN1cmVJbmplY3RlZCgpO1xuXG4gIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoVGhpcyBpcyBjYWxsZWQgYnkgZWFjaCB0b3AtbGV2ZWwgdXBkYXRlXG4gIC8vIGZ1bmN0aW9uLCBsaWtlIHNldFByb3BzLCBzZXRTdGF0ZSwgZm9yY2VVcGRhdGUsIGV0Yy47IGNyZWF0aW9uIGFuZFxuICAvLyBkZXN0cnVjdGlvbiBvZiB0b3AtbGV2ZWwgY29tcG9uZW50cyBpcyBndWFyZGVkIGluIFJlYWN0TW91bnQuKVxuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhcbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsXG4gICAgJ2VucXVldWVVcGRhdGUoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyAnICtcbiAgICAnYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciBpcyBub3QgJyArXG4gICAgJ2FsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICtcbiAgICAnY29tcG9uZW50RGlkVXBkYXRlLidcbiAgKSA6IG51bGwpO1xuXG4gIGlmICghYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcykge1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoZW5xdWV1ZVVwZGF0ZSwgY29tcG9uZW50LCBjYWxsYmFjayk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGlydHlDb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcblxuICBpZiAoY2FsbGJhY2spIHtcbiAgICBpZiAoY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRvIGJlIHJ1biBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJhdGNoaW5nIGN5Y2xlLiBUaHJvd3NcbiAqIGlmIG5vIHVwZGF0ZXMgYXJlIGN1cnJlbnRseSBiZWluZyBwZXJmb3JtZWQuXG4gKi9cbmZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzLFxuICAgICdSZWFjdFVwZGF0ZXMuYXNhcDogQ2FuXFwndCBlbnF1ZXVlIGFuIGFzYXAgY2FsbGJhY2sgaW4gYSBjb250ZXh0IHdoZXJlJyArXG4gICAgJ3VwZGF0ZXMgYXJlIG5vdCBiZWluZyBiYXRjaGVkLidcbiAgKSA6IGludmFyaWFudChiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzKSk7XG4gIGFzYXBDYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2ssIGNvbnRleHQpO1xuICBhc2FwRW5xdWV1ZWQgPSB0cnVlO1xufVxuXG52YXIgUmVhY3RVcGRhdGVzSW5qZWN0aW9uID0ge1xuICBpbmplY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogZnVuY3Rpb24oUmVjb25jaWxlVHJhbnNhY3Rpb24pIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgUmVjb25jaWxlVHJhbnNhY3Rpb24sXG4gICAgICAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MnXG4gICAgKSA6IGludmFyaWFudChSZWNvbmNpbGVUcmFuc2FjdGlvbikpO1xuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVjb25jaWxlVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgaW5qZWN0QmF0Y2hpbmdTdHJhdGVneTogZnVuY3Rpb24oX2JhdGNoaW5nU3RyYXRlZ3kpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgX2JhdGNoaW5nU3RyYXRlZ3ksXG4gICAgICAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGluZyBzdHJhdGVneSdcbiAgICApIDogaW52YXJpYW50KF9iYXRjaGluZ1N0cmF0ZWd5KSk7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIGJhdGNoZWRVcGRhdGVzKCkgZnVuY3Rpb24nXG4gICAgKSA6IGludmFyaWFudCh0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMgPT09ICdmdW5jdGlvbicpKTtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgdHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID09PSAnYm9vbGVhbicsXG4gICAgICAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYW4gaXNCYXRjaGluZ1VwZGF0ZXMgYm9vbGVhbiBhdHRyaWJ1dGUnXG4gICAgKSA6IGludmFyaWFudCh0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPT09ICdib29sZWFuJykpO1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kgPSBfYmF0Y2hpbmdTdHJhdGVneTtcbiAgfVxufTtcblxudmFyIFJlYWN0VXBkYXRlcyA9IHtcbiAgLyoqXG4gICAqIFJlYWN0IHJlZmVyZW5jZXMgYFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25gIHVzaW5nIHRoaXMgcHJvcGVydHkgaW4gb3JkZXJcbiAgICogdG8gYWxsb3cgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogbnVsbCxcblxuICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG4gIGVucXVldWVVcGRhdGU6IGVucXVldWVVcGRhdGUsXG4gIGZsdXNoQmF0Y2hlZFVwZGF0ZXM6IGZsdXNoQmF0Y2hlZFVwZGF0ZXMsXG4gIGluamVjdGlvbjogUmVhY3RVcGRhdGVzSW5qZWN0aW9uLFxuICBhc2FwOiBhc2FwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlcztcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNWR0RPTVByb3BlcnR5Q29uZmlnXG4gKi9cblxuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eVwiKTtcblxudmFyIE1VU1RfVVNFX0FUVFJJQlVURSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5NVVNUX1VTRV9BVFRSSUJVVEU7XG5cbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgUHJvcGVydGllczoge1xuICAgIGN4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY3k6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZHg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZpbGw6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmaWxsT3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvbnRGYW1pbHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb250U2l6ZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZ4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZnk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBncmFkaWVudFRyYW5zZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGdyYWRpZW50VW5pdHM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJFbmQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJNaWQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJTdGFydDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG9mZnNldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwYXR0ZXJuQ29udGVudFVuaXRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcGF0dGVyblVuaXRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcG9pbnRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJ5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3ByZWFkTWV0aG9kOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3RvcENvbG9yOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3RvcE9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2U6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VEYXNoYXJyYXk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VMaW5lY2FwOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlT3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZVdpZHRoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdGV4dEFuY2hvcjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHRyYW5zZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHZlcnNpb246IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB2aWV3Qm94OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeDE6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4MjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB5MTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHkyOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeTogTVVTVF9VU0VfQVRUUklCVVRFXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgZmlsbE9wYWNpdHk6ICdmaWxsLW9wYWNpdHknLFxuICAgIGZvbnRGYW1pbHk6ICdmb250LWZhbWlseScsXG4gICAgZm9udFNpemU6ICdmb250LXNpemUnLFxuICAgIGdyYWRpZW50VHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICAgIGdyYWRpZW50VW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgICBtYXJrZXJFbmQ6ICdtYXJrZXItZW5kJyxcbiAgICBtYXJrZXJNaWQ6ICdtYXJrZXItbWlkJyxcbiAgICBtYXJrZXJTdGFydDogJ21hcmtlci1zdGFydCcsXG4gICAgcGF0dGVybkNvbnRlbnRVbml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICAgIHBhdHRlcm5Vbml0czogJ3BhdHRlcm5Vbml0cycsXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICAgIHNwcmVhZE1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gICAgc3RvcENvbG9yOiAnc3RvcC1jb2xvcicsXG4gICAgc3RvcE9wYWNpdHk6ICdzdG9wLW9wYWNpdHknLFxuICAgIHN0cm9rZURhc2hhcnJheTogJ3N0cm9rZS1kYXNoYXJyYXknLFxuICAgIHN0cm9rZUxpbmVjYXA6ICdzdHJva2UtbGluZWNhcCcsXG4gICAgc3Ryb2tlT3BhY2l0eTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICBzdHJva2VXaWR0aDogJ3N0cm9rZS13aWR0aCcsXG4gICAgdGV4dEFuY2hvcjogJ3RleHQtYW5jaG9yJyxcbiAgICB2aWV3Qm94OiAndmlld0JveCdcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkdET01Qcm9wZXJ0eUNvbmZpZztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTZWxlY3RFdmVudFBsdWdpblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZShcIi4vRXZlbnRQcm9wYWdhdG9yc1wiKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZShcIi4vUmVhY3RJbnB1dFNlbGVjdGlvblwiKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0V2ZW50XCIpO1xuXG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoXCIuL2dldEFjdGl2ZUVsZW1lbnRcIik7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZShcIi4vaXNUZXh0SW5wdXRFbGVtZW50XCIpO1xudmFyIGtleU9mID0gcmVxdWlyZShcIi4va2V5T2ZcIik7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZShcIi4vc2hhbGxvd0VxdWFsXCIpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBzZWxlY3Q6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uU2VsZWN0OiBudWxsfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uU2VsZWN0Q2FwdHVyZTogbnVsbH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcbiAgICAgIHRvcExldmVsVHlwZXMudG9wQmx1cixcbiAgICAgIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnUsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd24sXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXAsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZVxuICAgIF1cbiAgfVxufTtcblxudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG52YXIgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG52YXIgbW91c2VEb3duID0gZmFsc2U7XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aGljaCBpcyBhIHVuaXF1ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XG4gKiB0d28gaWRlbnRpY2FsIHNlbGVjdGlvbnMgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHJldHVybiBpZGVudGljYWwgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmXG4gICAgICBSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogbm9kZS5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3JOb2RlOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldDogc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZTogc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXJlbnRFbGVtZW50OiByYW5nZS5wYXJlbnRFbGVtZW50KCksXG4gICAgICB0ZXh0OiByYW5nZS50ZXh0LFxuICAgICAgdG9wOiByYW5nZS5ib3VuZGluZ1RvcCxcbiAgICAgIGxlZnQ6IHJhbmdlLmJvdW5kaW5nTGVmdFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIGlmIChtb3VzZURvd24gfHxcbiAgICAgIGFjdGl2ZUVsZW1lbnQgPT0gbnVsbCB8fFxuICAgICAgYWN0aXZlRWxlbWVudCAhPSBnZXRBY3RpdmVFbGVtZW50KCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQpO1xuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuXG4gICAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKFxuICAgICAgZXZlbnRUeXBlcy5zZWxlY3QsXG4gICAgICBhY3RpdmVFbGVtZW50SUQsXG4gICAgICBuYXRpdmVFdmVudFxuICAgICk7XG5cbiAgICBzeW50aGV0aWNFdmVudC50eXBlID0gJ3NlbGVjdCc7XG4gICAgc3ludGhldGljRXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudDtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhzeW50aGV0aWNFdmVudCk7XG5cbiAgICByZXR1cm4gc3ludGhldGljRXZlbnQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbihcbiAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgIHRvcExldmVsVGFyZ2V0LFxuICAgICAgdG9wTGV2ZWxUYXJnZXRJRCxcbiAgICAgIG5hdGl2ZUV2ZW50KSB7XG5cbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRm9jdXM6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodG9wTGV2ZWxUYXJnZXQpIHx8XG4gICAgICAgICAgICB0b3BMZXZlbFRhcmdldC5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSB0b3BMZXZlbFRhcmdldDtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SUQgPSB0b3BMZXZlbFRhcmdldElEO1xuICAgICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xuICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nLiBUaGlzIG1hdGNoZXMgdGhlXG4gICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duOlxuICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb250ZXh0TWVudTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwOlxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50KTtcblxuICAgICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5VXA6XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdEV2ZW50UGx1Z2luO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNlcnZlclJlYWN0Um9vdEluZGV4XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFNpemUgb2YgdGhlIHJlYWN0Um9vdCBJRCBzcGFjZS4gV2UgZ2VuZXJhdGUgcmFuZG9tIG51bWJlcnMgZm9yIFJlYWN0IHJvb3RcbiAqIElEcyBhbmQgaWYgdGhlcmUncyBhIGNvbGxpc2lvbiB0aGUgZXZlbnRzIGFuZCBET00gdXBkYXRlIHN5c3RlbSB3aWxsXG4gKiBnZXQgY29uZnVzZWQuIEluIHRoZSBmdXR1cmUgd2UgbmVlZCBhIHdheSB0byBnZW5lcmF0ZSBHVUlEcyBidXQgZm9yXG4gKiBub3cgdGhpcyB3aWxsIHdvcmsgb24gYSBzbWFsbGVyIHNjYWxlLlxuICovXG52YXIgR0xPQkFMX01PVU5UX1BPSU5UX01BWCA9IE1hdGgucG93KDIsIDUzKTtcblxudmFyIFNlcnZlclJlYWN0Um9vdEluZGV4ID0ge1xuICBjcmVhdGVSZWFjdFJvb3RJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbChNYXRoLnJhbmRvbSgpICogR0xPQkFMX01PVU5UX1BPSU5UX01BWCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VydmVyUmVhY3RSb290SW5kZXg7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNpbXBsZUV2ZW50UGx1Z2luXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpblV0aWxzXCIpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKFwiLi9FdmVudFByb3BhZ2F0b3JzXCIpO1xudmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljQ2xpcGJvYXJkRXZlbnRcIik7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNFdmVudFwiKTtcbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljRm9jdXNFdmVudFwiKTtcbnZhciBTeW50aGV0aWNLZXlib2FyZEV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljS2V5Ym9hcmRFdmVudFwiKTtcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljTW91c2VFdmVudFwiKTtcbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNEcmFnRXZlbnRcIik7XG52YXIgU3ludGhldGljVG91Y2hFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY1RvdWNoRXZlbnRcIik7XG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY1VJRXZlbnRcIik7XG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY1doZWVsRXZlbnRcIik7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZShcIi4vZ2V0RXZlbnRDaGFyQ29kZVwiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoXCIuL2tleU9mXCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBibHVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkJsdXI6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25CbHVyQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBjbGljazoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25DbGljazogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkNsaWNrQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBjb250ZXh0TWVudToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25Db250ZXh0TWVudTogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkNvbnRleHRNZW51Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBjb3B5OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkNvcHk6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25Db3B5Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBjdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uQ3V0OiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uQ3V0Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBkb3VibGVDbGljazoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25Eb3VibGVDbGljazogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkRvdWJsZUNsaWNrQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBkcmFnOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkRyYWc6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25EcmFnQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBkcmFnRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkRyYWdFbmQ6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25EcmFnRW5kQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBkcmFnRW50ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uRHJhZ0VudGVyOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uRHJhZ0VudGVyQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBkcmFnRXhpdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25EcmFnRXhpdDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkRyYWdFeGl0Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBkcmFnTGVhdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uRHJhZ0xlYXZlOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uRHJhZ0xlYXZlQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBkcmFnT3Zlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25EcmFnT3ZlcjogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkRyYWdPdmVyQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBkcmFnU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uRHJhZ1N0YXJ0OiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uRHJhZ1N0YXJ0Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBkcm9wOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkRyb3A6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25Ecm9wQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBmb2N1czoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25Gb2N1czogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkZvY3VzQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBpbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25JbnB1dDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbklucHV0Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBrZXlEb3duOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbktleURvd246IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25LZXlEb3duQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBrZXlQcmVzczoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25LZXlQcmVzczogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbktleVByZXNzQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBrZXlVcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25LZXlVcDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbktleVVwQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBsb2FkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkxvYWQ6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25Mb2FkQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBlcnJvcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25FcnJvcjogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkVycm9yQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICAvLyBOb3RlOiBXZSBkbyBub3QgYWxsb3cgbGlzdGVuaW5nIHRvIG1vdXNlT3ZlciBldmVudHMuIEluc3RlYWQsIHVzZSB0aGVcbiAgLy8gb25Nb3VzZUVudGVyL29uTW91c2VMZWF2ZSBjcmVhdGVkIGJ5IGBFbnRlckxlYXZlRXZlbnRQbHVnaW5gLlxuICBtb3VzZURvd246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uTW91c2VEb3duOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uTW91c2VEb3duQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBtb3VzZU1vdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uTW91c2VNb3ZlOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uTW91c2VNb3ZlQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBtb3VzZU91dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25Nb3VzZU91dDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbk1vdXNlT3V0Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBtb3VzZU92ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uTW91c2VPdmVyOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uTW91c2VPdmVyQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBtb3VzZVVwOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbk1vdXNlVXA6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25Nb3VzZVVwQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBwYXN0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25QYXN0ZTogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvblBhc3RlQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICByZXNldDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25SZXNldDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvblJlc2V0Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBzY3JvbGw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uU2Nyb2xsOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uU2Nyb2xsQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBzdWJtaXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uU3VibWl0OiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uU3VibWl0Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICB0b3VjaENhbmNlbDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25Ub3VjaENhbmNlbDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvblRvdWNoQ2FuY2VsQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICB0b3VjaEVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25Ub3VjaEVuZDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvblRvdWNoRW5kQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICB0b3VjaE1vdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uVG91Y2hNb3ZlOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uVG91Y2hNb3ZlQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICB0b3VjaFN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvblRvdWNoU3RhcnQ6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25Ub3VjaFN0YXJ0Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICB3aGVlbDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25XaGVlbDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbldoZWVsQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9XG59O1xuXG52YXIgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICB0b3BCbHVyOiAgICAgICAgZXZlbnRUeXBlcy5ibHVyLFxuICB0b3BDbGljazogICAgICAgZXZlbnRUeXBlcy5jbGljayxcbiAgdG9wQ29udGV4dE1lbnU6IGV2ZW50VHlwZXMuY29udGV4dE1lbnUsXG4gIHRvcENvcHk6ICAgICAgICBldmVudFR5cGVzLmNvcHksXG4gIHRvcEN1dDogICAgICAgICBldmVudFR5cGVzLmN1dCxcbiAgdG9wRG91YmxlQ2xpY2s6IGV2ZW50VHlwZXMuZG91YmxlQ2xpY2ssXG4gIHRvcERyYWc6ICAgICAgICBldmVudFR5cGVzLmRyYWcsXG4gIHRvcERyYWdFbmQ6ICAgICBldmVudFR5cGVzLmRyYWdFbmQsXG4gIHRvcERyYWdFbnRlcjogICBldmVudFR5cGVzLmRyYWdFbnRlcixcbiAgdG9wRHJhZ0V4aXQ6ICAgIGV2ZW50VHlwZXMuZHJhZ0V4aXQsXG4gIHRvcERyYWdMZWF2ZTogICBldmVudFR5cGVzLmRyYWdMZWF2ZSxcbiAgdG9wRHJhZ092ZXI6ICAgIGV2ZW50VHlwZXMuZHJhZ092ZXIsXG4gIHRvcERyYWdTdGFydDogICBldmVudFR5cGVzLmRyYWdTdGFydCxcbiAgdG9wRHJvcDogICAgICAgIGV2ZW50VHlwZXMuZHJvcCxcbiAgdG9wRXJyb3I6ICAgICAgIGV2ZW50VHlwZXMuZXJyb3IsXG4gIHRvcEZvY3VzOiAgICAgICBldmVudFR5cGVzLmZvY3VzLFxuICB0b3BJbnB1dDogICAgICAgZXZlbnRUeXBlcy5pbnB1dCxcbiAgdG9wS2V5RG93bjogICAgIGV2ZW50VHlwZXMua2V5RG93bixcbiAgdG9wS2V5UHJlc3M6ICAgIGV2ZW50VHlwZXMua2V5UHJlc3MsXG4gIHRvcEtleVVwOiAgICAgICBldmVudFR5cGVzLmtleVVwLFxuICB0b3BMb2FkOiAgICAgICAgZXZlbnRUeXBlcy5sb2FkLFxuICB0b3BNb3VzZURvd246ICAgZXZlbnRUeXBlcy5tb3VzZURvd24sXG4gIHRvcE1vdXNlTW92ZTogICBldmVudFR5cGVzLm1vdXNlTW92ZSxcbiAgdG9wTW91c2VPdXQ6ICAgIGV2ZW50VHlwZXMubW91c2VPdXQsXG4gIHRvcE1vdXNlT3ZlcjogICBldmVudFR5cGVzLm1vdXNlT3ZlcixcbiAgdG9wTW91c2VVcDogICAgIGV2ZW50VHlwZXMubW91c2VVcCxcbiAgdG9wUGFzdGU6ICAgICAgIGV2ZW50VHlwZXMucGFzdGUsXG4gIHRvcFJlc2V0OiAgICAgICBldmVudFR5cGVzLnJlc2V0LFxuICB0b3BTY3JvbGw6ICAgICAgZXZlbnRUeXBlcy5zY3JvbGwsXG4gIHRvcFN1Ym1pdDogICAgICBldmVudFR5cGVzLnN1Ym1pdCxcbiAgdG9wVG91Y2hDYW5jZWw6IGV2ZW50VHlwZXMudG91Y2hDYW5jZWwsXG4gIHRvcFRvdWNoRW5kOiAgICBldmVudFR5cGVzLnRvdWNoRW5kLFxuICB0b3BUb3VjaE1vdmU6ICAgZXZlbnRUeXBlcy50b3VjaE1vdmUsXG4gIHRvcFRvdWNoU3RhcnQ6ICBldmVudFR5cGVzLnRvdWNoU3RhcnQsXG4gIHRvcFdoZWVsOiAgICAgICBldmVudFR5cGVzLndoZWVsXG59O1xuXG5mb3IgKHZhciB0b3BMZXZlbFR5cGUgaW4gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnKSB7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdLmRlcGVuZGVuY2llcyA9IFt0b3BMZXZlbFR5cGVdO1xufVxuXG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogU2FtZSBhcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiwgZXhjZXB0IGNhbmNlbHMgdGhlIGV2ZW50IHdoZW4gcmV0dXJuXG4gICAqIHZhbHVlIGlzIGZhbHNlLiBUaGlzIGJlaGF2aW9yIHdpbGwgYmUgZGlzYWJsZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IEV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZG9tSUQgRE9NIElEIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrLlxuICAgKi9cbiAgZXhlY3V0ZURpc3BhdGNoOiBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIsIGRvbUlEKSB7XG4gICAgdmFyIHJldHVyblZhbHVlID0gRXZlbnRQbHVnaW5VdGlscy5leGVjdXRlRGlzcGF0Y2goZXZlbnQsIGxpc3RlbmVyLCBkb21JRCk7XG5cbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhcbiAgICAgIHR5cGVvZiByZXR1cm5WYWx1ZSAhPT0gJ2Jvb2xlYW4nLFxuICAgICAgJ1JldHVybmluZyBgZmFsc2VgIGZyb20gYW4gZXZlbnQgaGFuZGxlciBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlICcgK1xuICAgICAgJ2lnbm9yZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4gSW5zdGVhZCwgbWFudWFsbHkgY2FsbCAnICtcbiAgICAgICdlLnN0b3BQcm9wYWdhdGlvbigpIG9yIGUucHJldmVudERlZmF1bHQoKSwgYXMgYXBwcm9wcmlhdGUuJ1xuICAgICkgOiBudWxsKTtcblxuICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24oXG4gICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICB0b3BMZXZlbFRhcmdldCxcbiAgICAgIHRvcExldmVsVGFyZ2V0SUQsXG4gICAgICBuYXRpdmVFdmVudCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcElucHV0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRXJyb3I6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUmVzZXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU3VibWl0OlxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgICAgLy8gRmlyZUZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbiAgICAgICAgLy8gbm9uLXByaW50YWJsZS4gT25lIHdvdWxkIGV4cGVjdCBUYWIgdG8gYmUgYXMgd2VsbCAoYnV0IGl0IGlzbid0KS5cbiAgICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5VXA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2xpY2s6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRG91YmxlQ2xpY2s6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlTW92ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VVcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWc6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0VuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnRW50ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0V4aXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0xlYXZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdPdmVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdTdGFydDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcm9wOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaENhbmNlbDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaEVuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFdoZWVsOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljV2hlZWxFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29weTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGFzdGU6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBFdmVudENvbnN0cnVjdG9yLFxuICAgICAgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4nLFxuICAgICAgdG9wTGV2ZWxUeXBlXG4gICAgKSA6IGludmFyaWFudChFdmVudENvbnN0cnVjdG9yKSk7XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoXG4gICAgICBkaXNwYXRjaENvbmZpZyxcbiAgICAgIHRvcExldmVsVGFyZ2V0SUQsXG4gICAgICBuYXRpdmVFdmVudFxuICAgICk7XG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVFdmVudFBsdWdpbjtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNFdmVudFwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICdjbGlwYm9hcmREYXRhJyBpbiBldmVudCA/XG4gICAgICAgIGV2ZW50LmNsaXBib2FyZERhdGEgOlxuICAgICAgICB3aW5kb3cuY2xpcGJvYXJkRGF0YVxuICAgICk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG5cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNFdmVudFwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KFxuICBkaXNwYXRjaENvbmZpZyxcbiAgZGlzcGF0Y2hNYXJrZXIsXG4gIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhcbiAgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCxcbiAgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZVxuKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50O1xuXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRHJhZ0V2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY01vdXNlRXZlbnRcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRHJhZ0V2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhVHJhbnNmZXI6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0RyYWdFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRHJhZ0V2ZW50LCBEcmFnRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZShcIi4vUG9vbGVkQ2xhc3NcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwiLi9PYmplY3QuYXNzaWduXCIpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZShcIi4vZ2V0RXZlbnRUYXJnZXRcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgdHlwZTogbnVsbCxcbiAgdGFyZ2V0OiBnZXRFdmVudFRhcmdldCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgfSxcbiAgZGVmYXVsdFByZXZlbnRlZDogbnVsbCxcbiAgaXNUcnVzdGVkOiBudWxsXG59O1xuXG4vKipcbiAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gKlxuICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICogZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGludG8gdGhlIHBvb2wgYWZ0ZXIgYmVpbmcgZGlzcGF0Y2hlZC4gVXNlcnMgdGhhdFxuICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAqXG4gKiBTeW50aGV0aWMgZXZlbnRzIChhbmQgc3ViY2xhc3NlcykgaW1wbGVtZW50IHRoZSBET00gTGV2ZWwgMyBFdmVudHMgQVBJIGJ5XG4gKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCkge1xuICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gZGlzcGF0Y2hDb25maWc7XG4gIHRoaXMuZGlzcGF0Y2hNYXJrZXIgPSBkaXNwYXRjaE1hcmtlcjtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtwcm9wTmFtZV07XG4gICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBub3JtYWxpemUobmF0aXZlRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W3Byb3BOYW1lXTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbCA/XG4gICAgbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6XG4gICAgbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbn1cblxuYXNzaWduKFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZSwge1xuXG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQgPyBldmVudC5wcmV2ZW50RGVmYXVsdCgpIDogZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPyBldmVudC5zdG9wUHJvcGFnYXRpb24oKSA6IGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlzUGVyc2lzdGVudCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNQZXJzaXN0ZW50OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UsXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIGBkZXN0cnVjdG9yYCBvbiBlYWNoIGluc3RhbmNlIGl0IHJlbGVhc2VzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gbnVsbDtcbiAgICB0aGlzLmRpc3BhdGNoTWFya2VyID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgfVxuXG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbi8qKlxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3NcbiAqIEBwYXJhbSB7P29iamVjdH0gSW50ZXJmYWNlXG4gKi9cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyA9IGZ1bmN0aW9uKENsYXNzLCBJbnRlcmZhY2UpIHtcbiAgdmFyIFN1cGVyID0gdGhpcztcblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICBhc3NpZ24ocHJvdG90eXBlLCBDbGFzcy5wcm90b3R5cGUpO1xuICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIENsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENsYXNzO1xuXG4gIENsYXNzLkludGVyZmFjZSA9IGFzc2lnbih7fSwgU3VwZXIuSW50ZXJmYWNlLCBJbnRlcmZhY2UpO1xuICBDbGFzcy5hdWdtZW50Q2xhc3MgPSBTdXBlci5hdWdtZW50Q2xhc3M7XG5cbiAgUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENsYXNzLCBQb29sZWRDbGFzcy50aHJlZUFyZ3VtZW50UG9vbGVyKTtcbn07XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCwgUG9vbGVkQ2xhc3MudGhyZWVBcmd1bWVudFBvb2xlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRXZlbnQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRm9jdXNFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNVSUV2ZW50XCIpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0ge1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNGb2N1c0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNGb2N1c0V2ZW50LCBGb2N1c0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0lucHV0RXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0V2ZW50XCIpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIElucHV0RXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0lucHV0RXZlbnQoXG4gIGRpc3BhdGNoQ29uZmlnLFxuICBkaXNwYXRjaE1hcmtlcixcbiAgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFxuICBTeW50aGV0aWNJbnB1dEV2ZW50LFxuICBJbnB1dEV2ZW50SW50ZXJmYWNlXG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0lucHV0RXZlbnQ7XG5cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNLZXlib2FyZEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY1VJRXZlbnRcIik7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZShcIi4vZ2V0RXZlbnRDaGFyQ29kZVwiKTtcbnZhciBnZXRFdmVudEtleSA9IHJlcXVpcmUoXCIuL2dldEV2ZW50S2V5XCIpO1xudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoXCIuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZVwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgLy8gYGNoYXJDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5UHJlc3MgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuXG4gICAgLy8gS2V5UHJlc3MgaXMgZGVwcmVjYXRlZCwgYnV0IGl0cyByZXBsYWNlbWVudCBpcyBub3QgeWV0IGZpbmFsIGFuZCBub3RcbiAgICAvLyBpbXBsZW1lbnRlZCBpbiBhbnkgbWFqb3IgYnJvd3Nlci4gT25seSBLZXlQcmVzcyBoYXMgY2hhckNvZGUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGtleUNvZGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgLy8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cblxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICB3aGljaDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY01vdXNlRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljVUlFdmVudFwiKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKFwiLi9WaWV3cG9ydE1ldHJpY3NcIik7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKFwiLi9nZXRFdmVudE1vZGlmaWVyU3RhdGVcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIE1vdXNlRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHNjcmVlblg6IG51bGwsXG4gIHNjcmVlblk6IG51bGwsXG4gIGNsaWVudFg6IG51bGwsXG4gIGNsaWVudFk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiBmdW5jdGlvbihldmVudCkge1xuICAgIC8vIFdlYmtpdCwgRmlyZWZveCwgSUU5K1xuICAgIC8vIHdoaWNoOiAgMSAyIDNcbiAgICAvLyBidXR0b246IDAgMSAyIChzdGFuZGFyZClcbiAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuICAgIGlmICgnd2hpY2gnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH1cbiAgICAvLyBJRTw5XG4gICAgLy8gd2hpY2g6ICB1bmRlZmluZWRcbiAgICAvLyBidXR0b246IDAgMCAwXG4gICAgLy8gYnV0dG9uOiAxIDQgMiAob25tb3VzZXVwKVxuICAgIHJldHVybiBidXR0b24gPT09IDIgPyAyIDogYnV0dG9uID09PSA0ID8gMSA6IDA7XG4gIH0sXG4gIGJ1dHRvbnM6IG51bGwsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKFxuICAgICAgZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgP1xuICAgICAgICBldmVudC50b0VsZW1lbnQgOlxuICAgICAgICBldmVudC5mcm9tRWxlbWVudFxuICAgICk7XG4gIH0sXG4gIC8vIFwiUHJvcHJpZXRhcnlcIiBJbnRlcmZhY2UuXG4gIHBhZ2VYOiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiAncGFnZVgnIGluIGV2ZW50ID9cbiAgICAgIGV2ZW50LnBhZ2VYIDpcbiAgICAgIGV2ZW50LmNsaWVudFggKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQ7XG4gIH0sXG4gIHBhZ2VZOiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiAncGFnZVknIGluIGV2ZW50ID9cbiAgICAgIGV2ZW50LnBhZ2VZIDpcbiAgICAgIGV2ZW50LmNsaWVudFkgKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljTW91c2VFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljTW91c2VFdmVudCwgTW91c2VFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljTW91c2VFdmVudDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNUb3VjaEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY1VJRXZlbnRcIik7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKFwiLi9nZXRFdmVudE1vZGlmaWVyU3RhdGVcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCkge1xuICBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljVUlFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljRXZlbnRcIik7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoXCIuL2dldEV2ZW50VGFyZ2V0XCIpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmIChldmVudC52aWV3KSB7XG4gICAgICByZXR1cm4gZXZlbnQudmlldztcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgIGlmICh0YXJnZXQgIT0gbnVsbCAmJiB0YXJnZXQud2luZG93ID09PSB0YXJnZXQpIHtcbiAgICAgIC8vIHRhcmdldCBpcyBhIHdpbmRvdyBvYmplY3RcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgdmFyIGRvYyA9IHRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICBpZiAoZG9jKSB7XG4gICAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICB9LFxuICBkZXRhaWw6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmRldGFpbCB8fCAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVUlFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNVSUV2ZW50LCBVSUV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNVSUV2ZW50O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1doZWVsRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljTW91c2VFdmVudFwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IHtcbiAgZGVsdGFYOiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiAoXG4gICAgICAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6XG4gICAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuICAgICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDBcbiAgICApO1xuICB9LFxuICBkZWx0YVk6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDpcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWWAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOlxuICAgICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwXG4gICAgKTtcbiAgfSxcbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNXaGVlbEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNXaGVlbEV2ZW50LCBXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBUcmFuc2FjdGlvblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIGBUcmFuc2FjdGlvbmAgY3JlYXRlcyBhIGJsYWNrIGJveCB0aGF0IGlzIGFibGUgdG8gd3JhcCBhbnkgbWV0aG9kIHN1Y2ggdGhhdFxuICogY2VydGFpbiBpbnZhcmlhbnRzIGFyZSBtYWludGFpbmVkIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIG1ldGhvZCBpcyBpbnZva2VkXG4gKiAoRXZlbiBpZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIHdoaWxlIGludm9raW5nIHRoZSB3cmFwcGVkIG1ldGhvZCkuIFdob2V2ZXJcbiAqIGluc3RhbnRpYXRlcyBhIHRyYW5zYWN0aW9uIGNhbiBwcm92aWRlIGVuZm9yY2VycyBvZiB0aGUgaW52YXJpYW50cyBhdFxuICogY3JlYXRpb24gdGltZS4gVGhlIGBUcmFuc2FjdGlvbmAgY2xhc3MgaXRzZWxmIHdpbGwgc3VwcGx5IG9uZSBhZGRpdGlvbmFsXG4gKiBhdXRvbWF0aWMgaW52YXJpYW50IGZvciB5b3UgLSB0aGUgaW52YXJpYW50IHRoYXQgYW55IHRyYW5zYWN0aW9uIGluc3RhbmNlXG4gKiBzaG91bGQgbm90IGJlIHJ1biB3aGlsZSBpdCBpcyBhbHJlYWR5IGJlaW5nIHJ1bi4gWW91IHdvdWxkIHR5cGljYWxseSBjcmVhdGUgYVxuICogc2luZ2xlIGluc3RhbmNlIG9mIGEgYFRyYW5zYWN0aW9uYCBmb3IgcmV1c2UgbXVsdGlwbGUgdGltZXMsIHRoYXQgcG90ZW50aWFsbHlcbiAqIGlzIHVzZWQgdG8gd3JhcCBzZXZlcmFsIGRpZmZlcmVudCBtZXRob2RzLiBXcmFwcGVycyBhcmUgZXh0cmVtZWx5IHNpbXBsZSAtXG4gKiB0aGV5IG9ubHkgcmVxdWlyZSBpbXBsZW1lbnRpbmcgdHdvIG1ldGhvZHMuXG4gKlxuICogPHByZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVycyAoaW5qZWN0ZWQgYXQgY3JlYXRpb24gdGltZSlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICAgICAgICArXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB2ICAgICAgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICstLS0tLS0tLS0tLS0tLS0rICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICArLS18ICAgIHdyYXBwZXIxICAgfC0tLXwtLS0tKyAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgKy0tLS0tLS0tLS0tLS0tLSsgICB2ICAgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICAgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICArLS0tLXwgICB3cmFwcGVyMiAgfC0tLS0tLS0tKyAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB2ICAgICB2ICAgICAgICAgICAgICAgICAgICAgdiAgICAgdiAgIHwgd3JhcHBlclxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHwgaW52YXJpYW50c1xuICogcGVyZm9ybShhbnlNZXRob2QpIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHwgbWFpbnRhaW5lZFxuICogKy0tLS0tLS0tLS0tLS0tLS0tPnwtfC0tLXwtfC0tLXwtLT58YW55TWV0aG9kfC0tLXwtLS18LXwtLS18LXwtLS0tLS0tLT5cbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgaW5pdGlhbGl6ZSAgICAgICAgICAgICAgICAgICAgY2xvc2UgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqIDwvcHJlPlxuICpcbiAqIFVzZSBjYXNlczpcbiAqIC0gUHJlc2VydmluZyB0aGUgaW5wdXQgc2VsZWN0aW9uIHJhbmdlcyBiZWZvcmUvYWZ0ZXIgcmVjb25jaWxpYXRpb24uXG4gKiAgIFJlc3RvcmluZyBzZWxlY3Rpb24gZXZlbiBpbiB0aGUgZXZlbnQgb2YgYW4gdW5leHBlY3RlZCBlcnJvci5cbiAqIC0gRGVhY3RpdmF0aW5nIGV2ZW50cyB3aGlsZSByZWFycmFuZ2luZyB0aGUgRE9NLCBwcmV2ZW50aW5nIGJsdXJzL2ZvY3VzZXMsXG4gKiAgIHdoaWxlIGd1YXJhbnRlZWluZyB0aGF0IGFmdGVyd2FyZHMsIHRoZSBldmVudCBzeXN0ZW0gaXMgcmVhY3RpdmF0ZWQuXG4gKiAtIEZsdXNoaW5nIGEgcXVldWUgb2YgY29sbGVjdGVkIERPTSBtdXRhdGlvbnMgdG8gdGhlIG1haW4gVUkgdGhyZWFkIGFmdGVyIGFcbiAqICAgcmVjb25jaWxpYXRpb24gdGFrZXMgcGxhY2UgaW4gYSB3b3JrZXIgdGhyZWFkLlxuICogLSBJbnZva2luZyBhbnkgY29sbGVjdGVkIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBhZnRlciByZW5kZXJpbmcgbmV3XG4gKiAgIGNvbnRlbnQuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBXcmFwcGluZyBwYXJ0aWN1bGFyIGZsdXNoZXMgb2YgdGhlIGBSZWFjdFdvcmtlcmAgcXVldWVcbiAqICAgdG8gcHJlc2VydmUgdGhlIGBzY3JvbGxUb3BgIChhbiBhdXRvbWF0aWMgc2Nyb2xsIGF3YXJlIERPTSkuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBMYXlvdXQgY2FsY3VsYXRpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgRE9NIHVwYXRlcy5cbiAqXG4gKiBUcmFuc2FjdGlvbmFsIHBsdWdpbiBBUEk6XG4gKiAtIEEgbW9kdWxlIHRoYXQgaGFzIGFuIGBpbml0aWFsaXplYCBtZXRob2QgdGhhdCByZXR1cm5zIGFueSBwcmVjb21wdXRhdGlvbi5cbiAqIC0gYW5kIGEgYGNsb3NlYCBtZXRob2QgdGhhdCBhY2NlcHRzIHRoZSBwcmVjb21wdXRhdGlvbi4gYGNsb3NlYCBpcyBpbnZva2VkXG4gKiAgIHdoZW4gdGhlIHdyYXBwZWQgcHJvY2VzcyBpcyBjb21wbGV0ZWQsIG9yIGhhcyBmYWlsZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxUcmFuc2FjdGlvbmFsV3JhcHBlcj59IHRyYW5zYWN0aW9uV3JhcHBlciBXcmFwcGVyIG1vZHVsZXNcbiAqIHRoYXQgaW1wbGVtZW50IGBpbml0aWFsaXplYCBhbmQgYGNsb3NlYC5cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSBTaW5nbGUgdHJhbnNhY3Rpb24gZm9yIHJldXNlIGluIHRocmVhZC5cbiAqXG4gKiBAY2xhc3MgVHJhbnNhY3Rpb25cbiAqL1xudmFyIE1peGluID0ge1xuICAvKipcbiAgICogU2V0cyB1cCB0aGlzIGluc3RhbmNlIHNvIHRoYXQgaXQgaXMgcHJlcGFyZWQgZm9yIGNvbGxlY3RpbmcgbWV0cmljcy4gRG9lc1xuICAgKiBzbyBzdWNoIHRoYXQgdGhpcyBzZXR1cCBtZXRob2QgbWF5IGJlIHVzZWQgb24gYW4gaW5zdGFuY2UgdGhhdCBpcyBhbHJlYWR5XG4gICAqIGluaXRpYWxpemVkLCBpbiBhIHdheSB0aGF0IGRvZXMgbm90IGNvbnN1bWUgYWRkaXRpb25hbCBtZW1vcnkgdXBvbiByZXVzZS5cbiAgICogVGhhdCBjYW4gYmUgdXNlZnVsIGlmIHlvdSBkZWNpZGUgdG8gbWFrZSB5b3VyIHN1YmNsYXNzIG9mIHRoaXMgbWl4aW4gYVxuICAgKiBcIlBvb2xlZENsYXNzXCIuXG4gICAqL1xuICByZWluaXRpYWxpemVUcmFuc2FjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy5nZXRUcmFuc2FjdGlvbldyYXBwZXJzKCk7XG4gICAgaWYgKCF0aGlzLndyYXBwZXJJbml0RGF0YSkge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gIH0sXG5cbiAgX2lzSW5UcmFuc2FjdGlvbjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+fSBBcnJheSBvZiB0cmFuc2FjdGlvbiB3cmFwcGVycy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IG51bGwsXG5cbiAgaXNJblRyYW5zYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISF0aGlzLl9pc0luVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBmdW5jdGlvbiB3aXRoaW4gYSBzYWZldHkgd2luZG93LiBVc2UgdGhpcyBmb3IgdGhlIHRvcCBsZXZlbFxuICAgKiBtZXRob2RzIHRoYXQgcmVzdWx0IGluIGxhcmdlIGFtb3VudHMgb2YgY29tcHV0YXRpb24vbXV0YXRpb25zIHRoYXQgd291bGRcbiAgICogbmVlZCB0byBiZSBzYWZldHkgY2hlY2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1lbWJlciBvZiBzY29wZSB0byBjYWxsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgU2NvcGUgdG8gaW52b2tlIGZyb20uXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGFyZ3MuLi4gQXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZCAob3B0aW9uYWwpLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIEhlbHBzIHByZXZlbnQgbmVlZCB0byBiaW5kIGluIG1hbnkgY2FzZXMuXG4gICAqIEByZXR1cm4gUmV0dXJuIHZhbHVlIGZyb20gYG1ldGhvZGAuXG4gICAqL1xuICBwZXJmb3JtOiBmdW5jdGlvbihtZXRob2QsIHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICF0aGlzLmlzSW5UcmFuc2FjdGlvbigpLFxuICAgICAgJ1RyYW5zYWN0aW9uLnBlcmZvcm0oLi4uKTogQ2Fubm90IGluaXRpYWxpemUgYSB0cmFuc2FjdGlvbiB3aGVuIHRoZXJlICcgK1xuICAgICAgJ2lzIGFscmVhZHkgYW4gb3V0c3RhbmRpbmcgdHJhbnNhY3Rpb24uJ1xuICAgICkgOiBpbnZhcmlhbnQoIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkpKTtcbiAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgdmFyIHJldDtcbiAgICB0cnkge1xuICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAvLyBvbmUgb2YgdGhlc2UgY2FsbHMgdGhyZXcuXG4gICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0aGlzLmluaXRpYWxpemVBbGwoMCk7XG4gICAgICByZXQgPSBtZXRob2QuY2FsbChzY29wZSwgYSwgYiwgYywgZCwgZSwgZik7XG4gICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBJZiBgbWV0aG9kYCB0aHJvd3MsIHByZWZlciB0byBzaG93IHRoYXQgc3RhY2sgdHJhY2Ugb3ZlciBhbnkgdGhyb3duXG4gICAgICAgICAgLy8gYnkgaW52b2tpbmcgYGNsb3NlQWxsYC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2luY2UgYG1ldGhvZGAgZGlkbid0IHRocm93LCB3ZSBkb24ndCB3YW50IHRvIHNpbGVuY2UgdGhlIGV4Y2VwdGlvblxuICAgICAgICAgIC8vIGhlcmUuXG4gICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUFsbDogZnVuY3Rpb24oc3RhcnRJbmRleCkge1xuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aCB0aGVcbiAgICAgICAgLy8gT0JTRVJWRURfRVJST1Igc3RhdGUgYmVmb3JlIG92ZXJ3cml0aW5nIGl0IHdpdGggdGhlIHJlYWwgcmV0dXJuIHZhbHVlXG4gICAgICAgIC8vIG9mIGluaXRpYWxpemUgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gT0JTRVJWRURfRVJST1IgaW4gdGhlIGZpbmFsbHlcbiAgICAgICAgLy8gYmxvY2ssIGl0IG1lYW5zIHdyYXBwZXIuaW5pdGlhbGl6ZSB0aHJldy5cbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUjtcbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSB3cmFwcGVyLmluaXRpYWxpemUgP1xuICAgICAgICAgIHdyYXBwZXIuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpIDpcbiAgICAgICAgICBudWxsO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhW2ldID09PSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUikge1xuICAgICAgICAgIC8vIFRoZSBpbml0aWFsaXplciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBpbml0aWFsaXplIHRoZVxuICAgICAgICAgIC8vIHJlbWFpbmluZyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlXG4gICAgICAgICAgLy8gdGhhdCB0aGUgZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGVhY2ggb2YgYHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycy5jbG9zZVtpXWAgZnVuY3Rpb25zLCBwYXNzaW5nIGludG9cbiAgICogdGhlbSB0aGUgcmVzcGVjdGl2ZSByZXR1cm4gdmFsdWVzIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuaW5pdFtpXWBcbiAgICogKGBjbG9zZWBycyB0aGF0IGNvcnJlc3BvbmQgdG8gaW5pdGlhbGl6ZXJzIHRoYXQgZmFpbGVkIHdpbGwgbm90IGJlXG4gICAqIGludm9rZWQpLlxuICAgKi9cbiAgY2xvc2VBbGw6IGZ1bmN0aW9uKHN0YXJ0SW5kZXgpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgdGhpcy5pc0luVHJhbnNhY3Rpb24oKSxcbiAgICAgICdUcmFuc2FjdGlvbi5jbG9zZUFsbCgpOiBDYW5ub3QgY2xvc2UgdHJhbnNhY3Rpb24gd2hlbiBub25lIGFyZSBvcGVuLidcbiAgICApIDogaW52YXJpYW50KHRoaXMuaXNJblRyYW5zYWN0aW9uKCkpKTtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHZhciBpbml0RGF0YSA9IHRoaXMud3JhcHBlckluaXREYXRhW2ldO1xuICAgICAgdmFyIGVycm9yVGhyb3duO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aFxuICAgICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAgIC8vIHdyYXBwZXIuY2xvc2UgdGhyZXcuXG4gICAgICAgIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluaXREYXRhICE9PSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUikge1xuICAgICAgICAgIHdyYXBwZXIuY2xvc2UgJiYgd3JhcHBlci5jbG9zZS5jYWxsKHRoaXMsIGluaXREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gVGhlIGNsb3NlciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBjbG9zZSB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgLy8gd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZSB0aGF0IHRoZVxuICAgICAgICAgIC8vIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKGkgKyAxKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMud3JhcHBlckluaXREYXRhLmxlbmd0aCA9IDA7XG4gIH1cbn07XG5cbnZhciBUcmFuc2FjdGlvbiA9IHtcblxuICBNaXhpbjogTWl4aW4sXG5cbiAgLyoqXG4gICAqIFRva2VuIHRvIGxvb2sgZm9yIHRvIGRldGVybWluZSBpZiBhbiBlcnJvciBvY2N1cmVkLlxuICAgKi9cbiAgT0JTRVJWRURfRVJST1I6IHt9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb247XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBWaWV3cG9ydE1ldHJpY3NcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uID0gcmVxdWlyZShcIi4vZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb25cIik7XG5cbnZhciBWaWV3cG9ydE1ldHJpY3MgPSB7XG5cbiAgY3VycmVudFNjcm9sbExlZnQ6IDAsXG5cbiAgY3VycmVudFNjcm9sbFRvcDogMCxcblxuICByZWZyZXNoU2Nyb2xsVmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbih3aW5kb3cpO1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdCA9IHNjcm9sbFBvc2l0aW9uLng7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3AgPSBzY3JvbGxQb3NpdGlvbi55O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnRNZXRyaWNzO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgYWNjdW11bGF0ZUludG9cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKlxuICogQWNjdW11bGF0ZXMgaXRlbXMgdGhhdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBpbnRvIHRoZSBmaXJzdCBvbmUuIFRoaXNcbiAqIGlzIHVzZWQgdG8gY29uc2VydmUgbWVtb3J5IGJ5IGF2b2lkaW5nIGFycmF5IGFsbG9jYXRpb25zLCBhbmQgdGh1cyBzYWNyaWZpY2VzXG4gKiBBUEkgY2xlYW5uZXNzLiBTaW5jZSBgY3VycmVudGAgY2FuIGJlIG51bGwgYmVmb3JlIGJlaW5nIHBhc3NlZCBpbiBhbmQgbm90XG4gKiBudWxsIGFmdGVyIHRoaXMgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0byBhc3NpZ24gaXQgYmFjayB0byBgY3VycmVudGA6XG4gKlxuICogYGEgPSBhY2N1bXVsYXRlSW50byhhLCBiKTtgXG4gKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIHNwYXJpbmdseSB1c2VkLiBUcnkgYGFjY3VtdWxhdGVgIGZvciBzb21ldGhpbmcgY2xlYW5lci5cbiAqXG4gKiBAcmV0dXJuIHsqfGFycmF5PCo+fSBBbiBhY2N1bXVsYXRpb24gb2YgaXRlbXMuXG4gKi9cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUludG8oY3VycmVudCwgbmV4dCkge1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIG5leHQgIT0gbnVsbCxcbiAgICAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJ1xuICApIDogaW52YXJpYW50KG5leHQgIT0gbnVsbCkpO1xuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvLyBCb3RoIGFyZSBub3QgZW1wdHkuIFdhcm5pbmc6IE5ldmVyIGNhbGwgeC5jb25jYXQoeSkgd2hlbiB5b3UgYXJlIG5vdFxuICAvLyBjZXJ0YWluIHRoYXQgeCBpcyBhbiBBcnJheSAoeCBjb3VsZCBiZSBhIHN0cmluZyB3aXRoIGNvbmNhdCBtZXRob2QpLlxuICB2YXIgY3VycmVudElzQXJyYXkgPSBBcnJheS5pc0FycmF5KGN1cnJlbnQpO1xuICB2YXIgbmV4dElzQXJyYXkgPSBBcnJheS5pc0FycmF5KG5leHQpO1xuXG4gIGlmIChjdXJyZW50SXNBcnJheSAmJiBuZXh0SXNBcnJheSkge1xuICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChjdXJyZW50SXNBcnJheSkge1xuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChuZXh0SXNBcnJheSkge1xuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWNjdW11bGF0ZUludG87XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhZGxlcjMyXG4gKi9cblxuLyoganNsaW50IGJpdHdpc2U6dHJ1ZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIE1PRCA9IDY1NTIxO1xuXG4vLyBUaGlzIGlzIGEgY2xlYW4tcm9vbSBpbXBsZW1lbnRhdGlvbiBvZiBhZGxlcjMyIGRlc2lnbmVkIGZvciBkZXRlY3Rpbmdcbi8vIGlmIG1hcmt1cCBpcyBub3Qgd2hhdCB3ZSBleHBlY3QgaXQgdG8gYmUuIEl0IGRvZXMgbm90IG5lZWQgdG8gYmVcbi8vIGNyeXB0b2dyYXBoaWNhbGx5IHN0cm9uZywgb25seSByZWFzb25hYmx5IGdvb2QgYXQgZGV0ZWN0aW5nIGlmIG1hcmt1cFxuLy8gZ2VuZXJhdGVkIG9uIHRoZSBzZXJ2ZXIgaXMgZGlmZmVyZW50IHRoYW4gdGhhdCBvbiB0aGUgY2xpZW50LlxuZnVuY3Rpb24gYWRsZXIzMihkYXRhKSB7XG4gIHZhciBhID0gMTtcbiAgdmFyIGIgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBhID0gKGEgKyBkYXRhLmNoYXJDb2RlQXQoaSkpICUgTU9EO1xuICAgIGIgPSAoYiArIGEpICUgTU9EO1xuICB9XG4gIHJldHVybiBhIHwgKGIgPDwgMTYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY2FtZWxpemVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF9oeXBoZW5QYXR0ZXJuID0gLy0oLikvZztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24oXywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY2FtZWxpemVTdHlsZU5hbWVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjYW1lbGl6ZSA9IHJlcXVpcmUoXCIuL2NhbWVsaXplXCIpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjb250YWluc05vZGVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKFwiLi9pc1RleHROb2RlXCIpO1xuXG4vKmpzbGludCBiaXR3aXNlOnRydWUgKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBET00gbm9kZSBjb250YWlucyBvciBpcyBhbm90aGVyIERPTSBub2RlLlxuICpcbiAqIEBwYXJhbSB7P0RPTU5vZGV9IG91dGVyTm9kZSBPdXRlciBET00gbm9kZS5cbiAqIEBwYXJhbSB7P0RPTU5vZGV9IGlubmVyTm9kZSBJbm5lciBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG91dGVyTm9kZWAgY29udGFpbnMgb3IgaXMgYGlubmVyTm9kZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZSkge1xuICBpZiAoIW91dGVyTm9kZSB8fCAhaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZSA9PT0gaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShvdXRlck5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUoaW5uZXJOb2RlKSkge1xuICAgIHJldHVybiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUucGFyZW50Tm9kZSk7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbnRhaW5zKSB7XG4gICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250YWluc05vZGU7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlQXJyYXlGcm9tXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciB0b0FycmF5ID0gcmVxdWlyZShcIi4vdG9BcnJheVwiKTtcblxuLyoqXG4gKiBQZXJmb3JtIGEgaGV1cmlzdGljIHRlc3QgdG8gZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBcImFycmF5LWxpa2VcIi5cbiAqXG4gKiAgIEEgbW9uayBhc2tlZCBKb3NodSwgYSBaZW4gbWFzdGVyLCBcIkhhcyBhIGRvZyBCdWRkaGEgbmF0dXJlP1wiXG4gKiAgIEpvc2h1IHJlcGxpZWQ6IFwiTXUuXCJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgaWYgaXRzIGFyZ3VtZW50IGhhcyBcImFycmF5IG5hdHVyZVwiOiBpdCByZXR1cm5zXG4gKiB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhY3R1YWwgYXJyYXksIGFuIGBhcmd1bWVudHMnIG9iamVjdCwgb3IgYW5cbiAqIEhUTUxDb2xsZWN0aW9uIChlLmcuIG5vZGUuY2hpbGROb2RlcyBvciBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCkpLlxuICpcbiAqIEl0IHdpbGwgcmV0dXJuIGZhbHNlIGZvciBvdGhlciBhcnJheS1saWtlIG9iamVjdHMgbGlrZSBGaWxlbGlzdC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzQXJyYXlOYXR1cmUob2JqKSB7XG4gIHJldHVybiAoXG4gICAgLy8gbm90IG51bGwvZmFsc2VcbiAgICAhIW9iaiAmJlxuICAgIC8vIGFycmF5cyBhcmUgb2JqZWN0cywgTm9kZUxpc3RzIGFyZSBmdW5jdGlvbnMgaW4gU2FmYXJpXG4gICAgKHR5cGVvZiBvYmogPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nKSAmJlxuICAgIC8vIHF1YWNrcyBsaWtlIGFuIGFycmF5XG4gICAgKCdsZW5ndGgnIGluIG9iaikgJiZcbiAgICAvLyBub3Qgd2luZG93XG4gICAgISgnc2V0SW50ZXJ2YWwnIGluIG9iaikgJiZcbiAgICAvLyBubyBET00gbm9kZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhbiBhcnJheS1saWtlXG4gICAgLy8gYSAnc2VsZWN0JyBlbGVtZW50IGhhcyAnbGVuZ3RoJyBhbmQgJ2l0ZW0nIHByb3BlcnRpZXMgb24gSUU4XG4gICAgKHR5cGVvZiBvYmoubm9kZVR5cGUgIT0gJ251bWJlcicpICYmXG4gICAgKFxuICAgICAgLy8gYSByZWFsIGFycmF5XG4gICAgICAoLy8gSFRNTENvbGxlY3Rpb24vTm9kZUxpc3RcbiAgICAgIChBcnJheS5pc0FycmF5KG9iaikgfHxcbiAgICAgIC8vIGFyZ3VtZW50c1xuICAgICAgKCdjYWxsZWUnIGluIG9iaikgfHwgJ2l0ZW0nIGluIG9iaikpXG4gICAgKVxuICApO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBieSB3cmFwcGluZyBpdCBpbiBhbiBhcnJheSBpZiBpdCBpcyBub3QuXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgYXJndW1lbnQgaWYgaXQgaXMgYWxyZWFkeSBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgaWRpb21hdGljYWxseTpcbiAqXG4gKiAgIHZhciBjcmVhdGVBcnJheUZyb20gPSByZXF1aXJlKCdjcmVhdGVBcnJheUZyb20nKTtcbiAqXG4gKiAgIGZ1bmN0aW9uIHRha2VzT25lT3JNb3JlVGhpbmdzKHRoaW5ncykge1xuICogICAgIHRoaW5ncyA9IGNyZWF0ZUFycmF5RnJvbSh0aGluZ3MpO1xuICogICAgIC4uLlxuICogICB9XG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyZWF0IGB0aGluZ3MnIGFzIGFuIGFycmF5LCBidXQgYWNjZXB0IHNjYWxhcnMgaW4gdGhlIEFQSS5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0byBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBsaWtlIGBhcmd1bWVudHNgLCBpbnRvIGFuIGFycmF5XG4gKiB1c2UgdG9BcnJheSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tKG9iaikge1xuICBpZiAoIWhhc0FycmF5TmF0dXJlKG9iaikpIHtcbiAgICByZXR1cm4gW29ial07XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0b0FycmF5KG9iaik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBcnJheUZyb207XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNyZWF0ZUZ1bGxQYWdlQ29tcG9uZW50XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBEZWZlYXQgY2lyY3VsYXIgcmVmZXJlbmNlcyBieSByZXF1aXJpbmcgdGhpcyBkaXJlY3RseS5cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBjb21wb25lbnQgdGhhdCB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiB3aGVuIHVubW91bnRlZC5cbiAqXG4gKiBDb21wb25lbnRzIGxpa2UgPGh0bWw+IDxoZWFkPiBhbmQgPGJvZHk+IGNhbid0IGJlIHJlbW92ZWQgb3IgYWRkZWRcbiAqIGVhc2lseSBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LCBob3dldmVyIGl0J3MgdmFsdWFibGUgdG8gYmUgYWJsZSB0b1xuICogdGFrZSBhZHZhbnRhZ2Ugb2YgUmVhY3QncyByZWNvbmNpbGlhdGlvbiBmb3Igc3R5bGluZyBhbmQgPHRpdGxlPlxuICogbWFuYWdlbWVudC4gU28gd2UganVzdCBkb2N1bWVudCBpdCBhbmQgdGhyb3cgaW4gZGFuZ2Vyb3VzIGNhc2VzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIHRhZyB0byB3cmFwXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gY29udmVuaWVuY2UgY29uc3RydWN0b3Igb2YgbmV3IGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVGdWxsUGFnZUNvbXBvbmVudCh0YWcpIHtcbiAgdmFyIGVsZW1lbnRGYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkodGFnKTtcblxuICB2YXIgRnVsbFBhZ2VDb21wb25lbnQgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5jcmVhdGVDbGFzcyh7XG4gICAgZGlzcGxheU5hbWU6ICdSZWFjdEZ1bGxQYWdlQ29tcG9uZW50JyArIHRhZyxcblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnJXMgdHJpZWQgdG8gdW5tb3VudC4gQmVjYXVzZSBvZiBjcm9zcy1icm93c2VyIHF1aXJrcyBpdCBpcyAnICtcbiAgICAgICAgJ2ltcG9zc2libGUgdG8gdW5tb3VudCBzb21lIHRvcC1sZXZlbCBjb21wb25lbnRzIChlZyA8aHRtbD4sIDxoZWFkPiwgJyArXG4gICAgICAgICdhbmQgPGJvZHk+KSByZWxpYWJseSBhbmQgZWZmaWNpZW50bHkuIFRvIGZpeCB0aGlzLCBoYXZlIGEgc2luZ2xlICcgK1xuICAgICAgICAndG9wLWxldmVsIGNvbXBvbmVudCB0aGF0IG5ldmVyIHVubW91bnRzIHJlbmRlciB0aGVzZSBlbGVtZW50cy4nLFxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lXG4gICAgICApIDogaW52YXJpYW50KGZhbHNlKSk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZWxlbWVudEZhY3RvcnkodGhpcy5wcm9wcyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gRnVsbFBhZ2VDb21wb25lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRnVsbFBhZ2VDb21wb25lbnQ7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlTm9kZXNGcm9tTWFya3VwXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qanNsaW50IGV2aWw6IHRydWUsIHN1YjogdHJ1ZSAqL1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxudmFyIGNyZWF0ZUFycmF5RnJvbSA9IHJlcXVpcmUoXCIuL2NyZWF0ZUFycmF5RnJvbVwiKTtcbnZhciBnZXRNYXJrdXBXcmFwID0gcmVxdWlyZShcIi4vZ2V0TWFya3VwV3JhcFwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gcmVuZGVyIGFsbCBtYXJrdXAuXG4gKi9cbnZhciBkdW1teU5vZGUgPVxuICBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogUGF0dGVybiB1c2VkIGJ5IGBnZXROb2RlTmFtZWAuXG4gKi9cbnZhciBub2RlTmFtZVBhdHRlcm4gPSAvXlxccyo8KFxcdyspLztcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYG5vZGVOYW1lYCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIHN0cmluZyBvZiBtYXJrdXAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICogQHJldHVybiB7P3N0cmluZ30gTm9kZSBuYW1lIG9mIHRoZSBzdXBwbGllZCBtYXJrdXAuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG1hcmt1cCkge1xuICB2YXIgbm9kZU5hbWVNYXRjaCA9IG1hcmt1cC5tYXRjaChub2RlTmFtZVBhdHRlcm4pO1xuICByZXR1cm4gbm9kZU5hbWVNYXRjaCAmJiBub2RlTmFtZU1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBub2RlcyByZW5kZXJlZCBmcm9tIHRoZSBzdXBwbGllZCBtYXJrdXAuIFRoZVxuICogb3B0aW9uYWxseSBzdXBwbGllZCBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgb25jZSBmb3IgZWFjaFxuICogPHNjcmlwdD4gZWxlbWVudCB0aGF0IGlzIHJlbmRlcmVkLiBJZiBubyBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiBpcyBzdXBwbGllZCxcbiAqIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgYW55IDxzY3JpcHQ+IGVsZW1lbnRzIGFyZSByZW5kZXJlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIEEgc3RyaW5nIG9mIHZhbGlkIEhUTUwgbWFya3VwLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGhhbmRsZVNjcmlwdCBJbnZva2VkIG9uY2UgZm9yIGVhY2ggcmVuZGVyZWQgPHNjcmlwdD4uXG4gKiBAcmV0dXJuIHthcnJheTxET01FbGVtZW50fERPTVRleHROb2RlPn0gQW4gYXJyYXkgb2YgcmVuZGVyZWQgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGhhbmRsZVNjcmlwdCkge1xuICB2YXIgbm9kZSA9IGR1bW15Tm9kZTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudCghIWR1bW15Tm9kZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCBkdW1teSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudCghIWR1bW15Tm9kZSkpO1xuICB2YXIgbm9kZU5hbWUgPSBnZXROb2RlTmFtZShtYXJrdXApO1xuXG4gIHZhciB3cmFwID0gbm9kZU5hbWUgJiYgZ2V0TWFya3VwV3JhcChub2RlTmFtZSk7XG4gIGlmICh3cmFwKSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSB3cmFwWzFdICsgbWFya3VwICsgd3JhcFsyXTtcblxuICAgIHZhciB3cmFwRGVwdGggPSB3cmFwWzBdO1xuICAgIHdoaWxlICh3cmFwRGVwdGgtLSkge1xuICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IG1hcmt1cDtcbiAgfVxuXG4gIHZhciBzY3JpcHRzID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gIGlmIChzY3JpcHRzLmxlbmd0aCkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBoYW5kbGVTY3JpcHQsXG4gICAgICAnY3JlYXRlTm9kZXNGcm9tTWFya3VwKC4uLik6IFVuZXhwZWN0ZWQgPHNjcmlwdD4gZWxlbWVudCByZW5kZXJlZC4nXG4gICAgKSA6IGludmFyaWFudChoYW5kbGVTY3JpcHQpKTtcbiAgICBjcmVhdGVBcnJheUZyb20oc2NyaXB0cykuZm9yRWFjaChoYW5kbGVTY3JpcHQpO1xuICB9XG5cbiAgdmFyIG5vZGVzID0gY3JlYXRlQXJyYXlGcm9tKG5vZGUuY2hpbGROb2Rlcyk7XG4gIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICB9XG4gIHJldHVybiBub2Rlcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXA7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBkYW5nZXJvdXNTdHlsZVZhbHVlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKFwiLi9DU1NQcm9wZXJ0eVwiKTtcblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlKSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgaXNOb25OdW1lcmljID0gaXNOYU4odmFsdWUpO1xuICBpZiAoaXNOb25OdW1lcmljIHx8IHZhbHVlID09PSAwIHx8XG4gICAgICBpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTsgLy8gY2FzdCB0byBzdHJpbmdcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlICsgJ3B4Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkYW5nZXJvdXNTdHlsZVZhbHVlO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBkZXByZWNhdGVkXG4gKi9cblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoXCIuL09iamVjdC5hc3NpZ25cIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbi8qKlxuICogVGhpcyB3aWxsIGxvZyBhIHNpbmdsZSBkZXByZWNhdGlvbiBub3RpY2UgcGVyIGZ1bmN0aW9uIGFuZCBmb3J3YXJkIHRoZSBjYWxsXG4gKiBvbiB0byB0aGUgbmV3IEFQSS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugb2YgdGhlIGNhbGwsIGVnICdSZWFjdCdcbiAqIEBwYXJhbSB7c3RyaW5nfSBvbGROYW1lIFRoZSBvbGQgZnVuY3Rpb24gbmFtZSwgZWcgJ3JlbmRlckNvbXBvbmVudCdcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdOYW1lIFRoZSBuZXcgZnVuY3Rpb24gbmFtZSwgZWcgJ3JlbmRlcidcbiAqIEBwYXJhbSB7Kn0gY3R4IFRoZSBjb250ZXh0IHRoaXMgZm9yd2FyZGVkIGNhbGwgc2hvdWxkIHJ1biBpblxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGZvcndhcmQgb24gdG9cbiAqIEByZXR1cm4geyp9IFdpbGwgYmUgdGhlIHZhbHVlIGFzIHJldHVybmVkIGZyb20gYGZuYFxuICovXG5mdW5jdGlvbiBkZXByZWNhdGVkKG5hbWVzcGFjZSwgb2xkTmFtZSwgbmV3TmFtZSwgY3R4LCBmbikge1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICB2YXIgbmV3Rm4gPSBmdW5jdGlvbigpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFxuICAgICAgICB3YXJuZWQsXG4gICAgICAgIChuYW1lc3BhY2UgKyBcIi5cIiArIG9sZE5hbWUgKyBcIiB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gXCIpICtcbiAgICAgICAgKFwiVXNlIFwiICsgbmFtZXNwYWNlICsgXCIuXCIgKyBuZXdOYW1lICsgXCIgaW5zdGVhZC5cIilcbiAgICAgICkgOiBudWxsKTtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgbmV3Rm4uZGlzcGxheU5hbWUgPSAobmFtZXNwYWNlICsgXCJfXCIgKyBvbGROYW1lKTtcbiAgICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSBhbGwgcHJvcGVydGllcyBvZiB0aGUgb3JpZ2luYWwgZm4gYXJlIGNvcGllZCBvdmVyLlxuICAgIC8vIEluIHBhcnRpY3VsYXIsIHRoaXMgaXMgbmVlZGVkIHRvIHN1cHBvcnQgUHJvcFR5cGVzXG4gICAgcmV0dXJuIGFzc2lnbihuZXdGbiwgZm4pO1xuICB9XG5cbiAgcmV0dXJuIGZuO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZWQ7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlbXB0eUZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbihhcmcpIHsgcmV0dXJuIGFyZzsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlbXB0eU9iamVjdFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVzY2FwZVRleHRGb3JCcm93c2VyXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRVNDQVBFX0xPT0tVUCA9IHtcbiAgXCImXCI6IFwiJmFtcDtcIixcbiAgXCI+XCI6IFwiJmd0O1wiLFxuICBcIjxcIjogXCImbHQ7XCIsXG4gIFwiXFxcIlwiOiBcIiZxdW90O1wiLFxuICBcIidcIjogXCImI3gyNztcIlxufTtcblxudmFyIEVTQ0FQRV9SRUdFWCA9IC9bJj48XCInXS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVyKG1hdGNoKSB7XG4gIHJldHVybiBFU0NBUEVfTE9PS1VQW21hdGNoXTtcbn1cblxuLyoqXG4gKiBFc2NhcGVzIHRleHQgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHRleHQgVGV4dCB2YWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKEVTQ0FQRV9SRUdFWCwgZXNjYXBlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXNjYXBlVGV4dEZvckJyb3dzZXI7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZsYXR0ZW5DaGlsZHJlblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RUZXh0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RUZXh0Q29tcG9uZW50XCIpO1xuXG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoXCIuL3RyYXZlcnNlQWxsQ2hpbGRyZW5cIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgcGFzc2VkIHRocm91Z2ggdHJhdmVyc2FsLlxuICogQHBhcmFtIHs/UmVhY3RDb21wb25lbnR9IGNoaWxkIFJlYWN0IGNoaWxkIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZSBTdHJpbmcgbmFtZSBvZiBrZXkgcGF0aCB0byBjaGlsZC5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgdmFyIHJlc3VsdCA9IHRyYXZlcnNlQ29udGV4dDtcbiAgdmFyIGtleVVuaXF1ZSA9ICFyZXN1bHQuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFxuICAgIGtleVVuaXF1ZSxcbiAgICAnZmxhdHRlbkNoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArXG4gICAgJ2Alc2AuIENoaWxkIGtleXMgbXVzdCBiZSB1bmlxdWU7IHdoZW4gdHdvIGNoaWxkcmVuIHNoYXJlIGEga2V5LCBvbmx5ICcgK1xuICAgICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLicsXG4gICAgbmFtZVxuICApIDogbnVsbCk7XG4gIGlmIChrZXlVbmlxdWUgJiYgY2hpbGQgIT0gbnVsbCkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkO1xuICAgIHZhciBub3JtYWxpemVkVmFsdWU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5vcm1hbGl6ZWRWYWx1ZSA9IFJlYWN0VGV4dENvbXBvbmVudChjaGlsZCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgbm9ybWFsaXplZFZhbHVlID0gUmVhY3RUZXh0Q29tcG9uZW50KCcnICsgY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3JtYWxpemVkVmFsdWUgPSBjaGlsZDtcbiAgICB9XG5cbiAgICByZXN1bHRbbmFtZV0gPSBub3JtYWxpemVkVmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBGbGF0dGVucyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuIEFueSBudWxsXG4gKiBjaGlsZHJlbiB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqIEByZXR1cm4geyFvYmplY3R9IGZsYXR0ZW5lZCBjaGlsZHJlbiBrZXllZCBieSBuYW1lLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuQ2hpbGRyZW47XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZm9jdXNOb2RlXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIGlucHV0L3RleHRhcmVhIHRvIGZvY3VzXG4gKi9cbmZ1bmN0aW9uIGZvY3VzTm9kZShub2RlKSB7XG4gIC8vIElFOCBjYW4gdGhyb3cgXCJDYW4ndCBtb3ZlIGZvY3VzIHRvIHRoZSBjb250cm9sIGJlY2F1c2UgaXQgaXMgaW52aXNpYmxlLFxuICAvLyBub3QgZW5hYmxlZCwgb3Igb2YgYSB0eXBlIHRoYXQgZG9lcyBub3QgYWNjZXB0IHRoZSBmb2N1cy5cIiBmb3IgYWxsIGtpbmRzIG9mXG4gIC8vIHJlYXNvbnMgdGhhdCBhcmUgdG9vIGV4cGVuc2l2ZSBhbmQgZnJhZ2lsZSB0byB0ZXN0LlxuICB0cnkge1xuICAgIG5vZGUuZm9jdXMoKTtcbiAgfSBjYXRjaChlKSB7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c05vZGU7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZm9yRWFjaEFjY3VtdWxhdGVkXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQHBhcmFtIHthcnJheX0gYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqL1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IGZ1bmN0aW9uKGFyciwgY2IsIHNjb3BlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBhcnIuZm9yRWFjaChjYiwgc2NvcGUpO1xuICB9IGVsc2UgaWYgKGFycikge1xuICAgIGNiLmNhbGwoc2NvcGUsIGFycik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaEFjY3VtdWxhdGVkO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEFjdGl2ZUVsZW1lbnRcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBTYW1lIGFzIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYnV0IHdyYXBzIGluIGEgdHJ5LWNhdGNoIGJsb2NrLiBJbiBJRSBpdCBpc1xuICogbm90IHNhZmUgdG8gY2FsbCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9jdXNlZC5cbiAqXG4gKiBUaGUgYWN0aXZlRWxlbWVudCB3aWxsIGJlIG51bGwgb25seSBpZiB0aGUgZG9jdW1lbnQgYm9keSBpcyBub3QgeWV0IGRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQoKSAvKj9ET01FbGVtZW50Ki8ge1xuICB0cnkge1xuICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRDaGFyQ29kZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGU7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7XG5cbiAgICAvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfVxuXG4gIC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuICBpZiAoY2hhckNvZGUgPj0gMzIgfHwgY2hhckNvZGUgPT09IDEzKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRDaGFyQ29kZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudEtleVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKFwiLi9nZXRFdmVudENoYXJDb2RlXCIpO1xuXG4vKipcbiAqIE5vcm1hbGl6YXRpb24gb2YgZGVwcmVjYXRlZCBIVE1MNSBga2V5YCB2YWx1ZXNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gICdFc2MnOiAnRXNjYXBlJyxcbiAgJ1NwYWNlYmFyJzogJyAnLFxuICAnTGVmdCc6ICdBcnJvd0xlZnQnLFxuICAnVXAnOiAnQXJyb3dVcCcsXG4gICdSaWdodCc6ICdBcnJvd1JpZ2h0JyxcbiAgJ0Rvd24nOiAnQXJyb3dEb3duJyxcbiAgJ0RlbCc6ICdEZWxldGUnLFxuICAnV2luJzogJ09TJyxcbiAgJ01lbnUnOiAnQ29udGV4dE1lbnUnLFxuICAnQXBwcyc6ICdDb250ZXh0TWVudScsXG4gICdTY3JvbGwnOiAnU2Nyb2xsTG9jaycsXG4gICdNb3pQcmludGFibGVLZXknOiAnVW5pZGVudGlmaWVkJ1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIGxlZ2FjeSBga2V5Q29kZWAgdG8gSFRNTDUgYGtleWBcbiAqIE9ubHkgc3BlY2lhbCBrZXlzIHN1cHBvcnRlZCwgYWxsIG90aGVycyBkZXBlbmQgb24ga2V5Ym9hcmQgbGF5b3V0IG9yIGJyb3dzZXJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgODogJ0JhY2tzcGFjZScsXG4gIDk6ICdUYWInLFxuICAxMjogJ0NsZWFyJyxcbiAgMTM6ICdFbnRlcicsXG4gIDE2OiAnU2hpZnQnLFxuICAxNzogJ0NvbnRyb2wnLFxuICAxODogJ0FsdCcsXG4gIDE5OiAnUGF1c2UnLFxuICAyMDogJ0NhcHNMb2NrJyxcbiAgMjc6ICdFc2NhcGUnLFxuICAzMjogJyAnLFxuICAzMzogJ1BhZ2VVcCcsXG4gIDM0OiAnUGFnZURvd24nLFxuICAzNTogJ0VuZCcsXG4gIDM2OiAnSG9tZScsXG4gIDM3OiAnQXJyb3dMZWZ0JyxcbiAgMzg6ICdBcnJvd1VwJyxcbiAgMzk6ICdBcnJvd1JpZ2h0JyxcbiAgNDA6ICdBcnJvd0Rvd24nLFxuICA0NTogJ0luc2VydCcsXG4gIDQ2OiAnRGVsZXRlJyxcbiAgMTEyOiAnRjEnLCAxMTM6ICdGMicsIDExNDogJ0YzJywgMTE1OiAnRjQnLCAxMTY6ICdGNScsIDExNzogJ0Y2JyxcbiAgMTE4OiAnRjcnLCAxMTk6ICdGOCcsIDEyMDogJ0Y5JywgMTIxOiAnRjEwJywgMTIyOiAnRjExJywgMTIzOiAnRjEyJyxcbiAgMTQ0OiAnTnVtTG9jaycsXG4gIDE0NTogJ1Njcm9sbExvY2snLFxuICAyMjQ6ICdNZXRhJ1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG5cbiAgICAvLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxuICAgIC8vIHByaW50YWJsZSBjaGFyYWN0ZXJzIChub3JtYWxpemVkIHRvIGBVbmlkZW50aWZpZWRgKSwgaWdub3JlIGl0LlxuICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG5cbiAgLy8gQnJvd3NlciBkb2VzIG5vdCBpbXBsZW1lbnQgYGtleWAsIHBvbHlmaWxsIGFzIG11Y2ggb2YgaXQgYXMgd2UgY2FuLlxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgIHZhciBjaGFyQ29kZSA9IGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpO1xuXG4gICAgLy8gVGhlIGVudGVyLWtleSBpcyB0ZWNobmljYWxseSBib3RoIHByaW50YWJsZSBhbmQgbm9uLXByaW50YWJsZSBhbmQgY2FuXG4gICAgLy8gdGh1cyBiZSBjYXB0dXJlZCBieSBga2V5cHJlc3NgLCBubyBvdGhlciBub24tcHJpbnRhYmxlIGtleSBzaG91bGQuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgfVxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAvLyBXaGlsZSB1c2VyIGtleWJvYXJkIGxheW91dCBkZXRlcm1pbmVzIHRoZSBhY3R1YWwgbWVhbmluZyBvZiBlYWNoXG4gICAgLy8gYGtleUNvZGVgIHZhbHVlLCBhbG1vc3QgYWxsIGZ1bmN0aW9uIGtleXMgaGF2ZSBhIHVuaXZlcnNhbCB2YWx1ZS5cbiAgICByZXR1cm4gdHJhbnNsYXRlVG9LZXlbbmF0aXZlRXZlbnQua2V5Q29kZV0gfHwgJ1VuaWRlbnRpZmllZCc7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50S2V5O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gICdBbHQnOiAnYWx0S2V5JyxcbiAgJ0NvbnRyb2wnOiAnY3RybEtleScsXG4gICdNZXRhJzogJ21ldGFLZXknLFxuICAnU2hpZnQnOiAnc2hpZnRLZXknXG59O1xuXG4vLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGdldE1vZGlmaWVyU3RhdGUgc28gd2Ugc2ltcGx5IG1hcCBpdCB0byB0aGUgb25seVxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudCBpdHNlbGYsIGRvZXMgbm90IHN1cHBvcnQgTG9jay1rZXlzLlxuLy8gQ3VycmVudGx5LCBhbGwgbWFqb3IgYnJvd3NlcnMgZXhjZXB0IENocm9tZSBzZWVtcyB0byBzdXBwb3J0IExvY2sta2V5cy5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XG4gIHZhciBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cbiAgdmFyIGtleVByb3AgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddO1xuICByZXR1cm4ga2V5UHJvcCA/ICEhbmF0aXZlRXZlbnRba2V5UHJvcF0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50TW9kaWZpZXJTdGF0ZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudFRhcmdldFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcbiAgLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gMyA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50VGFyZ2V0O1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRNYXJrdXBXcmFwXG4gKi9cblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gZGV0ZWN0IHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkuXG4gKi9cbnZhciBkdW1teU5vZGUgPVxuICBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogU29tZSBicm93c2VycyBjYW5ub3QgdXNlIGBpbm5lckhUTUxgIHRvIHJlbmRlciBjZXJ0YWluIGVsZW1lbnRzIHN0YW5kYWxvbmUsXG4gKiBzbyB3ZSB3cmFwIHRoZW0sIHJlbmRlciB0aGUgd3JhcHBlZCBub2RlcywgdGhlbiBleHRyYWN0IHRoZSBkZXNpcmVkIG5vZGUuXG4gKlxuICogSW4gSUU4LCBjZXJ0YWluIGVsZW1lbnRzIGNhbm5vdCByZW5kZXIgYWxvbmUsIHNvIHdyYXAgYWxsIGVsZW1lbnRzICgnKicpLlxuICovXG52YXIgc2hvdWxkV3JhcCA9IHtcbiAgLy8gRm9yY2Ugd3JhcHBpbmcgZm9yIFNWRyBlbGVtZW50cyBiZWNhdXNlIGlmIHRoZXkgZ2V0IGNyZWF0ZWQgaW5zaWRlIGEgPGRpdj4sXG4gIC8vIHRoZXkgd2lsbCBiZSBpbml0aWFsaXplZCBpbiB0aGUgd3JvbmcgbmFtZXNwYWNlIChhbmQgd2lsbCBub3QgZGlzcGxheSkuXG4gICdjaXJjbGUnOiB0cnVlLFxuICAnZGVmcyc6IHRydWUsXG4gICdlbGxpcHNlJzogdHJ1ZSxcbiAgJ2cnOiB0cnVlLFxuICAnbGluZSc6IHRydWUsXG4gICdsaW5lYXJHcmFkaWVudCc6IHRydWUsXG4gICdwYXRoJzogdHJ1ZSxcbiAgJ3BvbHlnb24nOiB0cnVlLFxuICAncG9seWxpbmUnOiB0cnVlLFxuICAncmFkaWFsR3JhZGllbnQnOiB0cnVlLFxuICAncmVjdCc6IHRydWUsXG4gICdzdG9wJzogdHJ1ZSxcbiAgJ3RleHQnOiB0cnVlXG59O1xuXG52YXIgc2VsZWN0V3JhcCA9IFsxLCAnPHNlbGVjdCBtdWx0aXBsZT1cInRydWVcIj4nLCAnPC9zZWxlY3Q+J107XG52YXIgdGFibGVXcmFwID0gWzEsICc8dGFibGU+JywgJzwvdGFibGU+J107XG52YXIgdHJXcmFwID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XG5cbnZhciBzdmdXcmFwID0gWzEsICc8c3ZnPicsICc8L3N2Zz4nXTtcblxudmFyIG1hcmt1cFdyYXAgPSB7XG4gICcqJzogWzEsICc/PGRpdj4nLCAnPC9kaXY+J10sXG5cbiAgJ2FyZWEnOiBbMSwgJzxtYXA+JywgJzwvbWFwPiddLFxuICAnY29sJzogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J10sXG4gICdsZWdlbmQnOiBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcbiAgJ3BhcmFtJzogWzEsICc8b2JqZWN0PicsICc8L29iamVjdD4nXSxcbiAgJ3RyJzogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG5cbiAgJ29wdGdyb3VwJzogc2VsZWN0V3JhcCxcbiAgJ29wdGlvbic6IHNlbGVjdFdyYXAsXG5cbiAgJ2NhcHRpb24nOiB0YWJsZVdyYXAsXG4gICdjb2xncm91cCc6IHRhYmxlV3JhcCxcbiAgJ3Rib2R5JzogdGFibGVXcmFwLFxuICAndGZvb3QnOiB0YWJsZVdyYXAsXG4gICd0aGVhZCc6IHRhYmxlV3JhcCxcblxuICAndGQnOiB0cldyYXAsXG4gICd0aCc6IHRyV3JhcCxcblxuICAnY2lyY2xlJzogc3ZnV3JhcCxcbiAgJ2RlZnMnOiBzdmdXcmFwLFxuICAnZWxsaXBzZSc6IHN2Z1dyYXAsXG4gICdnJzogc3ZnV3JhcCxcbiAgJ2xpbmUnOiBzdmdXcmFwLFxuICAnbGluZWFyR3JhZGllbnQnOiBzdmdXcmFwLFxuICAncGF0aCc6IHN2Z1dyYXAsXG4gICdwb2x5Z29uJzogc3ZnV3JhcCxcbiAgJ3BvbHlsaW5lJzogc3ZnV3JhcCxcbiAgJ3JhZGlhbEdyYWRpZW50Jzogc3ZnV3JhcCxcbiAgJ3JlY3QnOiBzdmdXcmFwLFxuICAnc3RvcCc6IHN2Z1dyYXAsXG4gICd0ZXh0Jzogc3ZnV3JhcFxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uIGZvciB0aGUgc3VwcGxpZWQgYG5vZGVOYW1lYC5cbiAqXG4gKiBOT1RFOiBUaGlzIGxhemlseSBkZXRlY3RzIHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVOYW1lIExvd2VyY2FzZSBgbm9kZU5hbWVgLlxuICogQHJldHVybiB7P2FycmF5fSBNYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uLCBpZiBhcHBsaWNhYmxlLlxuICovXG5mdW5jdGlvbiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKSB7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoISFkdW1teU5vZGUsICdNYXJrdXAgd3JhcHBpbmcgbm9kZSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudCghIWR1bW15Tm9kZSkpO1xuICBpZiAoIW1hcmt1cFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgbm9kZU5hbWUgPSAnKic7XG4gIH1cbiAgaWYgKCFzaG91bGRXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIGlmIChub2RlTmFtZSA9PT0gJyonKSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzxsaW5rIC8+JztcbiAgICB9IGVsc2Uge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8JyArIG5vZGVOYW1lICsgJz48LycgKyBub2RlTmFtZSArICc+JztcbiAgICB9XG4gICAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSAhZHVtbXlOb2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIHNob3VsZFdyYXBbbm9kZU5hbWVdID8gbWFya3VwV3JhcFtub2RlTmFtZV0gOiBudWxsO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFya3VwV3JhcDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXG4gKiBET00gaWYgYSBub2RlJ3Mgc2libGluZ3MgaGF2ZSBiZWVuIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBET0NfTk9ERV9UWVBFID0gOTtcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NRG9jdW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IG1heSBjb250YWluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIFJlYWN0IGNvbXBvbmVudFxuICogQHJldHVybiB7Pyp9IERPTSBlbGVtZW50IHRoYXQgbWF5IGhhdmUgdGhlIHJlYWN0Um9vdCBJRCwgb3IgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRUZXh0Q29udGVudEFjY2Vzc29yXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xuXG52YXIgY29udGVudEtleSA9IG51bGw7XG5cbi8qKlxuICogR2V0cyB0aGUga2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudCBvbiBhIERPTSBub2RlLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IEtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpIHtcbiAgaWYgKCFjb250ZW50S2V5ICYmIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAgIC8vIFByZWZlciB0ZXh0Q29udGVudCB0byBpbm5lclRleHQgYmVjYXVzZSBtYW55IGJyb3dzZXJzIHN1cHBvcnQgYm90aCBidXRcbiAgICAvLyBTVkcgPHRleHQ+IGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgaW5uZXJUZXh0IGV2ZW4gd2hlbiA8ZGl2PiBkb2VzLlxuICAgIGNvbnRlbnRLZXkgPSAndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/XG4gICAgICAndGV4dENvbnRlbnQnIDpcbiAgICAgICdpbm5lclRleHQnO1xuICB9XG4gIHJldHVybiBjb250ZW50S2V5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRleHRDb250ZW50QWNjZXNzb3I7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb25cbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBzdXBwbGllZCBlbGVtZW50IG9yIHdpbmRvdy5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlcyBhcmUgdW5ib3VuZGVkLCB1bmxpa2UgYGdldFNjcm9sbFBvc2l0aW9uYC4gVGhpcyBtZWFucyB0aGV5XG4gKiBtYXkgYmUgbmVnYXRpdmUgb3IgZXhjZWVkIHRoZSBlbGVtZW50IGJvdW5kYXJpZXMgKHdoaWNoIGlzIHBvc3NpYmxlIHVzaW5nXG4gKiBpbmVydGlhbCBzY3JvbGxpbmcpLlxuICpcbiAqIEBwYXJhbSB7RE9NV2luZG93fERPTUVsZW1lbnR9IHNjcm9sbGFibGVcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwIHdpdGggYHhgIGFuZCBgeWAga2V5cy5cbiAqL1xuZnVuY3Rpb24gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24oc2Nyb2xsYWJsZSkge1xuICBpZiAoc2Nyb2xsYWJsZSA9PT0gd2luZG93KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHNjcm9sbGFibGUuc2Nyb2xsTGVmdCxcbiAgICB5OiBzY3JvbGxhYmxlLnNjcm9sbFRvcFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGh5cGhlbmF0ZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgX3VwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICpcbiAqIEZvciBDU1Mgc3R5bGUgbmFtZXMsIHVzZSBgaHlwaGVuYXRlU3R5bGVOYW1lYCBpbnN0ZWFkIHdoaWNoIHdvcmtzIHByb3Blcmx5XG4gKiB3aXRoIGFsbCB2ZW5kb3IgcHJlZml4ZXMsIGluY2x1ZGluZyBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX3VwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBoeXBoZW5hdGVTdHlsZU5hbWVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKFwiLi9oeXBoZW5hdGVcIik7XG5cbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gaHlwaGVuYXRlKHN0cmluZykucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlU3R5bGVOYW1lO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVsZW1lbnRcIik7XG52YXIgUmVhY3RMZWdhY3lFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RMZWdhY3lFbGVtZW50XCIpO1xudmFyIFJlYWN0TmF0aXZlQ29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3ROYXRpdmVDb21wb25lbnRcIik7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RW1wdHlDb21wb25lbnRcIik7XG5cbi8qKlxuICogR2l2ZW4gYW4gYGVsZW1lbnRgIGNyZWF0ZSBhbiBpbnN0YW5jZSB0aGF0IHdpbGwgYWN0dWFsbHkgYmUgbW91bnRlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudFxuICogQHBhcmFtIHsqfSBwYXJlbnRDb21wb3NpdGVUeXBlIFRoZSBjb21wb3NpdGUgdHlwZSB0aGF0IHJlc29sdmVkIHRoaXMuXG4gKiBAcmV0dXJuIHtvYmplY3R9IEEgbmV3IGluc3RhbmNlIG9mIHRoZSBlbGVtZW50J3MgY29uc3RydWN0b3IuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoZWxlbWVudCwgcGFyZW50Q29tcG9zaXRlVHlwZSkge1xuICB2YXIgaW5zdGFuY2U7XG5cbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFxuICAgICAgZWxlbWVudCAmJiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpLFxuICAgICAgJ09ubHkgZnVuY3Rpb25zIG9yIHN0cmluZ3MgY2FuIGJlIG1vdW50ZWQgYXMgUmVhY3QgY29tcG9uZW50cy4nXG4gICAgKSA6IG51bGwpO1xuXG4gICAgLy8gUmVzb2x2ZSBtb2NrIGluc3RhbmNlc1xuICAgIGlmIChlbGVtZW50LnR5cGUuX21vY2tlZFJlYWN0Q2xhc3NDb25zdHJ1Y3Rvcikge1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIG1vY2tlZCBjbGFzcywgd2UgdHJlYXQgdGhlIGxlZ2FjeSBmYWN0b3J5IGFzIGlmIGl0IHdhcyB0aGVcbiAgICAgIC8vIGNsYXNzIGNvbnN0cnVjdG9yIGZvciBmdXR1cmUgcHJvb2ZpbmcgdW5pdCB0ZXN0cy4gQmVjYXVzZSB0aGlzIG1pZ2h0XG4gICAgICAvLyBiZSBtb2NrZWQgYXMgYSBsZWdhY3kgZmFjdG9yeSwgd2UgaWdub3JlIGFueSB3YXJuaW5ncyB0cmlnZ2VyZCBieVxuICAgICAgLy8gdGhpcyB0ZW1wb3JhcnkgaGFjay5cbiAgICAgIFJlYWN0TGVnYWN5RWxlbWVudC5faXNMZWdhY3lDYWxsV2FybmluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGluc3RhbmNlID0gbmV3IGVsZW1lbnQudHlwZS5fbW9ja2VkUmVhY3RDbGFzc0NvbnN0cnVjdG9yKFxuICAgICAgICAgIGVsZW1lbnQucHJvcHNcbiAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0TGVnYWN5RWxlbWVudC5faXNMZWdhY3lDYWxsV2FybmluZ0VuYWJsZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgbW9jayBpbXBsZW1lbnRhdGlvbiB3YXMgYSBsZWdhY3kgZmFjdG9yeSwgdGhlbiBpdCByZXR1cm5zIGFcbiAgICAgIC8vIGVsZW1lbnQuIFdlIG5lZWQgdG8gdHVybiB0aGlzIGludG8gYSByZWFsIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoaW5zdGFuY2UpKSB7XG4gICAgICAgIGluc3RhbmNlID0gbmV3IGluc3RhbmNlLnR5cGUoaW5zdGFuY2UucHJvcHMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVuZGVyID0gaW5zdGFuY2UucmVuZGVyO1xuICAgICAgaWYgKCFyZW5kZXIpIHtcbiAgICAgICAgLy8gRm9yIGF1dG8tbW9ja2VkIGZhY3RvcmllcywgdGhlIHByb3RvdHlwZSBpc24ndCBzaGltbWVkIGFuZCB0aGVyZWZvcmVcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gcmVuZGVyIGZ1bmN0aW9uIG9uIHRoZSBpbnN0YW5jZS4gV2UgcmVwbGFjZSB0aGUgd2hvbGVcbiAgICAgICAgLy8gY29tcG9uZW50IHdpdGggYW4gZW1wdHkgY29tcG9uZW50IGluc3RhbmNlIGluc3RlYWQuXG4gICAgICAgIGVsZW1lbnQgPSBSZWFjdEVtcHR5Q29tcG9uZW50LmdldEVtcHR5Q29tcG9uZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVuZGVyLl9pc01vY2tGdW5jdGlvbiAmJiAhcmVuZGVyLl9nZXRNb2NrSW1wbGVtZW50YXRpb24oKSkge1xuICAgICAgICAgIC8vIEF1dG8tbW9ja2VkIGNvbXBvbmVudHMgbWF5IGhhdmUgYSBwcm90b3R5cGUgd2l0aCBhIG1vY2tlZCByZW5kZXJcbiAgICAgICAgICAvLyBmdW5jdGlvbi4gRm9yIHRob3NlLCB3ZSdsbCBuZWVkIHRvIG1vY2sgdGhlIHJlc3VsdCBvZiB0aGUgcmVuZGVyXG4gICAgICAgICAgLy8gc2luY2Ugd2UgY29uc2lkZXIgdW5kZWZpbmVkIHRvIGJlIGludmFsaWQgcmVzdWx0cyBmcm9tIHJlbmRlci5cbiAgICAgICAgICByZW5kZXIubW9ja0ltcGxlbWVudGF0aW9uKFxuICAgICAgICAgICAgUmVhY3RFbXB0eUNvbXBvbmVudC5nZXRFbXB0eUNvbXBvbmVudFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UuY29uc3RydWN0KGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU3BlY2lhbCBjYXNlIHN0cmluZyB2YWx1ZXNcbiAgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaW5zdGFuY2UgPSBSZWFjdE5hdGl2ZUNvbXBvbmVudC5jcmVhdGVJbnN0YW5jZUZvclRhZyhcbiAgICAgIGVsZW1lbnQudHlwZSxcbiAgICAgIGVsZW1lbnQucHJvcHMsXG4gICAgICBwYXJlbnRDb21wb3NpdGVUeXBlXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBOb3JtYWwgY2FzZSBmb3Igbm9uLW1vY2tzIGFuZCBub24tc3RyaW5nc1xuICAgIGluc3RhbmNlID0gbmV3IGVsZW1lbnQudHlwZShlbGVtZW50LnByb3BzKTtcbiAgfVxuXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhcbiAgICAgIHR5cGVvZiBpbnN0YW5jZS5jb25zdHJ1Y3QgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBpbnN0YW5jZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIGluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbicsXG4gICAgICAnT25seSBSZWFjdCBDb21wb25lbnRzIGNhbiBiZSBtb3VudGVkLidcbiAgICApIDogbnVsbCk7XG4gIH1cblxuICAvLyBUaGlzIGFjdHVhbGx5IHNldHMgdXAgdGhlIGludGVybmFsIGluc3RhbmNlLiBUaGlzIHdpbGwgYmVjb21lIGRlY291cGxlZFxuICAvLyBmcm9tIHRoZSBwdWJsaWMgaW5zdGFuY2UgaW4gYSBmdXR1cmUgZGlmZi5cbiAgaW5zdGFuY2UuY29uc3RydWN0KGVsZW1lbnQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGludmFyaWFudFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdJbnZhcmlhbnQgVmlvbGF0aW9uOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzRXZlbnRTdXBwb3J0ZWRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciB1c2VIYXNGZWF0dXJlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB1c2VIYXNGZWF0dXJlID1cbiAgICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJlxuICAgIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiZcbiAgICAvLyBhbHdheXMgcmV0dXJucyB0cnVlIGluIG5ld2VyIGJyb3dzZXJzIGFzIHBlciB0aGUgc3RhbmRhcmQuXG4gICAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCcnLCAnJykgIT09IHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcGFyYW0gez9ib29sZWFufSBjYXB0dXJlIENoZWNrIGlmIHRoZSBjYXB0dXJlIHBoYXNlIGlzIHN1cHBvcnRlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAqIEBpbnRlcm5hbFxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4LCBjYXB0dXJlKSB7XG4gIGlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NIHx8XG4gICAgICBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFdmVudFN1cHBvcnRlZDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc05vZGVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHJldHVybiAhIShvYmplY3QgJiYgKFxuICAgIHR5cGVvZiBOb2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgTm9kZSA6XG4gICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiZcbiAgICAgIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnXG4gICkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc1RleHRJbnB1dEVsZW1lbnRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1pbnB1dC1lbGVtZW50Lmh0bWwjaW5wdXQtdHlwZS1hdHRyLXN1bW1hcnlcbiAqL1xudmFyIHN1cHBvcnRlZElucHV0VHlwZXMgPSB7XG4gICdjb2xvcic6IHRydWUsXG4gICdkYXRlJzogdHJ1ZSxcbiAgJ2RhdGV0aW1lJzogdHJ1ZSxcbiAgJ2RhdGV0aW1lLWxvY2FsJzogdHJ1ZSxcbiAgJ2VtYWlsJzogdHJ1ZSxcbiAgJ21vbnRoJzogdHJ1ZSxcbiAgJ251bWJlcic6IHRydWUsXG4gICdwYXNzd29yZCc6IHRydWUsXG4gICdyYW5nZSc6IHRydWUsXG4gICdzZWFyY2gnOiB0cnVlLFxuICAndGVsJzogdHJ1ZSxcbiAgJ3RleHQnOiB0cnVlLFxuICAndGltZSc6IHRydWUsXG4gICd1cmwnOiB0cnVlLFxuICAnd2Vlayc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHJldHVybiBlbGVtICYmIChcbiAgICAoZWxlbS5ub2RlTmFtZSA9PT0gJ0lOUFVUJyAmJiBzdXBwb3J0ZWRJbnB1dFR5cGVzW2VsZW0udHlwZV0pIHx8XG4gICAgZWxlbS5ub2RlTmFtZSA9PT0gJ1RFWFRBUkVBJ1xuICApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dElucHV0RWxlbWVudDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc1RleHROb2RlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKFwiLi9pc05vZGVcIik7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gdGV4dCBub2RlLlxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG9iamVjdCkge1xuICByZXR1cm4gaXNOb2RlKG9iamVjdCkgJiYgb2JqZWN0Lm5vZGVUeXBlID09IDM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0Tm9kZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBqb2luQ2xhc3Nlc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBjbGFzc05hbWUgc3RyaW5ncyBpbnRvIG9uZS5cbiAqIGh0dHA6Ly9qc3BlcmYuY29tL2pvaW5jbGFzc2VzLWFyZ3MtdnMtYXJyYXlcbiAqXG4gKiBAcGFyYW0gey4uLj9zdHJpbmd9IGNsYXNzZXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gam9pbkNsYXNzZXMoY2xhc3NOYW1lLyosIC4uLiAqLykge1xuICBpZiAoIWNsYXNzTmFtZSkge1xuICAgIGNsYXNzTmFtZSA9ICcnO1xuICB9XG4gIHZhciBuZXh0Q2xhc3M7XG4gIHZhciBhcmdMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICBpZiAoYXJnTGVuZ3RoID4gMSkge1xuICAgIGZvciAodmFyIGlpID0gMTsgaWkgPCBhcmdMZW5ndGg7IGlpKyspIHtcbiAgICAgIG5leHRDbGFzcyA9IGFyZ3VtZW50c1tpaV07XG4gICAgICBpZiAobmV4dENsYXNzKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IChjbGFzc05hbWUgPyBjbGFzc05hbWUgKyAnICcgOiAnJykgKyBuZXh0Q2xhc3M7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjbGFzc05hbWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gam9pbkNsYXNzZXM7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGtleU1pcnJvclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGFuIGVudW1lcmF0aW9uIHdpdGgga2V5cyBlcXVhbCB0byB0aGVpciB2YWx1ZS5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgIHZhciBDT0xPUlMgPSBrZXlNaXJyb3Ioe2JsdWU6IG51bGwsIHJlZDogbnVsbH0pO1xuICogICB2YXIgbXlDb2xvciA9IENPTE9SUy5ibHVlO1xuICogICB2YXIgaXNDb2xvclZhbGlkID0gISFDT0xPUlNbbXlDb2xvcl07XG4gKlxuICogVGhlIGxhc3QgbGluZSBjb3VsZCBub3QgYmUgcGVyZm9ybWVkIGlmIHRoZSB2YWx1ZXMgb2YgdGhlIGdlbmVyYXRlZCBlbnVtIHdlcmVcbiAqIG5vdCBlcXVhbCB0byB0aGVpciBrZXlzLlxuICpcbiAqICAgSW5wdXQ6ICB7a2V5MTogdmFsMSwga2V5MjogdmFsMn1cbiAqICAgT3V0cHV0OiB7a2V5MToga2V5MSwga2V5Mjoga2V5Mn1cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbnZhciBrZXlNaXJyb3IgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHJldCA9IHt9O1xuICB2YXIga2V5O1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIG9iaiBpbnN0YW5jZW9mIE9iamVjdCAmJiAhQXJyYXkuaXNBcnJheShvYmopLFxuICAgICdrZXlNaXJyb3IoLi4uKTogQXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuJ1xuICApIDogaW52YXJpYW50KG9iaiBpbnN0YW5jZW9mIE9iamVjdCAmJiAhQXJyYXkuaXNBcnJheShvYmopKSk7XG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXRba2V5XSA9IGtleTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlNaXJyb3I7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBrZXlPZlxuICovXG5cbi8qKlxuICogQWxsb3dzIGV4dHJhY3Rpb24gb2YgYSBtaW5pZmllZCBrZXkuIExldCdzIHRoZSBidWlsZCBzeXN0ZW0gbWluaWZ5IGtleXNcbiAqIHdpdGhvdXQgbG9vc2luZyB0aGUgYWJpbGl0eSB0byBkeW5hbWljYWxseSB1c2Uga2V5IHN0cmluZ3MgYXMgdmFsdWVzXG4gKiB0aGVtc2VsdmVzLiBQYXNzIGluIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlIGtleS92YWwgcGFpciBhbmQgaXQgd2lsbCByZXR1cm5cbiAqIHlvdSB0aGUgc3RyaW5nIGtleSBvZiB0aGF0IHNpbmdsZSByZWNvcmQuIFN1cHBvc2UgeW91IHdhbnQgdG8gZ3JhYiB0aGVcbiAqIHZhbHVlIGZvciBhIGtleSAnY2xhc3NOYW1lJyBpbnNpZGUgb2YgYW4gb2JqZWN0LiBLZXkvdmFsIG1pbmlmaWNhdGlvbiBtYXlcbiAqIGhhdmUgYWxpYXNlZCB0aGF0IGtleSB0byBiZSAneGExMicuIGtleU9mKHtjbGFzc05hbWU6IG51bGx9KSB3aWxsIHJldHVyblxuICogJ3hhMTInIGluIHRoYXQgY2FzZS4gUmVzb2x2ZSBrZXlzIHlvdSB3YW50IHRvIHVzZSBvbmNlIGF0IHN0YXJ0dXAgdGltZSwgdGhlblxuICogcmV1c2UgdGhvc2UgcmVzb2x1dGlvbnMuXG4gKi9cbnZhciBrZXlPZiA9IGZ1bmN0aW9uKG9uZUtleU9iaikge1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBvbmVLZXlPYmopIHtcbiAgICBpZiAoIW9uZUtleU9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlPZjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBtYXBPYmplY3RcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGBjYWxsYmFja2Agb25jZSBmb3IgZWFjaCBlbnVtZXJhYmxlIG93biBwcm9wZXJ0eSBpbiB0aGVcbiAqIG9iamVjdCBhbmQgY29uc3RydWN0cyBhIG5ldyBvYmplY3QgZnJvbSB0aGUgcmVzdWx0cy4gVGhlIGBjYWxsYmFja2AgaXNcbiAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKlxuICogIC0gdGhlIHByb3BlcnR5IHZhbHVlXG4gKiAgLSB0aGUgcHJvcGVydHkgbmFtZVxuICogIC0gdGhlIG9iamVjdCBiZWluZyB0cmF2ZXJzZWRcbiAqXG4gKiBQcm9wZXJ0aWVzIHRoYXQgYXJlIGFkZGVkIGFmdGVyIHRoZSBjYWxsIHRvIGBtYXBPYmplY3RgIHdpbGwgbm90IGJlIHZpc2l0ZWRcbiAqIGJ5IGBjYWxsYmFja2AuIElmIHRoZSB2YWx1ZXMgb2YgZXhpc3RpbmcgcHJvcGVydGllcyBhcmUgY2hhbmdlZCwgdGhlIHZhbHVlXG4gKiBwYXNzZWQgdG8gYGNhbGxiYWNrYCB3aWxsIGJlIHRoZSB2YWx1ZSBhdCB0aGUgdGltZSBgbWFwT2JqZWN0YCB2aXNpdHMgdGhlbS5cbiAqIFByb3BlcnRpZXMgdGhhdCBhcmUgZGVsZXRlZCBiZWZvcmUgYmVpbmcgdmlzaXRlZCBhcmUgbm90IHZpc2l0ZWQuXG4gKlxuICogQGdyZXAgZnVuY3Rpb24gb2JqZWN0TWFwKClcbiAqIEBncmVwIGZ1bmN0aW9uIG9iak1hcCgpXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGNvbnRleHRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1hcE9iamVjdChvYmplY3QsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgbmFtZSkpIHtcbiAgICAgIHJlc3VsdFtuYW1lXSA9IGNhbGxiYWNrLmNhbGwoY29udGV4dCwgb2JqZWN0W25hbWVdLCBuYW1lLCBvYmplY3QpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcE9iamVjdDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBtZW1vaXplU3RyaW5nT25seVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBNZW1vaXplcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBzdHJpbmcgYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBtZW1vaXplU3RyaW5nT25seShjYWxsYmFjaykge1xuICB2YXIgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gY2FjaGVbc3RyaW5nXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNhY2hlW3N0cmluZ10gPSBjYWxsYmFjay5jYWxsKHRoaXMsIHN0cmluZyk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVTdHJpbmdPbmx5O1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgbW9uaXRvckNvZGVVc2VcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBQcm92aWRlcyBvcGVuLXNvdXJjZSBjb21wYXRpYmxlIGluc3RydW1lbnRhdGlvbiBmb3IgbW9uaXRvcmluZyBjZXJ0YWluIEFQSVxuICogdXNlcyBiZWZvcmUgd2UncmUgcmVhZHkgdG8gaXNzdWUgYSB3YXJuaW5nIG9yIHJlZmFjdG9yLiBJdCBhY2NlcHRzIGFuIGV2ZW50XG4gKiBuYW1lIHdoaWNoIG1heSBvbmx5IGNvbnRhaW4gdGhlIGNoYXJhY3RlcnMgW2EtejAtOV9dIGFuZCBhbiBvcHRpb25hbCBkYXRhXG4gKiBvYmplY3Qgd2l0aCBmdXJ0aGVyIGluZm9ybWF0aW9uLlxuICovXG5cbmZ1bmN0aW9uIG1vbml0b3JDb2RlVXNlKGV2ZW50TmFtZSwgZGF0YSkge1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIGV2ZW50TmFtZSAmJiAhL1teYS16MC05X10vLnRlc3QoZXZlbnROYW1lKSxcbiAgICAnWW91IG11c3QgcHJvdmlkZSBhbiBldmVudE5hbWUgdXNpbmcgb25seSB0aGUgY2hhcmFjdGVycyBbYS16MC05X10nXG4gICkgOiBpbnZhcmlhbnQoZXZlbnROYW1lICYmICEvW15hLXowLTlfXS8udGVzdChldmVudE5hbWUpKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbW9uaXRvckNvZGVVc2U7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgb25seUNoaWxkXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbGVtZW50XCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXNcbiAqIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZVxuICogcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0byBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZVxuICogb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0Q29tcG9uZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbiksXG4gICAgJ29ubHlDaGlsZCBtdXN0IGJlIHBhc3NlZCBhIGNoaWxkcmVuIHdpdGggZXhhY3RseSBvbmUgY2hpbGQuJ1xuICApIDogaW52YXJpYW50KFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9ubHlDaGlsZDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHBlcmZvcm1hbmNlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxudmFyIHBlcmZvcm1hbmNlO1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHBlcmZvcm1hbmNlID1cbiAgICB3aW5kb3cucGVyZm9ybWFuY2UgfHxcbiAgICB3aW5kb3cubXNQZXJmb3JtYW5jZSB8fFxuICAgIHdpbmRvdy53ZWJraXRQZXJmb3JtYW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZSB8fCB7fTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBwZXJmb3JtYW5jZU5vd1xuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgcGVyZm9ybWFuY2UgPSByZXF1aXJlKFwiLi9wZXJmb3JtYW5jZVwiKTtcblxuLyoqXG4gKiBEZXRlY3QgaWYgd2UgY2FuIHVzZSBgd2luZG93LnBlcmZvcm1hbmNlLm5vdygpYCBhbmQgZ3JhY2VmdWxseSBmYWxsYmFjayB0b1xuICogYERhdGUubm93KClgIGlmIGl0IGRvZXNuJ3QgZXhpc3QuIFdlIG5lZWQgdG8gc3VwcG9ydCBGaXJlZm94IDwgMTUgZm9yIG5vd1xuICogYmVjYXVzZSBvZiBGYWNlYm9vaydzIHRlc3RpbmcgaW5mcmFzdHJ1Y3R1cmUuXG4gKi9cbmlmICghcGVyZm9ybWFuY2UgfHwgIXBlcmZvcm1hbmNlLm5vdykge1xuICBwZXJmb3JtYW5jZSA9IERhdGU7XG59XG5cbnZhciBwZXJmb3JtYW5jZU5vdyA9IHBlcmZvcm1hbmNlLm5vdy5iaW5kKHBlcmZvcm1hbmNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZU5vdztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzZXRJbm5lckhUTUxcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciBXSElURVNQQUNFX1RFU1QgPSAvXlsgXFxyXFxuXFx0XFxmXS87XG52YXIgTk9OVklTSUJMRV9URVNUID0gLzwoIS0tfGxpbmt8bm9zY3JpcHR8bWV0YXxzY3JpcHR8c3R5bGUpWyBcXHJcXG5cXHRcXGZcXC8+XS87XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldElubmVySFRNTCA9IGZ1bmN0aW9uKG5vZGUsIGh0bWwpIHtcbiAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xufTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTg6IFdoZW4gdXBkYXRpbmcgYSBqdXN0IGNyZWF0ZWQgbm9kZSB3aXRoIGlubmVySFRNTCBvbmx5IGxlYWRpbmdcbiAgLy8gd2hpdGVzcGFjZSBpcyByZW1vdmVkLiBXaGVuIHVwZGF0aW5nIGFuIGV4aXN0aW5nIG5vZGUgd2l0aCBpbm5lckhUTUxcbiAgLy8gd2hpdGVzcGFjZSBpbiByb290IFRleHROb2RlcyBpcyBhbHNvIGNvbGxhcHNlZC5cbiAgLy8gQHNlZSBxdWlya3Ntb2RlLm9yZy9idWdyZXBvcnRzL2FyY2hpdmVzLzIwMDQvMTEvaW5uZXJodG1sX2FuZF90Lmh0bWxcblxuICAvLyBGZWF0dXJlIGRldGVjdGlvbjsgb25seSBJRTggaXMga25vd24gdG8gYmVoYXZlIGltcHJvcGVybHkgbGlrZSB0aGlzLlxuICB2YXIgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gJyAnO1xuICBpZiAodGVzdEVsZW1lbnQuaW5uZXJIVE1MID09PSAnJykge1xuICAgIHNldElubmVySFRNTCA9IGZ1bmN0aW9uKG5vZGUsIGh0bWwpIHtcbiAgICAgIC8vIE1hZ2ljIHRoZW9yeTogSUU4IHN1cHBvc2VkbHkgZGlmZmVyZW50aWF0ZXMgYmV0d2VlbiBhZGRlZCBhbmQgdXBkYXRlZFxuICAgICAgLy8gbm9kZXMgd2hlbiBwcm9jZXNzaW5nIGlubmVySFRNTCwgaW5uZXJIVE1MIG9uIHVwZGF0ZWQgbm9kZXMgc3VmZmVyc1xuICAgICAgLy8gZnJvbSB3b3JzZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLiBSZS1hZGRpbmcgYSBub2RlIGxpa2UgdGhpcyB0cmlnZ2Vyc1xuICAgICAgLy8gdGhlIGluaXRpYWwgYW5kIG1vcmUgZmF2b3JhYmxlIHdoaXRlc3BhY2UgYmVoYXZpb3IuXG4gICAgICAvLyBUT0RPOiBXaGF0IHRvIGRvIG9uIGEgZGV0YWNoZWQgbm9kZT9cbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChub2RlLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgYWxzbyBpbXBsZW1lbnQgYSB3b3JrYXJvdW5kIGZvciBub24tdmlzaWJsZSB0YWdzIGRpc2FwcGVhcmluZyBpbnRvXG4gICAgICAvLyB0aGluIGFpciBvbiBJRTgsIHRoaXMgb25seSBoYXBwZW5zIGlmIHRoZXJlIGlzIG5vIHZpc2libGUgdGV4dFxuICAgICAgLy8gaW4tZnJvbnQgb2YgdGhlIG5vbi12aXNpYmxlIHRhZ3MuIFBpZ2d5YmFjayBvbiB0aGUgd2hpdGVzcGFjZSBmaXhcbiAgICAgIC8vIGFuZCBzaW1wbHkgY2hlY2sgaWYgYW55IG5vbi12aXNpYmxlIHRhZ3MgYXBwZWFyIGluIHRoZSBzb3VyY2UuXG4gICAgICBpZiAoV0hJVEVTUEFDRV9URVNULnRlc3QoaHRtbCkgfHxcbiAgICAgICAgICBodG1sWzBdID09PSAnPCcgJiYgTk9OVklTSUJMRV9URVNULnRlc3QoaHRtbCkpIHtcbiAgICAgICAgLy8gUmVjb3ZlciBsZWFkaW5nIHdoaXRlc3BhY2UgYnkgdGVtcG9yYXJpbHkgcHJlcGVuZGluZyBhbnkgY2hhcmFjdGVyLlxuICAgICAgICAvLyBcXHVGRUZGIGhhcyB0aGUgcG90ZW50aWFsIGFkdmFudGFnZSBvZiBiZWluZyB6ZXJvLXdpZHRoL2ludmlzaWJsZS5cbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSAnXFx1RkVGRicgKyBodG1sO1xuXG4gICAgICAgIC8vIGRlbGV0ZURhdGEgbGVhdmVzIGFuIGVtcHR5IGBUZXh0Tm9kZWAgd2hpY2ggb2Zmc2V0cyB0aGUgaW5kZXggb2YgYWxsXG4gICAgICAgIC8vIGNoaWxkcmVuLiBEZWZpbml0ZWx5IHdhbnQgdG8gYXZvaWQgdGhpcy5cbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUuZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKHRleHROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZS5kZWxldGVEYXRhKDAsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldElubmVySFRNTDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzaGFsbG93RXF1YWxcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nXG4gKiBmYWxzZSB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW5cbiAqIG9iakEgYW5kIG9iakIuIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGtleTtcbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yIChrZXkgaW4gb2JqQSkge1xuICAgIGlmIChvYmpBLmhhc093blByb3BlcnR5KGtleSkgJiZcbiAgICAgICAgKCFvYmpCLmhhc093blByb3BlcnR5KGtleSkgfHwgb2JqQVtrZXldICE9PSBvYmpCW2tleV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIFRlc3QgZm9yIEIncyBrZXlzIG1pc3NpbmcgZnJvbSBBLlxuICBmb3IgKGtleSBpbiBvYmpCKSB7XG4gICAgaWYgKG9iakIuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhb2JqQS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFcXVhbDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBHaXZlbiBhIGBwcmV2RWxlbWVudGAgYW5kIGBuZXh0RWxlbWVudGAsIGRldGVybWluZXMgaWYgdGhlIGV4aXN0aW5nXG4gKiBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZCBhcyBvcHBvc2VkIHRvIGJlaW5nIGRlc3Ryb3llZCBvciByZXBsYWNlZCBieSBhIG5ld1xuICogaW5zdGFuY2UuIEJvdGggYXJndW1lbnRzIGFyZSBlbGVtZW50cy4gVGhpcyBlbnN1cmVzIHRoYXQgdGhpcyBsb2dpYyBjYW5cbiAqIG9wZXJhdGUgb24gc3RhdGVsZXNzIHRyZWVzIHdpdGhvdXQgYW55IGJhY2tpbmcgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2RWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0RWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXhpc3RpbmcgaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICBpZiAocHJldkVsZW1lbnQgJiYgbmV4dEVsZW1lbnQgJiZcbiAgICAgIHByZXZFbGVtZW50LnR5cGUgPT09IG5leHRFbGVtZW50LnR5cGUgJiZcbiAgICAgIHByZXZFbGVtZW50LmtleSA9PT0gbmV4dEVsZW1lbnQua2V5ICYmXG4gICAgICBwcmV2RWxlbWVudC5fb3duZXIgPT09IG5leHRFbGVtZW50Ll9vd25lcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudDtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHRvQXJyYXlcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byBhcnJheXMuXG4gKlxuICogVGhpcyBBUEkgYXNzdW1lcyB0aGUgY2FsbGVyIGtub3dzIHRoZSBjb250ZW50cyBvZiB0aGUgZGF0YSB0eXBlLiBGb3IgbGVzc1xuICogd2VsbCBkZWZpbmVkIGlucHV0cyB1c2UgY3JlYXRlQXJyYXlGcm9tLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufGZpbGVsaXN0fSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcblxuICAvLyBTb21lIGJyb3dzZSBidWlsdGluIG9iamVjdHMgY2FuIHJlcG9ydCB0eXBlb2YgJ2Z1bmN0aW9uJyAoZS5nLiBOb2RlTGlzdCBpblxuICAvLyBvbGQgdmVyc2lvbnMgb2YgU2FmYXJpKS5cbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAhQXJyYXkuaXNBcnJheShvYmopICYmXG4gICAgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpLFxuICAgICd0b0FycmF5OiBBcnJheS1saWtlIG9iamVjdCBleHBlY3RlZCdcbiAgKSA6IGludmFyaWFudCghQXJyYXkuaXNBcnJheShvYmopICYmXG4gICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSkpO1xuXG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgdHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicsXG4gICAgJ3RvQXJyYXk6IE9iamVjdCBuZWVkcyBhIGxlbmd0aCBwcm9wZXJ0eSdcbiAgKSA6IGludmFyaWFudCh0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJykpO1xuXG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgbGVuZ3RoID09PSAwIHx8XG4gICAgKGxlbmd0aCAtIDEpIGluIG9iaixcbiAgICAndG9BcnJheTogT2JqZWN0IHNob3VsZCBoYXZlIGtleXMgZm9yIGluZGljZXMnXG4gICkgOiBpbnZhcmlhbnQobGVuZ3RoID09PSAwIHx8XG4gIChsZW5ndGggLSAxKSBpbiBvYmopKTtcblxuICAvLyBPbGQgSUUgZG9lc24ndCBnaXZlIGNvbGxlY3Rpb25zIGFjY2VzcyB0byBoYXNPd25Qcm9wZXJ0eS4gQXNzdW1lIGlucHV0c1xuICAvLyB3aXRob3V0IG1ldGhvZCB3aWxsIHRocm93IGR1cmluZyB0aGUgc2xpY2UgY2FsbCBhbmQgc2tpcCBzdHJhaWdodCB0byB0aGVcbiAgLy8gZmFsbGJhY2suXG4gIGlmIChvYmouaGFzT3duUHJvcGVydHkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSUUgPCA5IGRvZXMgbm90IHN1cHBvcnQgQXJyYXkjc2xpY2Ugb24gY29sbGVjdGlvbnMgb2JqZWN0c1xuICAgIH1cbiAgfVxuXG4gIC8vIEZhbGwgYmFjayB0byBjb3B5aW5nIGtleSBieSBrZXkuIFRoaXMgYXNzdW1lcyBhbGwga2V5cyBoYXZlIGEgdmFsdWUsXG4gIC8vIHNvIHdpbGwgbm90IHByZXNlcnZlIHNwYXJzZWx5IHBvcHVsYXRlZCBpbnB1dHMuXG4gIHZhciByZXQgPSBBcnJheShsZW5ndGgpO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGVuZ3RoOyBpaSsrKSB7XG4gICAgcmV0W2lpXSA9IG9ialtpaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0FycmF5O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHRyYXZlcnNlQWxsQ2hpbGRyZW5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RWxlbWVudFwiKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VIYW5kbGVzXCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG52YXIgU0VQQVJBVE9SID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuU0VQQVJBVE9SO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6JztcblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQ6XG4gKiAxLiBgbWFwQ2hpbGRyZW5gIHRyYW5zZm9ybXMgc3RyaW5ncyBhbmQgbnVtYmVycyBpbnRvIGBSZWFjdFRleHRDb21wb25lbnRgLlxuICogMi4gaXQoJ3Nob3VsZCBmYWlsIHdoZW4gc3VwcGxpZWQgZHVwbGljYXRlIGtleScsIGZ1bmN0aW9uKCkge1xuICogMy4gVGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleSBwYXR0ZXJuLlxuICogfSk7XG4gKi9cblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZXJMb29rdXAgPSB7XG4gICc9JzogJz0wJyxcbiAgJy4nOiAnPTEnLFxuICAnOic6ICc9Midcbn07XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9bPS46XS9nO1xuXG5mdW5jdGlvbiB1c2VyUHJvdmlkZWRLZXlFc2NhcGVyKG1hdGNoKSB7XG4gIHJldHVybiB1c2VyUHJvdmlkZWRLZXlFc2NhcGVyTG9va3VwW21hdGNoXTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgY29tcG9uZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiB3cmFwVXNlclByb3ZpZGVkS2V5KGNvbXBvbmVudC5rZXkpO1xuICB9XG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbi8qKlxuICogRXNjYXBlIGEgY29tcG9uZW50IGtleSBzbyB0aGF0IGl0IGlzIHNhZmUgdG8gdXNlIGluIGEgcmVhY3RpZC5cbiAqXG4gKiBAcGFyYW0geyp9IGtleSBDb21wb25lbnQga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZShcbiAgICB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCxcbiAgICB1c2VyUHJvdmlkZWRLZXlFc2NhcGVyXG4gICk7XG59XG5cbi8qKlxuICogV3JhcCBhIGBrZXlgIHZhbHVlIGV4cGxpY2l0bHkgcHJvdmlkZWQgYnkgdGhlIHVzZXIgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbVxuICogaW1wbGljaXRseS1nZW5lcmF0ZWQga2V5cyBnZW5lcmF0ZWQgYnkgYSBjb21wb25lbnQncyBpbmRleCBpbiBpdHMgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVmFsdWUgb2YgYSB1c2VyLXByb3ZpZGVkIGBrZXlgIGF0dHJpYnV0ZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB3cmFwVXNlclByb3ZpZGVkS2V5KGtleSkge1xuICByZXR1cm4gJyQnICsgZXNjYXBlVXNlclByb3ZpZGVkS2V5KGtleSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFudW1iZXJ9IGluZGV4U29GYXIgTnVtYmVyIG9mIGNoaWxkcmVuIGVuY291bnRlcmVkIHVudGlsIHRoaXMgcG9pbnQuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbCA9XG4gIGZ1bmN0aW9uKGNoaWxkcmVuLCBuYW1lU29GYXIsIGluZGV4U29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgICB2YXIgbmV4dE5hbWUsIG5leHRJbmRleDtcbiAgICB2YXIgc3VidHJlZUNvdW50ID0gMDsgIC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBuZXh0TmFtZSA9IChcbiAgICAgICAgICBuYW1lU29GYXIgK1xuICAgICAgICAgIChuYW1lU29GYXIgPyBTVUJTRVBBUkFUT1IgOiBTRVBBUkFUT1IpICtcbiAgICAgICAgICBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpXG4gICAgICAgICk7XG4gICAgICAgIG5leHRJbmRleCA9IGluZGV4U29GYXIgKyBzdWJ0cmVlQ291bnQ7XG4gICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChcbiAgICAgICAgICBjaGlsZCxcbiAgICAgICAgICBuZXh0TmFtZSxcbiAgICAgICAgICBuZXh0SW5kZXgsXG4gICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgdHJhdmVyc2VDb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuICAgICAgdmFyIGlzT25seUNoaWxkID0gbmFtZVNvRmFyID09PSAnJztcbiAgICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzXG4gICAgICB2YXIgc3RvcmFnZU5hbWUgPVxuICAgICAgICBpc09ubHlDaGlsZCA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXI7XG4gICAgICBpZiAoY2hpbGRyZW4gPT0gbnVsbCB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgbnVsbCwgc3RvcmFnZU5hbWUsIGluZGV4U29GYXIpO1xuICAgICAgICBzdWJ0cmVlQ291bnQgPSAxO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgICAgICBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sIHN0b3JhZ2VOYW1lLCBpbmRleFNvRmFyKTtcbiAgICAgICAgc3VidHJlZUNvdW50ID0gMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgICAhY2hpbGRyZW4gfHwgY2hpbGRyZW4ubm9kZVR5cGUgIT09IDEsXG4gICAgICAgICAgJ3RyYXZlcnNlQWxsQ2hpbGRyZW4oLi4uKTogRW5jb3VudGVyZWQgYW4gaW52YWxpZCBjaGlsZDsgRE9NICcgK1xuICAgICAgICAgICdlbGVtZW50cyBhcmUgbm90IHZhbGlkIGNoaWxkcmVuIG9mIFJlYWN0IGNvbXBvbmVudHMuJ1xuICAgICAgICApIDogaW52YXJpYW50KCFjaGlsZHJlbiB8fCBjaGlsZHJlbi5ub2RlVHlwZSAhPT0gMSkpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoY2hpbGRyZW4uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgbmV4dE5hbWUgPSAoXG4gICAgICAgICAgICAgIG5hbWVTb0ZhciArIChuYW1lU29GYXIgPyBTVUJTRVBBUkFUT1IgOiBTRVBBUkFUT1IpICtcbiAgICAgICAgICAgICAgd3JhcFVzZXJQcm92aWRlZEtleShrZXkpICsgU1VCU0VQQVJBVE9SICtcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuW2tleV0sIDApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbmV4dEluZGV4ID0gaW5kZXhTb0ZhciArIHN1YnRyZWVDb3VudDtcbiAgICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChcbiAgICAgICAgICAgICAgY2hpbGRyZW5ba2V5XSxcbiAgICAgICAgICAgICAgbmV4dE5hbWUsXG4gICAgICAgICAgICAgIG5leHRJbmRleCxcbiAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgIHRyYXZlcnNlQ29udGV4dFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbiAgfTtcblxuLyoqXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcbiAqXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXG4gKlxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sICcnLCAwLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmF2ZXJzZUFsbENoaWxkcmVuO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB3YXJuaW5nXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCApIHtmb3IgKHZhciBhcmdzPVtdLCRfXzA9MiwkX18xPWFyZ3VtZW50cy5sZW5ndGg7JF9fMDwkX18xOyRfXzArKykgYXJncy5wdXNoKGFyZ3VtZW50c1skX18wXSk7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgIHtyZXR1cm4gYXJnc1thcmdJbmRleCsrXTt9KSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvUmVhY3QnKTtcbiIsIi8qKlxuICogZGF0Lmdsb2JlIEphdmFzY3JpcHQgV2ViR0wgR2xvYmUgVG9vbGtpdFxuICogaHR0cDovL2RhdGFhcnRzLmdpdGh1Yi5jb20vZGF0Lmdsb2JlXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgRGF0YSBBcnRzIFRlYW0sIEdvb2dsZSBDcmVhdGl2ZSBMYWJcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbnZhciBUSFJFRSA9IHJlcXVpcmUoXCIuLi9nbG9iZS90aGlyZC1wYXJ0eS90aHJlZS5taW4uanNcIik7XG5cbnZhciBEQVQgPSBEQVQgfHwge307XG5cbkRBVC5HbG9iZSA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgXG4gIHZhciBjb2xvckZuID0gb3B0cy5jb2xvckZuIHx8IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgYyA9IG5ldyBUSFJFRS5Db2xvcigpO1xuICAgIGMuc2V0SFNMKCAoIDAuNiAtICggeCAqIDAuNSApICksIDEuMCwgMC41ICk7XG4gICAgcmV0dXJuIGM7XG4gIH07XG4gIHZhciBpbWdEaXIgPSBvcHRzLmltZ0RpciB8fCAnL2dsb2JlLyc7XG5cbiAgdmFyIFNoYWRlcnMgPSB7XG4gICAgJ2VhcnRoJyA6IHtcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICd0ZXh0dXJlJzogeyB0eXBlOiAndCcsIHZhbHVlOiBudWxsIH1cbiAgICAgIH0sXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IFtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMyB2Tm9ybWFsOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlV2OycsXG4gICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgICAnZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApOycsXG4gICAgICAgICAgJ3ZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApOycsXG4gICAgICAgICAgJ3ZVdiA9IHV2OycsXG4gICAgICAgICd9J1xuICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBbXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzMgdk5vcm1hbDsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZVdjsnLFxuICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICAgJ3ZlYzMgZGlmZnVzZSA9IHRleHR1cmUyRCggdGV4dHVyZSwgdlV2ICkueHl6OycsXG4gICAgICAgICAgJ2Zsb2F0IGludGVuc2l0eSA9IDEuMDUgLSBkb3QoIHZOb3JtYWwsIHZlYzMoIDAuMCwgMC4wLCAxLjAgKSApOycsXG4gICAgICAgICAgJ3ZlYzMgYXRtb3NwaGVyZSA9IHZlYzMoIDEuMCwgMS4wLCAxLjAgKSAqIHBvdyggaW50ZW5zaXR5LCAzLjAgKTsnLFxuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KCBkaWZmdXNlICsgYXRtb3NwaGVyZSwgMS4wICk7JyxcbiAgICAgICAgJ30nXG4gICAgICBdLmpvaW4oJ1xcbicpXG4gICAgfSxcbiAgICAnYXRtb3NwaGVyZScgOiB7XG4gICAgICB1bmlmb3Jtczoge30sXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IFtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMyB2Tm9ybWFsOycsXG4gICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgICAndk5vcm1hbCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogbm9ybWFsICk7JyxcbiAgICAgICAgICAnZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApOycsXG4gICAgICAgICd9J1xuICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgIGZyYWdtZW50U2hhZGVyOiBbXG4gICAgICAgICd2YXJ5aW5nIHZlYzMgdk5vcm1hbDsnLFxuICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICAgJ2Zsb2F0IGludGVuc2l0eSA9IHBvdyggMC44IC0gZG90KCB2Tm9ybWFsLCB2ZWMzKCAwLCAwLCAxLjAgKSApLCAxMi4wICk7JyxcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNCggMS4wLCAxLjAsIDEuMCwgMS4wICkgKiBpbnRlbnNpdHk7JyxcbiAgICAgICAgJ30nXG4gICAgICBdLmpvaW4oJ1xcbicpXG4gICAgfVxuICB9O1xuXG4gIHZhciBjYW1lcmEsIHNjZW5lLCByZW5kZXJlciwgdywgaDtcbiAgdmFyIG1lc2gsIGF0bW9zcGhlcmUsIHBvaW50O1xuXG4gIHZhciBvdmVyUmVuZGVyZXI7XG5cbiAgdmFyIGN1clpvb21TcGVlZCA9IDA7XG4gIHZhciB6b29tU3BlZWQgPSA1MDtcblxuICB2YXIgbW91c2UgPSB7IHg6IDAsIHk6IDAgfSwgbW91c2VPbkRvd24gPSB7IHg6IDAsIHk6IDAgfTtcbiAgdmFyIHJvdGF0aW9uID0geyB4OiAwLCB5OiAwIH0sXG4gICAgICB0YXJnZXQgPSB7IHg6IE1hdGguUEkqMy8yLCB5OiBNYXRoLlBJIC8gNi4wIH0sXG4gICAgICB0YXJnZXRPbkRvd24gPSB7IHg6IDAsIHk6IDAgfTtcblxuICB2YXIgZGlzdGFuY2UgPSAxMDAwMDAsIGRpc3RhbmNlVGFyZ2V0ID0gMTAwMDAwO1xuICB2YXIgcGFkZGluZyA9IDQwO1xuICB2YXIgUElfSEFMRiA9IE1hdGguUEkgLyAyO1xuXG4gIGZ1bmN0aW9uIGluaXQoKSB7XG5cbiAgICBjb250YWluZXIuc3R5bGUuY29sb3IgPSAnI2ZmZic7XG4gICAgY29udGFpbmVyLnN0eWxlLmZvbnQgPSAnMTNweC8yMHB4IEFyaWFsLCBzYW5zLXNlcmlmJztcblxuICAgIHZhciBzaGFkZXIsIHVuaWZvcm1zLCBtYXRlcmlhbDtcbiAgICB3ID0gY29udGFpbmVyLm9mZnNldFdpZHRoIHx8IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGggPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0IHx8IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgIGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSgzMCwgdyAvIGgsIDEsIDEwMDAwKTtcbiAgICBjYW1lcmEucG9zaXRpb24ueiA9IGRpc3RhbmNlO1xuXG4gICAgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgyMDAsIDQwLCAzMCk7XG5cbiAgICBzaGFkZXIgPSBTaGFkZXJzWydlYXJ0aCddO1xuICAgIHVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZShzaGFkZXIudW5pZm9ybXMpO1xuXG4gICAgdW5pZm9ybXNbJ3RleHR1cmUnXS52YWx1ZSA9IFRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUoaW1nRGlyKyd3b3JsZC5qcGcnKTtcblxuICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtcblxuICAgICAgICAgIHVuaWZvcm1zOiB1bmlmb3JtcyxcbiAgICAgICAgICB2ZXJ0ZXhTaGFkZXI6IHNoYWRlci52ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlclxuXG4gICAgICAgIH0pO1xuXG4gICAgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgbWVzaC5yb3RhdGlvbi55ID0gTWF0aC5QSTtcbiAgICBzY2VuZS5hZGQobWVzaCk7XG5cbiAgICBzaGFkZXIgPSBTaGFkZXJzWydhdG1vc3BoZXJlJ107XG4gICAgdW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKHNoYWRlci51bmlmb3Jtcyk7XG5cbiAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7XG5cbiAgICAgICAgICB1bmlmb3JtczogdW5pZm9ybXMsXG4gICAgICAgICAgdmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLFxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyOiBzaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgc2lkZTogVEhSRUUuQmFja1NpZGUsXG4gICAgICAgICAgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcsXG4gICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWVcblxuICAgICAgICB9KTtcblxuICAgIG1lc2ggPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgIG1lc2guc2NhbGUuc2V0KCAxLjEsIDEuMSwgMS4xICk7XG4gICAgc2NlbmUuYWRkKG1lc2gpO1xuXG4gICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3ViZUdlb21ldHJ5KDAuNzUsIDAuNzUsIDEpO1xuICAgIGdlb21ldHJ5LmFwcGx5TWF0cml4KG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVRyYW5zbGF0aW9uKDAsMCwtMC41KSk7XG5cbiAgICBwb2ludCA9IG5ldyBUSFJFRS5NZXNoKGdlb21ldHJ5KTtcblxuICAgIHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe2FudGlhbGlhczogdHJ1ZX0pO1xuICAgIHJlbmRlcmVyLnNldFNpemUodywgaCk7XG5cbiAgICByZW5kZXJlci5kb21FbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KTtcblxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbk1vdXNlRG93biwgZmFsc2UpO1xuXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBvbk1vdXNlV2hlZWwsIGZhbHNlKTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbkRvY3VtZW50S2V5RG93biwgZmFsc2UpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplLCBmYWxzZSk7XG5cbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgZnVuY3Rpb24oKSB7XG4gICAgICBvdmVyUmVuZGVyZXIgPSB0cnVlO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgb3ZlclJlbmRlcmVyID0gZmFsc2U7XG4gICAgfSwgZmFsc2UpO1xuICB9XG5cbiAgYWRkRGF0YSA9IGZ1bmN0aW9uKGRhdGEsIG9wdHMpIHtcbiAgICB2YXIgbGF0LCBsbmcsIHNpemUsIGNvbG9yLCBpLCBzdGVwLCBjb2xvckZuV3JhcHBlcjtcblxuICAgIG9wdHMuYW5pbWF0ZWQgPSBvcHRzLmFuaW1hdGVkIHx8IGZhbHNlO1xuICAgIHRoaXMuaXNfYW5pbWF0ZWQgPSBvcHRzLmFuaW1hdGVkO1xuICAgIG9wdHMuZm9ybWF0ID0gb3B0cy5mb3JtYXQgfHwgJ21hZ25pdHVkZSc7IC8vIG90aGVyIG9wdGlvbiBpcyAnbGVnZW5kJ1xuICAgIGNvbnNvbGUubG9nKG9wdHMuZm9ybWF0KTtcbiAgICBpZiAob3B0cy5mb3JtYXQgPT09ICdtYWduaXR1ZGUnKSB7XG4gICAgICBzdGVwID0gMztcbiAgICAgIGNvbG9yRm5XcmFwcGVyID0gZnVuY3Rpb24oZGF0YSwgaSkgeyByZXR1cm4gY29sb3JGbihkYXRhW2krMl0pOyB9XG4gICAgfSBlbHNlIGlmIChvcHRzLmZvcm1hdCA9PT0gJ2xlZ2VuZCcpIHtcbiAgICAgIHN0ZXAgPSA0O1xuICAgICAgY29sb3JGbldyYXBwZXIgPSBmdW5jdGlvbihkYXRhLCBpKSB7IHJldHVybiBjb2xvckZuKGRhdGFbaSszXSk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3coJ2Vycm9yOiBmb3JtYXQgbm90IHN1cHBvcnRlZDogJytvcHRzLmZvcm1hdCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuYW5pbWF0ZWQpIHtcbiAgICAgIGlmICh0aGlzLl9iYXNlR2VvbWV0cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9iYXNlR2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IHN0ZXApIHtcbiAgICAgICAgICBsYXQgPSBkYXRhW2ldO1xuICAgICAgICAgIGxuZyA9IGRhdGFbaSArIDFdO1xuLy8gICAgICAgIHNpemUgPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgICBjb2xvciA9IGNvbG9yRm5XcmFwcGVyKGRhdGEsaSk7XG4gICAgICAgICAgc2l6ZSA9IDA7XG4gICAgICAgICAgYWRkUG9pbnQobGF0LCBsbmcsIHNpemUsIGNvbG9yLCB0aGlzLl9iYXNlR2VvbWV0cnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZih0aGlzLl9tb3JwaFRhcmdldElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fbW9ycGhUYXJnZXRJZCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9tb3JwaFRhcmdldElkICs9IDE7XG4gICAgICB9XG4gICAgICBvcHRzLm5hbWUgPSBvcHRzLm5hbWUgfHwgJ21vcnBoVGFyZ2V0Jyt0aGlzLl9tb3JwaFRhcmdldElkO1xuICAgIH1cbiAgICB2YXIgc3ViZ2VvID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IHN0ZXApIHtcbiAgICAgIGxhdCA9IGRhdGFbaV07XG4gICAgICBsbmcgPSBkYXRhW2kgKyAxXTtcbiAgICAgIGNvbG9yID0gY29sb3JGbldyYXBwZXIoZGF0YSxpKTtcbiAgICAgIHNpemUgPSBkYXRhW2kgKyAyXTtcbiAgICAgIHNpemUgPSBzaXplKjIwMDtcbiAgICAgIGFkZFBvaW50KGxhdCwgbG5nLCBzaXplLCBjb2xvciwgc3ViZ2VvKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuYW5pbWF0ZWQpIHtcbiAgICAgIHRoaXMuX2Jhc2VHZW9tZXRyeS5tb3JwaFRhcmdldHMucHVzaCh7J25hbWUnOiBvcHRzLm5hbWUsIHZlcnRpY2VzOiBzdWJnZW8udmVydGljZXN9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYmFzZUdlb21ldHJ5ID0gc3ViZ2VvO1xuICAgIH1cblxuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVBvaW50cygpIHtcbiAgICBpZiAodGhpcy5fYmFzZUdlb21ldHJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aGlzLmlzX2FuaW1hdGVkID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLnBvaW50cyA9IG5ldyBUSFJFRS5NZXNoKHRoaXMuX2Jhc2VHZW9tZXRyeSwgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgICAgICAgY29sb3I6IDB4ZmZmZmZmLFxuICAgICAgICAgICAgICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLkZhY2VDb2xvcnMsXG4gICAgICAgICAgICAgIG1vcnBoVGFyZ2V0czogZmFsc2VcbiAgICAgICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9iYXNlR2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCA8IDgpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygndCBsJyx0aGlzLl9iYXNlR2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCk7XG4gICAgICAgICAgdmFyIHBhZGRpbmcgPSA4LXRoaXMuX2Jhc2VHZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdwYWRkaW5nJywgcGFkZGluZyk7XG4gICAgICAgICAgZm9yKHZhciBpPTA7IGk8PXBhZGRpbmc7IGkrKykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3BhZGRpbmcnLGkpO1xuICAgICAgICAgICAgdGhpcy5fYmFzZUdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5wdXNoKHsnbmFtZSc6ICdtb3JwaFBhZGRpbmcnK2ksIHZlcnRpY2VzOiB0aGlzLl9iYXNlR2VvbWV0cnkudmVydGljZXN9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb2ludHMgPSBuZXcgVEhSRUUuTWVzaCh0aGlzLl9iYXNlR2VvbWV0cnksIG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgICAgICAgIGNvbG9yOiAweGZmZmZmZixcbiAgICAgICAgICAgICAgdmVydGV4Q29sb3JzOiBUSFJFRS5GYWNlQ29sb3JzLFxuICAgICAgICAgICAgICBtb3JwaFRhcmdldHM6IHRydWVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHNjZW5lLmFkZCh0aGlzLnBvaW50cyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkUG9pbnQobGF0LCBsbmcsIHNpemUsIGNvbG9yLCBzdWJnZW8pIHtcblxuICAgIHZhciBwaGkgPSAoOTAgLSBsYXQpICogTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIgdGhldGEgPSAoMTgwIC0gbG5nKSAqIE1hdGguUEkgLyAxODA7XG5cbiAgICBwb2ludC5wb3NpdGlvbi54ID0gMjAwICogTWF0aC5zaW4ocGhpKSAqIE1hdGguY29zKHRoZXRhKTtcbiAgICBwb2ludC5wb3NpdGlvbi55ID0gMjAwICogTWF0aC5jb3MocGhpKTtcbiAgICBwb2ludC5wb3NpdGlvbi56ID0gMjAwICogTWF0aC5zaW4ocGhpKSAqIE1hdGguc2luKHRoZXRhKTtcblxuICAgIHBvaW50Lmxvb2tBdChtZXNoLnBvc2l0aW9uKTtcblxuICAgIHBvaW50LnNjYWxlLnogPSBNYXRoLm1heCggc2l6ZSwgMC4xICk7IC8vIGF2b2lkIG5vbi1pbnZlcnRpYmxlIG1hdHJpeFxuICAgIHBvaW50LnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludC5nZW9tZXRyeS5mYWNlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICBwb2ludC5nZW9tZXRyeS5mYWNlc1tpXS5jb2xvciA9IGNvbG9yO1xuXG4gICAgfVxuXG4gICAgVEhSRUUuR2VvbWV0cnlVdGlscy5tZXJnZShzdWJnZW8sIHBvaW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0Jywgb25Nb3VzZU91dCwgZmFsc2UpO1xuXG4gICAgbW91c2VPbkRvd24ueCA9IC0gZXZlbnQuY2xpZW50WDtcbiAgICBtb3VzZU9uRG93bi55ID0gZXZlbnQuY2xpZW50WTtcblxuICAgIHRhcmdldE9uRG93bi54ID0gdGFyZ2V0Lng7XG4gICAgdGFyZ2V0T25Eb3duLnkgPSB0YXJnZXQueTtcblxuICAgIGNvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSAnbW92ZSc7XG4gIH1cblxuICBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudCkge1xuICAgIG1vdXNlLnggPSAtIGV2ZW50LmNsaWVudFg7XG4gICAgbW91c2UueSA9IGV2ZW50LmNsaWVudFk7XG5cbiAgICB2YXIgem9vbURhbXAgPSBkaXN0YW5jZS8xMDAwO1xuXG4gICAgdGFyZ2V0LnggPSB0YXJnZXRPbkRvd24ueCArIChtb3VzZS54IC0gbW91c2VPbkRvd24ueCkgKiAwLjAwNSAqIHpvb21EYW1wO1xuICAgIHRhcmdldC55ID0gdGFyZ2V0T25Eb3duLnkgKyAobW91c2UueSAtIG1vdXNlT25Eb3duLnkpICogMC4wMDUgKiB6b29tRGFtcDtcblxuICAgIHRhcmdldC55ID0gdGFyZ2V0LnkgPiBQSV9IQUxGID8gUElfSEFMRiA6IHRhcmdldC55O1xuICAgIHRhcmdldC55ID0gdGFyZ2V0LnkgPCAtIFBJX0hBTEYgPyAtIFBJX0hBTEYgOiB0YXJnZXQueTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTW91c2VVcChldmVudCkge1xuICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgZmFsc2UpO1xuICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0Jywgb25Nb3VzZU91dCwgZmFsc2UpO1xuICAgIGNvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSAnYXV0byc7XG4gIH1cblxuICBmdW5jdGlvbiBvbk1vdXNlT3V0KGV2ZW50KSB7XG4gICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXAsIGZhbHNlKTtcbiAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBvbk1vdXNlT3V0LCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbk1vdXNlV2hlZWwoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChvdmVyUmVuZGVyZXIpIHtcbiAgICAgIHpvb20oZXZlbnQud2hlZWxEZWx0YVkgKiAwLjMpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBvbkRvY3VtZW50S2V5RG93bihldmVudCkge1xuICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgem9vbSgxMDApO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDA6XG4gICAgICAgIHpvb20oLTEwMCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uV2luZG93UmVzaXplKCBldmVudCApIHtcbiAgICBjYW1lcmEuYXNwZWN0ID0gY29udGFpbmVyLm9mZnNldFdpZHRoIC8gY29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIHJlbmRlcmVyLnNldFNpemUoIGNvbnRhaW5lci5vZmZzZXRXaWR0aCwgY29udGFpbmVyLm9mZnNldEhlaWdodCApO1xuICB9XG5cbiAgZnVuY3Rpb24gem9vbShkZWx0YSkge1xuICAgIGRpc3RhbmNlVGFyZ2V0IC09IGRlbHRhO1xuICAgIGRpc3RhbmNlVGFyZ2V0ID0gZGlzdGFuY2VUYXJnZXQgPiAxMDAwID8gMTAwMCA6IGRpc3RhbmNlVGFyZ2V0O1xuICAgIGRpc3RhbmNlVGFyZ2V0ID0gZGlzdGFuY2VUYXJnZXQgPCAzNTAgPyAzNTAgOiBkaXN0YW5jZVRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgIHJlbmRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHpvb20oY3VyWm9vbVNwZWVkKTtcblxuICAgIHJvdGF0aW9uLnggKz0gKHRhcmdldC54IC0gcm90YXRpb24ueCkgKiAwLjE7XG4gICAgcm90YXRpb24ueSArPSAodGFyZ2V0LnkgLSByb3RhdGlvbi55KSAqIDAuMTtcbiAgICBkaXN0YW5jZSArPSAoZGlzdGFuY2VUYXJnZXQgLSBkaXN0YW5jZSkgKiAwLjM7XG5cbiAgICBjYW1lcmEucG9zaXRpb24ueCA9IGRpc3RhbmNlICogTWF0aC5zaW4ocm90YXRpb24ueCkgKiBNYXRoLmNvcyhyb3RhdGlvbi55KTtcbiAgICBjYW1lcmEucG9zaXRpb24ueSA9IGRpc3RhbmNlICogTWF0aC5zaW4ocm90YXRpb24ueSk7XG4gICAgY2FtZXJhLnBvc2l0aW9uLnogPSBkaXN0YW5jZSAqIE1hdGguY29zKHJvdGF0aW9uLngpICogTWF0aC5jb3Mocm90YXRpb24ueSk7XG5cbiAgICBjYW1lcmEubG9va0F0KG1lc2gucG9zaXRpb24pO1xuXG4gICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICB9XG5cbiAgaW5pdCgpO1xuICB0aGlzLmFuaW1hdGUgPSBhbmltYXRlO1xuXG5cbiAgdGhpcy5fX2RlZmluZUdldHRlcl9fKCd0aW1lJywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWUgfHwgMDtcbiAgfSk7XG5cbiAgdGhpcy5fX2RlZmluZVNldHRlcl9fKCd0aW1lJywgZnVuY3Rpb24odCkge1xuICAgIHZhciB2YWxpZE1vcnBocyA9IFtdO1xuICAgIHZhciBtb3JwaERpY3QgPSB0aGlzLnBvaW50cy5tb3JwaFRhcmdldERpY3Rpb25hcnk7XG4gICAgZm9yKHZhciBrIGluIG1vcnBoRGljdCkge1xuICAgICAgaWYoay5pbmRleE9mKCdtb3JwaFBhZGRpbmcnKSA8IDApIHtcbiAgICAgICAgdmFsaWRNb3JwaHMucHVzaChtb3JwaERpY3Rba10pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YWxpZE1vcnBocy5zb3J0KCk7XG4gICAgdmFyIGwgPSB2YWxpZE1vcnBocy5sZW5ndGgtMTtcbiAgICB2YXIgc2NhbGVkdCA9IHQqbCsxO1xuICAgIHZhciBpbmRleCA9IE1hdGguZmxvb3Ioc2NhbGVkdCk7XG4gICAgZm9yIChpPTA7aTx2YWxpZE1vcnBocy5sZW5ndGg7aSsrKSB7XG4gICAgICB0aGlzLnBvaW50cy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbdmFsaWRNb3JwaHNbaV1dID0gMDtcbiAgICB9XG4gICAgdmFyIGxhc3RJbmRleCA9IGluZGV4IC0gMTtcbiAgICB2YXIgbGVmdG92ZXIgPSBzY2FsZWR0IC0gaW5kZXg7XG4gICAgaWYgKGxhc3RJbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLnBvaW50cy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbbGFzdEluZGV4XSA9IDEgLSBsZWZ0b3ZlcjtcbiAgICB9XG4gICAgdGhpcy5wb2ludHMubW9ycGhUYXJnZXRJbmZsdWVuY2VzW2luZGV4XSA9IGxlZnRvdmVyO1xuICAgIHRoaXMuX3RpbWUgPSB0O1xuICB9KTtcblxuICB0aGlzLmFkZERhdGEgPSBhZGREYXRhO1xuICB0aGlzLmNyZWF0ZVBvaW50cyA9IGNyZWF0ZVBvaW50cztcbiAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICB0aGlzLnNjZW5lID0gc2NlbmU7XG5cbiAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gREFUO1xuIiwiLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtci5kb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuRGV0ZWN0b3IgPSB7XG5cbiAgY2FudmFzIDogISEgd2luZG93LkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgd2ViZ2wgOiAoIGZ1bmN0aW9uICgpIHsgdHJ5IHsgcmV0dXJuICEhIHdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQgJiYgISEgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKS5nZXRDb250ZXh0KCAnZXhwZXJpbWVudGFsLXdlYmdsJyApOyB9IGNhdGNoKCBlICkgeyByZXR1cm4gZmFsc2U7IH0gfSApKCksXG4gIHdvcmtlcnMgOiAhISB3aW5kb3cuV29ya2VyLFxuICBmaWxlYXBpIDogd2luZG93LkZpbGUgJiYgd2luZG93LkZpbGVSZWFkZXIgJiYgd2luZG93LkZpbGVMaXN0ICYmIHdpbmRvdy5CbG9iLFxuXG4gIGdldFdlYkdMRXJyb3JNZXNzYWdlIDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXG4gICAgZG9tRWxlbWVudC5zdHlsZS5mb250RmFtaWx5ID0gJ21vbm9zcGFjZSc7XG4gICAgZG9tRWxlbWVudC5zdHlsZS5mb250U2l6ZSA9ICcxM3B4JztcbiAgICBkb21FbGVtZW50LnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGRvbUVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZCA9ICcjZWVlJztcbiAgICBkb21FbGVtZW50LnN0eWxlLmNvbG9yID0gJyMwMDAnO1xuICAgIGRvbUVsZW1lbnQuc3R5bGUucGFkZGluZyA9ICcxZW0nO1xuICAgIGRvbUVsZW1lbnQuc3R5bGUud2lkdGggPSAnNDc1cHgnO1xuICAgIGRvbUVsZW1lbnQuc3R5bGUubWFyZ2luID0gJzVlbSBhdXRvIDAnO1xuXG4gICAgaWYgKCAhIHRoaXMud2ViZ2wgKSB7XG5cbiAgICAgIGRvbUVsZW1lbnQuaW5uZXJIVE1MID0gd2luZG93LldlYkdMUmVuZGVyaW5nQ29udGV4dCA/IFtcbiAgICAgICAgJ1NvcnJ5LCB5b3VyIGdyYXBoaWNzIGNhcmQgZG9lc25cXCd0IHN1cHBvcnQgPGEgaHJlZj1cImh0dHA6Ly9raHJvbm9zLm9yZy93ZWJnbC93aWtpL0dldHRpbmdfYV9XZWJHTF9JbXBsZW1lbnRhdGlvblwiPldlYkdMPC9hPidcbiAgICAgIF0uam9pbiggJ1xcbicgKSA6IFtcbiAgICAgICAgJ1NvcnJ5LCB5b3VyIGJyb3dzZXIgZG9lc25cXCd0IHN1cHBvcnQgPGEgaHJlZj1cImh0dHA6Ly9raHJvbm9zLm9yZy93ZWJnbC93aWtpL0dldHRpbmdfYV9XZWJHTF9JbXBsZW1lbnRhdGlvblwiPldlYkdMPC9hPjxici8+JyxcbiAgICAgICAgJ1BsZWFzZSB0cnkgd2l0aCcsXG4gICAgICAgICc8YSBocmVmPVwiaHR0cDovL3d3dy5nb29nbGUuY29tL2Nocm9tZVwiPkNocm9tZTwvYT4sICcsXG4gICAgICAgICc8YSBocmVmPVwiaHR0cDovL3d3dy5tb3ppbGxhLmNvbS9lbi1VUy9maXJlZm94L25ldy9cIj5GaXJlZm94IDQ8L2E+IG9yJyxcbiAgICAgICAgJzxhIGhyZWY9XCJodHRwOi8vbmlnaHRseS53ZWJraXQub3JnL1wiPldlYmtpdCBOaWdodGx5IChNYWMpPC9hPidcbiAgICAgIF0uam9pbiggJ1xcbicgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBkb21FbGVtZW50O1xuXG4gIH0sXG5cbiAgYWRkR2V0V2ViR0xNZXNzYWdlIDogZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgdmFyIHBhcmVudCwgaWQsIGRvbUVsZW1lbnQ7XG5cbiAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcblxuICAgIHBhcmVudCA9IHBhcmFtZXRlcnMucGFyZW50ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnBhcmVudCA6IGRvY3VtZW50LmJvZHk7XG4gICAgaWQgPSBwYXJhbWV0ZXJzLmlkICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmlkIDogJ29sZGllJztcblxuICAgIGRvbUVsZW1lbnQgPSBEZXRlY3Rvci5nZXRXZWJHTEVycm9yTWVzc2FnZSgpO1xuICAgIGRvbUVsZW1lbnQuaWQgPSBpZDtcblxuICAgIHBhcmVudC5hcHBlbmRDaGlsZCggZG9tRWxlbWVudCApO1xuXG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZXRlY3RvcjtcblxuIiwiLy8gVHdlZW4uanMgLSBodHRwOi8vZ2l0aHViLmNvbS9zb2xlL3R3ZWVuLmpzXG52YXIgVFdFRU49VFdFRU58fGZ1bmN0aW9uKCl7dmFyIGEsZSxjLGQsZj1bXTtyZXR1cm57c3RhcnQ6ZnVuY3Rpb24oZyl7Yz1zZXRJbnRlcnZhbCh0aGlzLnVwZGF0ZSwxRTMvKGd8fDYwKSl9LHN0b3A6ZnVuY3Rpb24oKXtjbGVhckludGVydmFsKGMpfSxhZGQ6ZnVuY3Rpb24oZyl7Zi5wdXNoKGcpfSxyZW1vdmU6ZnVuY3Rpb24oZyl7YT1mLmluZGV4T2YoZyk7YSE9PS0xJiZmLnNwbGljZShhLDEpfSx1cGRhdGU6ZnVuY3Rpb24oKXthPTA7ZT1mLmxlbmd0aDtmb3IoZD0obmV3IERhdGUpLmdldFRpbWUoKTthPGU7KWlmKGZbYV0udXBkYXRlKGQpKWErKztlbHNle2Yuc3BsaWNlKGEsMSk7ZS0tfX19fSgpO1xuVFdFRU4uVHdlZW49ZnVuY3Rpb24oYSl7dmFyIGU9e30sYz17fSxkPXt9LGY9MUUzLGc9MCxqPW51bGwsbj1UV0VFTi5FYXNpbmcuTGluZWFyLkVhc2VOb25lLGs9bnVsbCxsPW51bGwsbT1udWxsO3RoaXMudG89ZnVuY3Rpb24oYixoKXtpZihoIT09bnVsbClmPWg7Zm9yKHZhciBpIGluIGIpaWYoYVtpXSE9PW51bGwpZFtpXT1iW2ldO3JldHVybiB0aGlzfTt0aGlzLnN0YXJ0PWZ1bmN0aW9uKCl7VFdFRU4uYWRkKHRoaXMpO2o9KG5ldyBEYXRlKS5nZXRUaW1lKCkrZztmb3IodmFyIGIgaW4gZClpZihhW2JdIT09bnVsbCl7ZVtiXT1hW2JdO2NbYl09ZFtiXS1hW2JdfXJldHVybiB0aGlzfTt0aGlzLnN0b3A9ZnVuY3Rpb24oKXtUV0VFTi5yZW1vdmUodGhpcyk7cmV0dXJuIHRoaXN9O3RoaXMuZGVsYXk9ZnVuY3Rpb24oYil7Zz1iO3JldHVybiB0aGlzfTt0aGlzLmVhc2luZz1mdW5jdGlvbihiKXtuPWI7cmV0dXJuIHRoaXN9O3RoaXMuY2hhaW49ZnVuY3Rpb24oYil7az1ifTt0aGlzLm9uVXBkYXRlPVxuZnVuY3Rpb24oYil7bD1iO3JldHVybiB0aGlzfTt0aGlzLm9uQ29tcGxldGU9ZnVuY3Rpb24oYil7bT1iO3JldHVybiB0aGlzfTt0aGlzLnVwZGF0ZT1mdW5jdGlvbihiKXt2YXIgaCxpO2lmKGI8ailyZXR1cm4gdHJ1ZTtiPShiLWopL2Y7Yj1iPjE/MTpiO2k9bihiKTtmb3IoaCBpbiBjKWFbaF09ZVtoXStjW2hdKmk7bCE9PW51bGwmJmwuY2FsbChhLGkpO2lmKGI9PTEpe20hPT1udWxsJiZtLmNhbGwoYSk7ayE9PW51bGwmJmsuc3RhcnQoKTtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9fTtUV0VFTi5FYXNpbmc9e0xpbmVhcjp7fSxRdWFkcmF0aWM6e30sQ3ViaWM6e30sUXVhcnRpYzp7fSxRdWludGljOnt9LFNpbnVzb2lkYWw6e30sRXhwb25lbnRpYWw6e30sQ2lyY3VsYXI6e30sRWxhc3RpYzp7fSxCYWNrOnt9LEJvdW5jZTp7fX07VFdFRU4uRWFzaW5nLkxpbmVhci5FYXNlTm9uZT1mdW5jdGlvbihhKXtyZXR1cm4gYX07XG5UV0VFTi5FYXNpbmcuUXVhZHJhdGljLkVhc2VJbj1mdW5jdGlvbihhKXtyZXR1cm4gYSphfTtUV0VFTi5FYXNpbmcuUXVhZHJhdGljLkVhc2VPdXQ9ZnVuY3Rpb24oYSl7cmV0dXJuLWEqKGEtMil9O1RXRUVOLkVhc2luZy5RdWFkcmF0aWMuRWFzZUluT3V0PWZ1bmN0aW9uKGEpe2lmKChhKj0yKTwxKXJldHVybiAwLjUqYSphO3JldHVybi0wLjUqKC0tYSooYS0yKS0xKX07VFdFRU4uRWFzaW5nLkN1YmljLkVhc2VJbj1mdW5jdGlvbihhKXtyZXR1cm4gYSphKmF9O1RXRUVOLkVhc2luZy5DdWJpYy5FYXNlT3V0PWZ1bmN0aW9uKGEpe3JldHVybi0tYSphKmErMX07VFdFRU4uRWFzaW5nLkN1YmljLkVhc2VJbk91dD1mdW5jdGlvbihhKXtpZigoYSo9Mik8MSlyZXR1cm4gMC41KmEqYSphO3JldHVybiAwLjUqKChhLT0yKSphKmErMil9O1RXRUVOLkVhc2luZy5RdWFydGljLkVhc2VJbj1mdW5jdGlvbihhKXtyZXR1cm4gYSphKmEqYX07XG5UV0VFTi5FYXNpbmcuUXVhcnRpYy5FYXNlT3V0PWZ1bmN0aW9uKGEpe3JldHVybi0oLS1hKmEqYSphLTEpfTtUV0VFTi5FYXNpbmcuUXVhcnRpYy5FYXNlSW5PdXQ9ZnVuY3Rpb24oYSl7aWYoKGEqPTIpPDEpcmV0dXJuIDAuNSphKmEqYSphO3JldHVybi0wLjUqKChhLT0yKSphKmEqYS0yKX07VFdFRU4uRWFzaW5nLlF1aW50aWMuRWFzZUluPWZ1bmN0aW9uKGEpe3JldHVybiBhKmEqYSphKmF9O1RXRUVOLkVhc2luZy5RdWludGljLkVhc2VPdXQ9ZnVuY3Rpb24oYSl7cmV0dXJuKGEtPTEpKmEqYSphKmErMX07VFdFRU4uRWFzaW5nLlF1aW50aWMuRWFzZUluT3V0PWZ1bmN0aW9uKGEpe2lmKChhKj0yKTwxKXJldHVybiAwLjUqYSphKmEqYSphO3JldHVybiAwLjUqKChhLT0yKSphKmEqYSphKzIpfTtUV0VFTi5FYXNpbmcuU2ludXNvaWRhbC5FYXNlSW49ZnVuY3Rpb24oYSl7cmV0dXJuLU1hdGguY29zKGEqTWF0aC5QSS8yKSsxfTtcblRXRUVOLkVhc2luZy5TaW51c29pZGFsLkVhc2VPdXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGguc2luKGEqTWF0aC5QSS8yKX07VFdFRU4uRWFzaW5nLlNpbnVzb2lkYWwuRWFzZUluT3V0PWZ1bmN0aW9uKGEpe3JldHVybi0wLjUqKE1hdGguY29zKE1hdGguUEkqYSktMSl9O1RXRUVOLkVhc2luZy5FeHBvbmVudGlhbC5FYXNlSW49ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PTA/MDpNYXRoLnBvdygyLDEwKihhLTEpKX07VFdFRU4uRWFzaW5nLkV4cG9uZW50aWFsLkVhc2VPdXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PTE/MTotTWF0aC5wb3coMiwtMTAqYSkrMX07VFdFRU4uRWFzaW5nLkV4cG9uZW50aWFsLkVhc2VJbk91dD1mdW5jdGlvbihhKXtpZihhPT0wKXJldHVybiAwO2lmKGE9PTEpcmV0dXJuIDE7aWYoKGEqPTIpPDEpcmV0dXJuIDAuNSpNYXRoLnBvdygyLDEwKihhLTEpKTtyZXR1cm4gMC41KigtTWF0aC5wb3coMiwtMTAqKGEtMSkpKzIpfTtcblRXRUVOLkVhc2luZy5DaXJjdWxhci5FYXNlSW49ZnVuY3Rpb24oYSl7cmV0dXJuLShNYXRoLnNxcnQoMS1hKmEpLTEpfTtUV0VFTi5FYXNpbmcuQ2lyY3VsYXIuRWFzZU91dD1mdW5jdGlvbihhKXtyZXR1cm4gTWF0aC5zcXJ0KDEtIC0tYSphKX07VFdFRU4uRWFzaW5nLkNpcmN1bGFyLkVhc2VJbk91dD1mdW5jdGlvbihhKXtpZigoYS89MC41KTwxKXJldHVybi0wLjUqKE1hdGguc3FydCgxLWEqYSktMSk7cmV0dXJuIDAuNSooTWF0aC5zcXJ0KDEtKGEtPTIpKmEpKzEpfTtUV0VFTi5FYXNpbmcuRWxhc3RpYy5FYXNlSW49ZnVuY3Rpb24oYSl7dmFyIGUsYz0wLjEsZD0wLjQ7aWYoYT09MClyZXR1cm4gMDtpZihhPT0xKXJldHVybiAxO2R8fChkPTAuMyk7aWYoIWN8fGM8MSl7Yz0xO2U9ZC80fWVsc2UgZT1kLygyKk1hdGguUEkpKk1hdGguYXNpbigxL2MpO3JldHVybi0oYypNYXRoLnBvdygyLDEwKihhLT0xKSkqTWF0aC5zaW4oKGEtZSkqMipNYXRoLlBJL2QpKX07XG5UV0VFTi5FYXNpbmcuRWxhc3RpYy5FYXNlT3V0PWZ1bmN0aW9uKGEpe3ZhciBlLGM9MC4xLGQ9MC40O2lmKGE9PTApcmV0dXJuIDA7aWYoYT09MSlyZXR1cm4gMTtkfHwoZD0wLjMpO2lmKCFjfHxjPDEpe2M9MTtlPWQvNH1lbHNlIGU9ZC8oMipNYXRoLlBJKSpNYXRoLmFzaW4oMS9jKTtyZXR1cm4gYypNYXRoLnBvdygyLC0xMCphKSpNYXRoLnNpbigoYS1lKSoyKk1hdGguUEkvZCkrMX07XG5UV0VFTi5FYXNpbmcuRWxhc3RpYy5FYXNlSW5PdXQ9ZnVuY3Rpb24oYSl7dmFyIGUsYz0wLjEsZD0wLjQ7aWYoYT09MClyZXR1cm4gMDtpZihhPT0xKXJldHVybiAxO2R8fChkPTAuMyk7aWYoIWN8fGM8MSl7Yz0xO2U9ZC80fWVsc2UgZT1kLygyKk1hdGguUEkpKk1hdGguYXNpbigxL2MpO2lmKChhKj0yKTwxKXJldHVybi0wLjUqYypNYXRoLnBvdygyLDEwKihhLT0xKSkqTWF0aC5zaW4oKGEtZSkqMipNYXRoLlBJL2QpO3JldHVybiBjKk1hdGgucG93KDIsLTEwKihhLT0xKSkqTWF0aC5zaW4oKGEtZSkqMipNYXRoLlBJL2QpKjAuNSsxfTtUV0VFTi5FYXNpbmcuQmFjay5FYXNlSW49ZnVuY3Rpb24oYSl7cmV0dXJuIGEqYSooMi43MDE1OCphLTEuNzAxNTgpfTtUV0VFTi5FYXNpbmcuQmFjay5FYXNlT3V0PWZ1bmN0aW9uKGEpe3JldHVybihhLT0xKSphKigyLjcwMTU4KmErMS43MDE1OCkrMX07XG5UV0VFTi5FYXNpbmcuQmFjay5FYXNlSW5PdXQ9ZnVuY3Rpb24oYSl7aWYoKGEqPTIpPDEpcmV0dXJuIDAuNSphKmEqKDMuNTk0OTA5NSphLTIuNTk0OTA5NSk7cmV0dXJuIDAuNSooKGEtPTIpKmEqKDMuNTk0OTA5NSphKzIuNTk0OTA5NSkrMil9O1RXRUVOLkVhc2luZy5Cb3VuY2UuRWFzZUluPWZ1bmN0aW9uKGEpe3JldHVybiAxLVRXRUVOLkVhc2luZy5Cb3VuY2UuRWFzZU91dCgxLWEpfTtUV0VFTi5FYXNpbmcuQm91bmNlLkVhc2VPdXQ9ZnVuY3Rpb24oYSl7cmV0dXJuKGEvPTEpPDEvMi43NT83LjU2MjUqYSphOmE8Mi8yLjc1PzcuNTYyNSooYS09MS41LzIuNzUpKmErMC43NTphPDIuNS8yLjc1PzcuNTYyNSooYS09Mi4yNS8yLjc1KSphKzAuOTM3NTo3LjU2MjUqKGEtPTIuNjI1LzIuNzUpKmErMC45ODQzNzV9O1xuVFdFRU4uRWFzaW5nLkJvdW5jZS5FYXNlSW5PdXQ9ZnVuY3Rpb24oYSl7aWYoYTwwLjUpcmV0dXJuIFRXRUVOLkVhc2luZy5Cb3VuY2UuRWFzZUluKGEqMikqMC41O3JldHVybiBUV0VFTi5FYXNpbmcuQm91bmNlLkVhc2VPdXQoYSoyLTEpKjAuNSswLjV9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRXRUVOO1xuIiwiLy8gdGhyZWUuanMgLSBodHRwOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanNcbid1c2Ugc3RyaWN0Jzt2YXIgVEhSRUU9e1JFVklTSU9OOlwiNjJcIn07c2VsZi5jb25zb2xlPXNlbGYuY29uc29sZXx8e2luZm86ZnVuY3Rpb24oKXt9LGxvZzpmdW5jdGlvbigpe30sZGVidWc6ZnVuY3Rpb24oKXt9LHdhcm46ZnVuY3Rpb24oKXt9LGVycm9yOmZ1bmN0aW9uKCl7fX07U3RyaW5nLnByb3RvdHlwZS50cmltPVN0cmluZy5wcm90b3R5cGUudHJpbXx8ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLFwiXCIpfTtUSFJFRS5leHRlbmQ9ZnVuY3Rpb24oYSxiKXtpZihPYmplY3Qua2V5cylmb3IodmFyIGM9T2JqZWN0LmtleXMoYiksZD0wLGU9Yy5sZW5ndGg7ZDxlO2QrKyl7dmFyIGY9Y1tkXTtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxmLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYixmKSl9ZWxzZSBmb3IoZiBpbiBjPXt9Lmhhc093blByb3BlcnR5LGIpYy5jYWxsKGIsZikmJihhW2ZdPWJbZl0pO3JldHVybiBhfTtcbihmdW5jdGlvbigpe2Zvcih2YXIgYT0wLGI9W1wibXNcIixcIm1velwiLFwid2Via2l0XCIsXCJvXCJdLGM9MDtjPGIubGVuZ3RoJiYhc2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7KytjKXNlbGYucmVxdWVzdEFuaW1hdGlvbkZyYW1lPXNlbGZbYltjXStcIlJlcXVlc3RBbmltYXRpb25GcmFtZVwiXSxzZWxmLmNhbmNlbEFuaW1hdGlvbkZyYW1lPXNlbGZbYltjXStcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXCJdfHxzZWxmW2JbY10rXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07dm9pZCAwPT09c2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUmJnZvaWQgMCE9PXNlbGYuc2V0VGltZW91dCYmKHNlbGYucmVxdWVzdEFuaW1hdGlvbkZyYW1lPWZ1bmN0aW9uKGIpe3ZhciBjPURhdGUubm93KCksZj1NYXRoLm1heCgwLDE2LShjLWEpKSxoPXNlbGYuc2V0VGltZW91dChmdW5jdGlvbigpe2IoYytmKX0sZik7YT1jK2Y7cmV0dXJuIGh9KTt2b2lkIDA9PT1zZWxmLmNhbmNlbEFuaW1hdGlvbkZyYW1lJiZ2b2lkIDAhPT1cbnNlbGYuY2xlYXJUaW1lb3V0JiYoc2VsZi5jYW5jZWxBbmltYXRpb25GcmFtZT1mdW5jdGlvbihhKXtzZWxmLmNsZWFyVGltZW91dChhKX0pfSkoKTtUSFJFRS5DdWxsRmFjZU5vbmU9MDtUSFJFRS5DdWxsRmFjZUJhY2s9MTtUSFJFRS5DdWxsRmFjZUZyb250PTI7VEhSRUUuQ3VsbEZhY2VGcm9udEJhY2s9MztUSFJFRS5Gcm9udEZhY2VEaXJlY3Rpb25DVz0wO1RIUkVFLkZyb250RmFjZURpcmVjdGlvbkNDVz0xO1RIUkVFLkJhc2ljU2hhZG93TWFwPTA7VEhSRUUuUENGU2hhZG93TWFwPTE7VEhSRUUuUENGU29mdFNoYWRvd01hcD0yO1RIUkVFLkZyb250U2lkZT0wO1RIUkVFLkJhY2tTaWRlPTE7VEhSRUUuRG91YmxlU2lkZT0yO1RIUkVFLk5vU2hhZGluZz0wO1RIUkVFLkZsYXRTaGFkaW5nPTE7VEhSRUUuU21vb3RoU2hhZGluZz0yO1RIUkVFLk5vQ29sb3JzPTA7VEhSRUUuRmFjZUNvbG9ycz0xO1RIUkVFLlZlcnRleENvbG9ycz0yO1RIUkVFLk5vQmxlbmRpbmc9MDtcblRIUkVFLk5vcm1hbEJsZW5kaW5nPTE7VEhSRUUuQWRkaXRpdmVCbGVuZGluZz0yO1RIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmc9MztUSFJFRS5NdWx0aXBseUJsZW5kaW5nPTQ7VEhSRUUuQ3VzdG9tQmxlbmRpbmc9NTtUSFJFRS5BZGRFcXVhdGlvbj0xMDA7VEhSRUUuU3VidHJhY3RFcXVhdGlvbj0xMDE7VEhSRUUuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb249MTAyO1RIUkVFLlplcm9GYWN0b3I9MjAwO1RIUkVFLk9uZUZhY3Rvcj0yMDE7VEhSRUUuU3JjQ29sb3JGYWN0b3I9MjAyO1RIUkVFLk9uZU1pbnVzU3JjQ29sb3JGYWN0b3I9MjAzO1RIUkVFLlNyY0FscGhhRmFjdG9yPTIwNDtUSFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yPTIwNTtUSFJFRS5Ec3RBbHBoYUZhY3Rvcj0yMDY7VEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3Rvcj0yMDc7VEhSRUUuRHN0Q29sb3JGYWN0b3I9MjA4O1RIUkVFLk9uZU1pbnVzRHN0Q29sb3JGYWN0b3I9MjA5O1xuVEhSRUUuU3JjQWxwaGFTYXR1cmF0ZUZhY3Rvcj0yMTA7VEhSRUUuTXVsdGlwbHlPcGVyYXRpb249MDtUSFJFRS5NaXhPcGVyYXRpb249MTtUSFJFRS5BZGRPcGVyYXRpb249MjtUSFJFRS5VVk1hcHBpbmc9ZnVuY3Rpb24oKXt9O1RIUkVFLkN1YmVSZWZsZWN0aW9uTWFwcGluZz1mdW5jdGlvbigpe307VEhSRUUuQ3ViZVJlZnJhY3Rpb25NYXBwaW5nPWZ1bmN0aW9uKCl7fTtUSFJFRS5TcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZz1mdW5jdGlvbigpe307VEhSRUUuU3BoZXJpY2FsUmVmcmFjdGlvbk1hcHBpbmc9ZnVuY3Rpb24oKXt9O1RIUkVFLlJlcGVhdFdyYXBwaW5nPTFFMztUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nPTEwMDE7VEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZz0xMDAyO1RIUkVFLk5lYXJlc3RGaWx0ZXI9MTAwMztUSFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlcj0xMDA0O1RIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXI9MTAwNTtcblRIUkVFLkxpbmVhckZpbHRlcj0xMDA2O1RIUkVFLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXI9MTAwNztUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI9MTAwODtUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlPTEwMDk7VEhSRUUuQnl0ZVR5cGU9MTAxMDtUSFJFRS5TaG9ydFR5cGU9MTAxMTtUSFJFRS5VbnNpZ25lZFNob3J0VHlwZT0xMDEyO1RIUkVFLkludFR5cGU9MTAxMztUSFJFRS5VbnNpZ25lZEludFR5cGU9MTAxNDtUSFJFRS5GbG9hdFR5cGU9MTAxNTtUSFJFRS5VbnNpZ25lZFNob3J0NDQ0NFR5cGU9MTAxNjtUSFJFRS5VbnNpZ25lZFNob3J0NTU1MVR5cGU9MTAxNztUSFJFRS5VbnNpZ25lZFNob3J0NTY1VHlwZT0xMDE4O1RIUkVFLkFscGhhRm9ybWF0PTEwMTk7VEhSRUUuUkdCRm9ybWF0PTEwMjA7VEhSRUUuUkdCQUZvcm1hdD0xMDIxO1RIUkVFLkx1bWluYW5jZUZvcm1hdD0xMDIyO1RIUkVFLkx1bWluYW5jZUFscGhhRm9ybWF0PTEwMjM7XG5USFJFRS5SR0JfUzNUQ19EWFQxX0Zvcm1hdD0yMDAxO1RIUkVFLlJHQkFfUzNUQ19EWFQxX0Zvcm1hdD0yMDAyO1RIUkVFLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdD0yMDAzO1RIUkVFLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdD0yMDA0O1RIUkVFLkNvbG9yPWZ1bmN0aW9uKGEpe3ZvaWQgMCE9PWEmJnRoaXMuc2V0KGEpO3JldHVybiB0aGlzfTtcblRIUkVFLkNvbG9yLnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuQ29sb3IscjoxLGc6MSxiOjEsc2V0OmZ1bmN0aW9uKGEpe2EgaW5zdGFuY2VvZiBUSFJFRS5Db2xvcj90aGlzLmNvcHkoYSk6XCJudW1iZXJcIj09PXR5cGVvZiBhP3RoaXMuc2V0SGV4KGEpOlwic3RyaW5nXCI9PT10eXBlb2YgYSYmdGhpcy5zZXRTdHlsZShhKTtyZXR1cm4gdGhpc30sc2V0SGV4OmZ1bmN0aW9uKGEpe2E9TWF0aC5mbG9vcihhKTt0aGlzLnI9KGE+PjE2JjI1NSkvMjU1O3RoaXMuZz0oYT4+OCYyNTUpLzI1NTt0aGlzLmI9KGEmMjU1KS8yNTU7cmV0dXJuIHRoaXN9LHNldFJHQjpmdW5jdGlvbihhLGIsYyl7dGhpcy5yPWE7dGhpcy5nPWI7dGhpcy5iPWM7cmV0dXJuIHRoaXN9LHNldEhTTDpmdW5jdGlvbihhLGIsYyl7aWYoMD09PWIpdGhpcy5yPXRoaXMuZz10aGlzLmI9YztlbHNle3ZhciBkPWZ1bmN0aW9uKGEsYixjKXswPmMmJihjKz0xKTsxPGMmJihjLT0xKTtyZXR1cm4gYzwxLzY/YSs2KihiLWEpKlxuYzowLjU+Yz9iOmM8Mi8zP2ErNiooYi1hKSooMi8zLWMpOmF9LGI9MC41Pj1jP2MqKDErYik6YytiLWMqYixjPTIqYy1iO3RoaXMucj1kKGMsYixhKzEvMyk7dGhpcy5nPWQoYyxiLGEpO3RoaXMuYj1kKGMsYixhLTEvMyl9cmV0dXJuIHRoaXN9LHNldFN0eWxlOmZ1bmN0aW9uKGEpe2lmKC9ecmdiXFwoKFxcZCspLCA/KFxcZCspLCA/KFxcZCspXFwpJC9pLnRlc3QoYSkpcmV0dXJuIGE9L15yZ2JcXCgoXFxkKyksID8oXFxkKyksID8oXFxkKylcXCkkL2kuZXhlYyhhKSx0aGlzLnI9TWF0aC5taW4oMjU1LHBhcnNlSW50KGFbMV0sMTApKS8yNTUsdGhpcy5nPU1hdGgubWluKDI1NSxwYXJzZUludChhWzJdLDEwKSkvMjU1LHRoaXMuYj1NYXRoLm1pbigyNTUscGFyc2VJbnQoYVszXSwxMCkpLzI1NSx0aGlzO2lmKC9ecmdiXFwoKFxcZCspXFwlLCA/KFxcZCspXFwlLCA/KFxcZCspXFwlXFwpJC9pLnRlc3QoYSkpcmV0dXJuIGE9L15yZ2JcXCgoXFxkKylcXCUsID8oXFxkKylcXCUsID8oXFxkKylcXCVcXCkkL2kuZXhlYyhhKSx0aGlzLnI9XG5NYXRoLm1pbigxMDAscGFyc2VJbnQoYVsxXSwxMCkpLzEwMCx0aGlzLmc9TWF0aC5taW4oMTAwLHBhcnNlSW50KGFbMl0sMTApKS8xMDAsdGhpcy5iPU1hdGgubWluKDEwMCxwYXJzZUludChhWzNdLDEwKSkvMTAwLHRoaXM7aWYoL15cXCMoWzAtOWEtZl17Nn0pJC9pLnRlc3QoYSkpcmV0dXJuIGE9L15cXCMoWzAtOWEtZl17Nn0pJC9pLmV4ZWMoYSksdGhpcy5zZXRIZXgocGFyc2VJbnQoYVsxXSwxNikpLHRoaXM7aWYoL15cXCMoWzAtOWEtZl0pKFswLTlhLWZdKShbMC05YS1mXSkkL2kudGVzdChhKSlyZXR1cm4gYT0vXlxcIyhbMC05YS1mXSkoWzAtOWEtZl0pKFswLTlhLWZdKSQvaS5leGVjKGEpLHRoaXMuc2V0SGV4KHBhcnNlSW50KGFbMV0rYVsxXSthWzJdK2FbMl0rYVszXSthWzNdLDE2KSksdGhpcztpZigvXihcXHcrKSQvaS50ZXN0KGEpKXJldHVybiB0aGlzLnNldEhleChUSFJFRS5Db2xvcktleXdvcmRzW2FdKSx0aGlzfSxjb3B5OmZ1bmN0aW9uKGEpe3RoaXMucj1hLnI7dGhpcy5nPVxuYS5nO3RoaXMuYj1hLmI7cmV0dXJuIHRoaXN9LGNvcHlHYW1tYVRvTGluZWFyOmZ1bmN0aW9uKGEpe3RoaXMucj1hLnIqYS5yO3RoaXMuZz1hLmcqYS5nO3RoaXMuYj1hLmIqYS5iO3JldHVybiB0aGlzfSxjb3B5TGluZWFyVG9HYW1tYTpmdW5jdGlvbihhKXt0aGlzLnI9TWF0aC5zcXJ0KGEucik7dGhpcy5nPU1hdGguc3FydChhLmcpO3RoaXMuYj1NYXRoLnNxcnQoYS5iKTtyZXR1cm4gdGhpc30sY29udmVydEdhbW1hVG9MaW5lYXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnIsYj10aGlzLmcsYz10aGlzLmI7dGhpcy5yPWEqYTt0aGlzLmc9YipiO3RoaXMuYj1jKmM7cmV0dXJuIHRoaXN9LGNvbnZlcnRMaW5lYXJUb0dhbW1hOmZ1bmN0aW9uKCl7dGhpcy5yPU1hdGguc3FydCh0aGlzLnIpO3RoaXMuZz1NYXRoLnNxcnQodGhpcy5nKTt0aGlzLmI9TWF0aC5zcXJ0KHRoaXMuYik7cmV0dXJuIHRoaXN9LGdldEhleDpmdW5jdGlvbigpe3JldHVybiAyNTUqdGhpcy5yPDwxNl4yNTUqdGhpcy5nPDxcbjheMjU1KnRoaXMuYjw8MH0sZ2V0SGV4U3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuKFwiMDAwMDAwXCIrdGhpcy5nZXRIZXgoKS50b1N0cmluZygxNikpLnNsaWNlKC02KX0sZ2V0SFNMOmZ1bmN0aW9uKCl7dmFyIGE9e2g6MCxzOjAsbDowfTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYj10aGlzLnIsYz10aGlzLmcsZD10aGlzLmIsZT1NYXRoLm1heChiLGMsZCksZj1NYXRoLm1pbihiLGMsZCksaCxnPShmK2UpLzI7aWYoZj09PWUpZj1oPTA7ZWxzZXt2YXIgaT1lLWYsZj0wLjU+PWc/aS8oZStmKTppLygyLWUtZik7c3dpdGNoKGUpe2Nhc2UgYjpoPShjLWQpL2krKGM8ZD82OjApO2JyZWFrO2Nhc2UgYzpoPShkLWIpL2krMjticmVhaztjYXNlIGQ6aD0oYi1jKS9pKzR9aC89Nn1hLmg9aDthLnM9ZjthLmw9ZztyZXR1cm4gYX19KCksZ2V0U3R5bGU6ZnVuY3Rpb24oKXtyZXR1cm5cInJnYihcIisoMjU1KnRoaXMucnwwKStcIixcIisoMjU1KnRoaXMuZ3wwKStcIixcIisoMjU1KnRoaXMuYnwwKStcIilcIn0sXG5vZmZzZXRIU0w6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXRoaXMuZ2V0SFNMKCk7ZC5oKz1hO2Qucys9YjtkLmwrPWM7dGhpcy5zZXRIU0woZC5oLGQucyxkLmwpO3JldHVybiB0aGlzfSxhZGQ6ZnVuY3Rpb24oYSl7dGhpcy5yKz1hLnI7dGhpcy5nKz1hLmc7dGhpcy5iKz1hLmI7cmV0dXJuIHRoaXN9LGFkZENvbG9yczpmdW5jdGlvbihhLGIpe3RoaXMucj1hLnIrYi5yO3RoaXMuZz1hLmcrYi5nO3RoaXMuYj1hLmIrYi5iO3JldHVybiB0aGlzfSxhZGRTY2FsYXI6ZnVuY3Rpb24oYSl7dGhpcy5yKz1hO3RoaXMuZys9YTt0aGlzLmIrPWE7cmV0dXJuIHRoaXN9LG11bHRpcGx5OmZ1bmN0aW9uKGEpe3RoaXMucio9YS5yO3RoaXMuZyo9YS5nO3RoaXMuYio9YS5iO3JldHVybiB0aGlzfSxtdWx0aXBseVNjYWxhcjpmdW5jdGlvbihhKXt0aGlzLnIqPWE7dGhpcy5nKj1hO3RoaXMuYio9YTtyZXR1cm4gdGhpc30sbGVycDpmdW5jdGlvbihhLGIpe3RoaXMucis9KGEuci10aGlzLnIpKmI7dGhpcy5nKz1cbihhLmctdGhpcy5nKSpiO3RoaXMuYis9KGEuYi10aGlzLmIpKmI7cmV0dXJuIHRoaXN9LGVxdWFsczpmdW5jdGlvbihhKXtyZXR1cm4gYS5yPT09dGhpcy5yJiZhLmc9PT10aGlzLmcmJmEuYj09PXRoaXMuYn0sZnJvbUFycmF5OmZ1bmN0aW9uKGEpe3RoaXMucj1hWzBdO3RoaXMuZz1hWzFdO3RoaXMuYj1hWzJdO3JldHVybiB0aGlzfSx0b0FycmF5OmZ1bmN0aW9uKCl7cmV0dXJuW3RoaXMucix0aGlzLmcsdGhpcy5iXX0sY2xvbmU6ZnVuY3Rpb24oKXtyZXR1cm4obmV3IFRIUkVFLkNvbG9yKS5zZXRSR0IodGhpcy5yLHRoaXMuZyx0aGlzLmIpfX07XG5USFJFRS5Db2xvcktleXdvcmRzPXthbGljZWJsdWU6MTU3OTIzODMsYW50aXF1ZXdoaXRlOjE2NDQ0Mzc1LGFxdWE6NjU1MzUsYXF1YW1hcmluZTo4Mzg4NTY0LGF6dXJlOjE1Nzk0MTc1LGJlaWdlOjE2MTE5MjYwLGJpc3F1ZToxNjc3MDI0NCxibGFjazowLGJsYW5jaGVkYWxtb25kOjE2NzcyMDQ1LGJsdWU6MjU1LGJsdWV2aW9sZXQ6OTA1NTIwMixicm93bjoxMDgyNDIzNCxidXJseXdvb2Q6MTQ1OTYyMzEsY2FkZXRibHVlOjYyNjY1MjgsY2hhcnRyZXVzZTo4Mzg4MzUyLGNob2NvbGF0ZToxMzc4OTQ3MCxjb3JhbDoxNjc0NDI3Mixjb3JuZmxvd2VyYmx1ZTo2NTkxOTgxLGNvcm5zaWxrOjE2Nzc1Mzg4LGNyaW1zb246MTQ0MjMxMDAsY3lhbjo2NTUzNSxkYXJrYmx1ZToxMzksZGFya2N5YW46MzU3MjMsZGFya2dvbGRlbnJvZDoxMjA5MjkzOSxkYXJrZ3JheToxMTExOTAxNyxkYXJrZ3JlZW46MjU2MDAsZGFya2dyZXk6MTExMTkwMTcsZGFya2toYWtpOjEyNDMzMjU5LGRhcmttYWdlbnRhOjkxMDk2NDMsXG5kYXJrb2xpdmVncmVlbjo1NTk3OTk5LGRhcmtvcmFuZ2U6MTY3NDc1MjAsZGFya29yY2hpZDoxMDA0MDAxMixkYXJrcmVkOjkxMDk1MDQsZGFya3NhbG1vbjoxNTMwODQxMCxkYXJrc2VhZ3JlZW46OTQxOTkxOSxkYXJrc2xhdGVibHVlOjQ3MzQzNDcsZGFya3NsYXRlZ3JheTozMTAwNDk1LGRhcmtzbGF0ZWdyZXk6MzEwMDQ5NSxkYXJrdHVycXVvaXNlOjUyOTQ1LGRhcmt2aW9sZXQ6OTY5OTUzOSxkZWVwcGluazoxNjcxNjk0NyxkZWVwc2t5Ymx1ZTo0OTE1MSxkaW1ncmF5OjY5MDgyNjUsZGltZ3JleTo2OTA4MjY1LGRvZGdlcmJsdWU6MjAwMzE5OSxmaXJlYnJpY2s6MTE2NzQxNDYsZmxvcmFsd2hpdGU6MTY3NzU5MjAsZm9yZXN0Z3JlZW46MjI2Mzg0MixmdWNoc2lhOjE2NzExOTM1LGdhaW5zYm9ybzoxNDQ3NDQ2MCxnaG9zdHdoaXRlOjE2MzE2NjcxLGdvbGQ6MTY3NjY3MjAsZ29sZGVucm9kOjE0MzI5MTIwLGdyYXk6ODQyMTUwNCxncmVlbjozMjc2OCxncmVlbnllbGxvdzoxMTQwMzA1NSxcbmdyZXk6ODQyMTUwNCxob25leWRldzoxNTc5NDE2MCxob3RwaW5rOjE2NzM4NzQwLGluZGlhbnJlZDoxMzQ1ODUyNCxpbmRpZ286NDkxNTMzMCxpdm9yeToxNjc3NzIwMCxraGFraToxNTc4NzY2MCxsYXZlbmRlcjoxNTEzMjQxMCxsYXZlbmRlcmJsdXNoOjE2NzczMzY1LGxhd25ncmVlbjo4MTkwOTc2LGxlbW9uY2hpZmZvbjoxNjc3NTg4NSxsaWdodGJsdWU6MTEzOTMyNTQsbGlnaHRjb3JhbDoxNTc2MTUzNixsaWdodGN5YW46MTQ3NDU1OTksbGlnaHRnb2xkZW5yb2R5ZWxsb3c6MTY0NDgyMTAsbGlnaHRncmF5OjEzODgyMzIzLGxpZ2h0Z3JlZW46OTQ5ODI1NixsaWdodGdyZXk6MTM4ODIzMjMsbGlnaHRwaW5rOjE2NzU4NDY1LGxpZ2h0c2FsbW9uOjE2NzUyNzYyLGxpZ2h0c2VhZ3JlZW46MjE0Mjg5MCxsaWdodHNreWJsdWU6ODkwMDM0NixsaWdodHNsYXRlZ3JheTo3ODMzNzUzLGxpZ2h0c2xhdGVncmV5Ojc4MzM3NTMsbGlnaHRzdGVlbGJsdWU6MTE1ODQ3MzQsbGlnaHR5ZWxsb3c6MTY3NzcxODQsXG5saW1lOjY1MjgwLGxpbWVncmVlbjozMzI5MzMwLGxpbmVuOjE2NDQ1NjcwLG1hZ2VudGE6MTY3MTE5MzUsbWFyb29uOjgzODg2MDgsbWVkaXVtYXF1YW1hcmluZTo2NzM3MzIyLG1lZGl1bWJsdWU6MjA1LG1lZGl1bW9yY2hpZDoxMjIxMTY2NyxtZWRpdW1wdXJwbGU6OTY2MjY4MyxtZWRpdW1zZWFncmVlbjozOTc4MDk3LG1lZGl1bXNsYXRlYmx1ZTo4MDg3NzkwLG1lZGl1bXNwcmluZ2dyZWVuOjY0MTU0LG1lZGl1bXR1cnF1b2lzZTo0NzcyMzAwLG1lZGl1bXZpb2xldHJlZDoxMzA0NzE3MyxtaWRuaWdodGJsdWU6MTY0NDkxMixtaW50Y3JlYW06MTYxMjE4NTAsbWlzdHlyb3NlOjE2NzcwMjczLG1vY2Nhc2luOjE2NzcwMjI5LG5hdmFqb3doaXRlOjE2NzY4Njg1LG5hdnk6MTI4LG9sZGxhY2U6MTY2NDM1NTgsb2xpdmU6ODQyMTM3NixvbGl2ZWRyYWI6NzA0ODczOSxvcmFuZ2U6MTY3NTM5MjAsb3JhbmdlcmVkOjE2NzI5MzQ0LG9yY2hpZDoxNDMxNTczNCxwYWxlZ29sZGVucm9kOjE1NjU3MTMwLFxucGFsZWdyZWVuOjEwMDI1ODgwLHBhbGV0dXJxdW9pc2U6MTE1Mjk5NjYscGFsZXZpb2xldHJlZDoxNDM4MTIwMyxwYXBheWF3aGlwOjE2NzczMDc3LHBlYWNocHVmZjoxNjc2NzY3MyxwZXJ1OjEzNDY4OTkxLHBpbms6MTY3NjEwMzUscGx1bToxNDUyNDYzNyxwb3dkZXJibHVlOjExNTkxOTEwLHB1cnBsZTo4Mzg4NzM2LHJlZDoxNjcxMTY4MCxyb3N5YnJvd246MTIzNTc1MTkscm95YWxibHVlOjQyODY5NDUsc2FkZGxlYnJvd246OTEyNzE4NyxzYWxtb246MTY0MTY4ODIsc2FuZHlicm93bjoxNjAzMjg2NCxzZWFncmVlbjozMDUwMzI3LHNlYXNoZWxsOjE2Nzc0NjM4LHNpZW5uYToxMDUwNjc5NyxzaWx2ZXI6MTI2MzIyNTYsc2t5Ymx1ZTo4OTAwMzMxLHNsYXRlYmx1ZTo2OTcwMDYxLHNsYXRlZ3JheTo3MzcyOTQ0LHNsYXRlZ3JleTo3MzcyOTQ0LHNub3c6MTY3NzU5MzAsc3ByaW5nZ3JlZW46NjU0MDcsc3RlZWxibHVlOjQ2MjA5ODAsdGFuOjEzODA4NzgwLHRlYWw6MzI4OTYsdGhpc3RsZToxNDIwNDg4OCxcbnRvbWF0bzoxNjczNzA5NSx0dXJxdW9pc2U6NDI1MTg1Nix2aW9sZXQ6MTU2MzEwODYsd2hlYXQ6MTYxMTMzMzEsd2hpdGU6MTY3NzcyMTUsd2hpdGVzbW9rZToxNjExOTI4NSx5ZWxsb3c6MTY3NzY5NjAseWVsbG93Z3JlZW46MTAxNDUwNzR9O1RIUkVFLlF1YXRlcm5pb249ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5feD1hfHwwO3RoaXMuX3k9Ynx8MDt0aGlzLl96PWN8fDA7dGhpcy5fdz12b2lkIDAhPT1kP2Q6MX07XG5USFJFRS5RdWF0ZXJuaW9uLnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuUXVhdGVybmlvbixfeDowLF95OjAsX3o6MCxfdzowLF9ldWxlcjp2b2lkIDAsX3VwZGF0ZUV1bGVyOmZ1bmN0aW9uKCl7dm9pZCAwIT09dGhpcy5fZXVsZXImJnRoaXMuX2V1bGVyLnNldEZyb21RdWF0ZXJuaW9uKHRoaXMsdm9pZCAwLCExKX0sZ2V0IHgoKXtyZXR1cm4gdGhpcy5feH0sc2V0IHgoYSl7dGhpcy5feD1hO3RoaXMuX3VwZGF0ZUV1bGVyKCl9LGdldCB5KCl7cmV0dXJuIHRoaXMuX3l9LHNldCB5KGEpe3RoaXMuX3k9YTt0aGlzLl91cGRhdGVFdWxlcigpfSxnZXQgeigpe3JldHVybiB0aGlzLl96fSxzZXQgeihhKXt0aGlzLl96PWE7dGhpcy5fdXBkYXRlRXVsZXIoKX0sZ2V0IHcoKXtyZXR1cm4gdGhpcy5fd30sc2V0IHcoYSl7dGhpcy5fdz1hO3RoaXMuX3VwZGF0ZUV1bGVyKCl9LHNldDpmdW5jdGlvbihhLGIsYyxkKXt0aGlzLl94PWE7dGhpcy5feT1iO3RoaXMuX3o9Yzt0aGlzLl93PWQ7XG50aGlzLl91cGRhdGVFdWxlcigpO3JldHVybiB0aGlzfSxjb3B5OmZ1bmN0aW9uKGEpe3RoaXMuX3g9YS5feDt0aGlzLl95PWEuX3k7dGhpcy5fej1hLl96O3RoaXMuX3c9YS5fdzt0aGlzLl91cGRhdGVFdWxlcigpO3JldHVybiB0aGlzfSxzZXRGcm9tRXVsZXI6ZnVuY3Rpb24oYSxiKXtpZighMT09PWEgaW5zdGFuY2VvZiBUSFJFRS5FdWxlcil0aHJvdyBFcnJvcihcIkVSUk9SOiBRdWF0ZXJuaW9uJ3MgLnNldEZyb21FdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4gIFBsZWFzZSB1cGRhdGUgeW91ciBjb2RlLlwiKTt2YXIgYz1NYXRoLmNvcyhhLl94LzIpLGQ9TWF0aC5jb3MoYS5feS8yKSxlPU1hdGguY29zKGEuX3ovMiksZj1NYXRoLnNpbihhLl94LzIpLGg9TWF0aC5zaW4oYS5feS8yKSxnPU1hdGguc2luKGEuX3ovMik7XCJYWVpcIj09PWEub3JkZXI/KHRoaXMuX3g9ZipkKmUrYypoKmcsdGhpcy5feT1jKmgqXG5lLWYqZCpnLHRoaXMuX3o9YypkKmcrZipoKmUsdGhpcy5fdz1jKmQqZS1mKmgqZyk6XCJZWFpcIj09PWEub3JkZXI/KHRoaXMuX3g9ZipkKmUrYypoKmcsdGhpcy5feT1jKmgqZS1mKmQqZyx0aGlzLl96PWMqZCpnLWYqaCplLHRoaXMuX3c9YypkKmUrZipoKmcpOlwiWlhZXCI9PT1hLm9yZGVyPyh0aGlzLl94PWYqZCplLWMqaCpnLHRoaXMuX3k9YypoKmUrZipkKmcsdGhpcy5fej1jKmQqZytmKmgqZSx0aGlzLl93PWMqZCplLWYqaCpnKTpcIlpZWFwiPT09YS5vcmRlcj8odGhpcy5feD1mKmQqZS1jKmgqZyx0aGlzLl95PWMqaCplK2YqZCpnLHRoaXMuX3o9YypkKmctZipoKmUsdGhpcy5fdz1jKmQqZStmKmgqZyk6XCJZWlhcIj09PWEub3JkZXI/KHRoaXMuX3g9ZipkKmUrYypoKmcsdGhpcy5feT1jKmgqZStmKmQqZyx0aGlzLl96PWMqZCpnLWYqaCplLHRoaXMuX3c9YypkKmUtZipoKmcpOlwiWFpZXCI9PT1hLm9yZGVyJiYodGhpcy5feD1mKmQqZS1jKmgqZyx0aGlzLl95PWMqaCplLWYqZCpnLHRoaXMuX3o9XG5jKmQqZytmKmgqZSx0aGlzLl93PWMqZCplK2YqaCpnKTshMSE9PWImJnRoaXMuX3VwZGF0ZUV1bGVyKCk7cmV0dXJuIHRoaXN9LHNldEZyb21BeGlzQW5nbGU6ZnVuY3Rpb24oYSxiKXt2YXIgYz1iLzIsZD1NYXRoLnNpbihjKTt0aGlzLl94PWEueCpkO3RoaXMuX3k9YS55KmQ7dGhpcy5fej1hLnoqZDt0aGlzLl93PU1hdGguY29zKGMpO3RoaXMuX3VwZGF0ZUV1bGVyKCk7cmV0dXJuIHRoaXN9LHNldEZyb21Sb3RhdGlvbk1hdHJpeDpmdW5jdGlvbihhKXt2YXIgYj1hLmVsZW1lbnRzLGM9YlswXSxhPWJbNF0sZD1iWzhdLGU9YlsxXSxmPWJbNV0saD1iWzldLGc9YlsyXSxpPWJbNl0sYj1iWzEwXSxrPWMrZitiOzA8az8oYz0wLjUvTWF0aC5zcXJ0KGsrMSksdGhpcy5fdz0wLjI1L2MsdGhpcy5feD0oaS1oKSpjLHRoaXMuX3k9KGQtZykqYyx0aGlzLl96PShlLWEpKmMpOmM+ZiYmYz5iPyhjPTIqTWF0aC5zcXJ0KDErYy1mLWIpLHRoaXMuX3c9KGktaCkvYyx0aGlzLl94PTAuMjUqYyxcbnRoaXMuX3k9KGErZSkvYyx0aGlzLl96PShkK2cpL2MpOmY+Yj8oYz0yKk1hdGguc3FydCgxK2YtYy1iKSx0aGlzLl93PShkLWcpL2MsdGhpcy5feD0oYStlKS9jLHRoaXMuX3k9MC4yNSpjLHRoaXMuX3o9KGgraSkvYyk6KGM9MipNYXRoLnNxcnQoMStiLWMtZiksdGhpcy5fdz0oZS1hKS9jLHRoaXMuX3g9KGQrZykvYyx0aGlzLl95PShoK2kpL2MsdGhpcy5fej0wLjI1KmMpO3RoaXMuX3VwZGF0ZUV1bGVyKCk7cmV0dXJuIHRoaXN9LGludmVyc2U6ZnVuY3Rpb24oKXt0aGlzLmNvbmp1Z2F0ZSgpLm5vcm1hbGl6ZSgpO3JldHVybiB0aGlzfSxjb25qdWdhdGU6ZnVuY3Rpb24oKXt0aGlzLl94Kj0tMTt0aGlzLl95Kj0tMTt0aGlzLl96Kj0tMTt0aGlzLl91cGRhdGVFdWxlcigpO3JldHVybiB0aGlzfSxsZW5ndGhTcTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl94KnRoaXMuX3grdGhpcy5feSp0aGlzLl95K3RoaXMuX3oqdGhpcy5feit0aGlzLl93KnRoaXMuX3d9LGxlbmd0aDpmdW5jdGlvbigpe3JldHVybiBNYXRoLnNxcnQodGhpcy5feCpcbnRoaXMuX3grdGhpcy5feSp0aGlzLl95K3RoaXMuX3oqdGhpcy5feit0aGlzLl93KnRoaXMuX3cpfSxub3JtYWxpemU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmxlbmd0aCgpOzA9PT1hPyh0aGlzLl96PXRoaXMuX3k9dGhpcy5feD0wLHRoaXMuX3c9MSk6KGE9MS9hLHRoaXMuX3gqPWEsdGhpcy5feSo9YSx0aGlzLl96Kj1hLHRoaXMuX3cqPWEpO3JldHVybiB0aGlzfSxtdWx0aXBseTpmdW5jdGlvbihhLGIpe3JldHVybiB2b2lkIDAhPT1iPyhjb25zb2xlLndhcm4oXCJERVBSRUNBVEVEOiBRdWF0ZXJuaW9uJ3MgLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlRdWF0ZXJuaW9ucyggYSwgYiApIGluc3RlYWQuXCIpLHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyhhLGIpKTp0aGlzLm11bHRpcGx5UXVhdGVybmlvbnModGhpcyxhKX0sbXVsdGlwbHlRdWF0ZXJuaW9uczpmdW5jdGlvbihhLGIpe3ZhciBjPWEuX3gsZD1hLl95LGU9YS5feixmPVxuYS5fdyxoPWIuX3gsZz1iLl95LGk9Yi5feixrPWIuX3c7dGhpcy5feD1jKmsrZipoK2QqaS1lKmc7dGhpcy5feT1kKmsrZipnK2UqaC1jKmk7dGhpcy5fej1lKmsrZippK2MqZy1kKmg7dGhpcy5fdz1mKmstYypoLWQqZy1lKmk7dGhpcy5fdXBkYXRlRXVsZXIoKTtyZXR1cm4gdGhpc30sbXVsdGlwbHlWZWN0b3IzOmZ1bmN0aW9uKGEpe2NvbnNvbGUud2FybihcIkRFUFJFQ0FURUQ6IFF1YXRlcm5pb24ncyAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGlzIG5vdyB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkgaW5zdGVhZC5cIik7cmV0dXJuIGEuYXBwbHlRdWF0ZXJuaW9uKHRoaXMpfSxzbGVycDpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuX3gsZD10aGlzLl95LGU9dGhpcy5feixmPXRoaXMuX3csaD1mKmEuX3crYyphLl94K2QqYS5feStlKmEuX3o7MD5oPyh0aGlzLl93PS1hLl93LHRoaXMuX3g9LWEuX3gsdGhpcy5feT0tYS5feSx0aGlzLl96PVxuLWEuX3osaD0taCk6dGhpcy5jb3B5KGEpO2lmKDE8PWgpcmV0dXJuIHRoaXMuX3c9Zix0aGlzLl94PWMsdGhpcy5feT1kLHRoaXMuX3o9ZSx0aGlzO3ZhciBnPU1hdGguYWNvcyhoKSxpPU1hdGguc3FydCgxLWgqaCk7aWYoMC4wMDE+TWF0aC5hYnMoaSkpcmV0dXJuIHRoaXMuX3c9MC41KihmK3RoaXMuX3cpLHRoaXMuX3g9MC41KihjK3RoaXMuX3gpLHRoaXMuX3k9MC41KihkK3RoaXMuX3kpLHRoaXMuX3o9MC41KihlK3RoaXMuX3opLHRoaXM7aD1NYXRoLnNpbigoMS1iKSpnKS9pO2c9TWF0aC5zaW4oYipnKS9pO3RoaXMuX3c9ZipoK3RoaXMuX3cqZzt0aGlzLl94PWMqaCt0aGlzLl94Kmc7dGhpcy5feT1kKmgrdGhpcy5feSpnO3RoaXMuX3o9ZSpoK3RoaXMuX3oqZzt0aGlzLl91cGRhdGVFdWxlcigpO3JldHVybiB0aGlzfSxlcXVhbHM6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuX3g9PT10aGlzLl94JiZhLl95PT09dGhpcy5feSYmYS5fej09PXRoaXMuX3omJmEuX3c9PT10aGlzLl93fSxcbmZyb21BcnJheTpmdW5jdGlvbihhKXt0aGlzLl94PWFbMF07dGhpcy5feT1hWzFdO3RoaXMuX3o9YVsyXTt0aGlzLl93PWFbM107dGhpcy5fdXBkYXRlRXVsZXIoKTtyZXR1cm4gdGhpc30sdG9BcnJheTpmdW5jdGlvbigpe3JldHVyblt0aGlzLl94LHRoaXMuX3ksdGhpcy5feix0aGlzLl93XX0sY2xvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFRIUkVFLlF1YXRlcm5pb24odGhpcy5feCx0aGlzLl95LHRoaXMuX3osdGhpcy5fdyl9fTtUSFJFRS5RdWF0ZXJuaW9uLnNsZXJwPWZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBjLmNvcHkoYSkuc2xlcnAoYixkKX07VEhSRUUuVmVjdG9yMj1mdW5jdGlvbihhLGIpe3RoaXMueD1hfHwwO3RoaXMueT1ifHwwfTtcblRIUkVFLlZlY3RvcjIucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5WZWN0b3IyLHNldDpmdW5jdGlvbihhLGIpe3RoaXMueD1hO3RoaXMueT1iO3JldHVybiB0aGlzfSxzZXRYOmZ1bmN0aW9uKGEpe3RoaXMueD1hO3JldHVybiB0aGlzfSxzZXRZOmZ1bmN0aW9uKGEpe3RoaXMueT1hO3JldHVybiB0aGlzfSxzZXRDb21wb25lbnQ6ZnVuY3Rpb24oYSxiKXtzd2l0Y2goYSl7Y2FzZSAwOnRoaXMueD1iO2JyZWFrO2Nhc2UgMTp0aGlzLnk9YjticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiBcIithKTt9fSxnZXRDb21wb25lbnQ6ZnVuY3Rpb24oYSl7c3dpdGNoKGEpe2Nhc2UgMDpyZXR1cm4gdGhpcy54O2Nhc2UgMTpyZXR1cm4gdGhpcy55O2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiK2EpO319LGNvcHk6ZnVuY3Rpb24oYSl7dGhpcy54PWEueDt0aGlzLnk9YS55O3JldHVybiB0aGlzfSxhZGQ6ZnVuY3Rpb24oYSxcbmIpe2lmKHZvaWQgMCE9PWIpcmV0dXJuIGNvbnNvbGUud2FybihcIkRFUFJFQ0FURUQ6IFZlY3RvcjIncyAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuXCIpLHRoaXMuYWRkVmVjdG9ycyhhLGIpO3RoaXMueCs9YS54O3RoaXMueSs9YS55O3JldHVybiB0aGlzfSxhZGRWZWN0b3JzOmZ1bmN0aW9uKGEsYil7dGhpcy54PWEueCtiLng7dGhpcy55PWEueStiLnk7cmV0dXJuIHRoaXN9LGFkZFNjYWxhcjpmdW5jdGlvbihhKXt0aGlzLngrPWE7dGhpcy55Kz1hO3JldHVybiB0aGlzfSxzdWI6ZnVuY3Rpb24oYSxiKXtpZih2b2lkIDAhPT1iKXJldHVybiBjb25zb2xlLndhcm4oXCJERVBSRUNBVEVEOiBWZWN0b3IyJ3MgLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLlwiKSx0aGlzLnN1YlZlY3RvcnMoYSxiKTt0aGlzLngtPWEueDt0aGlzLnktPVxuYS55O3JldHVybiB0aGlzfSxzdWJWZWN0b3JzOmZ1bmN0aW9uKGEsYil7dGhpcy54PWEueC1iLng7dGhpcy55PWEueS1iLnk7cmV0dXJuIHRoaXN9LG11bHRpcGx5U2NhbGFyOmZ1bmN0aW9uKGEpe3RoaXMueCo9YTt0aGlzLnkqPWE7cmV0dXJuIHRoaXN9LGRpdmlkZVNjYWxhcjpmdW5jdGlvbihhKXswIT09YT8oYT0xL2EsdGhpcy54Kj1hLHRoaXMueSo9YSk6dGhpcy55PXRoaXMueD0wO3JldHVybiB0aGlzfSxtaW46ZnVuY3Rpb24oYSl7dGhpcy54PmEueCYmKHRoaXMueD1hLngpO3RoaXMueT5hLnkmJih0aGlzLnk9YS55KTtyZXR1cm4gdGhpc30sbWF4OmZ1bmN0aW9uKGEpe3RoaXMueDxhLngmJih0aGlzLng9YS54KTt0aGlzLnk8YS55JiYodGhpcy55PWEueSk7cmV0dXJuIHRoaXN9LGNsYW1wOmZ1bmN0aW9uKGEsYil7dGhpcy54PGEueD90aGlzLng9YS54OnRoaXMueD5iLngmJih0aGlzLng9Yi54KTt0aGlzLnk8YS55P3RoaXMueT1hLnk6dGhpcy55PmIueSYmKHRoaXMueT1iLnkpO1xucmV0dXJuIHRoaXN9LG5lZ2F0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKC0xKX0sZG90OmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLngqYS54K3RoaXMueSphLnl9LGxlbmd0aFNxOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueX0sbGVuZ3RoOmZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLngqdGhpcy54K3RoaXMueSp0aGlzLnkpfSxub3JtYWxpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKSl9LGRpc3RhbmNlVG86ZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKGEpKX0sZGlzdGFuY2VUb1NxdWFyZWQ6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy54LWEueCxhPXRoaXMueS1hLnk7cmV0dXJuIGIqYithKmF9LHNldExlbmd0aDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmxlbmd0aCgpOzAhPT1iJiZhIT09YiYmdGhpcy5tdWx0aXBseVNjYWxhcihhL1xuYik7cmV0dXJuIHRoaXN9LGxlcnA6ZnVuY3Rpb24oYSxiKXt0aGlzLngrPShhLngtdGhpcy54KSpiO3RoaXMueSs9KGEueS10aGlzLnkpKmI7cmV0dXJuIHRoaXN9LGVxdWFsczpmdW5jdGlvbihhKXtyZXR1cm4gYS54PT09dGhpcy54JiZhLnk9PT10aGlzLnl9LGZyb21BcnJheTpmdW5jdGlvbihhKXt0aGlzLng9YVswXTt0aGlzLnk9YVsxXTtyZXR1cm4gdGhpc30sdG9BcnJheTpmdW5jdGlvbigpe3JldHVyblt0aGlzLngsdGhpcy55XX0sY2xvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIodGhpcy54LHRoaXMueSl9fTtUSFJFRS5WZWN0b3IzPWZ1bmN0aW9uKGEsYixjKXt0aGlzLng9YXx8MDt0aGlzLnk9Ynx8MDt0aGlzLno9Y3x8MH07XG5USFJFRS5WZWN0b3IzLnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuVmVjdG9yMyxzZXQ6ZnVuY3Rpb24oYSxiLGMpe3RoaXMueD1hO3RoaXMueT1iO3RoaXMuej1jO3JldHVybiB0aGlzfSxzZXRYOmZ1bmN0aW9uKGEpe3RoaXMueD1hO3JldHVybiB0aGlzfSxzZXRZOmZ1bmN0aW9uKGEpe3RoaXMueT1hO3JldHVybiB0aGlzfSxzZXRaOmZ1bmN0aW9uKGEpe3RoaXMuej1hO3JldHVybiB0aGlzfSxzZXRDb21wb25lbnQ6ZnVuY3Rpb24oYSxiKXtzd2l0Y2goYSl7Y2FzZSAwOnRoaXMueD1iO2JyZWFrO2Nhc2UgMTp0aGlzLnk9YjticmVhaztjYXNlIDI6dGhpcy56PWI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcImluZGV4IGlzIG91dCBvZiByYW5nZTogXCIrYSk7fX0sZ2V0Q29tcG9uZW50OmZ1bmN0aW9uKGEpe3N3aXRjaChhKXtjYXNlIDA6cmV0dXJuIHRoaXMueDtjYXNlIDE6cmV0dXJuIHRoaXMueTtjYXNlIDI6cmV0dXJuIHRoaXMuejtkZWZhdWx0OnRocm93IEVycm9yKFwiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiBcIitcbmEpO319LGNvcHk6ZnVuY3Rpb24oYSl7dGhpcy54PWEueDt0aGlzLnk9YS55O3RoaXMuej1hLno7cmV0dXJuIHRoaXN9LGFkZDpmdW5jdGlvbihhLGIpe2lmKHZvaWQgMCE9PWIpcmV0dXJuIGNvbnNvbGUud2FybihcIkRFUFJFQ0FURUQ6IFZlY3RvcjMncyAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuXCIpLHRoaXMuYWRkVmVjdG9ycyhhLGIpO3RoaXMueCs9YS54O3RoaXMueSs9YS55O3RoaXMueis9YS56O3JldHVybiB0aGlzfSxhZGRTY2FsYXI6ZnVuY3Rpb24oYSl7dGhpcy54Kz1hO3RoaXMueSs9YTt0aGlzLnorPWE7cmV0dXJuIHRoaXN9LGFkZFZlY3RvcnM6ZnVuY3Rpb24oYSxiKXt0aGlzLng9YS54K2IueDt0aGlzLnk9YS55K2IueTt0aGlzLno9YS56K2IuejtyZXR1cm4gdGhpc30sc3ViOmZ1bmN0aW9uKGEsYil7aWYodm9pZCAwIT09YilyZXR1cm4gY29uc29sZS53YXJuKFwiREVQUkVDQVRFRDogVmVjdG9yMydzIC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC5cIiksXG50aGlzLnN1YlZlY3RvcnMoYSxiKTt0aGlzLngtPWEueDt0aGlzLnktPWEueTt0aGlzLnotPWEuejtyZXR1cm4gdGhpc30sc3ViVmVjdG9yczpmdW5jdGlvbihhLGIpe3RoaXMueD1hLngtYi54O3RoaXMueT1hLnktYi55O3RoaXMuej1hLnotYi56O3JldHVybiB0aGlzfSxtdWx0aXBseTpmdW5jdGlvbihhLGIpe2lmKHZvaWQgMCE9PWIpcmV0dXJuIGNvbnNvbGUud2FybihcIkRFUFJFQ0FURUQ6IFZlY3RvcjMncyAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLlwiKSx0aGlzLm11bHRpcGx5VmVjdG9ycyhhLGIpO3RoaXMueCo9YS54O3RoaXMueSo9YS55O3RoaXMueio9YS56O3JldHVybiB0aGlzfSxtdWx0aXBseVNjYWxhcjpmdW5jdGlvbihhKXt0aGlzLngqPWE7dGhpcy55Kj1hO3RoaXMueio9YTtyZXR1cm4gdGhpc30sbXVsdGlwbHlWZWN0b3JzOmZ1bmN0aW9uKGEsYil7dGhpcy54PWEueCpcbmIueDt0aGlzLnk9YS55KmIueTt0aGlzLno9YS56KmIuejtyZXR1cm4gdGhpc30sYXBwbHlNYXRyaXgzOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMueCxjPXRoaXMueSxkPXRoaXMueixhPWEuZWxlbWVudHM7dGhpcy54PWFbMF0qYithWzNdKmMrYVs2XSpkO3RoaXMueT1hWzFdKmIrYVs0XSpjK2FbN10qZDt0aGlzLno9YVsyXSpiK2FbNV0qYythWzhdKmQ7cmV0dXJuIHRoaXN9LGFwcGx5TWF0cml4NDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLngsYz10aGlzLnksZD10aGlzLnosYT1hLmVsZW1lbnRzO3RoaXMueD1hWzBdKmIrYVs0XSpjK2FbOF0qZCthWzEyXTt0aGlzLnk9YVsxXSpiK2FbNV0qYythWzldKmQrYVsxM107dGhpcy56PWFbMl0qYithWzZdKmMrYVsxMF0qZCthWzE0XTtyZXR1cm4gdGhpc30sYXBwbHlQcm9qZWN0aW9uOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMueCxjPXRoaXMueSxkPXRoaXMueixhPWEuZWxlbWVudHMsZT0xLyhhWzNdKmIrYVs3XSpjK2FbMTFdKmQrYVsxNV0pO1xudGhpcy54PShhWzBdKmIrYVs0XSpjK2FbOF0qZCthWzEyXSkqZTt0aGlzLnk9KGFbMV0qYithWzVdKmMrYVs5XSpkK2FbMTNdKSplO3RoaXMuej0oYVsyXSpiK2FbNl0qYythWzEwXSpkK2FbMTRdKSplO3JldHVybiB0aGlzfSxhcHBseVF1YXRlcm5pb246ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy54LGM9dGhpcy55LGQ9dGhpcy56LGU9YS54LGY9YS55LGg9YS56LGE9YS53LGc9YSpiK2YqZC1oKmMsaT1hKmMraCpiLWUqZCxrPWEqZCtlKmMtZipiLGI9LWUqYi1mKmMtaCpkO3RoaXMueD1nKmErYiotZStpKi1oLWsqLWY7dGhpcy55PWkqYStiKi1mK2sqLWUtZyotaDt0aGlzLno9ayphK2IqLWgrZyotZi1pKi1lO3JldHVybiB0aGlzfSx0cmFuc2Zvcm1EaXJlY3Rpb246ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy54LGM9dGhpcy55LGQ9dGhpcy56LGE9YS5lbGVtZW50czt0aGlzLng9YVswXSpiK2FbNF0qYythWzhdKmQ7dGhpcy55PWFbMV0qYithWzVdKmMrYVs5XSpkO3RoaXMuej1hWzJdKlxuYithWzZdKmMrYVsxMF0qZDt0aGlzLm5vcm1hbGl6ZSgpO3JldHVybiB0aGlzfSxkaXZpZGU6ZnVuY3Rpb24oYSl7dGhpcy54Lz1hLng7dGhpcy55Lz1hLnk7dGhpcy56Lz1hLno7cmV0dXJuIHRoaXN9LGRpdmlkZVNjYWxhcjpmdW5jdGlvbihhKXswIT09YT8oYT0xL2EsdGhpcy54Kj1hLHRoaXMueSo9YSx0aGlzLnoqPWEpOnRoaXMuej10aGlzLnk9dGhpcy54PTA7cmV0dXJuIHRoaXN9LG1pbjpmdW5jdGlvbihhKXt0aGlzLng+YS54JiYodGhpcy54PWEueCk7dGhpcy55PmEueSYmKHRoaXMueT1hLnkpO3RoaXMuej5hLnomJih0aGlzLno9YS56KTtyZXR1cm4gdGhpc30sbWF4OmZ1bmN0aW9uKGEpe3RoaXMueDxhLngmJih0aGlzLng9YS54KTt0aGlzLnk8YS55JiYodGhpcy55PWEueSk7dGhpcy56PGEueiYmKHRoaXMuej1hLnopO3JldHVybiB0aGlzfSxjbGFtcDpmdW5jdGlvbihhLGIpe3RoaXMueDxhLng/dGhpcy54PWEueDp0aGlzLng+Yi54JiYodGhpcy54PWIueCk7dGhpcy55PFxuYS55P3RoaXMueT1hLnk6dGhpcy55PmIueSYmKHRoaXMueT1iLnkpO3RoaXMuejxhLno/dGhpcy56PWEuejp0aGlzLno+Yi56JiYodGhpcy56PWIueik7cmV0dXJuIHRoaXN9LG5lZ2F0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKC0xKX0sZG90OmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLngqYS54K3RoaXMueSphLnkrdGhpcy56KmEuen0sbGVuZ3RoU3E6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnp9LGxlbmd0aDpmdW5jdGlvbigpe3JldHVybiBNYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnopfSxsZW5ndGhNYW5oYXR0YW46ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5hYnModGhpcy54KStNYXRoLmFicyh0aGlzLnkpK01hdGguYWJzKHRoaXMueil9LG5vcm1hbGl6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpKX0sXG5zZXRMZW5ndGg6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5sZW5ndGgoKTswIT09YiYmYSE9PWImJnRoaXMubXVsdGlwbHlTY2FsYXIoYS9iKTtyZXR1cm4gdGhpc30sbGVycDpmdW5jdGlvbihhLGIpe3RoaXMueCs9KGEueC10aGlzLngpKmI7dGhpcy55Kz0oYS55LXRoaXMueSkqYjt0aGlzLnorPShhLnotdGhpcy56KSpiO3JldHVybiB0aGlzfSxjcm9zczpmdW5jdGlvbihhLGIpe2lmKHZvaWQgMCE9PWIpcmV0dXJuIGNvbnNvbGUud2FybihcIkRFUFJFQ0FURUQ6IFZlY3RvcjMncyAuY3Jvc3MoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5jcm9zc1ZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLlwiKSx0aGlzLmNyb3NzVmVjdG9ycyhhLGIpO3ZhciBjPXRoaXMueCxkPXRoaXMueSxlPXRoaXMuejt0aGlzLng9ZCphLnotZSphLnk7dGhpcy55PWUqYS54LWMqYS56O3RoaXMuej1jKmEueS1kKmEueDtyZXR1cm4gdGhpc30sY3Jvc3NWZWN0b3JzOmZ1bmN0aW9uKGEsYil7dmFyIGM9XG5hLngsZD1hLnksZT1hLnosZj1iLngsaD1iLnksZz1iLno7dGhpcy54PWQqZy1lKmg7dGhpcy55PWUqZi1jKmc7dGhpcy56PWMqaC1kKmY7cmV0dXJuIHRoaXN9LGFuZ2xlVG86ZnVuY3Rpb24oYSl7YT10aGlzLmRvdChhKS8odGhpcy5sZW5ndGgoKSphLmxlbmd0aCgpKTtyZXR1cm4gTWF0aC5hY29zKFRIUkVFLk1hdGguY2xhbXAoYSwtMSwxKSl9LGRpc3RhbmNlVG86ZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKGEpKX0sZGlzdGFuY2VUb1NxdWFyZWQ6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy54LWEueCxjPXRoaXMueS1hLnksYT10aGlzLnotYS56O3JldHVybiBiKmIrYypjK2EqYX0sc2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXg6ZnVuY3Rpb24oKXtjb25zb2xlLmVycm9yKFwiUkVNT1ZFRDogVmVjdG9yMydzIHNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4IGhhcyBiZWVuIHJlbW92ZWQgaW4gZmF2b3Igb2YgRXVsZXIuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCksIHBsZWFzZSB1cGRhdGUgeW91ciBjb2RlLlwiKX0sXG5zZXRFdWxlckZyb21RdWF0ZXJuaW9uOmZ1bmN0aW9uKCl7Y29uc29sZS5lcnJvcihcIlJFTU9WRUQ6IFZlY3RvcjMncyBzZXRFdWxlckZyb21RdWF0ZXJuaW9uOiBoYXMgYmVlbiByZW1vdmVkIGluIGZhdm9yIG9mIEV1bGVyLnNldEZyb21RdWF0ZXJuaW9uKCksIHBsZWFzZSB1cGRhdGUgeW91ciBjb2RlLlwiKX0sZ2V0UG9zaXRpb25Gcm9tTWF0cml4OmZ1bmN0aW9uKGEpe3RoaXMueD1hLmVsZW1lbnRzWzEyXTt0aGlzLnk9YS5lbGVtZW50c1sxM107dGhpcy56PWEuZWxlbWVudHNbMTRdO3JldHVybiB0aGlzfSxnZXRTY2FsZUZyb21NYXRyaXg6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5zZXQoYS5lbGVtZW50c1swXSxhLmVsZW1lbnRzWzFdLGEuZWxlbWVudHNbMl0pLmxlbmd0aCgpLGM9dGhpcy5zZXQoYS5lbGVtZW50c1s0XSxhLmVsZW1lbnRzWzVdLGEuZWxlbWVudHNbNl0pLmxlbmd0aCgpLGE9dGhpcy5zZXQoYS5lbGVtZW50c1s4XSxhLmVsZW1lbnRzWzldLGEuZWxlbWVudHNbMTBdKS5sZW5ndGgoKTtcbnRoaXMueD1iO3RoaXMueT1jO3RoaXMuej1hO3JldHVybiB0aGlzfSxnZXRDb2x1bW5Gcm9tTWF0cml4OmZ1bmN0aW9uKGEsYil7dmFyIGM9NCphLGQ9Yi5lbGVtZW50czt0aGlzLng9ZFtjXTt0aGlzLnk9ZFtjKzFdO3RoaXMuej1kW2MrMl07cmV0dXJuIHRoaXN9LGVxdWFsczpmdW5jdGlvbihhKXtyZXR1cm4gYS54PT09dGhpcy54JiZhLnk9PT10aGlzLnkmJmEuej09PXRoaXMuen0sZnJvbUFycmF5OmZ1bmN0aW9uKGEpe3RoaXMueD1hWzBdO3RoaXMueT1hWzFdO3RoaXMuej1hWzJdO3JldHVybiB0aGlzfSx0b0FycmF5OmZ1bmN0aW9uKCl7cmV0dXJuW3RoaXMueCx0aGlzLnksdGhpcy56XX0sY2xvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjModGhpcy54LHRoaXMueSx0aGlzLnopfX07XG5USFJFRS5leHRlbmQoVEhSRUUuVmVjdG9yMy5wcm90b3R5cGUse2FwcGx5RXVsZXI6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuUXVhdGVybmlvbjtyZXR1cm4gZnVuY3Rpb24oYil7ITE9PT1iIGluc3RhbmNlb2YgVEhSRUUuRXVsZXImJmNvbnNvbGUuZXJyb3IoXCJFUlJPUjogVmVjdG9yMydzIC5hcHBseUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLiAgUGxlYXNlIHVwZGF0ZSB5b3VyIGNvZGUuXCIpO3RoaXMuYXBwbHlRdWF0ZXJuaW9uKGEuc2V0RnJvbUV1bGVyKGIpKTtyZXR1cm4gdGhpc319KCksYXBwbHlBeGlzQW5nbGU6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuUXVhdGVybmlvbjtyZXR1cm4gZnVuY3Rpb24oYixjKXt0aGlzLmFwcGx5UXVhdGVybmlvbihhLnNldEZyb21BeGlzQW5nbGUoYixjKSk7cmV0dXJuIHRoaXN9fSgpLHByb2plY3RPblZlY3RvcjpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzO1xucmV0dXJuIGZ1bmN0aW9uKGIpe2EuY29weShiKS5ub3JtYWxpemUoKTtiPXRoaXMuZG90KGEpO3JldHVybiB0aGlzLmNvcHkoYSkubXVsdGlwbHlTY2FsYXIoYil9fSgpLHByb2plY3RPblBsYW5lOmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGIpe2EuY29weSh0aGlzKS5wcm9qZWN0T25WZWN0b3IoYik7cmV0dXJuIHRoaXMuc3ViKGEpfX0oKSxyZWZsZWN0OmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGIpe2EuY29weSh0aGlzKS5wcm9qZWN0T25WZWN0b3IoYikubXVsdGlwbHlTY2FsYXIoMik7cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyhhLHRoaXMpfX0oKX0pO1RIUkVFLlZlY3RvcjQ9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy54PWF8fDA7dGhpcy55PWJ8fDA7dGhpcy56PWN8fDA7dGhpcy53PXZvaWQgMCE9PWQ/ZDoxfTtcblRIUkVFLlZlY3RvcjQucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5WZWN0b3I0LHNldDpmdW5jdGlvbihhLGIsYyxkKXt0aGlzLng9YTt0aGlzLnk9Yjt0aGlzLno9Yzt0aGlzLnc9ZDtyZXR1cm4gdGhpc30sc2V0WDpmdW5jdGlvbihhKXt0aGlzLng9YTtyZXR1cm4gdGhpc30sc2V0WTpmdW5jdGlvbihhKXt0aGlzLnk9YTtyZXR1cm4gdGhpc30sc2V0WjpmdW5jdGlvbihhKXt0aGlzLno9YTtyZXR1cm4gdGhpc30sc2V0VzpmdW5jdGlvbihhKXt0aGlzLnc9YTtyZXR1cm4gdGhpc30sc2V0Q29tcG9uZW50OmZ1bmN0aW9uKGEsYil7c3dpdGNoKGEpe2Nhc2UgMDp0aGlzLng9YjticmVhaztjYXNlIDE6dGhpcy55PWI7YnJlYWs7Y2FzZSAyOnRoaXMuej1iO2JyZWFrO2Nhc2UgMzp0aGlzLnc9YjticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiBcIithKTt9fSxnZXRDb21wb25lbnQ6ZnVuY3Rpb24oYSl7c3dpdGNoKGEpe2Nhc2UgMDpyZXR1cm4gdGhpcy54O1xuY2FzZSAxOnJldHVybiB0aGlzLnk7Y2FzZSAyOnJldHVybiB0aGlzLno7Y2FzZSAzOnJldHVybiB0aGlzLnc7ZGVmYXVsdDp0aHJvdyBFcnJvcihcImluZGV4IGlzIG91dCBvZiByYW5nZTogXCIrYSk7fX0sY29weTpmdW5jdGlvbihhKXt0aGlzLng9YS54O3RoaXMueT1hLnk7dGhpcy56PWEuejt0aGlzLnc9dm9pZCAwIT09YS53P2EudzoxO3JldHVybiB0aGlzfSxhZGQ6ZnVuY3Rpb24oYSxiKXtpZih2b2lkIDAhPT1iKXJldHVybiBjb25zb2xlLndhcm4oXCJERVBSRUNBVEVEOiBWZWN0b3I0J3MgLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLlwiKSx0aGlzLmFkZFZlY3RvcnMoYSxiKTt0aGlzLngrPWEueDt0aGlzLnkrPWEueTt0aGlzLnorPWEuejt0aGlzLncrPWEudztyZXR1cm4gdGhpc30sYWRkU2NhbGFyOmZ1bmN0aW9uKGEpe3RoaXMueCs9YTt0aGlzLnkrPWE7dGhpcy56Kz1hO3RoaXMudys9YTtyZXR1cm4gdGhpc30sXG5hZGRWZWN0b3JzOmZ1bmN0aW9uKGEsYil7dGhpcy54PWEueCtiLng7dGhpcy55PWEueStiLnk7dGhpcy56PWEueitiLno7dGhpcy53PWEudytiLnc7cmV0dXJuIHRoaXN9LHN1YjpmdW5jdGlvbihhLGIpe2lmKHZvaWQgMCE9PWIpcmV0dXJuIGNvbnNvbGUud2FybihcIkRFUFJFQ0FURUQ6IFZlY3RvcjQncyAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuXCIpLHRoaXMuc3ViVmVjdG9ycyhhLGIpO3RoaXMueC09YS54O3RoaXMueS09YS55O3RoaXMuei09YS56O3RoaXMudy09YS53O3JldHVybiB0aGlzfSxzdWJWZWN0b3JzOmZ1bmN0aW9uKGEsYil7dGhpcy54PWEueC1iLng7dGhpcy55PWEueS1iLnk7dGhpcy56PWEuei1iLno7dGhpcy53PWEudy1iLnc7cmV0dXJuIHRoaXN9LG11bHRpcGx5U2NhbGFyOmZ1bmN0aW9uKGEpe3RoaXMueCo9YTt0aGlzLnkqPWE7dGhpcy56Kj1hO3RoaXMudyo9YTtyZXR1cm4gdGhpc30sXG5hcHBseU1hdHJpeDQ6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy54LGM9dGhpcy55LGQ9dGhpcy56LGU9dGhpcy53LGE9YS5lbGVtZW50czt0aGlzLng9YVswXSpiK2FbNF0qYythWzhdKmQrYVsxMl0qZTt0aGlzLnk9YVsxXSpiK2FbNV0qYythWzldKmQrYVsxM10qZTt0aGlzLno9YVsyXSpiK2FbNl0qYythWzEwXSpkK2FbMTRdKmU7dGhpcy53PWFbM10qYithWzddKmMrYVsxMV0qZCthWzE1XSplO3JldHVybiB0aGlzfSxkaXZpZGVTY2FsYXI6ZnVuY3Rpb24oYSl7MCE9PWE/KGE9MS9hLHRoaXMueCo9YSx0aGlzLnkqPWEsdGhpcy56Kj1hLHRoaXMudyo9YSk6KHRoaXMuej10aGlzLnk9dGhpcy54PTAsdGhpcy53PTEpO3JldHVybiB0aGlzfSxzZXRBeGlzQW5nbGVGcm9tUXVhdGVybmlvbjpmdW5jdGlvbihhKXt0aGlzLnc9MipNYXRoLmFjb3MoYS53KTt2YXIgYj1NYXRoLnNxcnQoMS1hLncqYS53KTsxRS00PmI/KHRoaXMueD0xLHRoaXMuej10aGlzLnk9MCk6KHRoaXMueD1hLngvYixcbnRoaXMueT1hLnkvYix0aGlzLno9YS56L2IpO3JldHVybiB0aGlzfSxzZXRBeGlzQW5nbGVGcm9tUm90YXRpb25NYXRyaXg6ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGE9YS5lbGVtZW50cyxlPWFbMF07ZD1hWzRdO3ZhciBmPWFbOF0saD1hWzFdLGc9YVs1XSxpPWFbOV07Yz1hWzJdO2I9YVs2XTt2YXIgaz1hWzEwXTtpZigwLjAxPk1hdGguYWJzKGQtaCkmJjAuMDE+TWF0aC5hYnMoZi1jKSYmMC4wMT5NYXRoLmFicyhpLWIpKXtpZigwLjE+TWF0aC5hYnMoZCtoKSYmMC4xPk1hdGguYWJzKGYrYykmJjAuMT5NYXRoLmFicyhpK2IpJiYwLjE+TWF0aC5hYnMoZStnK2stMykpcmV0dXJuIHRoaXMuc2V0KDEsMCwwLDApLHRoaXM7YT1NYXRoLlBJO2U9KGUrMSkvMjtnPShnKzEpLzI7az0oaysxKS8yO2Q9KGQraCkvNDtmPShmK2MpLzQ7aT0oaStiKS80O2U+ZyYmZT5rPzAuMDE+ZT8oYj0wLGQ9Yz0wLjcwNzEwNjc4MSk6KGI9TWF0aC5zcXJ0KGUpLGM9ZC9iLGQ9Zi9iKTpnPms/MC4wMT5nP1xuKGI9MC43MDcxMDY3ODEsYz0wLGQ9MC43MDcxMDY3ODEpOihjPU1hdGguc3FydChnKSxiPWQvYyxkPWkvYyk6MC4wMT5rPyhjPWI9MC43MDcxMDY3ODEsZD0wKTooZD1NYXRoLnNxcnQoayksYj1mL2QsYz1pL2QpO3RoaXMuc2V0KGIsYyxkLGEpO3JldHVybiB0aGlzfWE9TWF0aC5zcXJ0KChiLWkpKihiLWkpKyhmLWMpKihmLWMpKyhoLWQpKihoLWQpKTswLjAwMT5NYXRoLmFicyhhKSYmKGE9MSk7dGhpcy54PShiLWkpL2E7dGhpcy55PShmLWMpL2E7dGhpcy56PShoLWQpL2E7dGhpcy53PU1hdGguYWNvcygoZStnK2stMSkvMik7cmV0dXJuIHRoaXN9LG1pbjpmdW5jdGlvbihhKXt0aGlzLng+YS54JiYodGhpcy54PWEueCk7dGhpcy55PmEueSYmKHRoaXMueT1hLnkpO3RoaXMuej5hLnomJih0aGlzLno9YS56KTt0aGlzLnc+YS53JiYodGhpcy53PWEudyk7cmV0dXJuIHRoaXN9LG1heDpmdW5jdGlvbihhKXt0aGlzLng8YS54JiYodGhpcy54PWEueCk7dGhpcy55PGEueSYmKHRoaXMueT1cbmEueSk7dGhpcy56PGEueiYmKHRoaXMuej1hLnopO3RoaXMudzxhLncmJih0aGlzLnc9YS53KTtyZXR1cm4gdGhpc30sY2xhbXA6ZnVuY3Rpb24oYSxiKXt0aGlzLng8YS54P3RoaXMueD1hLng6dGhpcy54PmIueCYmKHRoaXMueD1iLngpO3RoaXMueTxhLnk/dGhpcy55PWEueTp0aGlzLnk+Yi55JiYodGhpcy55PWIueSk7dGhpcy56PGEuej90aGlzLno9YS56OnRoaXMuej5iLnomJih0aGlzLno9Yi56KTt0aGlzLnc8YS53P3RoaXMudz1hLnc6dGhpcy53PmIudyYmKHRoaXMudz1iLncpO3JldHVybiB0aGlzfSxuZWdhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigtMSl9LGRvdDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy54KmEueCt0aGlzLnkqYS55K3RoaXMueiphLnordGhpcy53KmEud30sbGVuZ3RoU3E6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnordGhpcy53KnRoaXMud30sbGVuZ3RoOmZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLngqXG50aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56K3RoaXMudyp0aGlzLncpfSxsZW5ndGhNYW5oYXR0YW46ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5hYnModGhpcy54KStNYXRoLmFicyh0aGlzLnkpK01hdGguYWJzKHRoaXMueikrTWF0aC5hYnModGhpcy53KX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkpfSxzZXRMZW5ndGg6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5sZW5ndGgoKTswIT09YiYmYSE9PWImJnRoaXMubXVsdGlwbHlTY2FsYXIoYS9iKTtyZXR1cm4gdGhpc30sbGVycDpmdW5jdGlvbihhLGIpe3RoaXMueCs9KGEueC10aGlzLngpKmI7dGhpcy55Kz0oYS55LXRoaXMueSkqYjt0aGlzLnorPShhLnotdGhpcy56KSpiO3RoaXMudys9KGEudy10aGlzLncpKmI7cmV0dXJuIHRoaXN9LGVxdWFsczpmdW5jdGlvbihhKXtyZXR1cm4gYS54PT09dGhpcy54JiZhLnk9PT10aGlzLnkmJmEuej09PXRoaXMueiYmXG5hLnc9PT10aGlzLnd9LGZyb21BcnJheTpmdW5jdGlvbihhKXt0aGlzLng9YVswXTt0aGlzLnk9YVsxXTt0aGlzLno9YVsyXTt0aGlzLnc9YVszXTtyZXR1cm4gdGhpc30sdG9BcnJheTpmdW5jdGlvbigpe3JldHVyblt0aGlzLngsdGhpcy55LHRoaXMueix0aGlzLnddfSxjbG9uZTpmdW5jdGlvbigpe3JldHVybiBuZXcgVEhSRUUuVmVjdG9yNCh0aGlzLngsdGhpcy55LHRoaXMueix0aGlzLncpfX07VEhSRUUuRXVsZXI9ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5feD1hfHwwO3RoaXMuX3k9Ynx8MDt0aGlzLl96PWN8fDA7dGhpcy5fb3JkZXI9ZHx8VEhSRUUuRXVsZXIuRGVmYXVsdE9yZGVyfTtUSFJFRS5FdWxlci5Sb3RhdGlvbk9yZGVycz1cIlhZWiBZWlggWlhZIFhaWSBZWFogWllYXCIuc3BsaXQoXCIgXCIpO1RIUkVFLkV1bGVyLkRlZmF1bHRPcmRlcj1cIlhZWlwiO1xuVEhSRUUuRXVsZXIucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5FdWxlcixfeDowLF95OjAsX3o6MCxfb3JkZXI6VEhSRUUuRXVsZXIuRGVmYXVsdE9yZGVyLF9xdWF0ZXJuaW9uOnZvaWQgMCxfdXBkYXRlUXVhdGVybmlvbjpmdW5jdGlvbigpe3ZvaWQgMCE9PXRoaXMuX3F1YXRlcm5pb24mJnRoaXMuX3F1YXRlcm5pb24uc2V0RnJvbUV1bGVyKHRoaXMsITEpfSxnZXQgeCgpe3JldHVybiB0aGlzLl94fSxzZXQgeChhKXt0aGlzLl94PWE7dGhpcy5fdXBkYXRlUXVhdGVybmlvbigpfSxnZXQgeSgpe3JldHVybiB0aGlzLl95fSxzZXQgeShhKXt0aGlzLl95PWE7dGhpcy5fdXBkYXRlUXVhdGVybmlvbigpfSxnZXQgeigpe3JldHVybiB0aGlzLl96fSxzZXQgeihhKXt0aGlzLl96PWE7dGhpcy5fdXBkYXRlUXVhdGVybmlvbigpfSxnZXQgb3JkZXIoKXtyZXR1cm4gdGhpcy5fb3JkZXJ9LHNldCBvcmRlcihhKXt0aGlzLl9vcmRlcj1hO3RoaXMuX3VwZGF0ZVF1YXRlcm5pb24oKX0sXG5zZXQ6ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5feD1hO3RoaXMuX3k9Yjt0aGlzLl96PWM7dGhpcy5fb3JkZXI9ZHx8dGhpcy5fb3JkZXI7dGhpcy5fdXBkYXRlUXVhdGVybmlvbigpO3JldHVybiB0aGlzfSxjb3B5OmZ1bmN0aW9uKGEpe3RoaXMuX3g9YS5feDt0aGlzLl95PWEuX3k7dGhpcy5fej1hLl96O3RoaXMuX29yZGVyPWEuX29yZGVyO3RoaXMuX3VwZGF0ZVF1YXRlcm5pb24oKTtyZXR1cm4gdGhpc30sc2V0RnJvbVJvdGF0aW9uTWF0cml4OmZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoYSwtMSksMSl9dmFyIGQ9YS5lbGVtZW50cyxlPWRbMF0sZj1kWzRdLGg9ZFs4XSxnPWRbMV0saT1kWzVdLGs9ZFs5XSxtPWRbMl0sbD1kWzZdLGQ9ZFsxMF0sYj1ifHx0aGlzLl9vcmRlcjtcIlhZWlwiPT09Yj8odGhpcy5feT1NYXRoLmFzaW4oYyhoKSksMC45OTk5OT5NYXRoLmFicyhoKT8odGhpcy5feD1NYXRoLmF0YW4yKC1rLGQpLHRoaXMuX3o9XG5NYXRoLmF0YW4yKC1mLGUpKToodGhpcy5feD1NYXRoLmF0YW4yKGwsaSksdGhpcy5fej0wKSk6XCJZWFpcIj09PWI/KHRoaXMuX3g9TWF0aC5hc2luKC1jKGspKSwwLjk5OTk5Pk1hdGguYWJzKGspPyh0aGlzLl95PU1hdGguYXRhbjIoaCxkKSx0aGlzLl96PU1hdGguYXRhbjIoZyxpKSk6KHRoaXMuX3k9TWF0aC5hdGFuMigtbSxlKSx0aGlzLl96PTApKTpcIlpYWVwiPT09Yj8odGhpcy5feD1NYXRoLmFzaW4oYyhsKSksMC45OTk5OT5NYXRoLmFicyhsKT8odGhpcy5feT1NYXRoLmF0YW4yKC1tLGQpLHRoaXMuX3o9TWF0aC5hdGFuMigtZixpKSk6KHRoaXMuX3k9MCx0aGlzLl96PU1hdGguYXRhbjIoZyxlKSkpOlwiWllYXCI9PT1iPyh0aGlzLl95PU1hdGguYXNpbigtYyhtKSksMC45OTk5OT5NYXRoLmFicyhtKT8odGhpcy5feD1NYXRoLmF0YW4yKGwsZCksdGhpcy5fej1NYXRoLmF0YW4yKGcsZSkpOih0aGlzLl94PTAsdGhpcy5fej1NYXRoLmF0YW4yKC1mLGkpKSk6XCJZWlhcIj09PWI/KHRoaXMuX3o9XG5NYXRoLmFzaW4oYyhnKSksMC45OTk5OT5NYXRoLmFicyhnKT8odGhpcy5feD1NYXRoLmF0YW4yKC1rLGkpLHRoaXMuX3k9TWF0aC5hdGFuMigtbSxlKSk6KHRoaXMuX3g9MCx0aGlzLl95PU1hdGguYXRhbjIoaCxkKSkpOlwiWFpZXCI9PT1iPyh0aGlzLl96PU1hdGguYXNpbigtYyhmKSksMC45OTk5OT5NYXRoLmFicyhmKT8odGhpcy5feD1NYXRoLmF0YW4yKGwsaSksdGhpcy5feT1NYXRoLmF0YW4yKGgsZSkpOih0aGlzLl94PU1hdGguYXRhbjIoLWssZCksdGhpcy5feT0wKSk6Y29uc29sZS53YXJuKFwiV0FSTklORzogRXVsZXIuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZ2l2ZW4gdW5zdXBwb3J0ZWQgb3JkZXI6IFwiK2IpO3RoaXMuX29yZGVyPWI7dGhpcy5fdXBkYXRlUXVhdGVybmlvbigpO3JldHVybiB0aGlzfSxzZXRGcm9tUXVhdGVybmlvbjpmdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChhKXtyZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoYSwtMSksMSl9dmFyIGU9YS54KmEueCxmPVxuYS55KmEueSxoPWEueiphLnosZz1hLncqYS53LGI9Ynx8dGhpcy5fb3JkZXI7XCJYWVpcIj09PWI/KHRoaXMuX3g9TWF0aC5hdGFuMigyKihhLngqYS53LWEueSphLnopLGctZS1mK2gpLHRoaXMuX3k9TWF0aC5hc2luKGQoMiooYS54KmEueithLnkqYS53KSkpLHRoaXMuX3o9TWF0aC5hdGFuMigyKihhLnoqYS53LWEueCphLnkpLGcrZS1mLWgpKTpcIllYWlwiPT09Yj8odGhpcy5feD1NYXRoLmFzaW4oZCgyKihhLngqYS53LWEueSphLnopKSksdGhpcy5feT1NYXRoLmF0YW4yKDIqKGEueCphLnorYS55KmEudyksZy1lLWYraCksdGhpcy5fej1NYXRoLmF0YW4yKDIqKGEueCphLnkrYS56KmEudyksZy1lK2YtaCkpOlwiWlhZXCI9PT1iPyh0aGlzLl94PU1hdGguYXNpbihkKDIqKGEueCphLncrYS55KmEueikpKSx0aGlzLl95PU1hdGguYXRhbjIoMiooYS55KmEudy1hLnoqYS54KSxnLWUtZitoKSx0aGlzLl96PU1hdGguYXRhbjIoMiooYS56KmEudy1hLngqYS55KSxnLWUrZi1oKSk6XCJaWVhcIj09PVxuYj8odGhpcy5feD1NYXRoLmF0YW4yKDIqKGEueCphLncrYS56KmEueSksZy1lLWYraCksdGhpcy5feT1NYXRoLmFzaW4oZCgyKihhLnkqYS53LWEueCphLnopKSksdGhpcy5fej1NYXRoLmF0YW4yKDIqKGEueCphLnkrYS56KmEudyksZytlLWYtaCkpOlwiWVpYXCI9PT1iPyh0aGlzLl94PU1hdGguYXRhbjIoMiooYS54KmEudy1hLnoqYS55KSxnLWUrZi1oKSx0aGlzLl95PU1hdGguYXRhbjIoMiooYS55KmEudy1hLngqYS56KSxnK2UtZi1oKSx0aGlzLl96PU1hdGguYXNpbihkKDIqKGEueCphLnkrYS56KmEudykpKSk6XCJYWllcIj09PWI/KHRoaXMuX3g9TWF0aC5hdGFuMigyKihhLngqYS53K2EueSphLnopLGctZStmLWgpLHRoaXMuX3k9TWF0aC5hdGFuMigyKihhLngqYS56K2EueSphLncpLGcrZS1mLWgpLHRoaXMuX3o9TWF0aC5hc2luKGQoMiooYS56KmEudy1hLngqYS55KSkpKTpjb25zb2xlLndhcm4oXCJXQVJOSU5HOiBFdWxlci5zZXRGcm9tUXVhdGVybmlvbigpIGdpdmVuIHVuc3VwcG9ydGVkIG9yZGVyOiBcIitcbmIpO3RoaXMuX29yZGVyPWI7ITEhPT1jJiZ0aGlzLl91cGRhdGVRdWF0ZXJuaW9uKCk7cmV0dXJuIHRoaXN9LHJlb3JkZXI6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuUXVhdGVybmlvbjtyZXR1cm4gZnVuY3Rpb24oYil7YS5zZXRGcm9tRXVsZXIodGhpcyk7dGhpcy5zZXRGcm9tUXVhdGVybmlvbihhLGIpfX0oKSxmcm9tQXJyYXk6ZnVuY3Rpb24oYSl7dGhpcy5feD1hWzBdO3RoaXMuX3k9YVsxXTt0aGlzLl96PWFbMl07dm9pZCAwIT09YVszXSYmKHRoaXMuX29yZGVyPWFbM10pO3RoaXMuX3VwZGF0ZVF1YXRlcm5pb24oKTtyZXR1cm4gdGhpc30sdG9BcnJheTpmdW5jdGlvbigpe3JldHVyblt0aGlzLl94LHRoaXMuX3ksdGhpcy5feix0aGlzLl9vcmRlcl19LGVxdWFsczpmdW5jdGlvbihhKXtyZXR1cm4gYS5feD09PXRoaXMuX3gmJmEuX3k9PT10aGlzLl95JiZhLl96PT09dGhpcy5feiYmYS5fb3JkZXI9PT10aGlzLl9vcmRlcn0sY2xvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFRIUkVFLkV1bGVyKHRoaXMuX3gsXG50aGlzLl95LHRoaXMuX3osdGhpcy5fb3JkZXIpfX07VEhSRUUuTGluZTM9ZnVuY3Rpb24oYSxiKXt0aGlzLnN0YXJ0PXZvaWQgMCE9PWE/YTpuZXcgVEhSRUUuVmVjdG9yMzt0aGlzLmVuZD12b2lkIDAhPT1iP2I6bmV3IFRIUkVFLlZlY3RvcjN9O1xuVEhSRUUuTGluZTMucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5MaW5lMyxzZXQ6ZnVuY3Rpb24oYSxiKXt0aGlzLnN0YXJ0LmNvcHkoYSk7dGhpcy5lbmQuY29weShiKTtyZXR1cm4gdGhpc30sY29weTpmdW5jdGlvbihhKXt0aGlzLnN0YXJ0LmNvcHkoYS5zdGFydCk7dGhpcy5lbmQuY29weShhLmVuZCk7cmV0dXJuIHRoaXN9LGNlbnRlcjpmdW5jdGlvbihhKXtyZXR1cm4oYXx8bmV3IFRIUkVFLlZlY3RvcjMpLmFkZFZlY3RvcnModGhpcy5zdGFydCx0aGlzLmVuZCkubXVsdGlwbHlTY2FsYXIoMC41KX0sZGVsdGE6ZnVuY3Rpb24oYSl7cmV0dXJuKGF8fG5ldyBUSFJFRS5WZWN0b3IzKS5zdWJWZWN0b3JzKHRoaXMuZW5kLHRoaXMuc3RhcnQpfSxkaXN0YW5jZVNxOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUb1NxdWFyZWQodGhpcy5lbmQpfSxkaXN0YW5jZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG8odGhpcy5lbmQpfSxhdDpmdW5jdGlvbihhLFxuYil7dmFyIGM9Ynx8bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIHRoaXMuZGVsdGEoYykubXVsdGlwbHlTY2FsYXIoYSkuYWRkKHRoaXMuc3RhcnQpfSxjbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyOmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjMsYj1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oYyxkKXthLnN1YlZlY3RvcnMoYyx0aGlzLnN0YXJ0KTtiLnN1YlZlY3RvcnModGhpcy5lbmQsdGhpcy5zdGFydCk7dmFyIGU9Yi5kb3QoYiksZT1iLmRvdChhKS9lO2QmJihlPVRIUkVFLk1hdGguY2xhbXAoZSwwLDEpKTtyZXR1cm4gZX19KCksY2xvc2VzdFBvaW50VG9Qb2ludDpmdW5jdGlvbihhLGIsYyl7YT10aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXIoYSxiKTtjPWN8fG5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiB0aGlzLmRlbHRhKGMpLm11bHRpcGx5U2NhbGFyKGEpLmFkZCh0aGlzLnN0YXJ0KX0sYXBwbHlNYXRyaXg0OmZ1bmN0aW9uKGEpe3RoaXMuc3RhcnQuYXBwbHlNYXRyaXg0KGEpO1xudGhpcy5lbmQuYXBwbHlNYXRyaXg0KGEpO3JldHVybiB0aGlzfSxlcXVhbHM6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuc3RhcnQuZXF1YWxzKHRoaXMuc3RhcnQpJiZhLmVuZC5lcXVhbHModGhpcy5lbmQpfSxjbG9uZTpmdW5jdGlvbigpe3JldHVybihuZXcgVEhSRUUuTGluZTMpLmNvcHkodGhpcyl9fTtUSFJFRS5Cb3gyPWZ1bmN0aW9uKGEsYil7dGhpcy5taW49dm9pZCAwIT09YT9hOm5ldyBUSFJFRS5WZWN0b3IyKEluZmluaXR5LEluZmluaXR5KTt0aGlzLm1heD12b2lkIDAhPT1iP2I6bmV3IFRIUkVFLlZlY3RvcjIoLUluZmluaXR5LC1JbmZpbml0eSl9O1xuVEhSRUUuQm94Mi5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLkJveDIsc2V0OmZ1bmN0aW9uKGEsYil7dGhpcy5taW4uY29weShhKTt0aGlzLm1heC5jb3B5KGIpO3JldHVybiB0aGlzfSxzZXRGcm9tUG9pbnRzOmZ1bmN0aW9uKGEpe2lmKDA8YS5sZW5ndGgpe3ZhciBiPWFbMF07dGhpcy5taW4uY29weShiKTt0aGlzLm1heC5jb3B5KGIpO2Zvcih2YXIgYz0xLGQ9YS5sZW5ndGg7YzxkO2MrKyliPWFbY10sYi54PHRoaXMubWluLng/dGhpcy5taW4ueD1iLng6Yi54PnRoaXMubWF4LngmJih0aGlzLm1heC54PWIueCksYi55PHRoaXMubWluLnk/dGhpcy5taW4ueT1iLnk6Yi55PnRoaXMubWF4LnkmJih0aGlzLm1heC55PWIueSl9ZWxzZSB0aGlzLm1ha2VFbXB0eSgpO3JldHVybiB0aGlzfSxzZXRGcm9tQ2VudGVyQW5kU2l6ZTpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IyO3JldHVybiBmdW5jdGlvbihiLGMpe3ZhciBkPWEuY29weShjKS5tdWx0aXBseVNjYWxhcigwLjUpO1xudGhpcy5taW4uY29weShiKS5zdWIoZCk7dGhpcy5tYXguY29weShiKS5hZGQoZCk7cmV0dXJuIHRoaXN9fSgpLGNvcHk6ZnVuY3Rpb24oYSl7dGhpcy5taW4uY29weShhLm1pbik7dGhpcy5tYXguY29weShhLm1heCk7cmV0dXJuIHRoaXN9LG1ha2VFbXB0eTpmdW5jdGlvbigpe3RoaXMubWluLng9dGhpcy5taW4ueT1JbmZpbml0eTt0aGlzLm1heC54PXRoaXMubWF4Lnk9LUluZmluaXR5O3JldHVybiB0aGlzfSxlbXB0eTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1heC54PHRoaXMubWluLnh8fHRoaXMubWF4Lnk8dGhpcy5taW4ueX0sY2VudGVyOmZ1bmN0aW9uKGEpe3JldHVybihhfHxuZXcgVEhSRUUuVmVjdG9yMikuYWRkVmVjdG9ycyh0aGlzLm1pbix0aGlzLm1heCkubXVsdGlwbHlTY2FsYXIoMC41KX0sc2l6ZTpmdW5jdGlvbihhKXtyZXR1cm4oYXx8bmV3IFRIUkVFLlZlY3RvcjIpLnN1YlZlY3RvcnModGhpcy5tYXgsdGhpcy5taW4pfSxleHBhbmRCeVBvaW50OmZ1bmN0aW9uKGEpe3RoaXMubWluLm1pbihhKTtcbnRoaXMubWF4Lm1heChhKTtyZXR1cm4gdGhpc30sZXhwYW5kQnlWZWN0b3I6ZnVuY3Rpb24oYSl7dGhpcy5taW4uc3ViKGEpO3RoaXMubWF4LmFkZChhKTtyZXR1cm4gdGhpc30sZXhwYW5kQnlTY2FsYXI6ZnVuY3Rpb24oYSl7dGhpcy5taW4uYWRkU2NhbGFyKC1hKTt0aGlzLm1heC5hZGRTY2FsYXIoYSk7cmV0dXJuIHRoaXN9LGNvbnRhaW5zUG9pbnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEueDx0aGlzLm1pbi54fHxhLng+dGhpcy5tYXgueHx8YS55PHRoaXMubWluLnl8fGEueT50aGlzLm1heC55PyExOiEwfSxjb250YWluc0JveDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5taW4ueDw9YS5taW4ueCYmYS5tYXgueDw9dGhpcy5tYXgueCYmdGhpcy5taW4ueTw9YS5taW4ueSYmYS5tYXgueTw9dGhpcy5tYXgueT8hMDohMX0sZ2V0UGFyYW1ldGVyOmZ1bmN0aW9uKGEpe3JldHVybiBuZXcgVEhSRUUuVmVjdG9yMigoYS54LXRoaXMubWluLngpLyh0aGlzLm1heC54LXRoaXMubWluLngpLFxuKGEueS10aGlzLm1pbi55KS8odGhpcy5tYXgueS10aGlzLm1pbi55KSl9LGlzSW50ZXJzZWN0aW9uQm94OmZ1bmN0aW9uKGEpe3JldHVybiBhLm1heC54PHRoaXMubWluLnh8fGEubWluLng+dGhpcy5tYXgueHx8YS5tYXgueTx0aGlzLm1pbi55fHxhLm1pbi55PnRoaXMubWF4Lnk/ITE6ITB9LGNsYW1wUG9pbnQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4oYnx8bmV3IFRIUkVFLlZlY3RvcjIpLmNvcHkoYSkuY2xhbXAodGhpcy5taW4sdGhpcy5tYXgpfSxkaXN0YW5jZVRvUG9pbnQ6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMjtyZXR1cm4gZnVuY3Rpb24oYil7cmV0dXJuIGEuY29weShiKS5jbGFtcCh0aGlzLm1pbix0aGlzLm1heCkuc3ViKGIpLmxlbmd0aCgpfX0oKSxpbnRlcnNlY3Q6ZnVuY3Rpb24oYSl7dGhpcy5taW4ubWF4KGEubWluKTt0aGlzLm1heC5taW4oYS5tYXgpO3JldHVybiB0aGlzfSx1bmlvbjpmdW5jdGlvbihhKXt0aGlzLm1pbi5taW4oYS5taW4pO3RoaXMubWF4Lm1heChhLm1heCk7XG5yZXR1cm4gdGhpc30sdHJhbnNsYXRlOmZ1bmN0aW9uKGEpe3RoaXMubWluLmFkZChhKTt0aGlzLm1heC5hZGQoYSk7cmV0dXJuIHRoaXN9LGVxdWFsczpmdW5jdGlvbihhKXtyZXR1cm4gYS5taW4uZXF1YWxzKHRoaXMubWluKSYmYS5tYXguZXF1YWxzKHRoaXMubWF4KX0sY2xvbmU6ZnVuY3Rpb24oKXtyZXR1cm4obmV3IFRIUkVFLkJveDIpLmNvcHkodGhpcyl9fTtUSFJFRS5Cb3gzPWZ1bmN0aW9uKGEsYil7dGhpcy5taW49dm9pZCAwIT09YT9hOm5ldyBUSFJFRS5WZWN0b3IzKEluZmluaXR5LEluZmluaXR5LEluZmluaXR5KTt0aGlzLm1heD12b2lkIDAhPT1iP2I6bmV3IFRIUkVFLlZlY3RvcjMoLUluZmluaXR5LC1JbmZpbml0eSwtSW5maW5pdHkpfTtcblRIUkVFLkJveDMucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5Cb3gzLHNldDpmdW5jdGlvbihhLGIpe3RoaXMubWluLmNvcHkoYSk7dGhpcy5tYXguY29weShiKTtyZXR1cm4gdGhpc30sYWRkUG9pbnQ6ZnVuY3Rpb24oYSl7YS54PHRoaXMubWluLng/dGhpcy5taW4ueD1hLng6YS54PnRoaXMubWF4LngmJih0aGlzLm1heC54PWEueCk7YS55PHRoaXMubWluLnk/dGhpcy5taW4ueT1hLnk6YS55PnRoaXMubWF4LnkmJih0aGlzLm1heC55PWEueSk7YS56PHRoaXMubWluLno/dGhpcy5taW4uej1hLno6YS56PnRoaXMubWF4LnomJih0aGlzLm1heC56PWEueil9LHNldEZyb21Qb2ludHM6ZnVuY3Rpb24oYSl7aWYoMDxhLmxlbmd0aCl7dmFyIGI9YVswXTt0aGlzLm1pbi5jb3B5KGIpO3RoaXMubWF4LmNvcHkoYik7Zm9yKHZhciBiPTEsYz1hLmxlbmd0aDtiPGM7YisrKXRoaXMuYWRkUG9pbnQoYVtiXSl9ZWxzZSB0aGlzLm1ha2VFbXB0eSgpO3JldHVybiB0aGlzfSxzZXRGcm9tQ2VudGVyQW5kU2l6ZTpmdW5jdGlvbigpe3ZhciBhPVxubmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS5jb3B5KGMpLm11bHRpcGx5U2NhbGFyKDAuNSk7dGhpcy5taW4uY29weShiKS5zdWIoZCk7dGhpcy5tYXguY29weShiKS5hZGQoZCk7cmV0dXJuIHRoaXN9fSgpLHNldEZyb21PYmplY3Q6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oYil7dmFyIGM9dGhpcztiLnVwZGF0ZU1hdHJpeFdvcmxkKCEwKTt0aGlzLm1ha2VFbXB0eSgpO2IudHJhdmVyc2UoZnVuY3Rpb24oYil7aWYodm9pZCAwIT09Yi5nZW9tZXRyeSYmdm9pZCAwIT09Yi5nZW9tZXRyeS52ZXJ0aWNlcylmb3IodmFyIGU9Yi5nZW9tZXRyeS52ZXJ0aWNlcyxmPTAsaD1lLmxlbmd0aDtmPGg7ZisrKWEuY29weShlW2ZdKSxhLmFwcGx5TWF0cml4NChiLm1hdHJpeFdvcmxkKSxjLmV4cGFuZEJ5UG9pbnQoYSl9KTtyZXR1cm4gdGhpc319KCksY29weTpmdW5jdGlvbihhKXt0aGlzLm1pbi5jb3B5KGEubWluKTtcbnRoaXMubWF4LmNvcHkoYS5tYXgpO3JldHVybiB0aGlzfSxtYWtlRW1wdHk6ZnVuY3Rpb24oKXt0aGlzLm1pbi54PXRoaXMubWluLnk9dGhpcy5taW4uej1JbmZpbml0eTt0aGlzLm1heC54PXRoaXMubWF4Lnk9dGhpcy5tYXguej0tSW5maW5pdHk7cmV0dXJuIHRoaXN9LGVtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4Lng8dGhpcy5taW4ueHx8dGhpcy5tYXgueTx0aGlzLm1pbi55fHx0aGlzLm1heC56PHRoaXMubWluLnp9LGNlbnRlcjpmdW5jdGlvbihhKXtyZXR1cm4oYXx8bmV3IFRIUkVFLlZlY3RvcjMpLmFkZFZlY3RvcnModGhpcy5taW4sdGhpcy5tYXgpLm11bHRpcGx5U2NhbGFyKDAuNSl9LHNpemU6ZnVuY3Rpb24oYSl7cmV0dXJuKGF8fG5ldyBUSFJFRS5WZWN0b3IzKS5zdWJWZWN0b3JzKHRoaXMubWF4LHRoaXMubWluKX0sZXhwYW5kQnlQb2ludDpmdW5jdGlvbihhKXt0aGlzLm1pbi5taW4oYSk7dGhpcy5tYXgubWF4KGEpO3JldHVybiB0aGlzfSxleHBhbmRCeVZlY3RvcjpmdW5jdGlvbihhKXt0aGlzLm1pbi5zdWIoYSk7XG50aGlzLm1heC5hZGQoYSk7cmV0dXJuIHRoaXN9LGV4cGFuZEJ5U2NhbGFyOmZ1bmN0aW9uKGEpe3RoaXMubWluLmFkZFNjYWxhcigtYSk7dGhpcy5tYXguYWRkU2NhbGFyKGEpO3JldHVybiB0aGlzfSxjb250YWluc1BvaW50OmZ1bmN0aW9uKGEpe3JldHVybiBhLng8dGhpcy5taW4ueHx8YS54PnRoaXMubWF4Lnh8fGEueTx0aGlzLm1pbi55fHxhLnk+dGhpcy5tYXgueXx8YS56PHRoaXMubWluLnp8fGEuej50aGlzLm1heC56PyExOiEwfSxjb250YWluc0JveDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5taW4ueDw9YS5taW4ueCYmYS5tYXgueDw9dGhpcy5tYXgueCYmdGhpcy5taW4ueTw9YS5taW4ueSYmYS5tYXgueTw9dGhpcy5tYXgueSYmdGhpcy5taW4uejw9YS5taW4ueiYmYS5tYXguejw9dGhpcy5tYXguej8hMDohMX0sZ2V0UGFyYW1ldGVyOmZ1bmN0aW9uKGEpe3JldHVybiBuZXcgVEhSRUUuVmVjdG9yMygoYS54LXRoaXMubWluLngpLyh0aGlzLm1heC54LXRoaXMubWluLngpLFxuKGEueS10aGlzLm1pbi55KS8odGhpcy5tYXgueS10aGlzLm1pbi55KSwoYS56LXRoaXMubWluLnopLyh0aGlzLm1heC56LXRoaXMubWluLnopKX0saXNJbnRlcnNlY3Rpb25Cb3g6ZnVuY3Rpb24oYSl7cmV0dXJuIGEubWF4Lng8dGhpcy5taW4ueHx8YS5taW4ueD50aGlzLm1heC54fHxhLm1heC55PHRoaXMubWluLnl8fGEubWluLnk+dGhpcy5tYXgueXx8YS5tYXguejx0aGlzLm1pbi56fHxhLm1pbi56PnRoaXMubWF4Lno/ITE6ITB9LGNsYW1wUG9pbnQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4oYnx8bmV3IFRIUkVFLlZlY3RvcjMpLmNvcHkoYSkuY2xhbXAodGhpcy5taW4sdGhpcy5tYXgpfSxkaXN0YW5jZVRvUG9pbnQ6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oYil7cmV0dXJuIGEuY29weShiKS5jbGFtcCh0aGlzLm1pbix0aGlzLm1heCkuc3ViKGIpLmxlbmd0aCgpfX0oKSxnZXRCb3VuZGluZ1NwaGVyZTpmdW5jdGlvbigpe3ZhciBhPVxubmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGIpe2I9Ynx8bmV3IFRIUkVFLlNwaGVyZTtiLmNlbnRlcj10aGlzLmNlbnRlcigpO2IucmFkaXVzPTAuNSp0aGlzLnNpemUoYSkubGVuZ3RoKCk7cmV0dXJuIGJ9fSgpLGludGVyc2VjdDpmdW5jdGlvbihhKXt0aGlzLm1pbi5tYXgoYS5taW4pO3RoaXMubWF4Lm1pbihhLm1heCk7cmV0dXJuIHRoaXN9LHVuaW9uOmZ1bmN0aW9uKGEpe3RoaXMubWluLm1pbihhLm1pbik7dGhpcy5tYXgubWF4KGEubWF4KTtyZXR1cm4gdGhpc30sYXBwbHlNYXRyaXg0OmZ1bmN0aW9uKCl7dmFyIGE9W25ldyBUSFJFRS5WZWN0b3IzLG5ldyBUSFJFRS5WZWN0b3IzLG5ldyBUSFJFRS5WZWN0b3IzLG5ldyBUSFJFRS5WZWN0b3IzLG5ldyBUSFJFRS5WZWN0b3IzLG5ldyBUSFJFRS5WZWN0b3IzLG5ldyBUSFJFRS5WZWN0b3IzLG5ldyBUSFJFRS5WZWN0b3IzXTtyZXR1cm4gZnVuY3Rpb24oYil7YVswXS5zZXQodGhpcy5taW4ueCx0aGlzLm1pbi55LFxudGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KGIpO2FbMV0uc2V0KHRoaXMubWluLngsdGhpcy5taW4ueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoYik7YVsyXS5zZXQodGhpcy5taW4ueCx0aGlzLm1heC55LHRoaXMubWluLnopLmFwcGx5TWF0cml4NChiKTthWzNdLnNldCh0aGlzLm1pbi54LHRoaXMubWF4LnksdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KGIpO2FbNF0uc2V0KHRoaXMubWF4LngsdGhpcy5taW4ueSx0aGlzLm1pbi56KS5hcHBseU1hdHJpeDQoYik7YVs1XS5zZXQodGhpcy5tYXgueCx0aGlzLm1pbi55LHRoaXMubWF4LnopLmFwcGx5TWF0cml4NChiKTthWzZdLnNldCh0aGlzLm1heC54LHRoaXMubWF4LnksdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KGIpO2FbN10uc2V0KHRoaXMubWF4LngsdGhpcy5tYXgueSx0aGlzLm1heC56KS5hcHBseU1hdHJpeDQoYik7dGhpcy5tYWtlRW1wdHkoKTt0aGlzLnNldEZyb21Qb2ludHMoYSk7cmV0dXJuIHRoaXN9fSgpLHRyYW5zbGF0ZTpmdW5jdGlvbihhKXt0aGlzLm1pbi5hZGQoYSk7XG50aGlzLm1heC5hZGQoYSk7cmV0dXJuIHRoaXN9LGVxdWFsczpmdW5jdGlvbihhKXtyZXR1cm4gYS5taW4uZXF1YWxzKHRoaXMubWluKSYmYS5tYXguZXF1YWxzKHRoaXMubWF4KX0sY2xvbmU6ZnVuY3Rpb24oKXtyZXR1cm4obmV3IFRIUkVFLkJveDMpLmNvcHkodGhpcyl9fTtUSFJFRS5NYXRyaXgzPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGgsZyxpKXt0aGlzLmVsZW1lbnRzPW5ldyBGbG9hdDMyQXJyYXkoOSk7dGhpcy5zZXQodm9pZCAwIT09YT9hOjEsYnx8MCxjfHwwLGR8fDAsdm9pZCAwIT09ZT9lOjEsZnx8MCxofHwwLGd8fDAsdm9pZCAwIT09aT9pOjEpfTtcblRIUkVFLk1hdHJpeDMucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5NYXRyaXgzLHNldDpmdW5jdGlvbihhLGIsYyxkLGUsZixoLGcsaSl7dmFyIGs9dGhpcy5lbGVtZW50cztrWzBdPWE7a1szXT1iO2tbNl09YztrWzFdPWQ7a1s0XT1lO2tbN109ZjtrWzJdPWg7a1s1XT1nO2tbOF09aTtyZXR1cm4gdGhpc30saWRlbnRpdHk6ZnVuY3Rpb24oKXt0aGlzLnNldCgxLDAsMCwwLDEsMCwwLDAsMSk7cmV0dXJuIHRoaXN9LGNvcHk6ZnVuY3Rpb24oYSl7YT1hLmVsZW1lbnRzO3RoaXMuc2V0KGFbMF0sYVszXSxhWzZdLGFbMV0sYVs0XSxhWzddLGFbMl0sYVs1XSxhWzhdKTtyZXR1cm4gdGhpc30sbXVsdGlwbHlWZWN0b3IzOmZ1bmN0aW9uKGEpe2NvbnNvbGUud2FybihcIkRFUFJFQ0FURUQ6IE1hdHJpeDMncyAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDMoIG1hdHJpeCApIGluc3RlYWQuXCIpO3JldHVybiBhLmFwcGx5TWF0cml4Myh0aGlzKX0sXG5tdWx0aXBseVZlY3RvcjNBcnJheTpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihiKXtmb3IodmFyIGM9MCxkPWIubGVuZ3RoO2M8ZDtjKz0zKWEueD1iW2NdLGEueT1iW2MrMV0sYS56PWJbYysyXSxhLmFwcGx5TWF0cml4Myh0aGlzKSxiW2NdPWEueCxiW2MrMV09YS55LGJbYysyXT1hLno7cmV0dXJuIGJ9fSgpLG11bHRpcGx5U2NhbGFyOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZWxlbWVudHM7YlswXSo9YTtiWzNdKj1hO2JbNl0qPWE7YlsxXSo9YTtiWzRdKj1hO2JbN10qPWE7YlsyXSo9YTtiWzVdKj1hO2JbOF0qPWE7cmV0dXJuIHRoaXN9LGRldGVybWluYW50OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lbGVtZW50cyxiPWFbMF0sYz1hWzFdLGQ9YVsyXSxlPWFbM10sZj1hWzRdLGg9YVs1XSxnPWFbNl0saT1hWzddLGE9YVs4XTtyZXR1cm4gYipmKmEtYipoKmktYyplKmErYypoKmcrZCplKmktZCpmKmd9LGdldEludmVyc2U6ZnVuY3Rpb24oYSxcbmIpe3ZhciBjPWEuZWxlbWVudHMsZD10aGlzLmVsZW1lbnRzO2RbMF09Y1sxMF0qY1s1XS1jWzZdKmNbOV07ZFsxXT0tY1sxMF0qY1sxXStjWzJdKmNbOV07ZFsyXT1jWzZdKmNbMV0tY1syXSpjWzVdO2RbM109LWNbMTBdKmNbNF0rY1s2XSpjWzhdO2RbNF09Y1sxMF0qY1swXS1jWzJdKmNbOF07ZFs1XT0tY1s2XSpjWzBdK2NbMl0qY1s0XTtkWzZdPWNbOV0qY1s0XS1jWzVdKmNbOF07ZFs3XT0tY1s5XSpjWzBdK2NbMV0qY1s4XTtkWzhdPWNbNV0qY1swXS1jWzFdKmNbNF07Yz1jWzBdKmRbMF0rY1sxXSpkWzNdK2NbMl0qZFs2XTtpZigwPT09Yyl7aWYoYil0aHJvdyBFcnJvcihcIk1hdHJpeDMuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCIpO2NvbnNvbGUud2FybihcIk1hdHJpeDMuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCIpO3RoaXMuaWRlbnRpdHkoKTtyZXR1cm4gdGhpc310aGlzLm11bHRpcGx5U2NhbGFyKDEvXG5jKTtyZXR1cm4gdGhpc30sdHJhbnNwb3NlOmZ1bmN0aW9uKCl7dmFyIGEsYj10aGlzLmVsZW1lbnRzO2E9YlsxXTtiWzFdPWJbM107YlszXT1hO2E9YlsyXTtiWzJdPWJbNl07Yls2XT1hO2E9Yls1XTtiWzVdPWJbN107Yls3XT1hO3JldHVybiB0aGlzfSxnZXROb3JtYWxNYXRyaXg6ZnVuY3Rpb24oYSl7dGhpcy5nZXRJbnZlcnNlKGEpLnRyYW5zcG9zZSgpO3JldHVybiB0aGlzfSx0cmFuc3Bvc2VJbnRvQXJyYXk6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5lbGVtZW50czthWzBdPWJbMF07YVsxXT1iWzNdO2FbMl09Yls2XTthWzNdPWJbMV07YVs0XT1iWzRdO2FbNV09Yls3XTthWzZdPWJbMl07YVs3XT1iWzVdO2FbOF09Yls4XTtyZXR1cm4gdGhpc30sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmVsZW1lbnRzO3JldHVybiBuZXcgVEhSRUUuTWF0cml4MyhhWzBdLGFbM10sYVs2XSxhWzFdLGFbNF0sYVs3XSxhWzJdLGFbNV0sYVs4XSl9fTtUSFJFRS5NYXRyaXg0PWZ1bmN0aW9uKGEsYixjLGQsZSxmLGgsZyxpLGssbSxsLHAscyx0LG4pe3ZhciByPXRoaXMuZWxlbWVudHM9bmV3IEZsb2F0MzJBcnJheSgxNik7clswXT12b2lkIDAhPT1hP2E6MTtyWzRdPWJ8fDA7cls4XT1jfHwwO3JbMTJdPWR8fDA7clsxXT1lfHwwO3JbNV09dm9pZCAwIT09Zj9mOjE7cls5XT1ofHwwO3JbMTNdPWd8fDA7clsyXT1pfHwwO3JbNl09a3x8MDtyWzEwXT12b2lkIDAhPT1tP206MTtyWzE0XT1sfHwwO3JbM109cHx8MDtyWzddPXN8fDA7clsxMV09dHx8MDtyWzE1XT12b2lkIDAhPT1uP246MX07XG5USFJFRS5NYXRyaXg0LnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuTWF0cml4NCxzZXQ6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsaCxnLGksayxtLGwscCxzLHQsbil7dmFyIHI9dGhpcy5lbGVtZW50cztyWzBdPWE7cls0XT1iO3JbOF09YztyWzEyXT1kO3JbMV09ZTtyWzVdPWY7cls5XT1oO3JbMTNdPWc7clsyXT1pO3JbNl09aztyWzEwXT1tO3JbMTRdPWw7clszXT1wO3JbN109cztyWzExXT10O3JbMTVdPW47cmV0dXJuIHRoaXN9LGlkZW50aXR5OmZ1bmN0aW9uKCl7dGhpcy5zZXQoMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMSk7cmV0dXJuIHRoaXN9LGNvcHk6ZnVuY3Rpb24oYSl7dGhpcy5lbGVtZW50cy5zZXQoYS5lbGVtZW50cyk7cmV0dXJuIHRoaXN9LGV4dHJhY3RQb3NpdGlvbjpmdW5jdGlvbihhKXtjb25zb2xlLndhcm4oXCJERVBSRUNBVEVEOiBNYXRyaXg0J3MgLmV4dHJhY3RQb3NpdGlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmNvcHlQb3NpdGlvbigpLlwiKTtcbnJldHVybiB0aGlzLmNvcHlQb3NpdGlvbihhKX0sY29weVBvc2l0aW9uOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZWxlbWVudHMsYT1hLmVsZW1lbnRzO2JbMTJdPWFbMTJdO2JbMTNdPWFbMTNdO2JbMTRdPWFbMTRdO3JldHVybiB0aGlzfSxleHRyYWN0Um90YXRpb246ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oYil7dmFyIGM9dGhpcy5lbGVtZW50cyxiPWIuZWxlbWVudHMsZD0xL2Euc2V0KGJbMF0sYlsxXSxiWzJdKS5sZW5ndGgoKSxlPTEvYS5zZXQoYls0XSxiWzVdLGJbNl0pLmxlbmd0aCgpLGY9MS9hLnNldChiWzhdLGJbOV0sYlsxMF0pLmxlbmd0aCgpO2NbMF09YlswXSpkO2NbMV09YlsxXSpkO2NbMl09YlsyXSpkO2NbNF09Yls0XSplO2NbNV09Yls1XSplO2NbNl09Yls2XSplO2NbOF09Yls4XSpmO2NbOV09Yls5XSpmO2NbMTBdPWJbMTBdKmY7cmV0dXJuIHRoaXN9fSgpLG1ha2VSb3RhdGlvbkZyb21FdWxlcjpmdW5jdGlvbihhKXshMT09PVxuYSBpbnN0YW5jZW9mIFRIUkVFLkV1bGVyJiZjb25zb2xlLmVycm9yKFwiRVJST1I6IE1hdHJpeCdzIC5tYWtlUm90YXRpb25Gcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuICBQbGVhc2UgdXBkYXRlIHlvdXIgY29kZS5cIik7dmFyIGI9dGhpcy5lbGVtZW50cyxjPWEueCxkPWEueSxlPWEueixmPU1hdGguY29zKGMpLGM9TWF0aC5zaW4oYyksaD1NYXRoLmNvcyhkKSxkPU1hdGguc2luKGQpLGc9TWF0aC5jb3MoZSksZT1NYXRoLnNpbihlKTtpZihcIlhZWlwiPT09YS5vcmRlcil7dmFyIGE9ZipnLGk9ZiplLGs9YypnLG09YyplO2JbMF09aCpnO2JbNF09LWgqZTtiWzhdPWQ7YlsxXT1pK2sqZDtiWzVdPWEtbSpkO2JbOV09LWMqaDtiWzJdPW0tYSpkO2JbNl09aytpKmQ7YlsxMF09ZipofWVsc2VcIllYWlwiPT09YS5vcmRlcj8oYT1oKmcsaT1oKmUsaz1kKmcsbT1kKmUsYlswXT1hK20qYyxiWzRdPWsqYy1pLGJbOF09XG5mKmQsYlsxXT1mKmUsYls1XT1mKmcsYls5XT0tYyxiWzJdPWkqYy1rLGJbNl09bSthKmMsYlsxMF09ZipoKTpcIlpYWVwiPT09YS5vcmRlcj8oYT1oKmcsaT1oKmUsaz1kKmcsbT1kKmUsYlswXT1hLW0qYyxiWzRdPS1mKmUsYls4XT1rK2kqYyxiWzFdPWkraypjLGJbNV09ZipnLGJbOV09bS1hKmMsYlsyXT0tZipkLGJbNl09YyxiWzEwXT1mKmgpOlwiWllYXCI9PT1hLm9yZGVyPyhhPWYqZyxpPWYqZSxrPWMqZyxtPWMqZSxiWzBdPWgqZyxiWzRdPWsqZC1pLGJbOF09YSpkK20sYlsxXT1oKmUsYls1XT1tKmQrYSxiWzldPWkqZC1rLGJbMl09LWQsYls2XT1jKmgsYlsxMF09ZipoKTpcIllaWFwiPT09YS5vcmRlcj8oYT1mKmgsaT1mKmQsaz1jKmgsbT1jKmQsYlswXT1oKmcsYls0XT1tLWEqZSxiWzhdPWsqZStpLGJbMV09ZSxiWzVdPWYqZyxiWzldPS1jKmcsYlsyXT0tZCpnLGJbNl09aSplK2ssYlsxMF09YS1tKmUpOlwiWFpZXCI9PT1hLm9yZGVyJiYoYT1mKmgsaT1mKmQsaz1jKmgsbT1jKmQsYlswXT1cbmgqZyxiWzRdPS1lLGJbOF09ZCpnLGJbMV09YSplK20sYls1XT1mKmcsYls5XT1pKmUtayxiWzJdPWsqZS1pLGJbNl09YypnLGJbMTBdPW0qZSthKTtiWzNdPTA7Yls3XT0wO2JbMTFdPTA7YlsxMl09MDtiWzEzXT0wO2JbMTRdPTA7YlsxNV09MTtyZXR1cm4gdGhpc30sc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjpmdW5jdGlvbihhKXtjb25zb2xlLndhcm4oXCJERVBSRUNBVEVEOiBNYXRyaXg0J3MgLnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uLiAgUGxlYXNlIHVwZGF0ZSB5b3VyIGNvZGUuXCIpO3JldHVybiB0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKGEpfSxtYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbjpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmVsZW1lbnRzLGM9YS54LGQ9YS55LGU9YS56LGY9YS53LGg9YytjLGc9ZCtkLGk9ZStlLGE9YypoLGs9YypnLGM9XG5jKmksbT1kKmcsZD1kKmksZT1lKmksaD1mKmgsZz1mKmcsZj1mKmk7YlswXT0xLShtK2UpO2JbNF09ay1mO2JbOF09YytnO2JbMV09aytmO2JbNV09MS0oYStlKTtiWzldPWQtaDtiWzJdPWMtZztiWzZdPWQraDtiWzEwXT0xLShhK20pO2JbM109MDtiWzddPTA7YlsxMV09MDtiWzEyXT0wO2JbMTNdPTA7YlsxNF09MDtiWzE1XT0xO3JldHVybiB0aGlzfSxsb29rQXQ6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMyxiPW5ldyBUSFJFRS5WZWN0b3IzLGM9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGQsZSxmKXt2YXIgaD10aGlzLmVsZW1lbnRzO2Muc3ViVmVjdG9ycyhkLGUpLm5vcm1hbGl6ZSgpOzA9PT1jLmxlbmd0aCgpJiYoYy56PTEpO2EuY3Jvc3NWZWN0b3JzKGYsYykubm9ybWFsaXplKCk7MD09PWEubGVuZ3RoKCkmJihjLngrPTFFLTQsYS5jcm9zc1ZlY3RvcnMoZixjKS5ub3JtYWxpemUoKSk7Yi5jcm9zc1ZlY3RvcnMoYyxhKTtoWzBdPWEueDtcbmhbNF09Yi54O2hbOF09Yy54O2hbMV09YS55O2hbNV09Yi55O2hbOV09Yy55O2hbMl09YS56O2hbNl09Yi56O2hbMTBdPWMuejtyZXR1cm4gdGhpc319KCksbXVsdGlwbHk6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdm9pZCAwIT09Yj8oY29uc29sZS53YXJuKFwiREVQUkVDQVRFRDogTWF0cml4NCdzIC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSBpbnN0ZWFkLlwiKSx0aGlzLm11bHRpcGx5TWF0cmljZXMoYSxiKSk6dGhpcy5tdWx0aXBseU1hdHJpY2VzKHRoaXMsYSl9LG11bHRpcGx5TWF0cmljZXM6ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmVsZW1lbnRzLGQ9Yi5lbGVtZW50cyxlPXRoaXMuZWxlbWVudHMsZj1jWzBdLGg9Y1s0XSxnPWNbOF0saT1jWzEyXSxrPWNbMV0sbT1jWzVdLGw9Y1s5XSxwPWNbMTNdLHM9Y1syXSx0PWNbNl0sbj1jWzEwXSxyPWNbMTRdLHE9Y1szXSx1PWNbN10sdz1jWzExXSxjPWNbMTVdLFxuej1kWzBdLEI9ZFs0XSxEPWRbOF0seD1kWzEyXSxGPWRbMV0sQT1kWzVdLE89ZFs5XSxDPWRbMTNdLEU9ZFsyXSxJPWRbNl0seT1kWzEwXSx2PWRbMTRdLEc9ZFszXSxSPWRbN10sSj1kWzExXSxkPWRbMTVdO2VbMF09Zip6K2gqRitnKkUraSpHO2VbNF09ZipCK2gqQStnKkkraSpSO2VbOF09ZipEK2gqTytnKnkraSpKO2VbMTJdPWYqeCtoKkMrZyp2K2kqZDtlWzFdPWsqeittKkYrbCpFK3AqRztlWzVdPWsqQittKkErbCpJK3AqUjtlWzldPWsqRCttKk8rbCp5K3AqSjtlWzEzXT1rKngrbSpDK2wqditwKmQ7ZVsyXT1zKnordCpGK24qRStyKkc7ZVs2XT1zKkIrdCpBK24qSStyKlI7ZVsxMF09cypEK3QqTytuKnkrcipKO2VbMTRdPXMqeCt0KkMrbip2K3IqZDtlWzNdPXEqeit1KkYrdypFK2MqRztlWzddPXEqQit1KkErdypJK2MqUjtlWzExXT1xKkQrdSpPK3cqeStjKko7ZVsxNV09cSp4K3UqQyt3KnYrYypkO3JldHVybiB0aGlzfSxtdWx0aXBseVRvQXJyYXk6ZnVuY3Rpb24oYSxiLFxuYyl7dmFyIGQ9dGhpcy5lbGVtZW50czt0aGlzLm11bHRpcGx5TWF0cmljZXMoYSxiKTtjWzBdPWRbMF07Y1sxXT1kWzFdO2NbMl09ZFsyXTtjWzNdPWRbM107Y1s0XT1kWzRdO2NbNV09ZFs1XTtjWzZdPWRbNl07Y1s3XT1kWzddO2NbOF09ZFs4XTtjWzldPWRbOV07Y1sxMF09ZFsxMF07Y1sxMV09ZFsxMV07Y1sxMl09ZFsxMl07Y1sxM109ZFsxM107Y1sxNF09ZFsxNF07Y1sxNV09ZFsxNV07cmV0dXJuIHRoaXN9LG11bHRpcGx5U2NhbGFyOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZWxlbWVudHM7YlswXSo9YTtiWzRdKj1hO2JbOF0qPWE7YlsxMl0qPWE7YlsxXSo9YTtiWzVdKj1hO2JbOV0qPWE7YlsxM10qPWE7YlsyXSo9YTtiWzZdKj1hO2JbMTBdKj1hO2JbMTRdKj1hO2JbM10qPWE7Yls3XSo9YTtiWzExXSo9YTtiWzE1XSo9YTtyZXR1cm4gdGhpc30sbXVsdGlwbHlWZWN0b3IzOmZ1bmN0aW9uKGEpe2NvbnNvbGUud2FybihcIkRFUFJFQ0FURUQ6IE1hdHJpeDQncyAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIG9yIHZlY3Rvci5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuXCIpO1xucmV0dXJuIGEuYXBwbHlQcm9qZWN0aW9uKHRoaXMpfSxtdWx0aXBseVZlY3RvcjQ6ZnVuY3Rpb24oYSl7Y29uc29sZS53YXJuKFwiREVQUkVDQVRFRDogTWF0cml4NCdzIC5tdWx0aXBseVZlY3RvcjQoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC5cIik7cmV0dXJuIGEuYXBwbHlNYXRyaXg0KHRoaXMpfSxtdWx0aXBseVZlY3RvcjNBcnJheTpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihiKXtmb3IodmFyIGM9MCxkPWIubGVuZ3RoO2M8ZDtjKz0zKWEueD1iW2NdLGEueT1iW2MrMV0sYS56PWJbYysyXSxhLmFwcGx5UHJvamVjdGlvbih0aGlzKSxiW2NdPWEueCxiW2MrMV09YS55LGJbYysyXT1hLno7cmV0dXJuIGJ9fSgpLHJvdGF0ZUF4aXM6ZnVuY3Rpb24oYSl7Y29uc29sZS53YXJuKFwiREVQUkVDQVRFRDogTWF0cml4NCdzIC5yb3RhdGVBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMudHJhbnNmb3JtRGlyZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLlwiKTtcbmEudHJhbnNmb3JtRGlyZWN0aW9uKHRoaXMpfSxjcm9zc1ZlY3RvcjpmdW5jdGlvbihhKXtjb25zb2xlLndhcm4oXCJERVBSRUNBVEVEOiBNYXRyaXg0J3MgLmNyb3NzVmVjdG9yKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuXCIpO3JldHVybiBhLmFwcGx5TWF0cml4NCh0aGlzKX0sZGV0ZXJtaW5hbnQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmVsZW1lbnRzLGI9YVswXSxjPWFbNF0sZD1hWzhdLGU9YVsxMl0sZj1hWzFdLGg9YVs1XSxnPWFbOV0saT1hWzEzXSxrPWFbMl0sbT1hWzZdLGw9YVsxMF0scD1hWzE0XTtyZXR1cm4gYVszXSooK2UqZyptLWQqaSptLWUqaCpsK2MqaSpsK2QqaCpwLWMqZypwKSthWzddKigrYipnKnAtYippKmwrZSpmKmwtZCpmKnArZCppKmstZSpnKmspK2FbMTFdKigrYippKm0tYipoKnAtZSpmKm0rYypmKnArZSpoKmstYyppKmspK2FbMTVdKigtZCpoKmstYipnKm0rYipoKmwrZCpmKm0tYypmKlxubCtjKmcqayl9LHRyYW5zcG9zZTpmdW5jdGlvbigpe3ZhciBhPXRoaXMuZWxlbWVudHMsYjtiPWFbMV07YVsxXT1hWzRdO2FbNF09YjtiPWFbMl07YVsyXT1hWzhdO2FbOF09YjtiPWFbNl07YVs2XT1hWzldO2FbOV09YjtiPWFbM107YVszXT1hWzEyXTthWzEyXT1iO2I9YVs3XTthWzddPWFbMTNdO2FbMTNdPWI7Yj1hWzExXTthWzExXT1hWzE0XTthWzE0XT1iO3JldHVybiB0aGlzfSxmbGF0dGVuVG9BcnJheTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmVsZW1lbnRzO2FbMF09YlswXTthWzFdPWJbMV07YVsyXT1iWzJdO2FbM109YlszXTthWzRdPWJbNF07YVs1XT1iWzVdO2FbNl09Yls2XTthWzddPWJbN107YVs4XT1iWzhdO2FbOV09Yls5XTthWzEwXT1iWzEwXTthWzExXT1iWzExXTthWzEyXT1iWzEyXTthWzEzXT1iWzEzXTthWzE0XT1iWzE0XTthWzE1XT1iWzE1XTtyZXR1cm4gYX0sZmxhdHRlblRvQXJyYXlPZmZzZXQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmVsZW1lbnRzO1xuYVtiXT1jWzBdO2FbYisxXT1jWzFdO2FbYisyXT1jWzJdO2FbYiszXT1jWzNdO2FbYis0XT1jWzRdO2FbYis1XT1jWzVdO2FbYis2XT1jWzZdO2FbYis3XT1jWzddO2FbYis4XT1jWzhdO2FbYis5XT1jWzldO2FbYisxMF09Y1sxMF07YVtiKzExXT1jWzExXTthW2IrMTJdPWNbMTJdO2FbYisxM109Y1sxM107YVtiKzE0XT1jWzE0XTthW2IrMTVdPWNbMTVdO3JldHVybiBhfSxnZXRQb3NpdGlvbjpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbigpe2NvbnNvbGUud2FybihcIkRFUFJFQ0FURUQ6IE1hdHJpeDQncyAuZ2V0UG9zaXRpb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy5nZXRQb3NpdGlvbkZyb21NYXRyaXgoIG1hdHJpeCApIGluc3RlYWQuXCIpO3ZhciBiPXRoaXMuZWxlbWVudHM7cmV0dXJuIGEuc2V0KGJbMTJdLGJbMTNdLGJbMTRdKX19KCksc2V0UG9zaXRpb246ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5lbGVtZW50cztcbmJbMTJdPWEueDtiWzEzXT1hLnk7YlsxNF09YS56O3JldHVybiB0aGlzfSxnZXRJbnZlcnNlOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5lbGVtZW50cyxkPWEuZWxlbWVudHMsZT1kWzBdLGY9ZFs0XSxoPWRbOF0sZz1kWzEyXSxpPWRbMV0saz1kWzVdLG09ZFs5XSxsPWRbMTNdLHA9ZFsyXSxzPWRbNl0sdD1kWzEwXSxuPWRbMTRdLHI9ZFszXSxxPWRbN10sdT1kWzExXSxkPWRbMTVdO2NbMF09bSpuKnEtbCp0KnErbCpzKnUtaypuKnUtbSpzKmQrayp0KmQ7Y1s0XT1nKnQqcS1oKm4qcS1nKnMqdStmKm4qdStoKnMqZC1mKnQqZDtjWzhdPWgqbCpxLWcqbSpxK2cqayp1LWYqbCp1LWgqaypkK2YqbSpkO2NbMTJdPWcqbSpzLWgqbCpzLWcqayp0K2YqbCp0K2gqaypuLWYqbSpuO2NbMV09bCp0KnItbSpuKnItbCpwKnUraSpuKnUrbSpwKmQtaSp0KmQ7Y1s1XT1oKm4qci1nKnQqcitnKnAqdS1lKm4qdS1oKnAqZCtlKnQqZDtjWzldPWcqbSpyLWgqbCpyLWcqaSp1K2UqbCp1K2gqaSpkLVxuZSptKmQ7Y1sxM109aCpsKnAtZyptKnArZyppKnQtZSpsKnQtaCppKm4rZSptKm47Y1syXT1rKm4qci1sKnMqcitsKnAqcS1pKm4qcS1rKnAqZCtpKnMqZDtjWzZdPWcqcypyLWYqbipyLWcqcCpxK2UqbipxK2YqcCpkLWUqcypkO2NbMTBdPWYqbCpyLWcqaypyK2cqaSpxLWUqbCpxLWYqaSpkK2UqaypkO2NbMTRdPWcqaypwLWYqbCpwLWcqaSpzK2UqbCpzK2YqaSpuLWUqaypuO2NbM109bSpzKnItayp0KnItbSpwKnEraSp0KnEraypwKnUtaSpzKnU7Y1s3XT1mKnQqci1oKnMqcitoKnAqcS1lKnQqcS1mKnAqdStlKnMqdTtjWzExXT1oKmsqci1mKm0qci1oKmkqcStlKm0qcStmKmkqdS1lKmsqdTtjWzE1XT1mKm0qcC1oKmsqcCtoKmkqcy1lKm0qcy1mKmkqdCtlKmsqdDtjPWUqY1swXStpKmNbNF0rcCpjWzhdK3IqY1sxMl07aWYoMD09Yyl7aWYoYil0aHJvdyBFcnJvcihcIk1hdHJpeDQuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCIpO2NvbnNvbGUud2FybihcIk1hdHJpeDQuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCIpO1xudGhpcy5pZGVudGl0eSgpO3JldHVybiB0aGlzfXRoaXMubXVsdGlwbHlTY2FsYXIoMS9jKTtyZXR1cm4gdGhpc30sdHJhbnNsYXRlOmZ1bmN0aW9uKCl7Y29uc29sZS53YXJuKFwiREVQUkVDQVRFRDogTWF0cml4NCdzIC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLlwiKX0scm90YXRlWDpmdW5jdGlvbigpe2NvbnNvbGUud2FybihcIkRFUFJFQ0FURUQ6IE1hdHJpeDQncyAucm90YXRlWCgpIGhhcyBiZWVuIHJlbW92ZWQuXCIpfSxyb3RhdGVZOmZ1bmN0aW9uKCl7Y29uc29sZS53YXJuKFwiREVQUkVDQVRFRDogTWF0cml4NCdzIC5yb3RhdGVZKCkgaGFzIGJlZW4gcmVtb3ZlZC5cIil9LHJvdGF0ZVo6ZnVuY3Rpb24oKXtjb25zb2xlLndhcm4oXCJERVBSRUNBVEVEOiBNYXRyaXg0J3MgLnJvdGF0ZVooKSBoYXMgYmVlbiByZW1vdmVkLlwiKX0scm90YXRlQnlBeGlzOmZ1bmN0aW9uKCl7Y29uc29sZS53YXJuKFwiREVQUkVDQVRFRDogTWF0cml4NCdzIC5yb3RhdGVCeUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLlwiKX0sXG5zY2FsZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmVsZW1lbnRzLGM9YS54LGQ9YS55LGE9YS56O2JbMF0qPWM7Yls0XSo9ZDtiWzhdKj1hO2JbMV0qPWM7Yls1XSo9ZDtiWzldKj1hO2JbMl0qPWM7Yls2XSo9ZDtiWzEwXSo9YTtiWzNdKj1jO2JbN10qPWQ7YlsxMV0qPWE7cmV0dXJuIHRoaXN9LGdldE1heFNjYWxlT25BeGlzOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lbGVtZW50cztyZXR1cm4gTWF0aC5zcXJ0KE1hdGgubWF4KGFbMF0qYVswXSthWzFdKmFbMV0rYVsyXSphWzJdLE1hdGgubWF4KGFbNF0qYVs0XSthWzVdKmFbNV0rYVs2XSphWzZdLGFbOF0qYVs4XSthWzldKmFbOV0rYVsxMF0qYVsxMF0pKSl9LG1ha2VUcmFuc2xhdGlvbjpmdW5jdGlvbihhLGIsYyl7dGhpcy5zZXQoMSwwLDAsYSwwLDEsMCxiLDAsMCwxLGMsMCwwLDAsMSk7cmV0dXJuIHRoaXN9LG1ha2VSb3RhdGlvblg6ZnVuY3Rpb24oYSl7dmFyIGI9TWF0aC5jb3MoYSksYT1NYXRoLnNpbihhKTt0aGlzLnNldCgxLFxuMCwwLDAsMCxiLC1hLDAsMCxhLGIsMCwwLDAsMCwxKTtyZXR1cm4gdGhpc30sbWFrZVJvdGF0aW9uWTpmdW5jdGlvbihhKXt2YXIgYj1NYXRoLmNvcyhhKSxhPU1hdGguc2luKGEpO3RoaXMuc2V0KGIsMCxhLDAsMCwxLDAsMCwtYSwwLGIsMCwwLDAsMCwxKTtyZXR1cm4gdGhpc30sbWFrZVJvdGF0aW9uWjpmdW5jdGlvbihhKXt2YXIgYj1NYXRoLmNvcyhhKSxhPU1hdGguc2luKGEpO3RoaXMuc2V0KGIsLWEsMCwwLGEsYiwwLDAsMCwwLDEsMCwwLDAsMCwxKTtyZXR1cm4gdGhpc30sbWFrZVJvdGF0aW9uQXhpczpmdW5jdGlvbihhLGIpe3ZhciBjPU1hdGguY29zKGIpLGQ9TWF0aC5zaW4oYiksZT0xLWMsZj1hLngsaD1hLnksZz1hLnosaT1lKmYsaz1lKmg7dGhpcy5zZXQoaSpmK2MsaSpoLWQqZyxpKmcrZCpoLDAsaSpoK2QqZyxrKmgrYyxrKmctZCpmLDAsaSpnLWQqaCxrKmcrZCpmLGUqZypnK2MsMCwwLDAsMCwxKTtyZXR1cm4gdGhpc30sbWFrZVNjYWxlOmZ1bmN0aW9uKGEsYixjKXt0aGlzLnNldChhLFxuMCwwLDAsMCxiLDAsMCwwLDAsYywwLDAsMCwwLDEpO3JldHVybiB0aGlzfSxjb21wb3NlOmZ1bmN0aW9uKGEsYixjKXt0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKGIpO3RoaXMuc2NhbGUoYyk7dGhpcy5zZXRQb3NpdGlvbihhKTtyZXR1cm4gdGhpc30sZGVjb21wb3NlOmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjMsYj1uZXcgVEhSRUUuTWF0cml4NDtyZXR1cm4gZnVuY3Rpb24oYyxkLGUpe3ZhciBmPXRoaXMuZWxlbWVudHMsaD1hLnNldChmWzBdLGZbMV0sZlsyXSkubGVuZ3RoKCksZz1hLnNldChmWzRdLGZbNV0sZls2XSkubGVuZ3RoKCksaT1hLnNldChmWzhdLGZbOV0sZlsxMF0pLmxlbmd0aCgpO2MueD1mWzEyXTtjLnk9ZlsxM107Yy56PWZbMTRdO2IuZWxlbWVudHMuc2V0KHRoaXMuZWxlbWVudHMpO3ZhciBjPTEvaCxmPTEvZyxrPTEvaTtiLmVsZW1lbnRzWzBdKj1jO2IuZWxlbWVudHNbMV0qPWM7Yi5lbGVtZW50c1syXSo9YztiLmVsZW1lbnRzWzRdKj1cbmY7Yi5lbGVtZW50c1s1XSo9ZjtiLmVsZW1lbnRzWzZdKj1mO2IuZWxlbWVudHNbOF0qPWs7Yi5lbGVtZW50c1s5XSo9aztiLmVsZW1lbnRzWzEwXSo9aztkLnNldEZyb21Sb3RhdGlvbk1hdHJpeChiKTtlLng9aDtlLnk9ZztlLno9aTtyZXR1cm4gdGhpc319KCksbWFrZUZydXN0dW06ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBoPXRoaXMuZWxlbWVudHM7aFswXT0yKmUvKGItYSk7aFs0XT0wO2hbOF09KGIrYSkvKGItYSk7aFsxMl09MDtoWzFdPTA7aFs1XT0yKmUvKGQtYyk7aFs5XT0oZCtjKS8oZC1jKTtoWzEzXT0wO2hbMl09MDtoWzZdPTA7aFsxMF09LShmK2UpLyhmLWUpO2hbMTRdPS0yKmYqZS8oZi1lKTtoWzNdPTA7aFs3XT0wO2hbMTFdPS0xO2hbMTVdPTA7cmV0dXJuIHRoaXN9LG1ha2VQZXJzcGVjdGl2ZTpmdW5jdGlvbihhLGIsYyxkKXt2YXIgYT1jKk1hdGgudGFuKFRIUkVFLk1hdGguZGVnVG9SYWQoMC41KmEpKSxlPS1hO3JldHVybiB0aGlzLm1ha2VGcnVzdHVtKGUqXG5iLGEqYixlLGEsYyxkKX0sbWFrZU9ydGhvZ3JhcGhpYzpmdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGg9dGhpcy5lbGVtZW50cyxnPWItYSxpPWMtZCxrPWYtZTtoWzBdPTIvZztoWzRdPTA7aFs4XT0wO2hbMTJdPS0oKGIrYSkvZyk7aFsxXT0wO2hbNV09Mi9pO2hbOV09MDtoWzEzXT0tKChjK2QpL2kpO2hbMl09MDtoWzZdPTA7aFsxMF09LTIvaztoWzE0XT0tKChmK2UpL2spO2hbM109MDtoWzddPTA7aFsxMV09MDtoWzE1XT0xO3JldHVybiB0aGlzfSxmcm9tQXJyYXk6ZnVuY3Rpb24oYSl7dGhpcy5lbGVtZW50cy5zZXQoYSk7cmV0dXJuIHRoaXN9LHRvQXJyYXk6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmVsZW1lbnRzO3JldHVyblthWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10sYVs4XSxhWzldLGFbMTBdLGFbMTFdLGFbMTJdLGFbMTNdLGFbMTRdLGFbMTVdXX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmVsZW1lbnRzO3JldHVybiBuZXcgVEhSRUUuTWF0cml4NChhWzBdLFxuYVs0XSxhWzhdLGFbMTJdLGFbMV0sYVs1XSxhWzldLGFbMTNdLGFbMl0sYVs2XSxhWzEwXSxhWzE0XSxhWzNdLGFbN10sYVsxMV0sYVsxNV0pfX07VEhSRUUuUmF5PWZ1bmN0aW9uKGEsYil7dGhpcy5vcmlnaW49dm9pZCAwIT09YT9hOm5ldyBUSFJFRS5WZWN0b3IzO3RoaXMuZGlyZWN0aW9uPXZvaWQgMCE9PWI/YjpuZXcgVEhSRUUuVmVjdG9yM307XG5USFJFRS5SYXkucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5SYXksc2V0OmZ1bmN0aW9uKGEsYil7dGhpcy5vcmlnaW4uY29weShhKTt0aGlzLmRpcmVjdGlvbi5jb3B5KGIpO3JldHVybiB0aGlzfSxjb3B5OmZ1bmN0aW9uKGEpe3RoaXMub3JpZ2luLmNvcHkoYS5vcmlnaW4pO3RoaXMuZGlyZWN0aW9uLmNvcHkoYS5kaXJlY3Rpb24pO3JldHVybiB0aGlzfSxhdDpmdW5jdGlvbihhLGIpe3JldHVybihifHxuZXcgVEhSRUUuVmVjdG9yMykuY29weSh0aGlzLmRpcmVjdGlvbikubXVsdGlwbHlTY2FsYXIoYSkuYWRkKHRoaXMub3JpZ2luKX0scmVjYXN0OmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGIpe3RoaXMub3JpZ2luLmNvcHkodGhpcy5hdChiLGEpKTtyZXR1cm4gdGhpc319KCksY2xvc2VzdFBvaW50VG9Qb2ludDpmdW5jdGlvbihhLGIpe3ZhciBjPWJ8fG5ldyBUSFJFRS5WZWN0b3IzO2Muc3ViVmVjdG9ycyhhLHRoaXMub3JpZ2luKTtcbnZhciBkPWMuZG90KHRoaXMuZGlyZWN0aW9uKTtyZXR1cm4gMD5kP2MuY29weSh0aGlzLm9yaWdpbik6Yy5jb3B5KHRoaXMuZGlyZWN0aW9uKS5tdWx0aXBseVNjYWxhcihkKS5hZGQodGhpcy5vcmlnaW4pfSxkaXN0YW5jZVRvUG9pbnQ6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oYil7dmFyIGM9YS5zdWJWZWN0b3JzKGIsdGhpcy5vcmlnaW4pLmRvdCh0aGlzLmRpcmVjdGlvbik7aWYoMD5jKXJldHVybiB0aGlzLm9yaWdpbi5kaXN0YW5jZVRvKGIpO2EuY29weSh0aGlzLmRpcmVjdGlvbikubXVsdGlwbHlTY2FsYXIoYykuYWRkKHRoaXMub3JpZ2luKTtyZXR1cm4gYS5kaXN0YW5jZVRvKGIpfX0oKSxkaXN0YW5jZVNxVG9TZWdtZW50OmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWEuY2xvbmUoKS5hZGQoYikubXVsdGlwbHlTY2FsYXIoMC41KSxmPWIuY2xvbmUoKS5zdWIoYSkubm9ybWFsaXplKCksaD0wLjUqYS5kaXN0YW5jZVRvKGIpLFxuZz10aGlzLm9yaWdpbi5jbG9uZSgpLnN1YihlKSxhPS10aGlzLmRpcmVjdGlvbi5kb3QoZiksYj1nLmRvdCh0aGlzLmRpcmVjdGlvbiksaT0tZy5kb3QoZiksaz1nLmxlbmd0aFNxKCksbT1NYXRoLmFicygxLWEqYSksbCxwOzA8PW0/KGc9YSppLWIsbD1hKmItaSxwPWgqbSwwPD1nP2w+PS1wP2w8PXA/KGg9MS9tLGcqPWgsbCo9aCxhPWcqKGcrYSpsKzIqYikrbCooYSpnK2wrMippKStrKToobD1oLGc9TWF0aC5tYXgoMCwtKGEqbCtiKSksYT0tZypnK2wqKGwrMippKStrKToobD0taCxnPU1hdGgubWF4KDAsLShhKmwrYikpLGE9LWcqZytsKihsKzIqaSkrayk6bDw9LXA/KGc9TWF0aC5tYXgoMCwtKC1hKmgrYikpLGw9MDxnPy1oOk1hdGgubWluKE1hdGgubWF4KC1oLC1pKSxoKSxhPS1nKmcrbCoobCsyKmkpK2spOmw8PXA/KGc9MCxsPU1hdGgubWluKE1hdGgubWF4KC1oLC1pKSxoKSxhPWwqKGwrMippKStrKTooZz1NYXRoLm1heCgwLC0oYSpoK2IpKSxsPTA8Zz9oOk1hdGgubWluKE1hdGgubWF4KC1oLFxuLWkpLGgpLGE9LWcqZytsKihsKzIqaSkraykpOihsPTA8YT8taDpoLGc9TWF0aC5tYXgoMCwtKGEqbCtiKSksYT0tZypnK2wqKGwrMippKStrKTtjJiZjLmNvcHkodGhpcy5kaXJlY3Rpb24uY2xvbmUoKS5tdWx0aXBseVNjYWxhcihnKS5hZGQodGhpcy5vcmlnaW4pKTtkJiZkLmNvcHkoZi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGwpLmFkZChlKSk7cmV0dXJuIGF9LGlzSW50ZXJzZWN0aW9uU3BoZXJlOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludChhLmNlbnRlcik8PWEucmFkaXVzfSxpc0ludGVyc2VjdGlvblBsYW5lOmZ1bmN0aW9uKGEpe3ZhciBiPWEuZGlzdGFuY2VUb1BvaW50KHRoaXMub3JpZ2luKTtyZXR1cm4gMD09PWJ8fDA+YS5ub3JtYWwuZG90KHRoaXMuZGlyZWN0aW9uKSpiPyEwOiExfSxkaXN0YW5jZVRvUGxhbmU6ZnVuY3Rpb24oYSl7dmFyIGI9YS5ub3JtYWwuZG90KHRoaXMuZGlyZWN0aW9uKTtpZigwPT1iKXJldHVybiAwPT1hLmRpc3RhbmNlVG9Qb2ludCh0aGlzLm9yaWdpbik/XG4wOm51bGw7YT0tKHRoaXMub3JpZ2luLmRvdChhLm5vcm1hbCkrYS5jb25zdGFudCkvYjtyZXR1cm4gMDw9YT9hOm51bGx9LGludGVyc2VjdFBsYW5lOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5kaXN0YW5jZVRvUGxhbmUoYSk7cmV0dXJuIG51bGw9PT1jP251bGw6dGhpcy5hdChjLGIpfSxpc0ludGVyc2VjdGlvbkJveDpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gbnVsbCE9PXRoaXMuaW50ZXJzZWN0Qm94KGIsYSl9fSgpLGludGVyc2VjdEJveDpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmLGg7ZD0xL3RoaXMuZGlyZWN0aW9uLng7Zj0xL3RoaXMuZGlyZWN0aW9uLnk7aD0xL3RoaXMuZGlyZWN0aW9uLno7dmFyIGc9dGhpcy5vcmlnaW47MDw9ZD8oYz0oYS5taW4ueC1nLngpKmQsZCo9YS5tYXgueC1nLngpOihjPShhLm1heC54LWcueCkqZCxkKj1hLm1pbi54LWcueCk7MDw9Zj8oZT0oYS5taW4ueS1nLnkpKmYsZio9XG5hLm1heC55LWcueSk6KGU9KGEubWF4LnktZy55KSpmLGYqPWEubWluLnktZy55KTtpZihjPmZ8fGU+ZClyZXR1cm4gbnVsbDtpZihlPmN8fGMhPT1jKWM9ZTtpZihmPGR8fGQhPT1kKWQ9ZjswPD1oPyhlPShhLm1pbi56LWcueikqaCxoKj1hLm1heC56LWcueik6KGU9KGEubWF4LnotZy56KSpoLGgqPWEubWluLnotZy56KTtpZihjPmh8fGU+ZClyZXR1cm4gbnVsbDtpZihlPmN8fGMhPT1jKWM9ZTtpZihoPGR8fGQhPT1kKWQ9aDtyZXR1cm4gMD5kP251bGw6dGhpcy5hdCgwPD1jP2M6ZCxiKX0saW50ZXJzZWN0VHJpYW5nbGU6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMyxiPW5ldyBUSFJFRS5WZWN0b3IzLGM9bmV3IFRIUkVFLlZlY3RvcjMsZD1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oZSxmLGgsZyxpKXtiLnN1YlZlY3RvcnMoZixlKTtjLnN1YlZlY3RvcnMoaCxlKTtkLmNyb3NzVmVjdG9ycyhiLGMpO2Y9dGhpcy5kaXJlY3Rpb24uZG90KGQpO2lmKDA8XG5mKXtpZihnKXJldHVybiBudWxsO2c9MX1lbHNlIGlmKDA+ZilnPS0xLGY9LWY7ZWxzZSByZXR1cm4gbnVsbDthLnN1YlZlY3RvcnModGhpcy5vcmlnaW4sZSk7ZT1nKnRoaXMuZGlyZWN0aW9uLmRvdChjLmNyb3NzVmVjdG9ycyhhLGMpKTtpZigwPmUpcmV0dXJuIG51bGw7aD1nKnRoaXMuZGlyZWN0aW9uLmRvdChiLmNyb3NzKGEpKTtpZigwPmh8fGUraD5mKXJldHVybiBudWxsO2U9LWcqYS5kb3QoZCk7cmV0dXJuIDA+ZT9udWxsOnRoaXMuYXQoZS9mLGkpfX0oKSxhcHBseU1hdHJpeDQ6ZnVuY3Rpb24oYSl7dGhpcy5kaXJlY3Rpb24uYWRkKHRoaXMub3JpZ2luKS5hcHBseU1hdHJpeDQoYSk7dGhpcy5vcmlnaW4uYXBwbHlNYXRyaXg0KGEpO3RoaXMuZGlyZWN0aW9uLnN1Yih0aGlzLm9yaWdpbik7dGhpcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7cmV0dXJuIHRoaXN9LGVxdWFsczpmdW5jdGlvbihhKXtyZXR1cm4gYS5vcmlnaW4uZXF1YWxzKHRoaXMub3JpZ2luKSYmYS5kaXJlY3Rpb24uZXF1YWxzKHRoaXMuZGlyZWN0aW9uKX0sXG5jbG9uZTpmdW5jdGlvbigpe3JldHVybihuZXcgVEhSRUUuUmF5KS5jb3B5KHRoaXMpfX07VEhSRUUuU3BoZXJlPWZ1bmN0aW9uKGEsYil7dGhpcy5jZW50ZXI9dm9pZCAwIT09YT9hOm5ldyBUSFJFRS5WZWN0b3IzO3RoaXMucmFkaXVzPXZvaWQgMCE9PWI/YjowfTtcblRIUkVFLlNwaGVyZS5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLlNwaGVyZSxzZXQ6ZnVuY3Rpb24oYSxiKXt0aGlzLmNlbnRlci5jb3B5KGEpO3RoaXMucmFkaXVzPWI7cmV0dXJuIHRoaXN9LHNldEZyb21Qb2ludHM6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuQm94MztyZXR1cm4gZnVuY3Rpb24oYixjKXt2YXIgZD10aGlzLmNlbnRlcjt2b2lkIDAhPT1jP2QuY29weShjKTphLnNldEZyb21Qb2ludHMoYikuY2VudGVyKGQpO2Zvcih2YXIgZT0wLGY9MCxoPWIubGVuZ3RoO2Y8aDtmKyspZT1NYXRoLm1heChlLGQuZGlzdGFuY2VUb1NxdWFyZWQoYltmXSkpO3RoaXMucmFkaXVzPU1hdGguc3FydChlKTtyZXR1cm4gdGhpc319KCksY29weTpmdW5jdGlvbihhKXt0aGlzLmNlbnRlci5jb3B5KGEuY2VudGVyKTt0aGlzLnJhZGl1cz1hLnJhZGl1cztyZXR1cm4gdGhpc30sZW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gMD49dGhpcy5yYWRpdXN9LGNvbnRhaW5zUG9pbnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZGlzdGFuY2VUb1NxdWFyZWQodGhpcy5jZW50ZXIpPD1cbnRoaXMucmFkaXVzKnRoaXMucmFkaXVzfSxkaXN0YW5jZVRvUG9pbnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuZGlzdGFuY2VUbyh0aGlzLmNlbnRlciktdGhpcy5yYWRpdXN9LGludGVyc2VjdHNTcGhlcmU6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5yYWRpdXMrYS5yYWRpdXM7cmV0dXJuIGEuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKHRoaXMuY2VudGVyKTw9YipifSxjbGFtcFBvaW50OmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoYSksZD1ifHxuZXcgVEhSRUUuVmVjdG9yMztkLmNvcHkoYSk7Yz50aGlzLnJhZGl1cyp0aGlzLnJhZGl1cyYmKGQuc3ViKHRoaXMuY2VudGVyKS5ub3JtYWxpemUoKSxkLm11bHRpcGx5U2NhbGFyKHRoaXMucmFkaXVzKS5hZGQodGhpcy5jZW50ZXIpKTtyZXR1cm4gZH0sZ2V0Qm91bmRpbmdCb3g6ZnVuY3Rpb24oYSl7YT1hfHxuZXcgVEhSRUUuQm94MzthLnNldCh0aGlzLmNlbnRlcix0aGlzLmNlbnRlcik7YS5leHBhbmRCeVNjYWxhcih0aGlzLnJhZGl1cyk7XG5yZXR1cm4gYX0sYXBwbHlNYXRyaXg0OmZ1bmN0aW9uKGEpe3RoaXMuY2VudGVyLmFwcGx5TWF0cml4NChhKTt0aGlzLnJhZGl1cyo9YS5nZXRNYXhTY2FsZU9uQXhpcygpO3JldHVybiB0aGlzfSx0cmFuc2xhdGU6ZnVuY3Rpb24oYSl7dGhpcy5jZW50ZXIuYWRkKGEpO3JldHVybiB0aGlzfSxlcXVhbHM6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuY2VudGVyLmVxdWFscyh0aGlzLmNlbnRlcikmJmEucmFkaXVzPT09dGhpcy5yYWRpdXN9LGNsb25lOmZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBUSFJFRS5TcGhlcmUpLmNvcHkodGhpcyl9fTtUSFJFRS5GcnVzdHVtPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt0aGlzLnBsYW5lcz1bdm9pZCAwIT09YT9hOm5ldyBUSFJFRS5QbGFuZSx2b2lkIDAhPT1iP2I6bmV3IFRIUkVFLlBsYW5lLHZvaWQgMCE9PWM/YzpuZXcgVEhSRUUuUGxhbmUsdm9pZCAwIT09ZD9kOm5ldyBUSFJFRS5QbGFuZSx2b2lkIDAhPT1lP2U6bmV3IFRIUkVFLlBsYW5lLHZvaWQgMCE9PWY/ZjpuZXcgVEhSRUUuUGxhbmVdfTtcblRIUkVFLkZydXN0dW0ucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5GcnVzdHVtLHNldDpmdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGg9dGhpcy5wbGFuZXM7aFswXS5jb3B5KGEpO2hbMV0uY29weShiKTtoWzJdLmNvcHkoYyk7aFszXS5jb3B5KGQpO2hbNF0uY29weShlKTtoWzVdLmNvcHkoZik7cmV0dXJuIHRoaXN9LGNvcHk6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXMucGxhbmVzLGM9MDs2PmM7YysrKWJbY10uY29weShhLnBsYW5lc1tjXSk7cmV0dXJuIHRoaXN9LHNldEZyb21NYXRyaXg6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5wbGFuZXMsYz1hLmVsZW1lbnRzLGE9Y1swXSxkPWNbMV0sZT1jWzJdLGY9Y1szXSxoPWNbNF0sZz1jWzVdLGk9Y1s2XSxrPWNbN10sbT1jWzhdLGw9Y1s5XSxwPWNbMTBdLHM9Y1sxMV0sdD1jWzEyXSxuPWNbMTNdLHI9Y1sxNF0sYz1jWzE1XTtiWzBdLnNldENvbXBvbmVudHMoZi1hLGstaCxzLW0sYy10KS5ub3JtYWxpemUoKTtiWzFdLnNldENvbXBvbmVudHMoZitcbmEsaytoLHMrbSxjK3QpLm5vcm1hbGl6ZSgpO2JbMl0uc2V0Q29tcG9uZW50cyhmK2QsaytnLHMrbCxjK24pLm5vcm1hbGl6ZSgpO2JbM10uc2V0Q29tcG9uZW50cyhmLWQsay1nLHMtbCxjLW4pLm5vcm1hbGl6ZSgpO2JbNF0uc2V0Q29tcG9uZW50cyhmLWUsay1pLHMtcCxjLXIpLm5vcm1hbGl6ZSgpO2JbNV0uc2V0Q29tcG9uZW50cyhmK2UsaytpLHMrcCxjK3IpLm5vcm1hbGl6ZSgpO3JldHVybiB0aGlzfSxpbnRlcnNlY3RzT2JqZWN0OmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlNwaGVyZTtyZXR1cm4gZnVuY3Rpb24oYil7dmFyIGM9Yi5nZW9tZXRyeTtudWxsPT09Yy5ib3VuZGluZ1NwaGVyZSYmYy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTthLmNvcHkoYy5ib3VuZGluZ1NwaGVyZSk7YS5hcHBseU1hdHJpeDQoYi5tYXRyaXhXb3JsZCk7cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZShhKX19KCksaW50ZXJzZWN0c1NwaGVyZTpmdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5wbGFuZXMsXG5jPWEuY2VudGVyLGE9LWEucmFkaXVzLGQ9MDs2PmQ7ZCsrKWlmKGJbZF0uZGlzdGFuY2VUb1BvaW50KGMpPGEpcmV0dXJuITE7cmV0dXJuITB9LGludGVyc2VjdHNCb3g6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMyxiPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihjKXtmb3IodmFyIGQ9dGhpcy5wbGFuZXMsZT0wOzY+ZTtlKyspe3ZhciBmPWRbZV07YS54PTA8Zi5ub3JtYWwueD9jLm1pbi54OmMubWF4Lng7Yi54PTA8Zi5ub3JtYWwueD9jLm1heC54OmMubWluLng7YS55PTA8Zi5ub3JtYWwueT9jLm1pbi55OmMubWF4Lnk7Yi55PTA8Zi5ub3JtYWwueT9jLm1heC55OmMubWluLnk7YS56PTA8Zi5ub3JtYWwuej9jLm1pbi56OmMubWF4Lno7Yi56PTA8Zi5ub3JtYWwuej9jLm1heC56OmMubWluLno7dmFyIGg9Zi5kaXN0YW5jZVRvUG9pbnQoYSksZj1mLmRpc3RhbmNlVG9Qb2ludChiKTtpZigwPmgmJjA+ZilyZXR1cm4hMX1yZXR1cm4hMH19KCksY29udGFpbnNQb2ludDpmdW5jdGlvbihhKXtmb3IodmFyIGI9XG50aGlzLnBsYW5lcyxjPTA7Nj5jO2MrKylpZigwPmJbY10uZGlzdGFuY2VUb1BvaW50KGEpKXJldHVybiExO3JldHVybiEwfSxjbG9uZTpmdW5jdGlvbigpe3JldHVybihuZXcgVEhSRUUuRnJ1c3R1bSkuY29weSh0aGlzKX19O1RIUkVFLlBsYW5lPWZ1bmN0aW9uKGEsYil7dGhpcy5ub3JtYWw9dm9pZCAwIT09YT9hOm5ldyBUSFJFRS5WZWN0b3IzKDEsMCwwKTt0aGlzLmNvbnN0YW50PXZvaWQgMCE9PWI/YjowfTtcblRIUkVFLlBsYW5lLnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuUGxhbmUsc2V0OmZ1bmN0aW9uKGEsYil7dGhpcy5ub3JtYWwuY29weShhKTt0aGlzLmNvbnN0YW50PWI7cmV0dXJuIHRoaXN9LHNldENvbXBvbmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dGhpcy5ub3JtYWwuc2V0KGEsYixjKTt0aGlzLmNvbnN0YW50PWQ7cmV0dXJuIHRoaXN9LHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50OmZ1bmN0aW9uKGEsYil7dGhpcy5ub3JtYWwuY29weShhKTt0aGlzLmNvbnN0YW50PS1iLmRvdCh0aGlzLm5vcm1hbCk7cmV0dXJuIHRoaXN9LHNldEZyb21Db3BsYW5hclBvaW50czpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzLGI9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGMsZCxlKXtkPWEuc3ViVmVjdG9ycyhlLGQpLmNyb3NzKGIuc3ViVmVjdG9ycyhjLGQpKS5ub3JtYWxpemUoKTt0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KGQsXG5jKTtyZXR1cm4gdGhpc319KCksY29weTpmdW5jdGlvbihhKXt0aGlzLm5vcm1hbC5jb3B5KGEubm9ybWFsKTt0aGlzLmNvbnN0YW50PWEuY29uc3RhbnQ7cmV0dXJuIHRoaXN9LG5vcm1hbGl6ZTpmdW5jdGlvbigpe3ZhciBhPTEvdGhpcy5ub3JtYWwubGVuZ3RoKCk7dGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIoYSk7dGhpcy5jb25zdGFudCo9YTtyZXR1cm4gdGhpc30sbmVnYXRlOmZ1bmN0aW9uKCl7dGhpcy5jb25zdGFudCo9LTE7dGhpcy5ub3JtYWwubmVnYXRlKCk7cmV0dXJuIHRoaXN9LGRpc3RhbmNlVG9Qb2ludDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5ub3JtYWwuZG90KGEpK3RoaXMuY29uc3RhbnR9LGRpc3RhbmNlVG9TcGhlcmU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KGEuY2VudGVyKS1hLnJhZGl1c30scHJvamVjdFBvaW50OmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMub3J0aG9Qb2ludChhLGIpLnN1YihhKS5uZWdhdGUoKX0sb3J0aG9Qb2ludDpmdW5jdGlvbihhLFxuYil7dmFyIGM9dGhpcy5kaXN0YW5jZVRvUG9pbnQoYSk7cmV0dXJuKGJ8fG5ldyBUSFJFRS5WZWN0b3IzKS5jb3B5KHRoaXMubm9ybWFsKS5tdWx0aXBseVNjYWxhcihjKX0saXNJbnRlcnNlY3Rpb25MaW5lOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZGlzdGFuY2VUb1BvaW50KGEuc3RhcnQpLGE9dGhpcy5kaXN0YW5jZVRvUG9pbnQoYS5lbmQpO3JldHVybiAwPmImJjA8YXx8MD5hJiYwPGJ9LGludGVyc2VjdExpbmU6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oYixjKXt2YXIgZD1jfHxuZXcgVEhSRUUuVmVjdG9yMyxlPWIuZGVsdGEoYSksZj10aGlzLm5vcm1hbC5kb3QoZSk7aWYoMD09Zil7aWYoMD09dGhpcy5kaXN0YW5jZVRvUG9pbnQoYi5zdGFydCkpcmV0dXJuIGQuY29weShiLnN0YXJ0KX1lbHNlIHJldHVybiBmPS0oYi5zdGFydC5kb3QodGhpcy5ub3JtYWwpK3RoaXMuY29uc3RhbnQpL2YsMD5mfHwxPGY/dm9pZCAwOmQuY29weShlKS5tdWx0aXBseVNjYWxhcihmKS5hZGQoYi5zdGFydCl9fSgpLFxuY29wbGFuYXJQb2ludDpmdW5jdGlvbihhKXtyZXR1cm4oYXx8bmV3IFRIUkVFLlZlY3RvcjMpLmNvcHkodGhpcy5ub3JtYWwpLm11bHRpcGx5U2NhbGFyKC10aGlzLmNvbnN0YW50KX0sYXBwbHlNYXRyaXg0OmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjMsYj1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oYyxkKXt2YXIgZD1kfHwobmV3IFRIUkVFLk1hdHJpeDMpLmdldE5vcm1hbE1hdHJpeChjKSxlPWEuY29weSh0aGlzLm5vcm1hbCkuYXBwbHlNYXRyaXgzKGQpLGY9dGhpcy5jb3BsYW5hclBvaW50KGIpO2YuYXBwbHlNYXRyaXg0KGMpO3RoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoZSxmKTtyZXR1cm4gdGhpc319KCksdHJhbnNsYXRlOmZ1bmN0aW9uKGEpe3RoaXMuY29uc3RhbnQtPWEuZG90KHRoaXMubm9ybWFsKTtyZXR1cm4gdGhpc30sZXF1YWxzOmZ1bmN0aW9uKGEpe3JldHVybiBhLm5vcm1hbC5lcXVhbHModGhpcy5ub3JtYWwpJiZcbmEuY29uc3RhbnQ9PXRoaXMuY29uc3RhbnR9LGNsb25lOmZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBUSFJFRS5QbGFuZSkuY29weSh0aGlzKX19O1RIUkVFLk1hdGg9e1BJMjoyKk1hdGguUEksZ2VuZXJhdGVVVUlEOmZ1bmN0aW9uKCl7dmFyIGE9XCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLnNwbGl0KFwiXCIpLGI9QXJyYXkoMzYpLGM9MCxkO3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgZT0wOzM2PmU7ZSsrKTg9PWV8fDEzPT1lfHwxOD09ZXx8MjM9PWU/YltlXT1cIi1cIjoxND09ZT9iW2VdPVwiNFwiOigyPj1jJiYoYz0zMzU1NDQzMisxNjc3NzIxNipNYXRoLnJhbmRvbSgpfDApLGQ9YyYxNSxjPj49NCxiW2VdPWFbMTk9PWU/ZCYzfDg6ZF0pO3JldHVybiBiLmpvaW4oXCJcIil9fSgpLGNsYW1wOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYTxiP2I6YT5jP2M6YX0sY2xhbXBCb3R0b206ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYTxiP2I6YX0sbWFwTGluZWFyOmZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIGQrKGEtYikqKGUtZCkvKGMtYil9LHNtb290aHN0ZXA6ZnVuY3Rpb24oYSxcbmIsYyl7aWYoYTw9YilyZXR1cm4gMDtpZihhPj1jKXJldHVybiAxO2E9KGEtYikvKGMtYik7cmV0dXJuIGEqYSooMy0yKmEpfSxzbW9vdGhlcnN0ZXA6ZnVuY3Rpb24oYSxiLGMpe2lmKGE8PWIpcmV0dXJuIDA7aWYoYT49YylyZXR1cm4gMTthPShhLWIpLyhjLWIpO3JldHVybiBhKmEqYSooYSooNiphLTE1KSsxMCl9LHJhbmRvbTE2OmZ1bmN0aW9uKCl7cmV0dXJuKDY1MjgwKk1hdGgucmFuZG9tKCkrMjU1Kk1hdGgucmFuZG9tKCkpLzY1NTM1fSxyYW5kSW50OmZ1bmN0aW9uKGEsYil7cmV0dXJuIGErTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKihiLWErMSkpfSxyYW5kRmxvYXQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYStNYXRoLnJhbmRvbSgpKihiLWEpfSxyYW5kRmxvYXRTcHJlYWQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEqKDAuNS1NYXRoLnJhbmRvbSgpKX0sc2lnbjpmdW5jdGlvbihhKXtyZXR1cm4gMD5hPy0xOjA8YT8xOjB9LGRlZ1RvUmFkOmZ1bmN0aW9uKCl7dmFyIGE9TWF0aC5QSS9cbjE4MDtyZXR1cm4gZnVuY3Rpb24oYil7cmV0dXJuIGIqYX19KCkscmFkVG9EZWc6ZnVuY3Rpb24oKXt2YXIgYT0xODAvTWF0aC5QSTtyZXR1cm4gZnVuY3Rpb24oYil7cmV0dXJuIGIqYX19KCl9O1RIUkVFLlNwbGluZT1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEsYixjLGQsZSxmLGgpe2E9MC41KihjLWEpO2Q9MC41KihkLWIpO3JldHVybigyKihiLWMpK2ErZCkqaCsoLTMqKGItYyktMiphLWQpKmYrYSplK2J9dGhpcy5wb2ludHM9YTt2YXIgYz1bXSxkPXt4OjAseTowLHo6MH0sZSxmLGgsZyxpLGssbSxsLHA7dGhpcy5pbml0RnJvbUFycmF5PWZ1bmN0aW9uKGEpe3RoaXMucG9pbnRzPVtdO2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXRoaXMucG9pbnRzW2JdPXt4OmFbYl1bMF0seTphW2JdWzFdLHo6YVtiXVsyXX19O3RoaXMuZ2V0UG9pbnQ9ZnVuY3Rpb24oYSl7ZT0odGhpcy5wb2ludHMubGVuZ3RoLTEpKmE7Zj1NYXRoLmZsb29yKGUpO2g9ZS1mO2NbMF09MD09PWY/ZjpmLTE7Y1sxXT1mO2NbMl09Zj50aGlzLnBvaW50cy5sZW5ndGgtMj90aGlzLnBvaW50cy5sZW5ndGgtMTpmKzE7Y1szXT1mPnRoaXMucG9pbnRzLmxlbmd0aC0zP3RoaXMucG9pbnRzLmxlbmd0aC0xOlxuZisyO2s9dGhpcy5wb2ludHNbY1swXV07bT10aGlzLnBvaW50c1tjWzFdXTtsPXRoaXMucG9pbnRzW2NbMl1dO3A9dGhpcy5wb2ludHNbY1szXV07Zz1oKmg7aT1oKmc7ZC54PWIoay54LG0ueCxsLngscC54LGgsZyxpKTtkLnk9YihrLnksbS55LGwueSxwLnksaCxnLGkpO2Quej1iKGsueixtLnosbC56LHAueixoLGcsaSk7cmV0dXJuIGR9O3RoaXMuZ2V0Q29udHJvbFBvaW50c0FycmF5PWZ1bmN0aW9uKCl7dmFyIGEsYixjPXRoaXMucG9pbnRzLmxlbmd0aCxkPVtdO2ZvcihhPTA7YTxjO2ErKyliPXRoaXMucG9pbnRzW2FdLGRbYV09W2IueCxiLnksYi56XTtyZXR1cm4gZH07dGhpcy5nZXRMZW5ndGg9ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGU9Yj1iPTAsZj1uZXcgVEhSRUUuVmVjdG9yMyxoPW5ldyBUSFJFRS5WZWN0b3IzLGc9W10saT0wO2dbMF09MDthfHwoYT0xMDApO2M9dGhpcy5wb2ludHMubGVuZ3RoKmE7Zi5jb3B5KHRoaXMucG9pbnRzWzBdKTtmb3IoYT0xO2E8YzthKyspYj1cbmEvYyxkPXRoaXMuZ2V0UG9pbnQoYiksaC5jb3B5KGQpLGkrPWguZGlzdGFuY2VUbyhmKSxmLmNvcHkoZCksYio9dGhpcy5wb2ludHMubGVuZ3RoLTEsYj1NYXRoLmZsb29yKGIpLGIhPWUmJihnW2JdPWksZT1iKTtnW2cubGVuZ3RoXT1pO3JldHVybntjaHVua3M6Zyx0b3RhbDppfX07dGhpcy5yZXBhcmFtZXRyaXplQnlBcmNMZW5ndGg9ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZixoLGc9W10saT1uZXcgVEhSRUUuVmVjdG9yMyxrPXRoaXMuZ2V0TGVuZ3RoKCk7Zy5wdXNoKGkuY29weSh0aGlzLnBvaW50c1swXSkuY2xvbmUoKSk7Zm9yKGI9MTtiPHRoaXMucG9pbnRzLmxlbmd0aDtiKyspe2M9ay5jaHVua3NbYl0tay5jaHVua3NbYi0xXTtoPU1hdGguY2VpbChhKmMvay50b3RhbCk7ZT0oYi0xKS8odGhpcy5wb2ludHMubGVuZ3RoLTEpO2Y9Yi8odGhpcy5wb2ludHMubGVuZ3RoLTEpO2ZvcihjPTE7YzxoLTE7YysrKWQ9ZStjKigxL2gpKihmLWUpLGQ9dGhpcy5nZXRQb2ludChkKSxcbmcucHVzaChpLmNvcHkoZCkuY2xvbmUoKSk7Zy5wdXNoKGkuY29weSh0aGlzLnBvaW50c1tiXSkuY2xvbmUoKSl9dGhpcy5wb2ludHM9Z319O1RIUkVFLlRyaWFuZ2xlPWZ1bmN0aW9uKGEsYixjKXt0aGlzLmE9dm9pZCAwIT09YT9hOm5ldyBUSFJFRS5WZWN0b3IzO3RoaXMuYj12b2lkIDAhPT1iP2I6bmV3IFRIUkVFLlZlY3RvcjM7dGhpcy5jPXZvaWQgMCE9PWM/YzpuZXcgVEhSRUUuVmVjdG9yM307VEhSRUUuVHJpYW5nbGUubm9ybWFsPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGIsYyxkLGUpe2U9ZXx8bmV3IFRIUkVFLlZlY3RvcjM7ZS5zdWJWZWN0b3JzKGQsYyk7YS5zdWJWZWN0b3JzKGIsYyk7ZS5jcm9zcyhhKTtiPWUubGVuZ3RoU3EoKTtyZXR1cm4gMDxiP2UubXVsdGlwbHlTY2FsYXIoMS9NYXRoLnNxcnQoYikpOmUuc2V0KDAsMCwwKX19KCk7XG5USFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQ9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMyxiPW5ldyBUSFJFRS5WZWN0b3IzLGM9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGQsZSxmLGgsZyl7YS5zdWJWZWN0b3JzKGgsZSk7Yi5zdWJWZWN0b3JzKGYsZSk7Yy5zdWJWZWN0b3JzKGQsZSk7dmFyIGQ9YS5kb3QoYSksZT1hLmRvdChiKSxmPWEuZG90KGMpLGk9Yi5kb3QoYiksaD1iLmRvdChjKSxrPWQqaS1lKmUsZz1nfHxuZXcgVEhSRUUuVmVjdG9yMztpZigwPT1rKXJldHVybiBnLnNldCgtMiwtMSwtMSk7az0xL2s7aT0oaSpmLWUqaCkqaztkPShkKmgtZSpmKSprO3JldHVybiBnLnNldCgxLWktZCxkLGkpfX0oKTtcblRIUkVFLlRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQ9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oYixjLGQsZSl7Yj1USFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoYixjLGQsZSxhKTtyZXR1cm4gMDw9Yi54JiYwPD1iLnkmJjE+PWIueCtiLnl9fSgpO1xuVEhSRUUuVHJpYW5nbGUucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5UcmlhbmdsZSxzZXQ6ZnVuY3Rpb24oYSxiLGMpe3RoaXMuYS5jb3B5KGEpO3RoaXMuYi5jb3B5KGIpO3RoaXMuYy5jb3B5KGMpO3JldHVybiB0aGlzfSxzZXRGcm9tUG9pbnRzQW5kSW5kaWNlczpmdW5jdGlvbihhLGIsYyxkKXt0aGlzLmEuY29weShhW2JdKTt0aGlzLmIuY29weShhW2NdKTt0aGlzLmMuY29weShhW2RdKTtyZXR1cm4gdGhpc30sY29weTpmdW5jdGlvbihhKXt0aGlzLmEuY29weShhLmEpO3RoaXMuYi5jb3B5KGEuYik7dGhpcy5jLmNvcHkoYS5jKTtyZXR1cm4gdGhpc30sYXJlYTpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzLGI9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKCl7YS5zdWJWZWN0b3JzKHRoaXMuYyx0aGlzLmIpO2Iuc3ViVmVjdG9ycyh0aGlzLmEsdGhpcy5iKTtyZXR1cm4gMC41KmEuY3Jvc3MoYikubGVuZ3RoKCl9fSgpLG1pZHBvaW50OmZ1bmN0aW9uKGEpe3JldHVybihhfHxcbm5ldyBUSFJFRS5WZWN0b3IzKS5hZGRWZWN0b3JzKHRoaXMuYSx0aGlzLmIpLmFkZCh0aGlzLmMpLm11bHRpcGx5U2NhbGFyKDEvMyl9LG5vcm1hbDpmdW5jdGlvbihhKXtyZXR1cm4gVEhSRUUuVHJpYW5nbGUubm9ybWFsKHRoaXMuYSx0aGlzLmIsdGhpcy5jLGEpfSxwbGFuZTpmdW5jdGlvbihhKXtyZXR1cm4oYXx8bmV3IFRIUkVFLlBsYW5lKS5zZXRGcm9tQ29wbGFuYXJQb2ludHModGhpcy5hLHRoaXMuYix0aGlzLmMpfSxiYXJ5Y29vcmRGcm9tUG9pbnQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gVEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KGEsdGhpcy5hLHRoaXMuYix0aGlzLmMsYil9LGNvbnRhaW5zUG9pbnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIFRIUkVFLlRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQoYSx0aGlzLmEsdGhpcy5iLHRoaXMuYyl9LGVxdWFsczpmdW5jdGlvbihhKXtyZXR1cm4gYS5hLmVxdWFscyh0aGlzLmEpJiZhLmIuZXF1YWxzKHRoaXMuYikmJmEuYy5lcXVhbHModGhpcy5jKX0sXG5jbG9uZTpmdW5jdGlvbigpe3JldHVybihuZXcgVEhSRUUuVHJpYW5nbGUpLmNvcHkodGhpcyl9fTtUSFJFRS5WZXJ0ZXg9ZnVuY3Rpb24oYSl7Y29uc29sZS53YXJuKFwiVEhSRUUuVmVydGV4IGhhcyBiZWVuIERFUFJFQ0FURUQuIFVzZSBUSFJFRS5WZWN0b3IzIGluc3RlYWQuXCIpO3JldHVybiBhfTtUSFJFRS5VVj1mdW5jdGlvbihhLGIpe2NvbnNvbGUud2FybihcIlRIUkVFLlVWIGhhcyBiZWVuIERFUFJFQ0FURUQuIFVzZSBUSFJFRS5WZWN0b3IyIGluc3RlYWQuXCIpO3JldHVybiBuZXcgVEhSRUUuVmVjdG9yMihhLGIpfTtUSFJFRS5DbG9jaz1mdW5jdGlvbihhKXt0aGlzLmF1dG9TdGFydD12b2lkIDAhPT1hP2E6ITA7dGhpcy5lbGFwc2VkVGltZT10aGlzLm9sZFRpbWU9dGhpcy5zdGFydFRpbWU9MDt0aGlzLnJ1bm5pbmc9ITF9O1xuVEhSRUUuQ2xvY2sucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5DbG9jayxzdGFydDpmdW5jdGlvbigpe3RoaXMub2xkVGltZT10aGlzLnN0YXJ0VGltZT12b2lkIDAhPT1zZWxmLnBlcmZvcm1hbmNlJiZ2b2lkIDAhPT1zZWxmLnBlcmZvcm1hbmNlLm5vdz9zZWxmLnBlcmZvcm1hbmNlLm5vdygpOkRhdGUubm93KCk7dGhpcy5ydW5uaW5nPSEwfSxzdG9wOmZ1bmN0aW9uKCl7dGhpcy5nZXRFbGFwc2VkVGltZSgpO3RoaXMucnVubmluZz0hMX0sZ2V0RWxhcHNlZFRpbWU6ZnVuY3Rpb24oKXt0aGlzLmdldERlbHRhKCk7cmV0dXJuIHRoaXMuZWxhcHNlZFRpbWV9LGdldERlbHRhOmZ1bmN0aW9uKCl7dmFyIGE9MDt0aGlzLmF1dG9TdGFydCYmIXRoaXMucnVubmluZyYmdGhpcy5zdGFydCgpO2lmKHRoaXMucnVubmluZyl7dmFyIGI9dm9pZCAwIT09c2VsZi5wZXJmb3JtYW5jZSYmdm9pZCAwIT09c2VsZi5wZXJmb3JtYW5jZS5ub3c/c2VsZi5wZXJmb3JtYW5jZS5ub3coKTpEYXRlLm5vdygpLFxuYT0wLjAwMSooYi10aGlzLm9sZFRpbWUpO3RoaXMub2xkVGltZT1iO3RoaXMuZWxhcHNlZFRpbWUrPWF9cmV0dXJuIGF9fTtUSFJFRS5FdmVudERpc3BhdGNoZXI9ZnVuY3Rpb24oKXt9O1xuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuRXZlbnREaXNwYXRjaGVyLGFwcGx5OmZ1bmN0aW9uKGEpe2EuYWRkRXZlbnRMaXN0ZW5lcj1USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7YS5oYXNFdmVudExpc3RlbmVyPVRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuaGFzRXZlbnRMaXN0ZW5lcjthLnJlbW92ZUV2ZW50TGlzdGVuZXI9VEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO2EuZGlzcGF0Y2hFdmVudD1USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnR9LGFkZEV2ZW50TGlzdGVuZXI6ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT10aGlzLl9saXN0ZW5lcnMmJih0aGlzLl9saXN0ZW5lcnM9e30pO3ZhciBjPXRoaXMuX2xpc3RlbmVyczt2b2lkIDA9PT1jW2FdJiYoY1thXT1bXSk7LTE9PT1jW2FdLmluZGV4T2YoYikmJlxuY1thXS5wdXNoKGIpfSxoYXNFdmVudExpc3RlbmVyOmZ1bmN0aW9uKGEsYil7aWYodm9pZCAwPT09dGhpcy5fbGlzdGVuZXJzKXJldHVybiExO3ZhciBjPXRoaXMuX2xpc3RlbmVycztyZXR1cm4gdm9pZCAwIT09Y1thXSYmLTEhPT1jW2FdLmluZGV4T2YoYik/ITA6ITF9LHJlbW92ZUV2ZW50TGlzdGVuZXI6ZnVuY3Rpb24oYSxiKXtpZih2b2lkIDAhPT10aGlzLl9saXN0ZW5lcnMpe3ZhciBjPXRoaXMuX2xpc3RlbmVycyxkPWNbYV0uaW5kZXhPZihiKTstMSE9PWQmJmNbYV0uc3BsaWNlKGQsMSl9fSxkaXNwYXRjaEV2ZW50OmZ1bmN0aW9uKCl7dmFyIGE9W107cmV0dXJuIGZ1bmN0aW9uKGIpe2lmKHZvaWQgMCE9PXRoaXMuX2xpc3RlbmVycyl7dmFyIGM9dGhpcy5fbGlzdGVuZXJzW2IudHlwZV07aWYodm9pZCAwIT09Yyl7Yi50YXJnZXQ9dGhpcztmb3IodmFyIGQ9Yy5sZW5ndGgsZT0wO2U8ZDtlKyspYVtlXT1jW2VdO2ZvcihlPTA7ZTxkO2UrKylhW2VdLmNhbGwodGhpcyxiKX19fX0oKX07KGZ1bmN0aW9uKGEpe2EuUmF5Y2FzdGVyPWZ1bmN0aW9uKGIsYyxkLGUpe3RoaXMucmF5PW5ldyBhLlJheShiLGMpO3RoaXMubmVhcj1kfHwwO3RoaXMuZmFyPWV8fEluZmluaXR5fTt2YXIgYj1uZXcgYS5TcGhlcmUsYz1uZXcgYS5SYXk7bmV3IGEuUGxhbmU7bmV3IGEuVmVjdG9yMzt2YXIgZD1uZXcgYS5WZWN0b3IzLGU9bmV3IGEuTWF0cml4NCxmPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuZGlzdGFuY2UtYi5kaXN0YW5jZX0saD1uZXcgYS5WZWN0b3IzLGc9bmV3IGEuVmVjdG9yMyxpPW5ldyBhLlZlY3RvcjMsaz1mdW5jdGlvbihmLG0scyl7aWYoZiBpbnN0YW5jZW9mIGEuU3ByaXRlKXtkLmdldFBvc2l0aW9uRnJvbU1hdHJpeChmLm1hdHJpeFdvcmxkKTt2YXIgdD1tLnJheS5kaXN0YW5jZVRvUG9pbnQoZCk7aWYodD5mLnNjYWxlLngpcmV0dXJuIHM7cy5wdXNoKHtkaXN0YW5jZTp0LHBvaW50OmYucG9zaXRpb24sZmFjZTpudWxsLG9iamVjdDpmfSl9ZWxzZSBpZihmIGluc3RhbmNlb2ZcbmEuTE9EKWQuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KGYubWF0cml4V29ybGQpLHQ9bS5yYXkub3JpZ2luLmRpc3RhbmNlVG8oZCksayhmLmdldE9iamVjdEZvckRpc3RhbmNlKHQpLG0scyk7ZWxzZSBpZihmIGluc3RhbmNlb2YgYS5NZXNoKXt2YXIgbj1mLmdlb21ldHJ5O251bGw9PT1uLmJvdW5kaW5nU3BoZXJlJiZuLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO2IuY29weShuLmJvdW5kaW5nU3BoZXJlKTtiLmFwcGx5TWF0cml4NChmLm1hdHJpeFdvcmxkKTtpZighMT09PW0ucmF5LmlzSW50ZXJzZWN0aW9uU3BoZXJlKGIpKXJldHVybiBzO2UuZ2V0SW52ZXJzZShmLm1hdHJpeFdvcmxkKTtjLmNvcHkobS5yYXkpLmFwcGx5TWF0cml4NChlKTtpZihudWxsIT09bi5ib3VuZGluZ0JveCYmITE9PT1jLmlzSW50ZXJzZWN0aW9uQm94KG4uYm91bmRpbmdCb3gpKXJldHVybiBzO2lmKG4gaW5zdGFuY2VvZiBhLkJ1ZmZlckdlb21ldHJ5KXt2YXIgcj1mLm1hdGVyaWFsO2lmKHZvaWQgMD09PVxucnx8ITE9PT1uLmR5bmFtaWMpcmV0dXJuIHM7dmFyIHEsdSx3PW0ucHJlY2lzaW9uO2lmKHZvaWQgMCE9PW4uYXR0cmlidXRlcy5pbmRleClmb3IodmFyIHo9bi5vZmZzZXRzLEI9bi5hdHRyaWJ1dGVzLmluZGV4LmFycmF5LEQ9bi5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5LHg9bi5vZmZzZXRzLmxlbmd0aCxGPW4uYXR0cmlidXRlcy5pbmRleC5hcnJheS5sZW5ndGgvMyxGPTA7Rjx4OysrRilmb3IodmFyIHQ9eltGXS5zdGFydCxBPXpbRl0uaW5kZXgsbj10LE89dCt6W0ZdLmNvdW50O248TztuKz0zKXQ9QStCW25dLHE9QStCW24rMV0sdT1BK0JbbisyXSxoLnNldChEWzMqdF0sRFszKnQrMV0sRFszKnQrMl0pLGcuc2V0KERbMypxXSxEWzMqcSsxXSxEWzMqcSsyXSksaS5zZXQoRFszKnVdLERbMyp1KzFdLERbMyp1KzJdKSxxPXIuc2lkZT09PWEuQmFja1NpZGU/Yy5pbnRlcnNlY3RUcmlhbmdsZShpLGcsaCwhMCk6Yy5pbnRlcnNlY3RUcmlhbmdsZShoLGcsaSxyLnNpZGUhPT1hLkRvdWJsZVNpZGUpLFxubnVsbCE9PXEmJihxLmFwcGx5TWF0cml4NChmLm1hdHJpeFdvcmxkKSx0PW0ucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKHEpLHQ8d3x8KHQ8bS5uZWFyfHx0Pm0uZmFyKXx8cy5wdXNoKHtkaXN0YW5jZTp0LHBvaW50OnEsZmFjZTpudWxsLGZhY2VJbmRleDpudWxsLG9iamVjdDpmfSkpO2Vsc2V7RD1uLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7Rj1uLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXkubGVuZ3RoO2ZvcihuPTA7bjxGO24rPTMpdD1uLHE9bisxLHU9bisyLGguc2V0KERbMyp0XSxEWzMqdCsxXSxEWzMqdCsyXSksZy5zZXQoRFszKnFdLERbMypxKzFdLERbMypxKzJdKSxpLnNldChEWzMqdV0sRFszKnUrMV0sRFszKnUrMl0pLHE9ci5zaWRlPT09YS5CYWNrU2lkZT9jLmludGVyc2VjdFRyaWFuZ2xlKGksZyxoLCEwKTpjLmludGVyc2VjdFRyaWFuZ2xlKGgsZyxpLHIuc2lkZSE9PWEuRG91YmxlU2lkZSksbnVsbCE9PXEmJihxLmFwcGx5TWF0cml4NChmLm1hdHJpeFdvcmxkKSxcbnQ9bS5yYXkub3JpZ2luLmRpc3RhbmNlVG8ocSksdDx3fHwodDxtLm5lYXJ8fHQ+bS5mYXIpfHxzLnB1c2goe2Rpc3RhbmNlOnQscG9pbnQ6cSxmYWNlOm51bGwsZmFjZUluZGV4Om51bGwsb2JqZWN0OmZ9KSl9fWVsc2UgaWYobiBpbnN0YW5jZW9mIGEuR2VvbWV0cnkpe0I9Zi5tYXRlcmlhbCBpbnN0YW5jZW9mIGEuTWVzaEZhY2VNYXRlcmlhbDtEPSEwPT09Qj9mLm1hdGVyaWFsLm1hdGVyaWFsczpudWxsO3c9bS5wcmVjaXNpb247ej1uLnZlcnRpY2VzO3g9MDtmb3IoRj1uLmZhY2VzLmxlbmd0aDt4PEY7eCsrKUE9bi5mYWNlc1t4XSxyPSEwPT09Qj9EW0EubWF0ZXJpYWxJbmRleF06Zi5tYXRlcmlhbCx2b2lkIDAhPT1yJiYodD16W0EuYV0scT16W0EuYl0sdT16W0EuY10scT1yLnNpZGU9PT1hLkJhY2tTaWRlP2MuaW50ZXJzZWN0VHJpYW5nbGUodSxxLHQsITApOmMuaW50ZXJzZWN0VHJpYW5nbGUodCxxLHUsci5zaWRlIT09YS5Eb3VibGVTaWRlKSxudWxsIT09cSYmKHEuYXBwbHlNYXRyaXg0KGYubWF0cml4V29ybGQpLFxudD1tLnJheS5vcmlnaW4uZGlzdGFuY2VUbyhxKSx0PHd8fCh0PG0ubmVhcnx8dD5tLmZhcil8fHMucHVzaCh7ZGlzdGFuY2U6dCxwb2ludDpxLGZhY2U6QSxmYWNlSW5kZXg6eCxvYmplY3Q6Zn0pKSl9fWVsc2UgaWYoZiBpbnN0YW5jZW9mIGEuTGluZSl7dz1tLmxpbmVQcmVjaXNpb247cj13Knc7bj1mLmdlb21ldHJ5O251bGw9PT1uLmJvdW5kaW5nU3BoZXJlJiZuLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO2IuY29weShuLmJvdW5kaW5nU3BoZXJlKTtiLmFwcGx5TWF0cml4NChmLm1hdHJpeFdvcmxkKTtpZighMT09PW0ucmF5LmlzSW50ZXJzZWN0aW9uU3BoZXJlKGIpKXJldHVybiBzO2UuZ2V0SW52ZXJzZShmLm1hdHJpeFdvcmxkKTtjLmNvcHkobS5yYXkpLmFwcGx5TWF0cml4NChlKTtpZihuIGluc3RhbmNlb2YgYS5HZW9tZXRyeSl7ej1uLnZlcnRpY2VzO3c9ei5sZW5ndGg7cT1uZXcgYS5WZWN0b3IzO3U9bmV3IGEuVmVjdG9yMztGPWYudHlwZT09PWEuTGluZVN0cmlwPzE6XG4yO2ZvcihuPTA7bjx3LTE7bis9RiljLmRpc3RhbmNlU3FUb1NlZ21lbnQoeltuXSx6W24rMV0sdSxxKT5yfHwodD1jLm9yaWdpbi5kaXN0YW5jZVRvKHUpLHQ8bS5uZWFyfHx0Pm0uZmFyfHxzLnB1c2goe2Rpc3RhbmNlOnQscG9pbnQ6cS5jbG9uZSgpLmFwcGx5TWF0cml4NChmLm1hdHJpeFdvcmxkKSxmYWNlOm51bGwsZmFjZUluZGV4Om51bGwsb2JqZWN0OmZ9KSl9fX0sbT1mdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBhPWEuZ2V0RGVzY2VuZGFudHMoKSxkPTAsZT1hLmxlbmd0aDtkPGU7ZCsrKWsoYVtkXSxiLGMpfTthLlJheWNhc3Rlci5wcm90b3R5cGUucHJlY2lzaW9uPTFFLTQ7YS5SYXljYXN0ZXIucHJvdG90eXBlLmxpbmVQcmVjaXNpb249MTthLlJheWNhc3Rlci5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsYil7dGhpcy5yYXkuc2V0KGEsYil9O2EuUmF5Y2FzdGVyLnByb3RvdHlwZS5pbnRlcnNlY3RPYmplY3Q9ZnVuY3Rpb24oYSxiKXt2YXIgYz1bXTshMD09PWImJm0oYSxcbnRoaXMsYyk7ayhhLHRoaXMsYyk7Yy5zb3J0KGYpO3JldHVybiBjfTthLlJheWNhc3Rlci5wcm90b3R5cGUuaW50ZXJzZWN0T2JqZWN0cz1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1bXSxkPTAsZT1hLmxlbmd0aDtkPGU7ZCsrKWsoYVtkXSx0aGlzLGMpLCEwPT09YiYmbShhW2RdLHRoaXMsYyk7Yy5zb3J0KGYpO3JldHVybiBjfX0pKFRIUkVFKTtUSFJFRS5PYmplY3QzRD1mdW5jdGlvbigpe3RoaXMuaWQ9VEhSRUUuT2JqZWN0M0RJZENvdW50Kys7dGhpcy51dWlkPVRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7dGhpcy5uYW1lPVwiXCI7dGhpcy5wYXJlbnQ9dm9pZCAwO3RoaXMuY2hpbGRyZW49W107dGhpcy51cD1uZXcgVEhSRUUuVmVjdG9yMygwLDEsMCk7dGhpcy5wb3NpdGlvbj1uZXcgVEhSRUUuVmVjdG9yMzt0aGlzLnJvdGF0aW9uPW5ldyBUSFJFRS5FdWxlcjt0aGlzLnF1YXRlcm5pb249bmV3IFRIUkVFLlF1YXRlcm5pb247dGhpcy5zY2FsZT1uZXcgVEhSRUUuVmVjdG9yMygxLDEsMSk7dGhpcy5yb3RhdGlvbi5fcXVhdGVybmlvbj10aGlzLnF1YXRlcm5pb247dGhpcy5xdWF0ZXJuaW9uLl9ldWxlcj10aGlzLnJvdGF0aW9uO3RoaXMucmVuZGVyRGVwdGg9bnVsbDt0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZT0hMDt0aGlzLm1hdHJpeD1uZXcgVEhSRUUuTWF0cml4NDt0aGlzLm1hdHJpeFdvcmxkPW5ldyBUSFJFRS5NYXRyaXg0O1xudGhpcy52aXNpYmxlPXRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZT10aGlzLm1hdHJpeEF1dG9VcGRhdGU9ITA7dGhpcy5yZWNlaXZlU2hhZG93PXRoaXMuY2FzdFNoYWRvdz0hMTt0aGlzLmZydXN0dW1DdWxsZWQ9ITA7dGhpcy51c2VyRGF0YT17fX07XG5USFJFRS5PYmplY3QzRC5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLk9iamVjdDNELGdldCBldWxlck9yZGVyKCl7Y29uc29sZS53YXJuKFwiREVQUkVDQVRFRDogT2JqZWN0M0QncyAuZXVsZXJPcmRlciBoYXMgYmVlbiBtb3ZlZCB0byBPYmplY3QzRCdzIC5yb3RhdGlvbi5vcmRlci5cIik7cmV0dXJuIHRoaXMucm90YXRpb24ub3JkZXJ9LHNldCBldWxlck9yZGVyKGEpe2NvbnNvbGUud2FybihcIkRFUFJFQ0FURUQ6IE9iamVjdDNEJ3MgLmV1bGVyT3JkZXIgaGFzIGJlZW4gbW92ZWQgdG8gT2JqZWN0M0QncyAucm90YXRpb24ub3JkZXIuXCIpO3RoaXMucm90YXRpb24ub3JkZXI9YX0sZ2V0IHVzZVF1YXRlcm5pb24oKXtjb25zb2xlLndhcm4oXCJERVBSRUNBVEVEOiBPYmplY3QzRCdzIC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuXCIpfSxzZXQgdXNlUXVhdGVybmlvbihhKXtjb25zb2xlLndhcm4oXCJERVBSRUNBVEVEOiBPYmplY3QzRCdzIC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuXCIpfSxcbmFwcGx5TWF0cml4OmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLk1hdHJpeDQ7cmV0dXJuIGZ1bmN0aW9uKGIpe3RoaXMubWF0cml4Lm11bHRpcGx5TWF0cmljZXMoYix0aGlzLm1hdHJpeCk7dGhpcy5wb3NpdGlvbi5nZXRQb3NpdGlvbkZyb21NYXRyaXgodGhpcy5tYXRyaXgpO3RoaXMuc2NhbGUuZ2V0U2NhbGVGcm9tTWF0cml4KHRoaXMubWF0cml4KTthLmV4dHJhY3RSb3RhdGlvbih0aGlzLm1hdHJpeCk7dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChhKX19KCksc2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlOmZ1bmN0aW9uKGEsYil7dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoYSxiKX0sc2V0Um90YXRpb25Gcm9tRXVsZXI6ZnVuY3Rpb24oYSl7dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21FdWxlcihhLCEwKX0sc2V0Um90YXRpb25Gcm9tTWF0cml4OmZ1bmN0aW9uKGEpe3RoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoYSl9LFxuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjpmdW5jdGlvbihhKXt0aGlzLnF1YXRlcm5pb24uY29weShhKX0scm90YXRlT25BeGlzOmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlF1YXRlcm5pb247cmV0dXJuIGZ1bmN0aW9uKGIsYyl7YS5zZXRGcm9tQXhpc0FuZ2xlKGIsYyk7dGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KGEpO3JldHVybiB0aGlzfX0oKSxyb3RhdGVYOmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjMoMSwwLDApO3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoYSxiKX19KCkscm90YXRlWTpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzKDAsMSwwKTtyZXR1cm4gZnVuY3Rpb24oYil7cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKGEsYil9fSgpLHJvdGF0ZVo6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMygwLDAsMSk7cmV0dXJuIGZ1bmN0aW9uKGIpe3JldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyhhLFxuYil9fSgpLHRyYW5zbGF0ZU9uQXhpczpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihiLGMpe2EuY29weShiKTthLmFwcGx5UXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pO3RoaXMucG9zaXRpb24uYWRkKGEubXVsdGlwbHlTY2FsYXIoYykpO3JldHVybiB0aGlzfX0oKSx0cmFuc2xhdGU6ZnVuY3Rpb24oYSxiKXtjb25zb2xlLndhcm4oXCJERVBSRUNBVEVEOiBPYmplY3QzRCdzIC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLnRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKSBpbnN0ZWFkLiBOb3RlIGFyZ3MgaGF2ZSBiZWVuIGNoYW5nZWQuXCIpO3JldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhiLGEpfSx0cmFuc2xhdGVYOmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjMoMSwwLDApO3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoYSxiKX19KCksdHJhbnNsYXRlWTpmdW5jdGlvbigpe3ZhciBhPVxubmV3IFRIUkVFLlZlY3RvcjMoMCwxLDApO3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoYSxiKX19KCksdHJhbnNsYXRlWjpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzKDAsMCwxKTtyZXR1cm4gZnVuY3Rpb24oYil7cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKGEsYil9fSgpLGxvY2FsVG9Xb3JsZDpmdW5jdGlvbihhKXtyZXR1cm4gYS5hcHBseU1hdHJpeDQodGhpcy5tYXRyaXhXb3JsZCl9LHdvcmxkVG9Mb2NhbDpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5NYXRyaXg0O3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gYi5hcHBseU1hdHJpeDQoYS5nZXRJbnZlcnNlKHRoaXMubWF0cml4V29ybGQpKX19KCksbG9va0F0OmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLk1hdHJpeDQ7cmV0dXJuIGZ1bmN0aW9uKGIpe2EubG9va0F0KGIsdGhpcy5wb3NpdGlvbix0aGlzLnVwKTt0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KGEpfX0oKSxcbmFkZDpmdW5jdGlvbihhKXtpZihhPT09dGhpcyljb25zb2xlLndhcm4oXCJUSFJFRS5PYmplY3QzRC5hZGQ6IEFuIG9iamVjdCBjYW4ndCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIGl0c2VsZi5cIik7ZWxzZSBpZihhIGluc3RhbmNlb2YgVEhSRUUuT2JqZWN0M0Qpe3ZvaWQgMCE9PWEucGFyZW50JiZhLnBhcmVudC5yZW1vdmUoYSk7YS5wYXJlbnQ9dGhpczthLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJhZGRlZFwifSk7dGhpcy5jaGlsZHJlbi5wdXNoKGEpO2Zvcih2YXIgYj10aGlzO3ZvaWQgMCE9PWIucGFyZW50OyliPWIucGFyZW50O3ZvaWQgMCE9PWImJmIgaW5zdGFuY2VvZiBUSFJFRS5TY2VuZSYmYi5fX2FkZE9iamVjdChhKX19LHJlbW92ZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoaWxkcmVuLmluZGV4T2YoYSk7aWYoLTEhPT1iKXthLnBhcmVudD12b2lkIDA7YS5kaXNwYXRjaEV2ZW50KHt0eXBlOlwicmVtb3ZlZFwifSk7dGhpcy5jaGlsZHJlbi5zcGxpY2UoYiwxKTtmb3IoYj10aGlzO3ZvaWQgMCE9PVxuYi5wYXJlbnQ7KWI9Yi5wYXJlbnQ7dm9pZCAwIT09YiYmYiBpbnN0YW5jZW9mIFRIUkVFLlNjZW5lJiZiLl9fcmVtb3ZlT2JqZWN0KGEpfX0sdHJhdmVyc2U6ZnVuY3Rpb24oYSl7YSh0aGlzKTtmb3IodmFyIGI9MCxjPXRoaXMuY2hpbGRyZW4ubGVuZ3RoO2I8YztiKyspdGhpcy5jaGlsZHJlbltiXS50cmF2ZXJzZShhKX0sZ2V0T2JqZWN0QnlJZDpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wLGQ9dGhpcy5jaGlsZHJlbi5sZW5ndGg7YzxkO2MrKyl7dmFyIGU9dGhpcy5jaGlsZHJlbltjXTtpZihlLmlkPT09YXx8ITA9PT1iJiYoZT1lLmdldE9iamVjdEJ5SWQoYSxiKSx2b2lkIDAhPT1lKSlyZXR1cm4gZX19LGdldE9iamVjdEJ5TmFtZTpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wLGQ9dGhpcy5jaGlsZHJlbi5sZW5ndGg7YzxkO2MrKyl7dmFyIGU9dGhpcy5jaGlsZHJlbltjXTtpZihlLm5hbWU9PT1hfHwhMD09PWImJihlPWUuZ2V0T2JqZWN0QnlOYW1lKGEsYiksdm9pZCAwIT09XG5lKSlyZXR1cm4gZX19LGdldENoaWxkQnlOYW1lOmZ1bmN0aW9uKGEsYil7Y29uc29sZS53YXJuKFwiREVQUkVDQVRFRDogT2JqZWN0M0QncyAuZ2V0Q2hpbGRCeU5hbWUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRPYmplY3RCeU5hbWUoKS5cIik7cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlOYW1lKGEsYil9LGdldERlc2NlbmRhbnRzOmZ1bmN0aW9uKGEpe3ZvaWQgMD09PWEmJihhPVtdKTtBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhLHRoaXMuY2hpbGRyZW4pO2Zvcih2YXIgYj0wLGM9dGhpcy5jaGlsZHJlbi5sZW5ndGg7YjxjO2IrKyl0aGlzLmNoaWxkcmVuW2JdLmdldERlc2NlbmRhbnRzKGEpO3JldHVybiBhfSx1cGRhdGVNYXRyaXg6ZnVuY3Rpb24oKXt0aGlzLm1hdHJpeC5jb21wb3NlKHRoaXMucG9zaXRpb24sdGhpcy5xdWF0ZXJuaW9uLHRoaXMuc2NhbGUpO3RoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMH0sdXBkYXRlTWF0cml4V29ybGQ6ZnVuY3Rpb24oYSl7ITA9PT1cbnRoaXMubWF0cml4QXV0b1VwZGF0ZSYmdGhpcy51cGRhdGVNYXRyaXgoKTtpZighMD09PXRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZXx8ITA9PT1hKXZvaWQgMD09PXRoaXMucGFyZW50P3RoaXMubWF0cml4V29ybGQuY29weSh0aGlzLm1hdHJpeCk6dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLHRoaXMubWF0cml4KSx0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITEsYT0hMDtmb3IodmFyIGI9MCxjPXRoaXMuY2hpbGRyZW4ubGVuZ3RoO2I8YztiKyspdGhpcy5jaGlsZHJlbltiXS51cGRhdGVNYXRyaXhXb3JsZChhKX0sY2xvbmU6ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT1hJiYoYT1uZXcgVEhSRUUuT2JqZWN0M0QpO3ZvaWQgMD09PWImJihiPSEwKTthLm5hbWU9dGhpcy5uYW1lO2EudXAuY29weSh0aGlzLnVwKTthLnBvc2l0aW9uLmNvcHkodGhpcy5wb3NpdGlvbik7YS5xdWF0ZXJuaW9uLmNvcHkodGhpcy5xdWF0ZXJuaW9uKTtcbmEuc2NhbGUuY29weSh0aGlzLnNjYWxlKTthLnJlbmRlckRlcHRoPXRoaXMucmVuZGVyRGVwdGg7YS5yb3RhdGlvbkF1dG9VcGRhdGU9dGhpcy5yb3RhdGlvbkF1dG9VcGRhdGU7YS5tYXRyaXguY29weSh0aGlzLm1hdHJpeCk7YS5tYXRyaXhXb3JsZC5jb3B5KHRoaXMubWF0cml4V29ybGQpO2EubWF0cml4QXV0b1VwZGF0ZT10aGlzLm1hdHJpeEF1dG9VcGRhdGU7YS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPXRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZTthLnZpc2libGU9dGhpcy52aXNpYmxlO2EuY2FzdFNoYWRvdz10aGlzLmNhc3RTaGFkb3c7YS5yZWNlaXZlU2hhZG93PXRoaXMucmVjZWl2ZVNoYWRvdzthLmZydXN0dW1DdWxsZWQ9dGhpcy5mcnVzdHVtQ3VsbGVkO2EudXNlckRhdGE9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLnVzZXJEYXRhKSk7aWYoITA9PT1iKWZvcih2YXIgYz0wO2M8dGhpcy5jaGlsZHJlbi5sZW5ndGg7YysrKWEuYWRkKHRoaXMuY2hpbGRyZW5bY10uY2xvbmUoKSk7XG5yZXR1cm4gYX19O1RIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlKTtUSFJFRS5PYmplY3QzRElkQ291bnQ9MDtUSFJFRS5Qcm9qZWN0b3I9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7aWYoaT09PW0pe3ZhciBhPW5ldyBUSFJFRS5SZW5kZXJhYmxlVmVydGV4O2sucHVzaChhKTttKys7aSsrO3JldHVybiBhfXJldHVybiBrW2krK119ZnVuY3Rpb24gYihhLGIpe3JldHVybiBhLnohPT1iLno/Yi56LWEuejphLmlkIT09Yi5pZD9hLmlkLWIuaWQ6MH1mdW5jdGlvbiBjKGEsYil7dmFyIGM9MCxkPTEsZT1hLnorYS53LGY9Yi56K2IudyxoPS1hLnorYS53LGc9LWIueitiLnc7aWYoMDw9ZSYmMDw9ZiYmMDw9aCYmMDw9ZylyZXR1cm4hMDtpZigwPmUmJjA+Znx8MD5oJiYwPmcpcmV0dXJuITE7MD5lP2M9TWF0aC5tYXgoYyxlLyhlLWYpKTowPmYmJihkPU1hdGgubWluKGQsZS8oZS1mKSkpOzA+aD9jPU1hdGgubWF4KGMsaC8oaC1nKSk6MD5nJiYoZD1NYXRoLm1pbihkLGgvKGgtZykpKTtpZihkPGMpcmV0dXJuITE7YS5sZXJwKGIsYyk7Yi5sZXJwKGEsMS1kKTtyZXR1cm4hMH12YXIgZCxlLGY9W10saD1cbjAsZyxpLGs9W10sbT0wLGwscCxzPVtdLHQ9MCxuLHIscT1bXSx1PTAsdyx6LEI9W10sRD0wLHg9e29iamVjdHM6W10sc3ByaXRlczpbXSxsaWdodHM6W10sZWxlbWVudHM6W119LEY9bmV3IFRIUkVFLlZlY3RvcjMsQT1uZXcgVEhSRUUuVmVjdG9yNCxPPW5ldyBUSFJFRS5Cb3gzKG5ldyBUSFJFRS5WZWN0b3IzKC0xLC0xLC0xKSxuZXcgVEhSRUUuVmVjdG9yMygxLDEsMSkpLEM9bmV3IFRIUkVFLkJveDMsRT1BcnJheSgzKSxJPW5ldyBUSFJFRS5NYXRyaXg0LHk9bmV3IFRIUkVFLk1hdHJpeDQsdixHPW5ldyBUSFJFRS5NYXRyaXg0LFI9bmV3IFRIUkVFLk1hdHJpeDMsSj1uZXcgVEhSRUUuTWF0cml4MyxiYT1uZXcgVEhSRUUuVmVjdG9yMyxvYT1uZXcgVEhSRUUuRnJ1c3R1bSxwYT1uZXcgVEhSRUUuVmVjdG9yNCxOPW5ldyBUSFJFRS5WZWN0b3I0O3RoaXMucHJvamVjdFZlY3Rvcj1mdW5jdGlvbihhLGIpe2IubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoYi5tYXRyaXhXb3JsZCk7XG55Lm11bHRpcGx5TWF0cmljZXMoYi5wcm9qZWN0aW9uTWF0cml4LGIubWF0cml4V29ybGRJbnZlcnNlKTtyZXR1cm4gYS5hcHBseVByb2plY3Rpb24oeSl9O3RoaXMudW5wcm9qZWN0VmVjdG9yPWZ1bmN0aW9uKGEsYil7Yi5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKGIucHJvamVjdGlvbk1hdHJpeCk7eS5tdWx0aXBseU1hdHJpY2VzKGIubWF0cml4V29ybGQsYi5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSk7cmV0dXJuIGEuYXBwbHlQcm9qZWN0aW9uKHkpfTt0aGlzLnBpY2tpbmdSYXk9ZnVuY3Rpb24oYSxiKXthLno9LTE7dmFyIGM9bmV3IFRIUkVFLlZlY3RvcjMoYS54LGEueSwxKTt0aGlzLnVucHJvamVjdFZlY3RvcihhLGIpO3RoaXMudW5wcm9qZWN0VmVjdG9yKGMsYik7Yy5zdWIoYSkubm9ybWFsaXplKCk7cmV0dXJuIG5ldyBUSFJFRS5SYXljYXN0ZXIoYSxjKX07dmFyIE09ZnVuY3Rpb24oYSl7aWYoZT09PWgpe3ZhciBiPW5ldyBUSFJFRS5SZW5kZXJhYmxlT2JqZWN0O1xuZi5wdXNoKGIpO2grKztlKys7ZD1ifWVsc2UgZD1mW2UrK107ZC5pZD1hLmlkO2Qub2JqZWN0PWE7bnVsbCE9PWEucmVuZGVyRGVwdGg/ZC56PWEucmVuZGVyRGVwdGg6KEYuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KGEubWF0cml4V29ybGQpLEYuYXBwbHlQcm9qZWN0aW9uKHkpLGQuej1GLnopO3JldHVybiBkfSxRPWZ1bmN0aW9uKGEpe2lmKCExIT09YS52aXNpYmxlKXthIGluc3RhbmNlb2YgVEhSRUUuTGlnaHQ/eC5saWdodHMucHVzaChhKTphIGluc3RhbmNlb2YgVEhSRUUuTWVzaHx8YSBpbnN0YW5jZW9mIFRIUkVFLkxpbmU/KCExPT09YS5mcnVzdHVtQ3VsbGVkfHwhMD09PW9hLmludGVyc2VjdHNPYmplY3QoYSkpJiZ4Lm9iamVjdHMucHVzaChNKGEpKTphIGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlJiZ4LnNwcml0ZXMucHVzaChNKGEpKTtmb3IodmFyIGI9MCxjPWEuY2hpbGRyZW4ubGVuZ3RoO2I8YztiKyspUShhLmNoaWxkcmVuW2JdKX19O3RoaXMucHJvamVjdFNjZW5lPWZ1bmN0aW9uKGQsXG5mLGgsbSl7dmFyIGRhPSExLEYsTSxlYSxWLFAsWixVLGthLHRhLGlhLExhLEdhO3o9cj1wPTA7eC5lbGVtZW50cy5sZW5ndGg9MDshMD09PWQuYXV0b1VwZGF0ZSYmZC51cGRhdGVNYXRyaXhXb3JsZCgpO3ZvaWQgMD09PWYucGFyZW50JiZmLnVwZGF0ZU1hdHJpeFdvcmxkKCk7SS5jb3B5KGYubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoZi5tYXRyaXhXb3JsZCkpO3kubXVsdGlwbHlNYXRyaWNlcyhmLnByb2plY3Rpb25NYXRyaXgsSSk7Si5nZXROb3JtYWxNYXRyaXgoSSk7b2Euc2V0RnJvbU1hdHJpeCh5KTtlPTA7eC5vYmplY3RzLmxlbmd0aD0wO3guc3ByaXRlcy5sZW5ndGg9MDt4LmxpZ2h0cy5sZW5ndGg9MDtRKGQpOyEwPT09aCYmeC5vYmplY3RzLnNvcnQoYik7ZD0wO2ZvcihoPXgub2JqZWN0cy5sZW5ndGg7ZDxoO2QrKylpZihVPXgub2JqZWN0c1tkXS5vYmplY3Qsdj1VLm1hdHJpeFdvcmxkLGk9MCxVIGluc3RhbmNlb2YgVEhSRUUuTWVzaCl7a2E9VS5nZW9tZXRyeTtcbmVhPWthLnZlcnRpY2VzO3RhPWthLmZhY2VzO2thPWthLmZhY2VWZXJ0ZXhVdnM7Ui5nZXROb3JtYWxNYXRyaXgodik7TGE9VS5tYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWw7R2E9ITA9PT1MYT9VLm1hdGVyaWFsOm51bGw7Rj0wO2ZvcihNPWVhLmxlbmd0aDtGPE07RisrKXtnPWEoKTtnLnBvc2l0aW9uV29ybGQuY29weShlYVtGXSkuYXBwbHlNYXRyaXg0KHYpO2cucG9zaXRpb25TY3JlZW4uY29weShnLnBvc2l0aW9uV29ybGQpLmFwcGx5TWF0cml4NCh5KTt2YXIgZmE9MS9nLnBvc2l0aW9uU2NyZWVuLnc7Zy5wb3NpdGlvblNjcmVlbi54Kj1mYTtnLnBvc2l0aW9uU2NyZWVuLnkqPWZhO2cucG9zaXRpb25TY3JlZW4ueio9ZmE7Zy52aXNpYmxlPSEoLTE+Zy5wb3NpdGlvblNjcmVlbi54fHwxPGcucG9zaXRpb25TY3JlZW4ueHx8LTE+Zy5wb3NpdGlvblNjcmVlbi55fHwxPGcucG9zaXRpb25TY3JlZW4ueXx8LTE+Zy5wb3NpdGlvblNjcmVlbi56fHwxPFxuZy5wb3NpdGlvblNjcmVlbi56KX1lYT0wO2ZvcihGPXRhLmxlbmd0aDtlYTxGO2VhKyspaWYoTT10YVtlYV0sZmE9ITA9PT1MYT9HYS5tYXRlcmlhbHNbTS5tYXRlcmlhbEluZGV4XTpVLm1hdGVyaWFsLHZvaWQgMCE9PWZhJiYoWj1mYS5zaWRlLFY9a1tNLmFdLFA9a1tNLmJdLGlhPWtbTS5jXSxFWzBdPVYucG9zaXRpb25TY3JlZW4sRVsxXT1QLnBvc2l0aW9uU2NyZWVuLEVbMl09aWEucG9zaXRpb25TY3JlZW4sITA9PT1WLnZpc2libGV8fCEwPT09UC52aXNpYmxlfHwhMD09PWlhLnZpc2libGV8fE8uaXNJbnRlcnNlY3Rpb25Cb3goQy5zZXRGcm9tUG9pbnRzKEUpKSkpaWYoZGE9MD4oaWEucG9zaXRpb25TY3JlZW4ueC1WLnBvc2l0aW9uU2NyZWVuLngpKihQLnBvc2l0aW9uU2NyZWVuLnktVi5wb3NpdGlvblNjcmVlbi55KS0oaWEucG9zaXRpb25TY3JlZW4ueS1WLnBvc2l0aW9uU2NyZWVuLnkpKihQLnBvc2l0aW9uU2NyZWVuLngtVi5wb3NpdGlvblNjcmVlbi54KSxaPT09VEhSRUUuRG91YmxlU2lkZXx8XG5kYT09PShaPT09VEhSRUUuRnJvbnRTaWRlKSl7aWYocD09PXQpe3ZhciBEYT1uZXcgVEhSRUUuUmVuZGVyYWJsZUZhY2UzO3MucHVzaChEYSk7dCsrO3ArKztsPURhfWVsc2UgbD1zW3ArK107bC5pZD1VLmlkO2wudjEuY29weShWKTtsLnYyLmNvcHkoUCk7bC52My5jb3B5KGlhKTtsLm5vcm1hbE1vZGVsLmNvcHkoTS5ub3JtYWwpOyExPT09ZGEmJihaPT09VEhSRUUuQmFja1NpZGV8fFo9PT1USFJFRS5Eb3VibGVTaWRlKSYmbC5ub3JtYWxNb2RlbC5uZWdhdGUoKTtsLm5vcm1hbE1vZGVsLmFwcGx5TWF0cml4MyhSKS5ub3JtYWxpemUoKTtsLm5vcm1hbE1vZGVsVmlldy5jb3B5KGwubm9ybWFsTW9kZWwpLmFwcGx5TWF0cml4MyhKKTtsLmNlbnRyb2lkTW9kZWwuY29weShNLmNlbnRyb2lkKS5hcHBseU1hdHJpeDQodik7aWE9TS52ZXJ0ZXhOb3JtYWxzO1Y9MDtmb3IoUD1NYXRoLm1pbihpYS5sZW5ndGgsMyk7VjxQO1YrKylEYT1sLnZlcnRleE5vcm1hbHNNb2RlbFtWXSxEYS5jb3B5KGlhW1ZdKSxcbiExPT09ZGEmJihaPT09VEhSRUUuQmFja1NpZGV8fFo9PT1USFJFRS5Eb3VibGVTaWRlKSYmRGEubmVnYXRlKCksRGEuYXBwbHlNYXRyaXgzKFIpLm5vcm1hbGl6ZSgpLGwudmVydGV4Tm9ybWFsc01vZGVsVmlld1tWXS5jb3B5KERhKS5hcHBseU1hdHJpeDMoSik7bC52ZXJ0ZXhOb3JtYWxzTGVuZ3RoPWlhLmxlbmd0aDtkYT0wO2ZvcihWPU1hdGgubWluKGthLmxlbmd0aCwzKTtkYTxWO2RhKyspaWYoaWE9a2FbZGFdW2VhXSx2b2lkIDAhPT1pYSl7UD0wO2ZvcihaPWlhLmxlbmd0aDtQPFo7UCsrKWwudXZzW2RhXVtQXT1pYVtQXX1sLmNvbG9yPU0uY29sb3I7bC5tYXRlcmlhbD1mYTtiYS5jb3B5KGwuY2VudHJvaWRNb2RlbCkuYXBwbHlQcm9qZWN0aW9uKHkpO2wuej1iYS56O3guZWxlbWVudHMucHVzaChsKX19ZWxzZSBpZihVIGluc3RhbmNlb2YgVEhSRUUuTGluZSl7Ry5tdWx0aXBseU1hdHJpY2VzKHksdik7ZWE9VS5nZW9tZXRyeS52ZXJ0aWNlcztWPWEoKTtWLnBvc2l0aW9uU2NyZWVuLmNvcHkoZWFbMF0pLmFwcGx5TWF0cml4NChHKTtcbnRhPVUudHlwZT09PVRIUkVFLkxpbmVQaWVjZXM/MjoxO0Y9MTtmb3IoTT1lYS5sZW5ndGg7RjxNO0YrKylWPWEoKSxWLnBvc2l0aW9uU2NyZWVuLmNvcHkoZWFbRl0pLmFwcGx5TWF0cml4NChHKSwwPChGKzEpJXRhfHwoUD1rW2ktMl0scGEuY29weShWLnBvc2l0aW9uU2NyZWVuKSxOLmNvcHkoUC5wb3NpdGlvblNjcmVlbiksITA9PT1jKHBhLE4pJiYocGEubXVsdGlwbHlTY2FsYXIoMS9wYS53KSxOLm11bHRpcGx5U2NhbGFyKDEvTi53KSxyPT09dT8oa2E9bmV3IFRIUkVFLlJlbmRlcmFibGVMaW5lLHEucHVzaChrYSksdSsrLHIrKyxuPWthKTpuPXFbcisrXSxuLmlkPVUuaWQsbi52MS5wb3NpdGlvblNjcmVlbi5jb3B5KHBhKSxuLnYyLnBvc2l0aW9uU2NyZWVuLmNvcHkoTiksbi56PU1hdGgubWF4KHBhLnosTi56KSxuLm1hdGVyaWFsPVUubWF0ZXJpYWwsVS5tYXRlcmlhbC52ZXJ0ZXhDb2xvcnM9PT1USFJFRS5WZXJ0ZXhDb2xvcnMmJihuLnZlcnRleENvbG9yc1swXS5jb3B5KFUuZ2VvbWV0cnkuY29sb3JzW0ZdKSxcbm4udmVydGV4Q29sb3JzWzFdLmNvcHkoVS5nZW9tZXRyeS5jb2xvcnNbRi0xXSkpLHguZWxlbWVudHMucHVzaChuKSkpfWQ9MDtmb3IoaD14LnNwcml0ZXMubGVuZ3RoO2Q8aDtkKyspVT14LnNwcml0ZXNbZF0ub2JqZWN0LHY9VS5tYXRyaXhXb3JsZCxVIGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlJiYoQS5zZXQodi5lbGVtZW50c1sxMl0sdi5lbGVtZW50c1sxM10sdi5lbGVtZW50c1sxNF0sMSksQS5hcHBseU1hdHJpeDQoeSksZmE9MS9BLncsQS56Kj1mYSwtMTxBLnomJjE+QS56JiYoej09PUQ/KHRhPW5ldyBUSFJFRS5SZW5kZXJhYmxlU3ByaXRlLEIucHVzaCh0YSksRCsrLHorKyx3PXRhKTp3PUJbeisrXSx3LmlkPVUuaWQsdy54PUEueCpmYSx3Lnk9QS55KmZhLHcuej1BLnosdy5vYmplY3Q9VSx3LnJvdGF0aW9uPVUucm90YXRpb24sdy5zY2FsZS54PVUuc2NhbGUueCpNYXRoLmFicyh3LngtKEEueCtmLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbMF0pLyhBLncrZi5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWzEyXSkpLFxudy5zY2FsZS55PVUuc2NhbGUueSpNYXRoLmFicyh3LnktKEEueStmLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbNV0pLyhBLncrZi5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWzEzXSkpLHcubWF0ZXJpYWw9VS5tYXRlcmlhbCx4LmVsZW1lbnRzLnB1c2godykpKTshMD09PW0mJnguZWxlbWVudHMuc29ydChiKTtyZXR1cm4geH19O1RIUkVFLkZhY2UzPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt0aGlzLmE9YTt0aGlzLmI9Yjt0aGlzLmM9Yzt0aGlzLm5vcm1hbD1kIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMz9kOm5ldyBUSFJFRS5WZWN0b3IzO3RoaXMudmVydGV4Tm9ybWFscz1kIGluc3RhbmNlb2YgQXJyYXk/ZDpbXTt0aGlzLmNvbG9yPWUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvcj9lOm5ldyBUSFJFRS5Db2xvcjt0aGlzLnZlcnRleENvbG9ycz1lIGluc3RhbmNlb2YgQXJyYXk/ZTpbXTt0aGlzLnZlcnRleFRhbmdlbnRzPVtdO3RoaXMubWF0ZXJpYWxJbmRleD12b2lkIDAhPT1mP2Y6MDt0aGlzLmNlbnRyb2lkPW5ldyBUSFJFRS5WZWN0b3IzfTtcblRIUkVFLkZhY2UzLnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuRmFjZTMsY2xvbmU6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuRmFjZTModGhpcy5hLHRoaXMuYix0aGlzLmMpO2Eubm9ybWFsLmNvcHkodGhpcy5ub3JtYWwpO2EuY29sb3IuY29weSh0aGlzLmNvbG9yKTthLmNlbnRyb2lkLmNvcHkodGhpcy5jZW50cm9pZCk7YS5tYXRlcmlhbEluZGV4PXRoaXMubWF0ZXJpYWxJbmRleDt2YXIgYixjO2I9MDtmb3IoYz10aGlzLnZlcnRleE5vcm1hbHMubGVuZ3RoO2I8YztiKyspYS52ZXJ0ZXhOb3JtYWxzW2JdPXRoaXMudmVydGV4Tm9ybWFsc1tiXS5jbG9uZSgpO2I9MDtmb3IoYz10aGlzLnZlcnRleENvbG9ycy5sZW5ndGg7YjxjO2IrKylhLnZlcnRleENvbG9yc1tiXT10aGlzLnZlcnRleENvbG9yc1tiXS5jbG9uZSgpO2I9MDtmb3IoYz10aGlzLnZlcnRleFRhbmdlbnRzLmxlbmd0aDtiPGM7YisrKWEudmVydGV4VGFuZ2VudHNbYl09dGhpcy52ZXJ0ZXhUYW5nZW50c1tiXS5jbG9uZSgpO1xucmV0dXJuIGF9fTtUSFJFRS5GYWNlND1mdW5jdGlvbihhLGIsYyxkLGUsZixoKXtjb25zb2xlLndhcm4oXCJUSFJFRS5GYWNlNCBoYXMgYmVlbiByZW1vdmVkLiBBIFRIUkVFLkZhY2UzIHdpbGwgYmUgY3JlYXRlZCBpbnN0ZWFkLlwiKTtyZXR1cm4gbmV3IFRIUkVFLkZhY2UzKGEsYixjLGUsZixoKX07VEhSRUUuR2VvbWV0cnk9ZnVuY3Rpb24oKXt0aGlzLmlkPVRIUkVFLkdlb21ldHJ5SWRDb3VudCsrO3RoaXMudXVpZD1USFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO3RoaXMubmFtZT1cIlwiO3RoaXMudmVydGljZXM9W107dGhpcy5jb2xvcnM9W107dGhpcy5mYWNlcz1bXTt0aGlzLmZhY2VWZXJ0ZXhVdnM9W1tdXTt0aGlzLm1vcnBoVGFyZ2V0cz1bXTt0aGlzLm1vcnBoQ29sb3JzPVtdO3RoaXMubW9ycGhOb3JtYWxzPVtdO3RoaXMuc2tpbldlaWdodHM9W107dGhpcy5za2luSW5kaWNlcz1bXTt0aGlzLmxpbmVEaXN0YW5jZXM9W107dGhpcy5ib3VuZGluZ1NwaGVyZT10aGlzLmJvdW5kaW5nQm94PW51bGw7dGhpcy5oYXNUYW5nZW50cz0hMTt0aGlzLmR5bmFtaWM9ITA7dGhpcy5idWZmZXJzTmVlZFVwZGF0ZT10aGlzLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlPXRoaXMuY29sb3JzTmVlZFVwZGF0ZT10aGlzLnRhbmdlbnRzTmVlZFVwZGF0ZT10aGlzLm5vcm1hbHNOZWVkVXBkYXRlPXRoaXMudXZzTmVlZFVwZGF0ZT1cbnRoaXMuZWxlbWVudHNOZWVkVXBkYXRlPXRoaXMudmVydGljZXNOZWVkVXBkYXRlPSExfTtcblRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuR2VvbWV0cnksYXBwbHlNYXRyaXg6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPShuZXcgVEhSRUUuTWF0cml4MykuZ2V0Tm9ybWFsTWF0cml4KGEpLGM9MCxkPXRoaXMudmVydGljZXMubGVuZ3RoO2M8ZDtjKyspdGhpcy52ZXJ0aWNlc1tjXS5hcHBseU1hdHJpeDQoYSk7Yz0wO2ZvcihkPXRoaXMuZmFjZXMubGVuZ3RoO2M8ZDtjKyspe3ZhciBlPXRoaXMuZmFjZXNbY107ZS5ub3JtYWwuYXBwbHlNYXRyaXgzKGIpLm5vcm1hbGl6ZSgpO2Zvcih2YXIgZj0wLGg9ZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDtmPGg7ZisrKWUudmVydGV4Tm9ybWFsc1tmXS5hcHBseU1hdHJpeDMoYikubm9ybWFsaXplKCk7ZS5jZW50cm9pZC5hcHBseU1hdHJpeDQoYSl9dGhpcy5ib3VuZGluZ0JveCBpbnN0YW5jZW9mIFRIUkVFLkJveDMmJnRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7dGhpcy5ib3VuZGluZ1NwaGVyZSBpbnN0YW5jZW9mXG5USFJFRS5TcGhlcmUmJnRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCl9LGNvbXB1dGVDZW50cm9pZHM6ZnVuY3Rpb24oKXt2YXIgYSxiLGM7YT0wO2ZvcihiPXRoaXMuZmFjZXMubGVuZ3RoO2E8YjthKyspYz10aGlzLmZhY2VzW2FdLGMuY2VudHJvaWQuc2V0KDAsMCwwKSxjLmNlbnRyb2lkLmFkZCh0aGlzLnZlcnRpY2VzW2MuYV0pLGMuY2VudHJvaWQuYWRkKHRoaXMudmVydGljZXNbYy5iXSksYy5jZW50cm9pZC5hZGQodGhpcy52ZXJ0aWNlc1tjLmNdKSxjLmNlbnRyb2lkLmRpdmlkZVNjYWxhcigzKX0sY29tcHV0ZUZhY2VOb3JtYWxzOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPW5ldyBUSFJFRS5WZWN0b3IzLGI9bmV3IFRIUkVFLlZlY3RvcjMsYz0wLGQ9dGhpcy5mYWNlcy5sZW5ndGg7YzxkO2MrKyl7dmFyIGU9dGhpcy5mYWNlc1tjXSxmPXRoaXMudmVydGljZXNbZS5hXSxoPXRoaXMudmVydGljZXNbZS5iXTthLnN1YlZlY3RvcnModGhpcy52ZXJ0aWNlc1tlLmNdLGgpO2Iuc3ViVmVjdG9ycyhmLFxuaCk7YS5jcm9zcyhiKTthLm5vcm1hbGl6ZSgpO2Uubm9ybWFsLmNvcHkoYSl9fSxjb21wdXRlVmVydGV4Tm9ybWFsczpmdW5jdGlvbihhKXt2YXIgYixjLGQsZTtpZih2b2lkIDA9PT10aGlzLl9fdG1wVmVydGljZXMpe2U9dGhpcy5fX3RtcFZlcnRpY2VzPUFycmF5KHRoaXMudmVydGljZXMubGVuZ3RoKTtiPTA7Zm9yKGM9dGhpcy52ZXJ0aWNlcy5sZW5ndGg7YjxjO2IrKyllW2JdPW5ldyBUSFJFRS5WZWN0b3IzO2I9MDtmb3IoYz10aGlzLmZhY2VzLmxlbmd0aDtiPGM7YisrKWQ9dGhpcy5mYWNlc1tiXSxkLnZlcnRleE5vcm1hbHM9W25ldyBUSFJFRS5WZWN0b3IzLG5ldyBUSFJFRS5WZWN0b3IzLG5ldyBUSFJFRS5WZWN0b3IzXX1lbHNle2U9dGhpcy5fX3RtcFZlcnRpY2VzO2I9MDtmb3IoYz10aGlzLnZlcnRpY2VzLmxlbmd0aDtiPGM7YisrKWVbYl0uc2V0KDAsMCwwKX1pZihhKXt2YXIgZixoLGc9bmV3IFRIUkVFLlZlY3RvcjMsaT1uZXcgVEhSRUUuVmVjdG9yMztuZXcgVEhSRUUuVmVjdG9yMztcbm5ldyBUSFJFRS5WZWN0b3IzO25ldyBUSFJFRS5WZWN0b3IzO2I9MDtmb3IoYz10aGlzLmZhY2VzLmxlbmd0aDtiPGM7YisrKWQ9dGhpcy5mYWNlc1tiXSxhPXRoaXMudmVydGljZXNbZC5hXSxmPXRoaXMudmVydGljZXNbZC5iXSxoPXRoaXMudmVydGljZXNbZC5jXSxnLnN1YlZlY3RvcnMoaCxmKSxpLnN1YlZlY3RvcnMoYSxmKSxnLmNyb3NzKGkpLGVbZC5hXS5hZGQoZyksZVtkLmJdLmFkZChnKSxlW2QuY10uYWRkKGcpfWVsc2V7Yj0wO2ZvcihjPXRoaXMuZmFjZXMubGVuZ3RoO2I8YztiKyspZD10aGlzLmZhY2VzW2JdLGVbZC5hXS5hZGQoZC5ub3JtYWwpLGVbZC5iXS5hZGQoZC5ub3JtYWwpLGVbZC5jXS5hZGQoZC5ub3JtYWwpfWI9MDtmb3IoYz10aGlzLnZlcnRpY2VzLmxlbmd0aDtiPGM7YisrKWVbYl0ubm9ybWFsaXplKCk7Yj0wO2ZvcihjPXRoaXMuZmFjZXMubGVuZ3RoO2I8YztiKyspZD10aGlzLmZhY2VzW2JdLGQudmVydGV4Tm9ybWFsc1swXS5jb3B5KGVbZC5hXSksZC52ZXJ0ZXhOb3JtYWxzWzFdLmNvcHkoZVtkLmJdKSxcbmQudmVydGV4Tm9ybWFsc1syXS5jb3B5KGVbZC5jXSl9LGNvbXB1dGVNb3JwaE5vcm1hbHM6ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlO2M9MDtmb3IoZD10aGlzLmZhY2VzLmxlbmd0aDtjPGQ7YysrKXtlPXRoaXMuZmFjZXNbY107ZS5fX29yaWdpbmFsRmFjZU5vcm1hbD9lLl9fb3JpZ2luYWxGYWNlTm9ybWFsLmNvcHkoZS5ub3JtYWwpOmUuX19vcmlnaW5hbEZhY2VOb3JtYWw9ZS5ub3JtYWwuY2xvbmUoKTtlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzfHwoZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscz1bXSk7YT0wO2ZvcihiPWUudmVydGV4Tm9ybWFscy5sZW5ndGg7YTxiO2ErKyllLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzW2FdP2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbYV0uY29weShlLnZlcnRleE5vcm1hbHNbYV0pOmUuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbYV09ZS52ZXJ0ZXhOb3JtYWxzW2FdLmNsb25lKCl9dmFyIGY9bmV3IFRIUkVFLkdlb21ldHJ5O2YuZmFjZXM9XG50aGlzLmZhY2VzO2E9MDtmb3IoYj10aGlzLm1vcnBoVGFyZ2V0cy5sZW5ndGg7YTxiO2ErKyl7aWYoIXRoaXMubW9ycGhOb3JtYWxzW2FdKXt0aGlzLm1vcnBoTm9ybWFsc1thXT17fTt0aGlzLm1vcnBoTm9ybWFsc1thXS5mYWNlTm9ybWFscz1bXTt0aGlzLm1vcnBoTm9ybWFsc1thXS52ZXJ0ZXhOb3JtYWxzPVtdO2U9dGhpcy5tb3JwaE5vcm1hbHNbYV0uZmFjZU5vcm1hbHM7dmFyIGg9dGhpcy5tb3JwaE5vcm1hbHNbYV0udmVydGV4Tm9ybWFscyxnLGk7Yz0wO2ZvcihkPXRoaXMuZmFjZXMubGVuZ3RoO2M8ZDtjKyspZz1uZXcgVEhSRUUuVmVjdG9yMyxpPXthOm5ldyBUSFJFRS5WZWN0b3IzLGI6bmV3IFRIUkVFLlZlY3RvcjMsYzpuZXcgVEhSRUUuVmVjdG9yM30sZS5wdXNoKGcpLGgucHVzaChpKX1oPXRoaXMubW9ycGhOb3JtYWxzW2FdO2YudmVydGljZXM9dGhpcy5tb3JwaFRhcmdldHNbYV0udmVydGljZXM7Zi5jb21wdXRlRmFjZU5vcm1hbHMoKTtmLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5jPTA7Zm9yKGQ9dGhpcy5mYWNlcy5sZW5ndGg7YzxkO2MrKyllPXRoaXMuZmFjZXNbY10sZz1oLmZhY2VOb3JtYWxzW2NdLGk9aC52ZXJ0ZXhOb3JtYWxzW2NdLGcuY29weShlLm5vcm1hbCksaS5hLmNvcHkoZS52ZXJ0ZXhOb3JtYWxzWzBdKSxpLmIuY29weShlLnZlcnRleE5vcm1hbHNbMV0pLGkuYy5jb3B5KGUudmVydGV4Tm9ybWFsc1syXSl9Yz0wO2ZvcihkPXRoaXMuZmFjZXMubGVuZ3RoO2M8ZDtjKyspZT10aGlzLmZhY2VzW2NdLGUubm9ybWFsPWUuX19vcmlnaW5hbEZhY2VOb3JtYWwsZS52ZXJ0ZXhOb3JtYWxzPWUuX19vcmlnaW5hbFZlcnRleE5vcm1hbHN9LGNvbXB1dGVUYW5nZW50czpmdW5jdGlvbigpe3ZhciBhLGIsYyxkLGUsZixoLGcsaSxrLG0sbCxwLHMsdCxuLHIscT1bXSx1PVtdO2M9bmV3IFRIUkVFLlZlY3RvcjM7dmFyIHc9bmV3IFRIUkVFLlZlY3RvcjMsej1uZXcgVEhSRUUuVmVjdG9yMyxCPW5ldyBUSFJFRS5WZWN0b3IzLEQ9bmV3IFRIUkVFLlZlY3RvcjM7XG5hPTA7Zm9yKGI9dGhpcy52ZXJ0aWNlcy5sZW5ndGg7YTxiO2ErKylxW2FdPW5ldyBUSFJFRS5WZWN0b3IzLHVbYV09bmV3IFRIUkVFLlZlY3RvcjM7YT0wO2ZvcihiPXRoaXMuZmFjZXMubGVuZ3RoO2E8YjthKyspZT10aGlzLmZhY2VzW2FdLGY9dGhpcy5mYWNlVmVydGV4VXZzWzBdW2FdLGQ9ZS5hLHI9ZS5iLGU9ZS5jLGg9dGhpcy52ZXJ0aWNlc1tkXSxnPXRoaXMudmVydGljZXNbcl0saT10aGlzLnZlcnRpY2VzW2VdLGs9ZlswXSxtPWZbMV0sbD1mWzJdLGY9Zy54LWgueCxwPWkueC1oLngscz1nLnktaC55LHQ9aS55LWgueSxnPWcuei1oLnosaD1pLnotaC56LGk9bS54LWsueCxuPWwueC1rLngsbT1tLnktay55LGs9bC55LWsueSxsPTEvKGkqay1uKm0pLGMuc2V0KChrKmYtbSpwKSpsLChrKnMtbSp0KSpsLChrKmctbSpoKSpsKSx3LnNldCgoaSpwLW4qZikqbCwoaSp0LW4qcykqbCwoaSpoLW4qZykqbCkscVtkXS5hZGQoYykscVtyXS5hZGQoYykscVtlXS5hZGQoYyksdVtkXS5hZGQodyksXG51W3JdLmFkZCh3KSx1W2VdLmFkZCh3KTt3PVtcImFcIixcImJcIixcImNcIixcImRcIl07YT0wO2ZvcihiPXRoaXMuZmFjZXMubGVuZ3RoO2E8YjthKyspe2U9dGhpcy5mYWNlc1thXTtmb3IoYz0wO2M8TWF0aC5taW4oZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCwzKTtjKyspRC5jb3B5KGUudmVydGV4Tm9ybWFsc1tjXSksZD1lW3dbY11dLHI9cVtkXSx6LmNvcHkociksei5zdWIoRC5tdWx0aXBseVNjYWxhcihELmRvdChyKSkpLm5vcm1hbGl6ZSgpLEIuY3Jvc3NWZWN0b3JzKGUudmVydGV4Tm9ybWFsc1tjXSxyKSxkPUIuZG90KHVbZF0pLGQ9MD5kPy0xOjEsZS52ZXJ0ZXhUYW5nZW50c1tjXT1uZXcgVEhSRUUuVmVjdG9yNCh6Lngsei55LHoueixkKX10aGlzLmhhc1RhbmdlbnRzPSEwfSxjb21wdXRlTGluZURpc3RhbmNlczpmdW5jdGlvbigpe2Zvcih2YXIgYT0wLGI9dGhpcy52ZXJ0aWNlcyxjPTAsZD1iLmxlbmd0aDtjPGQ7YysrKTA8YyYmKGErPWJbY10uZGlzdGFuY2VUbyhiW2MtMV0pKSx0aGlzLmxpbmVEaXN0YW5jZXNbY109XG5hfSxjb21wdXRlQm91bmRpbmdCb3g6ZnVuY3Rpb24oKXtudWxsPT09dGhpcy5ib3VuZGluZ0JveCYmKHRoaXMuYm91bmRpbmdCb3g9bmV3IFRIUkVFLkJveDMpO3RoaXMuYm91bmRpbmdCb3guc2V0RnJvbVBvaW50cyh0aGlzLnZlcnRpY2VzKX0sY29tcHV0ZUJvdW5kaW5nU3BoZXJlOmZ1bmN0aW9uKCl7bnVsbD09PXRoaXMuYm91bmRpbmdTcGhlcmUmJih0aGlzLmJvdW5kaW5nU3BoZXJlPW5ldyBUSFJFRS5TcGhlcmUpO3RoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyh0aGlzLnZlcnRpY2VzKX0sbWVyZ2VWZXJ0aWNlczpmdW5jdGlvbigpe3ZhciBhPXt9LGI9W10sYz1bXSxkLGU9TWF0aC5wb3coMTAsNCksZixoO3RoaXMuX190bXBWZXJ0aWNlcz12b2lkIDA7Zj0wO2ZvcihoPXRoaXMudmVydGljZXMubGVuZ3RoO2Y8aDtmKyspZD10aGlzLnZlcnRpY2VzW2ZdLGQ9TWF0aC5yb3VuZChkLngqZSkrXCJfXCIrTWF0aC5yb3VuZChkLnkqZSkrXCJfXCIrTWF0aC5yb3VuZChkLnoqXG5lKSx2b2lkIDA9PT1hW2RdPyhhW2RdPWYsYi5wdXNoKHRoaXMudmVydGljZXNbZl0pLGNbZl09Yi5sZW5ndGgtMSk6Y1tmXT1jW2FbZF1dO2E9W107Zj0wO2ZvcihoPXRoaXMuZmFjZXMubGVuZ3RoO2Y8aDtmKyspe2U9dGhpcy5mYWNlc1tmXTtlLmE9Y1tlLmFdO2UuYj1jW2UuYl07ZS5jPWNbZS5jXTtlPVtlLmEsZS5iLGUuY107Zm9yKGQ9MDszPmQ7ZCsrKWlmKGVbZF09PWVbKGQrMSklM10pe2EucHVzaChmKTticmVha319Zm9yKGY9YS5sZW5ndGgtMTswPD1mO2YtLSl7ZT1hW2ZdO3RoaXMuZmFjZXMuc3BsaWNlKGUsMSk7Yz0wO2ZvcihoPXRoaXMuZmFjZVZlcnRleFV2cy5sZW5ndGg7YzxoO2MrKyl0aGlzLmZhY2VWZXJ0ZXhVdnNbY10uc3BsaWNlKGUsMSl9Zj10aGlzLnZlcnRpY2VzLmxlbmd0aC1iLmxlbmd0aDt0aGlzLnZlcnRpY2VzPWI7cmV0dXJuIGZ9LGNsb25lOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPW5ldyBUSFJFRS5HZW9tZXRyeSxiPXRoaXMudmVydGljZXMsYz0wLGQ9XG5iLmxlbmd0aDtjPGQ7YysrKWEudmVydGljZXMucHVzaChiW2NdLmNsb25lKCkpO2I9dGhpcy5mYWNlcztjPTA7Zm9yKGQ9Yi5sZW5ndGg7YzxkO2MrKylhLmZhY2VzLnB1c2goYltjXS5jbG9uZSgpKTtiPXRoaXMuZmFjZVZlcnRleFV2c1swXTtjPTA7Zm9yKGQ9Yi5sZW5ndGg7YzxkO2MrKyl7Zm9yKHZhciBlPWJbY10sZj1bXSxoPTAsZz1lLmxlbmd0aDtoPGc7aCsrKWYucHVzaChuZXcgVEhSRUUuVmVjdG9yMihlW2hdLngsZVtoXS55KSk7YS5mYWNlVmVydGV4VXZzWzBdLnB1c2goZil9cmV0dXJuIGF9LGRpc3Bvc2U6ZnVuY3Rpb24oKXt0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJkaXNwb3NlXCJ9KX19O1RIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlKTtUSFJFRS5HZW9tZXRyeUlkQ291bnQ9MDtUSFJFRS5CdWZmZXJHZW9tZXRyeT1mdW5jdGlvbigpe3RoaXMuaWQ9VEhSRUUuR2VvbWV0cnlJZENvdW50Kys7dGhpcy51dWlkPVRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7dGhpcy5uYW1lPVwiXCI7dGhpcy5hdHRyaWJ1dGVzPXt9O3RoaXMuZHluYW1pYz0hMDt0aGlzLm9mZnNldHM9W107dGhpcy5ib3VuZGluZ1NwaGVyZT10aGlzLmJvdW5kaW5nQm94PW51bGw7dGhpcy5oYXNUYW5nZW50cz0hMTt0aGlzLm1vcnBoVGFyZ2V0cz1bXX07XG5USFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLkJ1ZmZlckdlb21ldHJ5LGFkZEF0dHJpYnV0ZTpmdW5jdGlvbihhLGIsYyxkKXt0aGlzLmF0dHJpYnV0ZXNbYV09e2l0ZW1TaXplOmQsYXJyYXk6bmV3IGIoYypkKX19LGFwcGx5TWF0cml4OmZ1bmN0aW9uKGEpe3ZhciBiLGM7dGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uJiYoYj10aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXkpO3RoaXMuYXR0cmlidXRlcy5ub3JtYWwmJihjPXRoaXMuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXkpO3ZvaWQgMCE9PWImJihhLm11bHRpcGx5VmVjdG9yM0FycmF5KGIpLHRoaXMudmVydGljZXNOZWVkVXBkYXRlPSEwKTt2b2lkIDAhPT1jJiYoKG5ldyBUSFJFRS5NYXRyaXgzKS5nZXROb3JtYWxNYXRyaXgoYSkubXVsdGlwbHlWZWN0b3IzQXJyYXkoYyksdGhpcy5ub3JtYWxpemVOb3JtYWxzKCksdGhpcy5ub3JtYWxzTmVlZFVwZGF0ZT0hMCl9LGNvbXB1dGVCb3VuZGluZ0JveDpmdW5jdGlvbigpe251bGw9PT1cbnRoaXMuYm91bmRpbmdCb3gmJih0aGlzLmJvdW5kaW5nQm94PW5ldyBUSFJFRS5Cb3gzKTt2YXIgYT10aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7aWYoYSl7dmFyIGI9dGhpcy5ib3VuZGluZ0JveCxjLGQsZTszPD1hLmxlbmd0aCYmKGIubWluLng9Yi5tYXgueD1hWzBdLGIubWluLnk9Yi5tYXgueT1hWzFdLGIubWluLno9Yi5tYXguej1hWzJdKTtmb3IodmFyIGY9MyxoPWEubGVuZ3RoO2Y8aDtmKz0zKWM9YVtmXSxkPWFbZisxXSxlPWFbZisyXSxjPGIubWluLng/Yi5taW4ueD1jOmM+Yi5tYXgueCYmKGIubWF4Lng9YyksZDxiLm1pbi55P2IubWluLnk9ZDpkPmIubWF4LnkmJihiLm1heC55PWQpLGU8Yi5taW4uej9iLm1pbi56PWU6ZT5iLm1heC56JiYoYi5tYXguej1lKX1pZih2b2lkIDA9PT1hfHwwPT09YS5sZW5ndGgpdGhpcy5ib3VuZGluZ0JveC5taW4uc2V0KDAsMCwwKSx0aGlzLmJvdW5kaW5nQm94Lm1heC5zZXQoMCwwLDApfSxjb21wdXRlQm91bmRpbmdTcGhlcmU6ZnVuY3Rpb24oKXt2YXIgYT1cbm5ldyBUSFJFRS5Cb3gzLGI9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKCl7bnVsbD09PXRoaXMuYm91bmRpbmdTcGhlcmUmJih0aGlzLmJvdW5kaW5nU3BoZXJlPW5ldyBUSFJFRS5TcGhlcmUpO3ZhciBjPXRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtpZihjKXtmb3IodmFyIGQ9dGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXIsZT0wLGY9Yy5sZW5ndGg7ZTxmO2UrPTMpYi5zZXQoY1tlXSxjW2UrMV0sY1tlKzJdKSxhLmFkZFBvaW50KGIpO2EuY2VudGVyKGQpO2Zvcih2YXIgaD0wLGU9MCxmPWMubGVuZ3RoO2U8ZjtlKz0zKWIuc2V0KGNbZV0sY1tlKzFdLGNbZSsyXSksaD1NYXRoLm1heChoLGQuZGlzdGFuY2VUb1NxdWFyZWQoYikpO3RoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzPU1hdGguc3FydChoKX19fSgpLGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOmZ1bmN0aW9uKCl7aWYodGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uKXt2YXIgYSxiLGMsZDthPXRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheS5sZW5ndGg7XG5pZih2b2lkIDA9PT10aGlzLmF0dHJpYnV0ZXMubm9ybWFsKXRoaXMuYXR0cmlidXRlcy5ub3JtYWw9e2l0ZW1TaXplOjMsYXJyYXk6bmV3IEZsb2F0MzJBcnJheShhKX07ZWxzZXthPTA7Zm9yKGI9dGhpcy5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheS5sZW5ndGg7YTxiO2ErKyl0aGlzLmF0dHJpYnV0ZXMubm9ybWFsLmFycmF5W2FdPTB9dmFyIGU9dGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5LGY9dGhpcy5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheSxoLGcsaSxrLG0sbCxwPW5ldyBUSFJFRS5WZWN0b3IzLHM9bmV3IFRIUkVFLlZlY3RvcjMsdD1uZXcgVEhSRUUuVmVjdG9yMyxuPW5ldyBUSFJFRS5WZWN0b3IzLHI9bmV3IFRIUkVFLlZlY3RvcjM7aWYodGhpcy5hdHRyaWJ1dGVzLmluZGV4KXt2YXIgcT10aGlzLmF0dHJpYnV0ZXMuaW5kZXguYXJyYXksdT10aGlzLm9mZnNldHM7Yz0wO2ZvcihkPXUubGVuZ3RoO2M8ZDsrK2Mpe2I9dVtjXS5zdGFydDtoPXVbY10uY291bnQ7dmFyIHc9XG51W2NdLmluZGV4O2E9Yjtmb3IoYis9aDthPGI7YSs9MyloPXcrcVthXSxnPXcrcVthKzFdLGk9dytxW2ErMl0saz1lWzMqaF0sbT1lWzMqaCsxXSxsPWVbMypoKzJdLHAuc2V0KGssbSxsKSxrPWVbMypnXSxtPWVbMypnKzFdLGw9ZVszKmcrMl0scy5zZXQoayxtLGwpLGs9ZVszKmldLG09ZVszKmkrMV0sbD1lWzMqaSsyXSx0LnNldChrLG0sbCksbi5zdWJWZWN0b3JzKHQscyksci5zdWJWZWN0b3JzKHAscyksbi5jcm9zcyhyKSxmWzMqaF0rPW4ueCxmWzMqaCsxXSs9bi55LGZbMypoKzJdKz1uLnosZlszKmddKz1uLngsZlszKmcrMV0rPW4ueSxmWzMqZysyXSs9bi56LGZbMyppXSs9bi54LGZbMyppKzFdKz1uLnksZlszKmkrMl0rPW4uen19ZWxzZXthPTA7Zm9yKGI9ZS5sZW5ndGg7YTxiO2ErPTkpaz1lW2FdLG09ZVthKzFdLGw9ZVthKzJdLHAuc2V0KGssbSxsKSxrPWVbYSszXSxtPWVbYSs0XSxsPWVbYSs1XSxzLnNldChrLG0sbCksaz1lW2ErNl0sbT1lW2ErN10sbD1lW2ErOF0sXG50LnNldChrLG0sbCksbi5zdWJWZWN0b3JzKHQscyksci5zdWJWZWN0b3JzKHAscyksbi5jcm9zcyhyKSxmW2FdPW4ueCxmW2ErMV09bi55LGZbYSsyXT1uLnosZlthKzNdPW4ueCxmW2ErNF09bi55LGZbYSs1XT1uLnosZlthKzZdPW4ueCxmW2ErN109bi55LGZbYSs4XT1uLnp9dGhpcy5ub3JtYWxpemVOb3JtYWxzKCk7dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZT0hMH19LG5vcm1hbGl6ZU5vcm1hbHM6ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheSxiLGMsZCxlPTAsZj1hLmxlbmd0aDtlPGY7ZSs9MyliPWFbZV0sYz1hW2UrMV0sZD1hW2UrMl0sYj0xL01hdGguc3FydChiKmIrYypjK2QqZCksYVtlXSo9YixhW2UrMV0qPWIsYVtlKzJdKj1ifSxjb21wdXRlVGFuZ2VudHM6ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEpe29hLng9ZFszKmFdO29hLnk9ZFszKmErMV07b2Euej1kWzMqYSsyXTtwYS5jb3B5KG9hKTtNPWdbYV07Si5jb3B5KE0pO0ouc3ViKG9hLm11bHRpcGx5U2NhbGFyKG9hLmRvdChNKSkpLm5vcm1hbGl6ZSgpO1xuYmEuY3Jvc3NWZWN0b3JzKHBhLE0pO1E9YmEuZG90KGlbYV0pO049MD5RPy0xOjE7aFs0KmFdPUoueDtoWzQqYSsxXT1KLnk7aFs0KmErMl09Si56O2hbNCphKzNdPU59aWYodm9pZCAwPT09dGhpcy5hdHRyaWJ1dGVzLmluZGV4fHx2b2lkIDA9PT10aGlzLmF0dHJpYnV0ZXMucG9zaXRpb258fHZvaWQgMD09PXRoaXMuYXR0cmlidXRlcy5ub3JtYWx8fHZvaWQgMD09PXRoaXMuYXR0cmlidXRlcy51diljb25zb2xlLndhcm4oXCJNaXNzaW5nIHJlcXVpcmVkIGF0dHJpYnV0ZXMgKGluZGV4LCBwb3NpdGlvbiwgbm9ybWFsIG9yIHV2KSBpbiBCdWZmZXJHZW9tZXRyeS5jb21wdXRlVGFuZ2VudHMoKVwiKTtlbHNle3ZhciBiPXRoaXMuYXR0cmlidXRlcy5pbmRleC5hcnJheSxjPXRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheSxkPXRoaXMuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXksZT10aGlzLmF0dHJpYnV0ZXMudXYuYXJyYXksZj1jLmxlbmd0aC8zO3ZvaWQgMD09PXRoaXMuYXR0cmlidXRlcy50YW5nZW50JiZcbih0aGlzLmF0dHJpYnV0ZXMudGFuZ2VudD17aXRlbVNpemU6NCxhcnJheTpuZXcgRmxvYXQzMkFycmF5KDQqZil9KTtmb3IodmFyIGg9dGhpcy5hdHRyaWJ1dGVzLnRhbmdlbnQuYXJyYXksZz1bXSxpPVtdLGs9MDtrPGY7aysrKWdba109bmV3IFRIUkVFLlZlY3RvcjMsaVtrXT1uZXcgVEhSRUUuVmVjdG9yMzt2YXIgbSxsLHAscyx0LG4scixxLHUsdyx6LEIsRCx4LEYsZj1uZXcgVEhSRUUuVmVjdG9yMyxrPW5ldyBUSFJFRS5WZWN0b3IzLEEsTyxDLEUsSSx5LHYsRz10aGlzLm9mZnNldHM7Qz0wO2ZvcihFPUcubGVuZ3RoO0M8RTsrK0Mpe089R1tDXS5zdGFydDtJPUdbQ10uY291bnQ7dmFyIFI9R1tDXS5pbmRleDtBPU87Zm9yKE8rPUk7QTxPO0ErPTMpST1SK2JbQV0seT1SK2JbQSsxXSx2PVIrYltBKzJdLG09Y1szKkldLGw9Y1szKkkrMV0scD1jWzMqSSsyXSxzPWNbMyp5XSx0PWNbMyp5KzFdLG49Y1szKnkrMl0scj1jWzMqdl0scT1jWzMqdisxXSx1PWNbMyp2KzJdLHc9ZVsyKlxuSV0sej1lWzIqSSsxXSxCPWVbMip5XSxEPWVbMip5KzFdLHg9ZVsyKnZdLEY9ZVsyKnYrMV0scy09bSxtPXItbSx0LT1sLGw9cS1sLG4tPXAscD11LXAsQi09dyx3PXgtdyxELT16LHo9Ri16LEY9MS8oQip6LXcqRCksZi5zZXQoKHoqcy1EKm0pKkYsKHoqdC1EKmwpKkYsKHoqbi1EKnApKkYpLGsuc2V0KChCKm0tdypzKSpGLChCKmwtdyp0KSpGLChCKnAtdypuKSpGKSxnW0ldLmFkZChmKSxnW3ldLmFkZChmKSxnW3ZdLmFkZChmKSxpW0ldLmFkZChrKSxpW3ldLmFkZChrKSxpW3ZdLmFkZChrKX12YXIgSj1uZXcgVEhSRUUuVmVjdG9yMyxiYT1uZXcgVEhSRUUuVmVjdG9yMyxvYT1uZXcgVEhSRUUuVmVjdG9yMyxwYT1uZXcgVEhSRUUuVmVjdG9yMyxOLE0sUTtDPTA7Zm9yKEU9Ry5sZW5ndGg7QzxFOysrQyl7Tz1HW0NdLnN0YXJ0O0k9R1tDXS5jb3VudDtSPUdbQ10uaW5kZXg7QT1PO2ZvcihPKz1JO0E8TztBKz0zKUk9UitiW0FdLHk9UitiW0ErMV0sdj1SK2JbQSsyXSxhKEkpLGEoeSksXG5hKHYpfXRoaXMudGFuZ2VudHNOZWVkVXBkYXRlPXRoaXMuaGFzVGFuZ2VudHM9ITB9fSxjbG9uZTpmdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSxiPVtJbnQ4QXJyYXksVWludDhBcnJheSxVaW50OENsYW1wZWRBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheV0sYztmb3IoYyBpbiB0aGlzLmF0dHJpYnV0ZXMpe2Zvcih2YXIgZD10aGlzLmF0dHJpYnV0ZXNbY10sZT1kLmFycmF5LGY9e2l0ZW1TaXplOmQuaXRlbVNpemUsbnVtSXRlbXM6ZC5udW1JdGVtcyxhcnJheTpudWxsfSxkPTAsaD1iLmxlbmd0aDtkPGg7ZCsrKXt2YXIgZz1iW2RdO2lmKGUgaW5zdGFuY2VvZiBnKXtmLmFycmF5PW5ldyBnKGUpO2JyZWFrfX1hLmF0dHJpYnV0ZXNbY109Zn1kPTA7Zm9yKGg9dGhpcy5vZmZzZXRzLmxlbmd0aDtkPGg7ZCsrKWI9dGhpcy5vZmZzZXRzW2RdLGEub2Zmc2V0cy5wdXNoKHtzdGFydDpiLnN0YXJ0LFxuaW5kZXg6Yi5pbmRleCxjb3VudDpiLmNvdW50fSk7cmV0dXJuIGF9LGRpc3Bvc2U6ZnVuY3Rpb24oKXt0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJkaXNwb3NlXCJ9KX19O1RIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlKTtUSFJFRS5DYW1lcmE9ZnVuY3Rpb24oKXtUSFJFRS5PYmplY3QzRC5jYWxsKHRoaXMpO3RoaXMubWF0cml4V29ybGRJbnZlcnNlPW5ldyBUSFJFRS5NYXRyaXg0O3RoaXMucHJvamVjdGlvbk1hdHJpeD1uZXcgVEhSRUUuTWF0cml4NDt0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlPW5ldyBUSFJFRS5NYXRyaXg0fTtUSFJFRS5DYW1lcmEucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlKTtUSFJFRS5DYW1lcmEucHJvdG90eXBlLmxvb2tBdD1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5NYXRyaXg0O3JldHVybiBmdW5jdGlvbihiKXthLmxvb2tBdCh0aGlzLnBvc2l0aW9uLGIsdGhpcy51cCk7dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChhKX19KCk7XG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKGEpe3ZvaWQgMD09PWEmJihhPW5ldyBUSFJFRS5DYW1lcmEpO1RIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7YS5tYXRyaXhXb3JsZEludmVyc2UuY29weSh0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZSk7YS5wcm9qZWN0aW9uTWF0cml4LmNvcHkodGhpcy5wcm9qZWN0aW9uTWF0cml4KTthLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmNvcHkodGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSk7cmV0dXJuIGF9O1RIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYT1mdW5jdGlvbihhLGIsYyxkLGUsZil7VEhSRUUuQ2FtZXJhLmNhbGwodGhpcyk7dGhpcy5sZWZ0PWE7dGhpcy5yaWdodD1iO3RoaXMudG9wPWM7dGhpcy5ib3R0b209ZDt0aGlzLm5lYXI9dm9pZCAwIT09ZT9lOjAuMTt0aGlzLmZhcj12b2lkIDAhPT1mP2Y6MkUzO3RoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpfTtUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSk7VEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4PWZ1bmN0aW9uKCl7dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VPcnRob2dyYXBoaWModGhpcy5sZWZ0LHRoaXMucmlnaHQsdGhpcy50b3AsdGhpcy5ib3R0b20sdGhpcy5uZWFyLHRoaXMuZmFyKX07XG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYTtUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyxhKTthLmxlZnQ9dGhpcy5sZWZ0O2EucmlnaHQ9dGhpcy5yaWdodDthLnRvcD10aGlzLnRvcDthLmJvdHRvbT10aGlzLmJvdHRvbTthLm5lYXI9dGhpcy5uZWFyO2EuZmFyPXRoaXMuZmFyO3JldHVybiBhfTtUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYT1mdW5jdGlvbihhLGIsYyxkKXtUSFJFRS5DYW1lcmEuY2FsbCh0aGlzKTt0aGlzLmZvdj12b2lkIDAhPT1hP2E6NTA7dGhpcy5hc3BlY3Q9dm9pZCAwIT09Yj9iOjE7dGhpcy5uZWFyPXZvaWQgMCE9PWM/YzowLjE7dGhpcy5mYXI9dm9pZCAwIT09ZD9kOjJFMzt0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKX07VEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSk7VEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnNldExlbnM9ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT1iJiYoYj0yNCk7dGhpcy5mb3Y9MipUSFJFRS5NYXRoLnJhZFRvRGVnKE1hdGguYXRhbihiLygyKmEpKSk7dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9O1xuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnNldFZpZXdPZmZzZXQ9ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3RoaXMuZnVsbFdpZHRoPWE7dGhpcy5mdWxsSGVpZ2h0PWI7dGhpcy54PWM7dGhpcy55PWQ7dGhpcy53aWR0aD1lO3RoaXMuaGVpZ2h0PWY7dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCl9O1xuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnVwZGF0ZVByb2plY3Rpb25NYXRyaXg9ZnVuY3Rpb24oKXtpZih0aGlzLmZ1bGxXaWR0aCl7dmFyIGE9dGhpcy5mdWxsV2lkdGgvdGhpcy5mdWxsSGVpZ2h0LGI9TWF0aC50YW4oVEhSRUUuTWF0aC5kZWdUb1JhZCgwLjUqdGhpcy5mb3YpKSp0aGlzLm5lYXIsYz0tYixkPWEqYyxhPU1hdGguYWJzKGEqYi1kKSxjPU1hdGguYWJzKGItYyk7dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VGcnVzdHVtKGQrdGhpcy54KmEvdGhpcy5mdWxsV2lkdGgsZCsodGhpcy54K3RoaXMud2lkdGgpKmEvdGhpcy5mdWxsV2lkdGgsYi0odGhpcy55K3RoaXMuaGVpZ2h0KSpjL3RoaXMuZnVsbEhlaWdodCxiLXRoaXMueSpjL3RoaXMuZnVsbEhlaWdodCx0aGlzLm5lYXIsdGhpcy5mYXIpfWVsc2UgdGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VQZXJzcGVjdGl2ZSh0aGlzLmZvdix0aGlzLmFzcGVjdCx0aGlzLm5lYXIsdGhpcy5mYXIpfTtcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYTtUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyxhKTthLmZvdj10aGlzLmZvdjthLmFzcGVjdD10aGlzLmFzcGVjdDthLm5lYXI9dGhpcy5uZWFyO2EuZmFyPXRoaXMuZmFyO3JldHVybiBhfTtUSFJFRS5MaWdodD1mdW5jdGlvbihhKXtUSFJFRS5PYmplY3QzRC5jYWxsKHRoaXMpO3RoaXMuY29sb3I9bmV3IFRIUkVFLkNvbG9yKGEpfTtUSFJFRS5MaWdodC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUpO1RIUkVFLkxpZ2h0LnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbihhKXt2b2lkIDA9PT1hJiYoYT1uZXcgVEhSRUUuTGlnaHQpO1RIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7YS5jb2xvci5jb3B5KHRoaXMuY29sb3IpO3JldHVybiBhfTtUSFJFRS5BbWJpZW50TGlnaHQ9ZnVuY3Rpb24oYSl7VEhSRUUuTGlnaHQuY2FsbCh0aGlzLGEpfTtUSFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuTGlnaHQucHJvdG90eXBlKTtUSFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLkFtYmllbnRMaWdodDtUSFJFRS5MaWdodC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO3JldHVybiBhfTtUSFJFRS5BcmVhTGlnaHQ9ZnVuY3Rpb24oYSxiKXtUSFJFRS5MaWdodC5jYWxsKHRoaXMsYSk7dGhpcy5ub3JtYWw9bmV3IFRIUkVFLlZlY3RvcjMoMCwtMSwwKTt0aGlzLnJpZ2h0PW5ldyBUSFJFRS5WZWN0b3IzKDEsMCwwKTt0aGlzLmludGVuc2l0eT12b2lkIDAhPT1iP2I6MTt0aGlzLmhlaWdodD10aGlzLndpZHRoPTE7dGhpcy5jb25zdGFudEF0dGVudWF0aW9uPTEuNTt0aGlzLmxpbmVhckF0dGVudWF0aW9uPTAuNTt0aGlzLnF1YWRyYXRpY0F0dGVudWF0aW9uPTAuMX07VEhSRUUuQXJlYUxpZ2h0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkxpZ2h0LnByb3RvdHlwZSk7VEhSRUUuRGlyZWN0aW9uYWxMaWdodD1mdW5jdGlvbihhLGIpe1RIUkVFLkxpZ2h0LmNhbGwodGhpcyxhKTt0aGlzLnBvc2l0aW9uLnNldCgwLDEsMCk7dGhpcy50YXJnZXQ9bmV3IFRIUkVFLk9iamVjdDNEO3RoaXMuaW50ZW5zaXR5PXZvaWQgMCE9PWI/YjoxO3RoaXMub25seVNoYWRvdz10aGlzLmNhc3RTaGFkb3c9ITE7dGhpcy5zaGFkb3dDYW1lcmFOZWFyPTUwO3RoaXMuc2hhZG93Q2FtZXJhRmFyPTVFMzt0aGlzLnNoYWRvd0NhbWVyYUxlZnQ9LTUwMDt0aGlzLnNoYWRvd0NhbWVyYVRvcD10aGlzLnNoYWRvd0NhbWVyYVJpZ2h0PTUwMDt0aGlzLnNoYWRvd0NhbWVyYUJvdHRvbT0tNTAwO3RoaXMuc2hhZG93Q2FtZXJhVmlzaWJsZT0hMTt0aGlzLnNoYWRvd0JpYXM9MDt0aGlzLnNoYWRvd0RhcmtuZXNzPTAuNTt0aGlzLnNoYWRvd01hcEhlaWdodD10aGlzLnNoYWRvd01hcFdpZHRoPTUxMjt0aGlzLnNoYWRvd0Nhc2NhZGU9ITE7dGhpcy5zaGFkb3dDYXNjYWRlT2Zmc2V0PW5ldyBUSFJFRS5WZWN0b3IzKDAsXG4wLC0xRTMpO3RoaXMuc2hhZG93Q2FzY2FkZUNvdW50PTI7dGhpcy5zaGFkb3dDYXNjYWRlQmlhcz1bMCwwLDBdO3RoaXMuc2hhZG93Q2FzY2FkZVdpZHRoPVs1MTIsNTEyLDUxMl07dGhpcy5zaGFkb3dDYXNjYWRlSGVpZ2h0PVs1MTIsNTEyLDUxMl07dGhpcy5zaGFkb3dDYXNjYWRlTmVhclo9Wy0xLDAuOTksMC45OThdO3RoaXMuc2hhZG93Q2FzY2FkZUZhclo9WzAuOTksMC45OTgsMV07dGhpcy5zaGFkb3dDYXNjYWRlQXJyYXk9W107dGhpcy5zaGFkb3dNYXRyaXg9dGhpcy5zaGFkb3dDYW1lcmE9dGhpcy5zaGFkb3dNYXBTaXplPXRoaXMuc2hhZG93TWFwPW51bGx9O1RIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuTGlnaHQucHJvdG90eXBlKTtcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQ7VEhSRUUuTGlnaHQucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyxhKTthLnRhcmdldD10aGlzLnRhcmdldC5jbG9uZSgpO2EuaW50ZW5zaXR5PXRoaXMuaW50ZW5zaXR5O2EuY2FzdFNoYWRvdz10aGlzLmNhc3RTaGFkb3c7YS5vbmx5U2hhZG93PXRoaXMub25seVNoYWRvdztyZXR1cm4gYX07VEhSRUUuSGVtaXNwaGVyZUxpZ2h0PWZ1bmN0aW9uKGEsYixjKXtUSFJFRS5MaWdodC5jYWxsKHRoaXMsYSk7dGhpcy5wb3NpdGlvbi5zZXQoMCwxMDAsMCk7dGhpcy5ncm91bmRDb2xvcj1uZXcgVEhSRUUuQ29sb3IoYik7dGhpcy5pbnRlbnNpdHk9dm9pZCAwIT09Yz9jOjF9O1RIUkVFLkhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5MaWdodC5wcm90b3R5cGUpO1RIUkVFLkhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0O1RIUkVFLkxpZ2h0LnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7YS5ncm91bmRDb2xvci5jb3B5KHRoaXMuZ3JvdW5kQ29sb3IpO2EuaW50ZW5zaXR5PXRoaXMuaW50ZW5zaXR5O3JldHVybiBhfTtUSFJFRS5Qb2ludExpZ2h0PWZ1bmN0aW9uKGEsYixjKXtUSFJFRS5MaWdodC5jYWxsKHRoaXMsYSk7dGhpcy5pbnRlbnNpdHk9dm9pZCAwIT09Yj9iOjE7dGhpcy5kaXN0YW5jZT12b2lkIDAhPT1jP2M6MH07VEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5MaWdodC5wcm90b3R5cGUpO1RIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlBvaW50TGlnaHQ7VEhSRUUuTGlnaHQucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyxhKTthLmludGVuc2l0eT10aGlzLmludGVuc2l0eTthLmRpc3RhbmNlPXRoaXMuZGlzdGFuY2U7cmV0dXJuIGF9O1RIUkVFLlNwb3RMaWdodD1mdW5jdGlvbihhLGIsYyxkLGUpe1RIUkVFLkxpZ2h0LmNhbGwodGhpcyxhKTt0aGlzLnBvc2l0aW9uLnNldCgwLDEsMCk7dGhpcy50YXJnZXQ9bmV3IFRIUkVFLk9iamVjdDNEO3RoaXMuaW50ZW5zaXR5PXZvaWQgMCE9PWI/YjoxO3RoaXMuZGlzdGFuY2U9dm9pZCAwIT09Yz9jOjA7dGhpcy5hbmdsZT12b2lkIDAhPT1kP2Q6TWF0aC5QSS8zO3RoaXMuZXhwb25lbnQ9dm9pZCAwIT09ZT9lOjEwO3RoaXMub25seVNoYWRvdz10aGlzLmNhc3RTaGFkb3c9ITE7dGhpcy5zaGFkb3dDYW1lcmFOZWFyPTUwO3RoaXMuc2hhZG93Q2FtZXJhRmFyPTVFMzt0aGlzLnNoYWRvd0NhbWVyYUZvdj01MDt0aGlzLnNoYWRvd0NhbWVyYVZpc2libGU9ITE7dGhpcy5zaGFkb3dCaWFzPTA7dGhpcy5zaGFkb3dEYXJrbmVzcz0wLjU7dGhpcy5zaGFkb3dNYXBIZWlnaHQ9dGhpcy5zaGFkb3dNYXBXaWR0aD01MTI7dGhpcy5zaGFkb3dNYXRyaXg9dGhpcy5zaGFkb3dDYW1lcmE9dGhpcy5zaGFkb3dNYXBTaXplPVxudGhpcy5zaGFkb3dNYXA9bnVsbH07VEhSRUUuU3BvdExpZ2h0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkxpZ2h0LnByb3RvdHlwZSk7VEhSRUUuU3BvdExpZ2h0LnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5TcG90TGlnaHQ7VEhSRUUuTGlnaHQucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyxhKTthLnRhcmdldD10aGlzLnRhcmdldC5jbG9uZSgpO2EuaW50ZW5zaXR5PXRoaXMuaW50ZW5zaXR5O2EuZGlzdGFuY2U9dGhpcy5kaXN0YW5jZTthLmFuZ2xlPXRoaXMuYW5nbGU7YS5leHBvbmVudD10aGlzLmV4cG9uZW50O2EuY2FzdFNoYWRvdz10aGlzLmNhc3RTaGFkb3c7YS5vbmx5U2hhZG93PXRoaXMub25seVNoYWRvdztyZXR1cm4gYX07VEhSRUUuTG9hZGVyPWZ1bmN0aW9uKGEpe3RoaXMuc3RhdHVzRG9tRWxlbWVudD0odGhpcy5zaG93U3RhdHVzPWEpP1RIUkVFLkxvYWRlci5wcm90b3R5cGUuYWRkU3RhdHVzRWxlbWVudCgpOm51bGw7dGhpcy5vbkxvYWRTdGFydD1mdW5jdGlvbigpe307dGhpcy5vbkxvYWRQcm9ncmVzcz1mdW5jdGlvbigpe307dGhpcy5vbkxvYWRDb21wbGV0ZT1mdW5jdGlvbigpe319O1xuVEhSRUUuTG9hZGVyLnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuTG9hZGVyLGNyb3NzT3JpZ2luOlwiYW5vbnltb3VzXCIsYWRkU3RhdHVzRWxlbWVudDpmdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7YS5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCI7YS5zdHlsZS5yaWdodD1cIjBweFwiO2Euc3R5bGUudG9wPVwiMHB4XCI7YS5zdHlsZS5mb250U2l6ZT1cIjAuOGVtXCI7YS5zdHlsZS50ZXh0QWxpZ249XCJsZWZ0XCI7YS5zdHlsZS5iYWNrZ3JvdW5kPVwicmdiYSgwLDAsMCwwLjI1KVwiO2Euc3R5bGUuY29sb3I9XCIjZmZmXCI7YS5zdHlsZS53aWR0aD1cIjEyMHB4XCI7YS5zdHlsZS5wYWRkaW5nPVwiMC41ZW0gMC41ZW0gMC41ZW0gMC41ZW1cIjthLnN0eWxlLnpJbmRleD0xRTM7YS5pbm5lckhUTUw9XCJMb2FkaW5nIC4uLlwiO3JldHVybiBhfSx1cGRhdGVQcm9ncmVzczpmdW5jdGlvbihhKXt2YXIgYj1cIkxvYWRlZCBcIixiPWEudG90YWw/YisoKDEwMCphLmxvYWRlZC9cbmEudG90YWwpLnRvRml4ZWQoMCkrXCIlXCIpOmIrKChhLmxvYWRlZC8xRTMpLnRvRml4ZWQoMikrXCIgS0JcIik7dGhpcy5zdGF0dXNEb21FbGVtZW50LmlubmVySFRNTD1ifSxleHRyYWN0VXJsQmFzZTpmdW5jdGlvbihhKXthPWEuc3BsaXQoXCIvXCIpO2EucG9wKCk7cmV0dXJuKDE+YS5sZW5ndGg/XCIuXCI6YS5qb2luKFwiL1wiKSkrXCIvXCJ9LGluaXRNYXRlcmlhbHM6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9W10sZD0wO2Q8YS5sZW5ndGg7KytkKWNbZF09VEhSRUUuTG9hZGVyLnByb3RvdHlwZS5jcmVhdGVNYXRlcmlhbChhW2RdLGIpO3JldHVybiBjfSxuZWVkc1RhbmdlbnRzOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0wLGM9YS5sZW5ndGg7YjxjO2IrKylpZihhW2JdaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbClyZXR1cm4hMDtyZXR1cm4hMX0sY3JlYXRlTWF0ZXJpYWw6ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEpe2E9TWF0aC5sb2coYSkvTWF0aC5MTjI7cmV0dXJuIE1hdGguZmxvb3IoYSk9PVxuYX1mdW5jdGlvbiBkKGEpe2E9TWF0aC5sb2coYSkvTWF0aC5MTjI7cmV0dXJuIE1hdGgucG93KDIsTWF0aC5yb3VuZChhKSl9ZnVuY3Rpb24gZShhLGUsZixnLGksayxyKXt2YXIgcT0vXFwuZGRzJC9pLnRlc3QoZiksdT1iK1wiL1wiK2Y7aWYocSl7dmFyIHc9VEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmUodSk7YVtlXT13fWVsc2Ugdz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLGFbZV09bmV3IFRIUkVFLlRleHR1cmUodyk7YVtlXS5zb3VyY2VGaWxlPWY7ZyYmKGFbZV0ucmVwZWF0LnNldChnWzBdLGdbMV0pLDEhPT1nWzBdJiYoYVtlXS53cmFwUz1USFJFRS5SZXBlYXRXcmFwcGluZyksMSE9PWdbMV0mJihhW2VdLndyYXBUPVRIUkVFLlJlcGVhdFdyYXBwaW5nKSk7aSYmYVtlXS5vZmZzZXQuc2V0KGlbMF0saVsxXSk7ayYmKGY9e3JlcGVhdDpUSFJFRS5SZXBlYXRXcmFwcGluZyxtaXJyb3I6VEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZ30sdm9pZCAwIT09XG5mW2tbMF1dJiYoYVtlXS53cmFwUz1mW2tbMF1dKSx2b2lkIDAhPT1mW2tbMV1dJiYoYVtlXS53cmFwVD1mW2tbMV1dKSk7ciYmKGFbZV0uYW5pc290cm9weT1yKTtpZighcSl7dmFyIHo9YVtlXSxhPW5ldyBJbWFnZTthLm9ubG9hZD1mdW5jdGlvbigpe2lmKCFjKHRoaXMud2lkdGgpfHwhYyh0aGlzLmhlaWdodCkpe3ZhciBhPWQodGhpcy53aWR0aCksYj1kKHRoaXMuaGVpZ2h0KTt6LmltYWdlLndpZHRoPWE7ei5pbWFnZS5oZWlnaHQ9Yjt6LmltYWdlLmdldENvbnRleHQoXCIyZFwiKS5kcmF3SW1hZ2UodGhpcywwLDAsYSxiKX1lbHNlIHouaW1hZ2U9dGhpczt6Lm5lZWRzVXBkYXRlPSEwfTthLmNyb3NzT3JpZ2luPWguY3Jvc3NPcmlnaW47YS5zcmM9dX19ZnVuY3Rpb24gZihhKXtyZXR1cm4oMjU1KmFbMF08PDE2KSsoMjU1KmFbMV08PDgpKzI1NSphWzJdfXZhciBoPXRoaXMsZz1cIk1lc2hMYW1iZXJ0TWF0ZXJpYWxcIixpPXtjb2xvcjoxNTY1ODczNCxvcGFjaXR5OjEsbWFwOm51bGwsXG5saWdodE1hcDpudWxsLG5vcm1hbE1hcDpudWxsLGJ1bXBNYXA6bnVsbCx3aXJlZnJhbWU6ITF9O2lmKGEuc2hhZGluZyl7dmFyIGs9YS5zaGFkaW5nLnRvTG93ZXJDYXNlKCk7XCJwaG9uZ1wiPT09az9nPVwiTWVzaFBob25nTWF0ZXJpYWxcIjpcImJhc2ljXCI9PT1rJiYoZz1cIk1lc2hCYXNpY01hdGVyaWFsXCIpfXZvaWQgMCE9PWEuYmxlbmRpbmcmJnZvaWQgMCE9PVRIUkVFW2EuYmxlbmRpbmddJiYoaS5ibGVuZGluZz1USFJFRVthLmJsZW5kaW5nXSk7aWYodm9pZCAwIT09YS50cmFuc3BhcmVudHx8MT5hLm9wYWNpdHkpaS50cmFuc3BhcmVudD1hLnRyYW5zcGFyZW50O3ZvaWQgMCE9PWEuZGVwdGhUZXN0JiYoaS5kZXB0aFRlc3Q9YS5kZXB0aFRlc3QpO3ZvaWQgMCE9PWEuZGVwdGhXcml0ZSYmKGkuZGVwdGhXcml0ZT1hLmRlcHRoV3JpdGUpO3ZvaWQgMCE9PWEudmlzaWJsZSYmKGkudmlzaWJsZT1hLnZpc2libGUpO3ZvaWQgMCE9PWEuZmxpcFNpZGVkJiYoaS5zaWRlPVRIUkVFLkJhY2tTaWRlKTtcbnZvaWQgMCE9PWEuZG91YmxlU2lkZWQmJihpLnNpZGU9VEhSRUUuRG91YmxlU2lkZSk7dm9pZCAwIT09YS53aXJlZnJhbWUmJihpLndpcmVmcmFtZT1hLndpcmVmcmFtZSk7dm9pZCAwIT09YS52ZXJ0ZXhDb2xvcnMmJihcImZhY2VcIj09PWEudmVydGV4Q29sb3JzP2kudmVydGV4Q29sb3JzPVRIUkVFLkZhY2VDb2xvcnM6YS52ZXJ0ZXhDb2xvcnMmJihpLnZlcnRleENvbG9ycz1USFJFRS5WZXJ0ZXhDb2xvcnMpKTthLmNvbG9yRGlmZnVzZT9pLmNvbG9yPWYoYS5jb2xvckRpZmZ1c2UpOmEuRGJnQ29sb3ImJihpLmNvbG9yPWEuRGJnQ29sb3IpO2EuY29sb3JTcGVjdWxhciYmKGkuc3BlY3VsYXI9ZihhLmNvbG9yU3BlY3VsYXIpKTthLmNvbG9yQW1iaWVudCYmKGkuYW1iaWVudD1mKGEuY29sb3JBbWJpZW50KSk7YS50cmFuc3BhcmVuY3kmJihpLm9wYWNpdHk9YS50cmFuc3BhcmVuY3kpO2Euc3BlY3VsYXJDb2VmJiYoaS5zaGluaW5lc3M9YS5zcGVjdWxhckNvZWYpO2EubWFwRGlmZnVzZSYmXG5iJiZlKGksXCJtYXBcIixhLm1hcERpZmZ1c2UsYS5tYXBEaWZmdXNlUmVwZWF0LGEubWFwRGlmZnVzZU9mZnNldCxhLm1hcERpZmZ1c2VXcmFwLGEubWFwRGlmZnVzZUFuaXNvdHJvcHkpO2EubWFwTGlnaHQmJmImJmUoaSxcImxpZ2h0TWFwXCIsYS5tYXBMaWdodCxhLm1hcExpZ2h0UmVwZWF0LGEubWFwTGlnaHRPZmZzZXQsYS5tYXBMaWdodFdyYXAsYS5tYXBMaWdodEFuaXNvdHJvcHkpO2EubWFwQnVtcCYmYiYmZShpLFwiYnVtcE1hcFwiLGEubWFwQnVtcCxhLm1hcEJ1bXBSZXBlYXQsYS5tYXBCdW1wT2Zmc2V0LGEubWFwQnVtcFdyYXAsYS5tYXBCdW1wQW5pc290cm9weSk7YS5tYXBOb3JtYWwmJmImJmUoaSxcIm5vcm1hbE1hcFwiLGEubWFwTm9ybWFsLGEubWFwTm9ybWFsUmVwZWF0LGEubWFwTm9ybWFsT2Zmc2V0LGEubWFwTm9ybWFsV3JhcCxhLm1hcE5vcm1hbEFuaXNvdHJvcHkpO2EubWFwU3BlY3VsYXImJmImJmUoaSxcInNwZWN1bGFyTWFwXCIsYS5tYXBTcGVjdWxhcixhLm1hcFNwZWN1bGFyUmVwZWF0LFxuYS5tYXBTcGVjdWxhck9mZnNldCxhLm1hcFNwZWN1bGFyV3JhcCxhLm1hcFNwZWN1bGFyQW5pc290cm9weSk7YS5tYXBCdW1wU2NhbGUmJihpLmJ1bXBTY2FsZT1hLm1hcEJ1bXBTY2FsZSk7YS5tYXBOb3JtYWw/KGc9VEhSRUUuU2hhZGVyTGliLm5vcm1hbG1hcCxrPVRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoZy51bmlmb3Jtcyksay50Tm9ybWFsLnZhbHVlPWkubm9ybWFsTWFwLGEubWFwTm9ybWFsRmFjdG9yJiZrLnVOb3JtYWxTY2FsZS52YWx1ZS5zZXQoYS5tYXBOb3JtYWxGYWN0b3IsYS5tYXBOb3JtYWxGYWN0b3IpLGkubWFwJiYoay50RGlmZnVzZS52YWx1ZT1pLm1hcCxrLmVuYWJsZURpZmZ1c2UudmFsdWU9ITApLGkuc3BlY3VsYXJNYXAmJihrLnRTcGVjdWxhci52YWx1ZT1pLnNwZWN1bGFyTWFwLGsuZW5hYmxlU3BlY3VsYXIudmFsdWU9ITApLGkubGlnaHRNYXAmJihrLnRBTy52YWx1ZT1pLmxpZ2h0TWFwLGsuZW5hYmxlQU8udmFsdWU9ITApLGsudURpZmZ1c2VDb2xvci52YWx1ZS5zZXRIZXgoaS5jb2xvciksXG5rLnVTcGVjdWxhckNvbG9yLnZhbHVlLnNldEhleChpLnNwZWN1bGFyKSxrLnVBbWJpZW50Q29sb3IudmFsdWUuc2V0SGV4KGkuYW1iaWVudCksay51U2hpbmluZXNzLnZhbHVlPWkuc2hpbmluZXNzLHZvaWQgMCE9PWkub3BhY2l0eSYmKGsudU9wYWNpdHkudmFsdWU9aS5vcGFjaXR5KSxnPW5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7ZnJhZ21lbnRTaGFkZXI6Zy5mcmFnbWVudFNoYWRlcix2ZXJ0ZXhTaGFkZXI6Zy52ZXJ0ZXhTaGFkZXIsdW5pZm9ybXM6ayxsaWdodHM6ITAsZm9nOiEwfSksaS50cmFuc3BhcmVudCYmKGcudHJhbnNwYXJlbnQ9ITApKTpnPW5ldyBUSFJFRVtnXShpKTt2b2lkIDAhPT1hLkRiZ05hbWUmJihnLm5hbWU9YS5EYmdOYW1lKTtyZXR1cm4gZ319O1RIUkVFLlhIUkxvYWRlcj1mdW5jdGlvbihhKXt0aGlzLm1hbmFnZXI9dm9pZCAwIT09YT9hOlRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcn07XG5USFJFRS5YSFJMb2FkZXIucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5YSFJMb2FkZXIsbG9hZDpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLGY9bmV3IFhNTEh0dHBSZXF1ZXN0O3ZvaWQgMCE9PWImJmYuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixmdW5jdGlvbihjKXtiKGMudGFyZ2V0LnJlc3BvbnNlVGV4dCk7ZS5tYW5hZ2VyLml0ZW1FbmQoYSl9LCExKTt2b2lkIDAhPT1jJiZmLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLGZ1bmN0aW9uKGEpe2MoYSl9LCExKTt2b2lkIDAhPT1kJiZmLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLGZ1bmN0aW9uKGEpe2QoYSl9LCExKTt2b2lkIDAhPT10aGlzLmNyb3NzT3JpZ2luJiYoZi5jcm9zc09yaWdpbj10aGlzLmNyb3NzT3JpZ2luKTtmLm9wZW4oXCJHRVRcIixhLCEwKTtmLnNlbmQobnVsbCk7ZS5tYW5hZ2VyLml0ZW1TdGFydChhKX0sc2V0Q3Jvc3NPcmlnaW46ZnVuY3Rpb24oYSl7dGhpcy5jcm9zc09yaWdpbj1hfX07VEhSRUUuSW1hZ2VMb2FkZXI9ZnVuY3Rpb24oYSl7dGhpcy5tYW5hZ2VyPXZvaWQgMCE9PWE/YTpUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXJ9O1xuVEhSRUUuSW1hZ2VMb2FkZXIucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5JbWFnZUxvYWRlcixsb2FkOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMsZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO3ZvaWQgMCE9PWImJmYuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixmdW5jdGlvbigpe2UubWFuYWdlci5pdGVtRW5kKGEpO2IodGhpcyl9LCExKTt2b2lkIDAhPT1jJiZmLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLGZ1bmN0aW9uKGEpe2MoYSl9LCExKTt2b2lkIDAhPT1kJiZmLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLGZ1bmN0aW9uKGEpe2QoYSl9LCExKTt2b2lkIDAhPT10aGlzLmNyb3NzT3JpZ2luJiYoZi5jcm9zc09yaWdpbj10aGlzLmNyb3NzT3JpZ2luKTtmLnNyYz1hO2UubWFuYWdlci5pdGVtU3RhcnQoYSk7cmV0dXJuIGZ9LHNldENyb3NzT3JpZ2luOmZ1bmN0aW9uKGEpe3RoaXMuY3Jvc3NPcmlnaW49YX19O1RIUkVFLkpTT05Mb2FkZXI9ZnVuY3Rpb24oYSl7VEhSRUUuTG9hZGVyLmNhbGwodGhpcyxhKTt0aGlzLndpdGhDcmVkZW50aWFscz0hMX07VEhSRUUuSlNPTkxvYWRlci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5Mb2FkZXIucHJvdG90eXBlKTtUSFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGEsYixjKXtjPWMmJlwic3RyaW5nXCI9PT10eXBlb2YgYz9jOnRoaXMuZXh0cmFjdFVybEJhc2UoYSk7dGhpcy5vbkxvYWRTdGFydCgpO3RoaXMubG9hZEFqYXhKU09OKHRoaXMsYSxiLGMpfTtcblRIUkVFLkpTT05Mb2FkZXIucHJvdG90eXBlLmxvYWRBamF4SlNPTj1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPW5ldyBYTUxIdHRwUmVxdWVzdCxoPTA7Zi5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtpZihmLnJlYWR5U3RhdGU9PT1mLkRPTkUpaWYoMjAwPT09Zi5zdGF0dXN8fDA9PT1mLnN0YXR1cyl7aWYoZi5yZXNwb25zZVRleHQpe3ZhciBnPUpTT04ucGFyc2UoZi5yZXNwb25zZVRleHQpLGc9YS5wYXJzZShnLGQpO2MoZy5nZW9tZXRyeSxnLm1hdGVyaWFscyl9ZWxzZSBjb25zb2xlLndhcm4oXCJUSFJFRS5KU09OTG9hZGVyOiBbXCIrYitcIl0gc2VlbXMgdG8gYmUgdW5yZWFjaGFibGUgb3IgZmlsZSB0aGVyZSBpcyBlbXB0eVwiKTthLm9uTG9hZENvbXBsZXRlKCl9ZWxzZSBjb25zb2xlLmVycm9yKFwiVEhSRUUuSlNPTkxvYWRlcjogQ291bGRuJ3QgbG9hZCBbXCIrYitcIl0gW1wiK2Yuc3RhdHVzK1wiXVwiKTtlbHNlIGYucmVhZHlTdGF0ZT09PWYuTE9BRElORz9lJiYoMD09PWgmJlxuKGg9Zi5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtTGVuZ3RoXCIpKSxlKHt0b3RhbDpoLGxvYWRlZDpmLnJlc3BvbnNlVGV4dC5sZW5ndGh9KSk6Zi5yZWFkeVN0YXRlPT09Zi5IRUFERVJTX1JFQ0VJVkVEJiZ2b2lkIDAhPT1lJiYoaD1mLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1MZW5ndGhcIikpfTtmLm9wZW4oXCJHRVRcIixiLCEwKTtmLndpdGhDcmVkZW50aWFscz10aGlzLndpdGhDcmVkZW50aWFscztmLnNlbmQobnVsbCl9O1xuVEhSRUUuSlNPTkxvYWRlci5wcm90b3R5cGUucGFyc2U9ZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgVEhSRUUuR2VvbWV0cnksZD12b2lkIDAhPT1hLnNjYWxlPzEvYS5zY2FsZToxLGUsZixoLGcsaSxrLG0sbCxwLHMsdCxuLHIscSx1PWEuZmFjZXM7cD1hLnZlcnRpY2VzO3ZhciB3PWEubm9ybWFscyx6PWEuY29sb3JzLEI9MDtpZih2b2lkIDAhPT1hLnV2cyl7Zm9yKGU9MDtlPGEudXZzLmxlbmd0aDtlKyspYS51dnNbZV0ubGVuZ3RoJiZCKys7Zm9yKGU9MDtlPEI7ZSsrKWMuZmFjZVZlcnRleFV2c1tlXT1bXX1nPTA7Zm9yKGk9cC5sZW5ndGg7ZzxpOylrPW5ldyBUSFJFRS5WZWN0b3IzLGsueD1wW2crK10qZCxrLnk9cFtnKytdKmQsay56PXBbZysrXSpkLGMudmVydGljZXMucHVzaChrKTtnPTA7Zm9yKGk9dS5sZW5ndGg7ZzxpOylpZihwPXVbZysrXSxzPXAmMSxoPXAmMixlPXAmOCxtPXAmMTYsdD1wJjMyLGs9cCY2NCxwJj0xMjgscyl7cz1uZXcgVEhSRUUuRmFjZTM7cy5hPXVbZ107XG5zLmI9dVtnKzFdO3MuYz11W2crM107bj1uZXcgVEhSRUUuRmFjZTM7bi5hPXVbZysxXTtuLmI9dVtnKzJdO24uYz11W2crM107Zys9NDtoJiYoaD11W2crK10scy5tYXRlcmlhbEluZGV4PWgsbi5tYXRlcmlhbEluZGV4PWgpO2g9Yy5mYWNlcy5sZW5ndGg7aWYoZSlmb3IoZT0wO2U8QjtlKyspe3I9YS51dnNbZV07Yy5mYWNlVmVydGV4VXZzW2VdW2hdPVtdO2MuZmFjZVZlcnRleFV2c1tlXVtoKzFdPVtdO2ZvcihmPTA7ND5mO2YrKylsPXVbZysrXSxxPXJbMipsXSxsPXJbMipsKzFdLHE9bmV3IFRIUkVFLlZlY3RvcjIocSxsKSwyIT09ZiYmYy5mYWNlVmVydGV4VXZzW2VdW2hdLnB1c2gocSksMCE9PWYmJmMuZmFjZVZlcnRleFV2c1tlXVtoKzFdLnB1c2gocSl9bSYmKG09Myp1W2crK10scy5ub3JtYWwuc2V0KHdbbSsrXSx3W20rK10sd1ttXSksbi5ub3JtYWwuY29weShzLm5vcm1hbCkpO2lmKHQpZm9yKGU9MDs0PmU7ZSsrKW09Myp1W2crK10sdD1uZXcgVEhSRUUuVmVjdG9yMyh3W20rK10sXG53W20rK10sd1ttXSksMiE9PWUmJnMudmVydGV4Tm9ybWFscy5wdXNoKHQpLDAhPT1lJiZuLnZlcnRleE5vcm1hbHMucHVzaCh0KTtrJiYoaz11W2crK10saz16W2tdLHMuY29sb3Iuc2V0SGV4KGspLG4uY29sb3Iuc2V0SGV4KGspKTtpZihwKWZvcihlPTA7ND5lO2UrKylrPXVbZysrXSxrPXpba10sMiE9PWUmJnMudmVydGV4Q29sb3JzLnB1c2gobmV3IFRIUkVFLkNvbG9yKGspKSwwIT09ZSYmbi52ZXJ0ZXhDb2xvcnMucHVzaChuZXcgVEhSRUUuQ29sb3IoaykpO2MuZmFjZXMucHVzaChzKTtjLmZhY2VzLnB1c2gobil9ZWxzZXtzPW5ldyBUSFJFRS5GYWNlMztzLmE9dVtnKytdO3MuYj11W2crK107cy5jPXVbZysrXTtoJiYoaD11W2crK10scy5tYXRlcmlhbEluZGV4PWgpO2g9Yy5mYWNlcy5sZW5ndGg7aWYoZSlmb3IoZT0wO2U8QjtlKyspe3I9YS51dnNbZV07Yy5mYWNlVmVydGV4VXZzW2VdW2hdPVtdO2ZvcihmPTA7Mz5mO2YrKylsPXVbZysrXSxxPXJbMipsXSxsPXJbMipsKzFdLFxucT1uZXcgVEhSRUUuVmVjdG9yMihxLGwpLGMuZmFjZVZlcnRleFV2c1tlXVtoXS5wdXNoKHEpfW0mJihtPTMqdVtnKytdLHMubm9ybWFsLnNldCh3W20rK10sd1ttKytdLHdbbV0pKTtpZih0KWZvcihlPTA7Mz5lO2UrKyltPTMqdVtnKytdLHQ9bmV3IFRIUkVFLlZlY3RvcjMod1ttKytdLHdbbSsrXSx3W21dKSxzLnZlcnRleE5vcm1hbHMucHVzaCh0KTtrJiYoaz11W2crK10scy5jb2xvci5zZXRIZXgoeltrXSkpO2lmKHApZm9yKGU9MDszPmU7ZSsrKWs9dVtnKytdLHMudmVydGV4Q29sb3JzLnB1c2gobmV3IFRIUkVFLkNvbG9yKHpba10pKTtjLmZhY2VzLnB1c2gocyl9aWYoYS5za2luV2VpZ2h0cyl7Zz0wO2ZvcihpPWEuc2tpbldlaWdodHMubGVuZ3RoO2c8aTtnKz0yKXU9YS5za2luV2VpZ2h0c1tnXSx3PWEuc2tpbldlaWdodHNbZysxXSxjLnNraW5XZWlnaHRzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjQodSx3LDAsMCkpfWlmKGEuc2tpbkluZGljZXMpe2c9MDtmb3IoaT1hLnNraW5JbmRpY2VzLmxlbmd0aDtnPFxuaTtnKz0yKXU9YS5za2luSW5kaWNlc1tnXSx3PWEuc2tpbkluZGljZXNbZysxXSxjLnNraW5JbmRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjQodSx3LDAsMCkpfWMuYm9uZXM9YS5ib25lcztjLmFuaW1hdGlvbj1hLmFuaW1hdGlvbjtjLmFuaW1hdGlvbnM9YS5hbmltYXRpb25zO2lmKHZvaWQgMCE9PWEubW9ycGhUYXJnZXRzKXtnPTA7Zm9yKGk9YS5tb3JwaFRhcmdldHMubGVuZ3RoO2c8aTtnKyspe2MubW9ycGhUYXJnZXRzW2ddPXt9O2MubW9ycGhUYXJnZXRzW2ddLm5hbWU9YS5tb3JwaFRhcmdldHNbZ10ubmFtZTtjLm1vcnBoVGFyZ2V0c1tnXS52ZXJ0aWNlcz1bXTt6PWMubW9ycGhUYXJnZXRzW2ddLnZlcnRpY2VzO0I9YS5tb3JwaFRhcmdldHNbZ10udmVydGljZXM7dT0wO2Zvcih3PUIubGVuZ3RoO3U8dzt1Kz0zKXA9bmV3IFRIUkVFLlZlY3RvcjMscC54PUJbdV0qZCxwLnk9Qlt1KzFdKmQscC56PUJbdSsyXSpkLHoucHVzaChwKX19aWYodm9pZCAwIT09YS5tb3JwaENvbG9ycyl7Zz1cbjA7Zm9yKGk9YS5tb3JwaENvbG9ycy5sZW5ndGg7ZzxpO2crKyl7Yy5tb3JwaENvbG9yc1tnXT17fTtjLm1vcnBoQ29sb3JzW2ddLm5hbWU9YS5tb3JwaENvbG9yc1tnXS5uYW1lO2MubW9ycGhDb2xvcnNbZ10uY29sb3JzPVtdO3c9Yy5tb3JwaENvbG9yc1tnXS5jb2xvcnM7ej1hLm1vcnBoQ29sb3JzW2ddLmNvbG9ycztkPTA7Zm9yKHU9ei5sZW5ndGg7ZDx1O2QrPTMpQj1uZXcgVEhSRUUuQ29sb3IoMTY3NTUyMDApLEIuc2V0UkdCKHpbZF0seltkKzFdLHpbZCsyXSksdy5wdXNoKEIpfX1jLmNvbXB1dGVDZW50cm9pZHMoKTtjLmNvbXB1dGVGYWNlTm9ybWFscygpO2MuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7aWYodm9pZCAwPT09YS5tYXRlcmlhbHMpcmV0dXJue2dlb21ldHJ5OmN9O2Q9dGhpcy5pbml0TWF0ZXJpYWxzKGEubWF0ZXJpYWxzLGIpO3RoaXMubmVlZHNUYW5nZW50cyhkKSYmYy5jb21wdXRlVGFuZ2VudHMoKTtyZXR1cm57Z2VvbWV0cnk6YyxtYXRlcmlhbHM6ZH19O1RIUkVFLkxvYWRpbmdNYW5hZ2VyPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLGU9MCxmPTA7dGhpcy5vbkxvYWQ9YTt0aGlzLm9uUHJvZ3Jlc3M9Yjt0aGlzLm9uRXJyb3I9Yzt0aGlzLml0ZW1TdGFydD1mdW5jdGlvbigpe2YrK307dGhpcy5pdGVtRW5kPWZ1bmN0aW9uKGEpe2UrKztpZih2b2lkIDAhPT1kLm9uUHJvZ3Jlc3MpZC5vblByb2dyZXNzKGEsZSxmKTtpZihlPT09ZiYmdm9pZCAwIT09ZC5vbkxvYWQpZC5vbkxvYWQoKX19O1RIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcj1uZXcgVEhSRUUuTG9hZGluZ01hbmFnZXI7VEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXI9ZnVuY3Rpb24oYSl7dGhpcy5tYW5hZ2VyPXZvaWQgMCE9PWE/YTpUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXJ9O1xuVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlcixsb2FkOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcyxkPW5ldyBUSFJFRS5YSFJMb2FkZXI7ZC5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtkLmxvYWQoYSxmdW5jdGlvbihhKXtiKGMucGFyc2UoSlNPTi5wYXJzZShhKSkpfSl9LHNldENyb3NzT3JpZ2luOmZ1bmN0aW9uKGEpe3RoaXMuY3Jvc3NPcmlnaW49YX0scGFyc2U6ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5LGM9YS5hdHRyaWJ1dGVzLGQ9YS5vZmZzZXRzLGE9YS5ib3VuZGluZ1NwaGVyZSxlO2ZvcihlIGluIGMpe3ZhciBmPWNbZV07Yi5hdHRyaWJ1dGVzW2VdPXtpdGVtU2l6ZTpmLml0ZW1TaXplLGFycmF5Om5ldyBzZWxmW2YudHlwZV0oZi5hcnJheSl9fXZvaWQgMCE9PWQmJihiLm9mZnNldHM9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkKSkpO1xudm9pZCAwIT09YSYmKGIuYm91bmRpbmdTcGhlcmU9bmV3IFRIUkVFLlNwaGVyZSgobmV3IFRIUkVFLlZlY3RvcjMpLmZyb21BcnJheSh2b2lkIDAhPT1hLmNlbnRlcj9hLmNlbnRlcjpbMCwwLDBdKSxhLnJhZGl1cykpO3JldHVybiBifX07VEhSRUUuR2VvbWV0cnlMb2FkZXI9ZnVuY3Rpb24oYSl7dGhpcy5tYW5hZ2VyPXZvaWQgMCE9PWE/YTpUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXJ9O1RIUkVFLkdlb21ldHJ5TG9hZGVyLnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuR2VvbWV0cnlMb2FkZXIsbG9hZDpmdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZD1uZXcgVEhSRUUuWEhSTG9hZGVyO2Quc2V0Q3Jvc3NPcmlnaW4odGhpcy5jcm9zc09yaWdpbik7ZC5sb2FkKGEsZnVuY3Rpb24oYSl7YihjLnBhcnNlKEpTT04ucGFyc2UoYSkpKX0pfSxzZXRDcm9zc09yaWdpbjpmdW5jdGlvbihhKXt0aGlzLmNyb3NzT3JpZ2luPWF9LHBhcnNlOmZ1bmN0aW9uKCl7fX07VEhSRUUuTWF0ZXJpYWxMb2FkZXI9ZnVuY3Rpb24oYSl7dGhpcy5tYW5hZ2VyPXZvaWQgMCE9PWE/YTpUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXJ9O1xuVEhSRUUuTWF0ZXJpYWxMb2FkZXIucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5NYXRlcmlhbExvYWRlcixsb2FkOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcyxkPW5ldyBUSFJFRS5YSFJMb2FkZXI7ZC5zZXRDcm9zc09yaWdpbih0aGlzLmNyb3NzT3JpZ2luKTtkLmxvYWQoYSxmdW5jdGlvbihhKXtiKGMucGFyc2UoSlNPTi5wYXJzZShhKSkpfSl9LHNldENyb3NzT3JpZ2luOmZ1bmN0aW9uKGEpe3RoaXMuY3Jvc3NPcmlnaW49YX0scGFyc2U6ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IFRIUkVFW2EudHlwZV07dm9pZCAwIT09YS5jb2xvciYmYi5jb2xvci5zZXRIZXgoYS5jb2xvcik7dm9pZCAwIT09YS5hbWJpZW50JiZiLmFtYmllbnQuc2V0SGV4KGEuYW1iaWVudCk7dm9pZCAwIT09YS5lbWlzc2l2ZSYmYi5lbWlzc2l2ZS5zZXRIZXgoYS5lbWlzc2l2ZSk7dm9pZCAwIT09YS5zcGVjdWxhciYmYi5zcGVjdWxhci5zZXRIZXgoYS5zcGVjdWxhcik7dm9pZCAwIT09YS5zaGluaW5lc3MmJlxuKGIuc2hpbmluZXNzPWEuc2hpbmluZXNzKTt2b2lkIDAhPT1hLnZlcnRleENvbG9ycyYmKGIudmVydGV4Q29sb3JzPWEudmVydGV4Q29sb3JzKTt2b2lkIDAhPT1hLmJsZW5kaW5nJiYoYi5ibGVuZGluZz1hLmJsZW5kaW5nKTt2b2lkIDAhPT1hLm9wYWNpdHkmJihiLm9wYWNpdHk9YS5vcGFjaXR5KTt2b2lkIDAhPT1hLnRyYW5zcGFyZW50JiYoYi50cmFuc3BhcmVudD1hLnRyYW5zcGFyZW50KTt2b2lkIDAhPT1hLndpcmVmcmFtZSYmKGIud2lyZWZyYW1lPWEud2lyZWZyYW1lKTtpZih2b2lkIDAhPT1hLm1hdGVyaWFscylmb3IodmFyIGM9MCxkPWEubWF0ZXJpYWxzLmxlbmd0aDtjPGQ7YysrKWIubWF0ZXJpYWxzLnB1c2godGhpcy5wYXJzZShhLm1hdGVyaWFsc1tjXSkpO3JldHVybiBifX07VEhSRUUuT2JqZWN0TG9hZGVyPWZ1bmN0aW9uKGEpe3RoaXMubWFuYWdlcj12b2lkIDAhPT1hP2E6VEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyfTtcblRIUkVFLk9iamVjdExvYWRlci5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLk9iamVjdExvYWRlcixsb2FkOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcyxkPW5ldyBUSFJFRS5YSFJMb2FkZXIoYy5tYW5hZ2VyKTtkLnNldENyb3NzT3JpZ2luKHRoaXMuY3Jvc3NPcmlnaW4pO2QubG9hZChhLGZ1bmN0aW9uKGEpe2IoYy5wYXJzZShKU09OLnBhcnNlKGEpKSl9KX0sc2V0Q3Jvc3NPcmlnaW46ZnVuY3Rpb24oYSl7dGhpcy5jcm9zc09yaWdpbj1hfSxwYXJzZTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLnBhcnNlR2VvbWV0cmllcyhhLmdlb21ldHJpZXMpLGM9dGhpcy5wYXJzZU1hdGVyaWFscyhhLm1hdGVyaWFscyk7cmV0dXJuIHRoaXMucGFyc2VPYmplY3QoYS5vYmplY3QsYixjKX0scGFyc2VHZW9tZXRyaWVzOmZ1bmN0aW9uKGEpe3ZhciBiPXt9O2lmKHZvaWQgMCE9PWEpZm9yKHZhciBjPW5ldyBUSFJFRS5KU09OTG9hZGVyLGQ9bmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyLFxuZT0wLGY9YS5sZW5ndGg7ZTxmO2UrKyl7dmFyIGgsZz1hW2VdO3N3aXRjaChnLnR5cGUpe2Nhc2UgXCJQbGFuZUdlb21ldHJ5XCI6aD1uZXcgVEhSRUUuUGxhbmVHZW9tZXRyeShnLndpZHRoLGcuaGVpZ2h0LGcud2lkdGhTZWdtZW50cyxnLmhlaWdodFNlZ21lbnRzKTticmVhaztjYXNlIFwiQ2lyY2xlR2VvbWV0cnlcIjpoPW5ldyBUSFJFRS5DaXJjbGVHZW9tZXRyeShnLnJhZGl1cyxnLnNlZ21lbnRzKTticmVhaztjYXNlIFwiQ3ViZUdlb21ldHJ5XCI6aD1uZXcgVEhSRUUuQ3ViZUdlb21ldHJ5KGcud2lkdGgsZy5oZWlnaHQsZy5kZXB0aCxnLndpZHRoU2VnbWVudHMsZy5oZWlnaHRTZWdtZW50cyxnLmRlcHRoU2VnbWVudHMpO2JyZWFrO2Nhc2UgXCJDeWxpbmRlckdlb21ldHJ5XCI6aD1uZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeShnLnJhZGl1c1RvcCxnLnJhZGl1c0JvdHRvbSxnLmhlaWdodCxnLnJhZGl1c1NlZ21lbnRzLGcuaGVpZ2h0U2VnbWVudHMsZy5vcGVuRW5kZWQpO2JyZWFrO2Nhc2UgXCJTcGhlcmVHZW9tZXRyeVwiOmg9XG5uZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoZy5yYWRpdXMsZy53aWR0aFNlZ21lbnRzLGcuaGVpZ2h0U2VnbWVudHMsZy5waGlTdGFydCxnLnBoaUxlbmd0aCxnLnRoZXRhU3RhcnQsZy50aGV0YUxlbmd0aCk7YnJlYWs7Y2FzZSBcIkljb3NhaGVkcm9uR2VvbWV0cnlcIjpoPW5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KGcucmFkaXVzLGcuZGV0YWlsKTticmVhaztjYXNlIFwiVG9ydXNHZW9tZXRyeVwiOmg9bmV3IFRIUkVFLlRvcnVzR2VvbWV0cnkoZy5yYWRpdXMsZy50dWJlLGcucmFkaWFsU2VnbWVudHMsZy50dWJ1bGFyU2VnbWVudHMsZy5hcmMpO2JyZWFrO2Nhc2UgXCJUb3J1c0tub3RHZW9tZXRyeVwiOmg9bmV3IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5KGcucmFkaXVzLGcudHViZSxnLnJhZGlhbFNlZ21lbnRzLGcudHVidWxhclNlZ21lbnRzLGcucCxnLnEsZy5oZWlnaHRTY2FsZSk7YnJlYWs7Y2FzZSBcIkJ1ZmZlckdlb21ldHJ5XCI6aD1kLnBhcnNlKGcuZGF0YSk7YnJlYWs7Y2FzZSBcIkdlb21ldHJ5XCI6aD1cbmMucGFyc2UoZy5kYXRhKS5nZW9tZXRyeX1oLnV1aWQ9Zy51dWlkO3ZvaWQgMCE9PWcubmFtZSYmKGgubmFtZT1nLm5hbWUpO2JbZy51dWlkXT1ofXJldHVybiBifSxwYXJzZU1hdGVyaWFsczpmdW5jdGlvbihhKXt2YXIgYj17fTtpZih2b2lkIDAhPT1hKWZvcih2YXIgYz1uZXcgVEhSRUUuTWF0ZXJpYWxMb2FkZXIsZD0wLGU9YS5sZW5ndGg7ZDxlO2QrKyl7dmFyIGY9YVtkXSxoPWMucGFyc2UoZik7aC51dWlkPWYudXVpZDt2b2lkIDAhPT1mLm5hbWUmJihoLm5hbWU9Zi5uYW1lKTtiW2YudXVpZF09aH1yZXR1cm4gYn0scGFyc2VPYmplY3Q6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuTWF0cml4NDtyZXR1cm4gZnVuY3Rpb24oYixjLGQpe3ZhciBlO3N3aXRjaChiLnR5cGUpe2Nhc2UgXCJTY2VuZVwiOmU9bmV3IFRIUkVFLlNjZW5lO2JyZWFrO2Nhc2UgXCJQZXJzcGVjdGl2ZUNhbWVyYVwiOmU9bmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKGIuZm92LGIuYXNwZWN0LGIubmVhcixcbmIuZmFyKTticmVhaztjYXNlIFwiT3J0aG9ncmFwaGljQ2FtZXJhXCI6ZT1uZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKGIubGVmdCxiLnJpZ2h0LGIudG9wLGIuYm90dG9tLGIubmVhcixiLmZhcik7YnJlYWs7Y2FzZSBcIkFtYmllbnRMaWdodFwiOmU9bmV3IFRIUkVFLkFtYmllbnRMaWdodChiLmNvbG9yKTticmVhaztjYXNlIFwiRGlyZWN0aW9uYWxMaWdodFwiOmU9bmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoYi5jb2xvcixiLmludGVuc2l0eSk7YnJlYWs7Y2FzZSBcIlBvaW50TGlnaHRcIjplPW5ldyBUSFJFRS5Qb2ludExpZ2h0KGIuY29sb3IsYi5pbnRlbnNpdHksYi5kaXN0YW5jZSk7YnJlYWs7Y2FzZSBcIlNwb3RMaWdodFwiOmU9bmV3IFRIUkVFLlNwb3RMaWdodChiLmNvbG9yLGIuaW50ZW5zaXR5LGIuZGlzdGFuY2UsYi5hbmdsZSxiLmV4cG9uZW50KTticmVhaztjYXNlIFwiSGVtaXNwaGVyZUxpZ2h0XCI6ZT1uZXcgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0KGIuY29sb3IsYi5ncm91bmRDb2xvcixcbmIuaW50ZW5zaXR5KTticmVhaztjYXNlIFwiTWVzaFwiOmU9Y1tiLmdlb21ldHJ5XTt2YXIgZj1kW2IubWF0ZXJpYWxdO3ZvaWQgMD09PWUmJmNvbnNvbGUuZXJyb3IoXCJUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBnZW9tZXRyeSBcIitiLmdlb21ldHJ5KTt2b2lkIDA9PT1mJiZjb25zb2xlLmVycm9yKFwiVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwgXCIrYi5tYXRlcmlhbCk7ZT1uZXcgVEhSRUUuTWVzaChlLGYpO2JyZWFrO2RlZmF1bHQ6ZT1uZXcgVEhSRUUuT2JqZWN0M0R9ZS51dWlkPWIudXVpZDt2b2lkIDAhPT1iLm5hbWUmJihlLm5hbWU9Yi5uYW1lKTt2b2lkIDAhPT1iLm1hdHJpeD8oYS5mcm9tQXJyYXkoYi5tYXRyaXgpLGEuZGVjb21wb3NlKGUucG9zaXRpb24sZS5xdWF0ZXJuaW9uLGUuc2NhbGUpKToodm9pZCAwIT09Yi5wb3NpdGlvbiYmZS5wb3NpdGlvbi5mcm9tQXJyYXkoYi5wb3NpdGlvbiksdm9pZCAwIT09Yi5yb3RhdGlvbiYmZS5yb3RhdGlvbi5mcm9tQXJyYXkoYi5yb3RhdGlvbiksXG52b2lkIDAhPT1iLnNjYWxlJiZlLnNjYWxlLmZyb21BcnJheShiLnNjYWxlKSk7dm9pZCAwIT09Yi52aXNpYmxlJiYoZS52aXNpYmxlPWIudmlzaWJsZSk7dm9pZCAwIT09Yi51c2VyRGF0YSYmKGUudXNlckRhdGE9Yi51c2VyRGF0YSk7aWYodm9pZCAwIT09Yi5jaGlsZHJlbilmb3IodmFyIGggaW4gYi5jaGlsZHJlbillLmFkZCh0aGlzLnBhcnNlT2JqZWN0KGIuY2hpbGRyZW5baF0sYyxkKSk7cmV0dXJuIGV9fSgpfTtUSFJFRS5TY2VuZUxvYWRlcj1mdW5jdGlvbigpe3RoaXMub25Mb2FkU3RhcnQ9ZnVuY3Rpb24oKXt9O3RoaXMub25Mb2FkUHJvZ3Jlc3M9ZnVuY3Rpb24oKXt9O3RoaXMub25Mb2FkQ29tcGxldGU9ZnVuY3Rpb24oKXt9O3RoaXMuY2FsbGJhY2tTeW5jPWZ1bmN0aW9uKCl7fTt0aGlzLmNhbGxiYWNrUHJvZ3Jlc3M9ZnVuY3Rpb24oKXt9O3RoaXMuZ2VvbWV0cnlIYW5kbGVycz17fTt0aGlzLmhpZXJhcmNoeUhhbmRsZXJzPXt9O3RoaXMuYWRkR2VvbWV0cnlIYW5kbGVyKFwiYXNjaWlcIixUSFJFRS5KU09OTG9hZGVyKX07XG5USFJFRS5TY2VuZUxvYWRlci5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLlNjZW5lTG9hZGVyLGxvYWQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLGQ9bmV3IFRIUkVFLlhIUkxvYWRlcihjLm1hbmFnZXIpO2Quc2V0Q3Jvc3NPcmlnaW4odGhpcy5jcm9zc09yaWdpbik7ZC5sb2FkKGEsZnVuY3Rpb24oZCl7Yy5wYXJzZShKU09OLnBhcnNlKGQpLGIsYSl9KX0sc2V0Q3Jvc3NPcmlnaW46ZnVuY3Rpb24oYSl7dGhpcy5jcm9zc09yaWdpbj1hfSxhZGRHZW9tZXRyeUhhbmRsZXI6ZnVuY3Rpb24oYSxiKXt0aGlzLmdlb21ldHJ5SGFuZGxlcnNbYV09e2xvYWRlckNsYXNzOmJ9fSxhZGRIaWVyYXJjaHlIYW5kbGVyOmZ1bmN0aW9uKGEsYil7dGhpcy5oaWVyYXJjaHlIYW5kbGVyc1thXT17bG9hZGVyQ2xhc3M6Yn19LHBhcnNlOmZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGEsYil7cmV0dXJuXCJyZWxhdGl2ZVRvSFRNTFwiPT1iP2E6cCtcIi9cIithfWZ1bmN0aW9uIGUoKXtmKEEuc2NlbmUsXG5DLm9iamVjdHMpfWZ1bmN0aW9uIGYoYSxiKXt2YXIgYyxlLGgsaSxrLG0scDtmb3IocCBpbiBiKXt2YXIgcj1BLm9iamVjdHNbcF0scT1iW3BdO2lmKHZvaWQgMD09PXIpe2lmKHEudHlwZSYmcS50eXBlIGluIGwuaGllcmFyY2h5SGFuZGxlcnMpe2lmKHZvaWQgMD09PXEubG9hZGluZyl7ZT17dHlwZToxLHVybDoxLG1hdGVyaWFsOjEscG9zaXRpb246MSxyb3RhdGlvbjoxLHNjYWxlOjEsdmlzaWJsZToxLGNoaWxkcmVuOjEsdXNlckRhdGE6MSxza2luOjEsbW9ycGg6MSxtaXJyb3JlZExvb3A6MSxkdXJhdGlvbjoxfTtoPXt9O2Zvcih2YXIgQiBpbiBxKUIgaW4gZXx8KGhbQl09cVtCXSk7dD1BLm1hdGVyaWFsc1txLm1hdGVyaWFsXTtxLmxvYWRpbmc9ITA7ZT1sLmhpZXJhcmNoeUhhbmRsZXJzW3EudHlwZV0ubG9hZGVyT2JqZWN0O2Uub3B0aW9ucz9lLmxvYWQoZChxLnVybCxDLnVybEJhc2VUeXBlKSxnKHAsYSx0LHEpKTplLmxvYWQoZChxLnVybCxDLnVybEJhc2VUeXBlKSxnKHAsXG5hLHQscSksaCl9fWVsc2UgaWYodm9pZCAwIT09cS5nZW9tZXRyeSl7aWYocz1BLmdlb21ldHJpZXNbcS5nZW9tZXRyeV0pe3I9ITE7dD1BLm1hdGVyaWFsc1txLm1hdGVyaWFsXTtyPXQgaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbDtoPXEucG9zaXRpb247aT1xLnJvdGF0aW9uO2s9cS5zY2FsZTtjPXEubWF0cml4O209cS5xdWF0ZXJuaW9uO3EubWF0ZXJpYWx8fCh0PW5ldyBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsKEEuZmFjZV9tYXRlcmlhbHNbcS5nZW9tZXRyeV0pKTt0IGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCYmMD09PXQubWF0ZXJpYWxzLmxlbmd0aCYmKHQ9bmV3IFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwoQS5mYWNlX21hdGVyaWFsc1txLmdlb21ldHJ5XSkpO2lmKHQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsKWZvcihlPTA7ZTx0Lm1hdGVyaWFscy5sZW5ndGg7ZSsrKXI9cnx8dC5tYXRlcmlhbHNbZV1pbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsO1xuciYmcy5jb21wdXRlVGFuZ2VudHMoKTtxLnNraW4/cj1uZXcgVEhSRUUuU2tpbm5lZE1lc2gocyx0KTpxLm1vcnBoPyhyPW5ldyBUSFJFRS5Nb3JwaEFuaW1NZXNoKHMsdCksdm9pZCAwIT09cS5kdXJhdGlvbiYmKHIuZHVyYXRpb249cS5kdXJhdGlvbiksdm9pZCAwIT09cS50aW1lJiYoci50aW1lPXEudGltZSksdm9pZCAwIT09cS5taXJyb3JlZExvb3AmJihyLm1pcnJvcmVkTG9vcD1xLm1pcnJvcmVkTG9vcCksdC5tb3JwaE5vcm1hbHMmJnMuY29tcHV0ZU1vcnBoTm9ybWFscygpKTpyPW5ldyBUSFJFRS5NZXNoKHMsdCk7ci5uYW1lPXA7Yz8oci5tYXRyaXhBdXRvVXBkYXRlPSExLHIubWF0cml4LnNldChjWzBdLGNbMV0sY1syXSxjWzNdLGNbNF0sY1s1XSxjWzZdLGNbN10sY1s4XSxjWzldLGNbMTBdLGNbMTFdLGNbMTJdLGNbMTNdLGNbMTRdLGNbMTVdKSk6KHIucG9zaXRpb24uZnJvbUFycmF5KGgpLG0/ci5xdWF0ZXJuaW9uLmZyb21BcnJheShtKTpyLnJvdGF0aW9uLmZyb21BcnJheShpKSxcbnIuc2NhbGUuZnJvbUFycmF5KGspKTtyLnZpc2libGU9cS52aXNpYmxlO3IuY2FzdFNoYWRvdz1xLmNhc3RTaGFkb3c7ci5yZWNlaXZlU2hhZG93PXEucmVjZWl2ZVNoYWRvdzthLmFkZChyKTtBLm9iamVjdHNbcF09cn19ZWxzZVwiRGlyZWN0aW9uYWxMaWdodFwiPT09cS50eXBlfHxcIlBvaW50TGlnaHRcIj09PXEudHlwZXx8XCJBbWJpZW50TGlnaHRcIj09PXEudHlwZT8odz12b2lkIDAhPT1xLmNvbG9yP3EuY29sb3I6MTY3NzcyMTUsej12b2lkIDAhPT1xLmludGVuc2l0eT9xLmludGVuc2l0eToxLFwiRGlyZWN0aW9uYWxMaWdodFwiPT09cS50eXBlPyhoPXEuZGlyZWN0aW9uLHU9bmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQodyx6KSx1LnBvc2l0aW9uLmZyb21BcnJheShoKSxxLnRhcmdldCYmKE8ucHVzaCh7b2JqZWN0OnUsdGFyZ2V0TmFtZTpxLnRhcmdldH0pLHUudGFyZ2V0PW51bGwpKTpcIlBvaW50TGlnaHRcIj09PXEudHlwZT8oaD1xLnBvc2l0aW9uLGU9cS5kaXN0YW5jZSx1PW5ldyBUSFJFRS5Qb2ludExpZ2h0KHcsXG56LGUpLHUucG9zaXRpb24uZnJvbUFycmF5KGgpKTpcIkFtYmllbnRMaWdodFwiPT09cS50eXBlJiYodT1uZXcgVEhSRUUuQW1iaWVudExpZ2h0KHcpKSxhLmFkZCh1KSx1Lm5hbWU9cCxBLmxpZ2h0c1twXT11LEEub2JqZWN0c1twXT11KTpcIlBlcnNwZWN0aXZlQ2FtZXJhXCI9PT1xLnR5cGV8fFwiT3J0aG9ncmFwaGljQ2FtZXJhXCI9PT1xLnR5cGU/KGg9cS5wb3NpdGlvbixpPXEucm90YXRpb24sbT1xLnF1YXRlcm5pb24sXCJQZXJzcGVjdGl2ZUNhbWVyYVwiPT09cS50eXBlP249bmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKHEuZm92LHEuYXNwZWN0LHEubmVhcixxLmZhcik6XCJPcnRob2dyYXBoaWNDYW1lcmFcIj09PXEudHlwZSYmKG49bmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYShxLmxlZnQscS5yaWdodCxxLnRvcCxxLmJvdHRvbSxxLm5lYXIscS5mYXIpKSxuLm5hbWU9cCxuLnBvc2l0aW9uLmZyb21BcnJheShoKSx2b2lkIDAhPT1tP24ucXVhdGVybmlvbi5mcm9tQXJyYXkobSk6XG52b2lkIDAhPT1pJiZuLnJvdGF0aW9uLmZyb21BcnJheShpKSxhLmFkZChuKSxBLmNhbWVyYXNbcF09bixBLm9iamVjdHNbcF09bik6KGg9cS5wb3NpdGlvbixpPXEucm90YXRpb24saz1xLnNjYWxlLG09cS5xdWF0ZXJuaW9uLHI9bmV3IFRIUkVFLk9iamVjdDNELHIubmFtZT1wLHIucG9zaXRpb24uZnJvbUFycmF5KGgpLG0/ci5xdWF0ZXJuaW9uLmZyb21BcnJheShtKTpyLnJvdGF0aW9uLmZyb21BcnJheShpKSxyLnNjYWxlLmZyb21BcnJheShrKSxyLnZpc2libGU9dm9pZCAwIT09cS52aXNpYmxlP3EudmlzaWJsZTohMSxhLmFkZChyKSxBLm9iamVjdHNbcF09cixBLmVtcHRpZXNbcF09cik7aWYocil7aWYodm9pZCAwIT09cS51c2VyRGF0YSlmb3IodmFyIEQgaW4gcS51c2VyRGF0YSlyLnVzZXJEYXRhW0RdPXEudXNlckRhdGFbRF07aWYodm9pZCAwIT09cS5ncm91cHMpZm9yKGU9MDtlPHEuZ3JvdXBzLmxlbmd0aDtlKyspaD1xLmdyb3Vwc1tlXSx2b2lkIDA9PT1BLmdyb3Vwc1toXSYmXG4oQS5ncm91cHNbaF09W10pLEEuZ3JvdXBzW2hdLnB1c2gocCl9fXZvaWQgMCE9PXImJnZvaWQgMCE9PXEuY2hpbGRyZW4mJmYocixxLmNoaWxkcmVuKX19ZnVuY3Rpb24gaChhKXtyZXR1cm4gZnVuY3Rpb24oYixjKXtiLm5hbWU9YTtBLmdlb21ldHJpZXNbYV09YjtBLmZhY2VfbWF0ZXJpYWxzW2FdPWM7ZSgpO0ItPTE7bC5vbkxvYWRDb21wbGV0ZSgpO2soKX19ZnVuY3Rpb24gZyhhLGIsYyxkKXtyZXR1cm4gZnVuY3Rpb24oZil7dmFyIGY9Zi5jb250ZW50P2YuY29udGVudDpmLmRhZT9mLnNjZW5lOmYsaD1kLnJvdGF0aW9uLGc9ZC5xdWF0ZXJuaW9uLGk9ZC5zY2FsZTtmLnBvc2l0aW9uLmZyb21BcnJheShkLnBvc2l0aW9uKTtnP2YucXVhdGVybmlvbi5mcm9tQXJyYXkoZyk6Zi5yb3RhdGlvbi5mcm9tQXJyYXkoaCk7Zi5zY2FsZS5mcm9tQXJyYXkoaSk7YyYmZi50cmF2ZXJzZShmdW5jdGlvbihhKXthLm1hdGVyaWFsPWN9KTt2YXIgbT12b2lkIDAhPT1kLnZpc2libGU/ZC52aXNpYmxlOlxuITA7Zi50cmF2ZXJzZShmdW5jdGlvbihhKXthLnZpc2libGU9bX0pO2IuYWRkKGYpO2YubmFtZT1hO0Eub2JqZWN0c1thXT1mO2UoKTtCLT0xO2wub25Mb2FkQ29tcGxldGUoKTtrKCl9fWZ1bmN0aW9uIGkoYSl7cmV0dXJuIGZ1bmN0aW9uKGIsYyl7Yi5uYW1lPWE7QS5nZW9tZXRyaWVzW2FdPWI7QS5mYWNlX21hdGVyaWFsc1thXT1jfX1mdW5jdGlvbiBrKCl7bC5jYWxsYmFja1Byb2dyZXNzKHt0b3RhbE1vZGVsczp4LHRvdGFsVGV4dHVyZXM6Rixsb2FkZWRNb2RlbHM6eC1CLGxvYWRlZFRleHR1cmVzOkYtRH0sQSk7bC5vbkxvYWRQcm9ncmVzcygpO2lmKDA9PT1CJiYwPT09RCl7Zm9yKHZhciBhPTA7YTxPLmxlbmd0aDthKyspe3ZhciBjPU9bYV0sZD1BLm9iamVjdHNbYy50YXJnZXROYW1lXTtkP2Mub2JqZWN0LnRhcmdldD1kOihjLm9iamVjdC50YXJnZXQ9bmV3IFRIUkVFLk9iamVjdDNELEEuc2NlbmUuYWRkKGMub2JqZWN0LnRhcmdldCkpO2Mub2JqZWN0LnRhcmdldC51c2VyRGF0YS50YXJnZXRJbnZlcnNlPVxuYy5vYmplY3R9YihBKX19ZnVuY3Rpb24gbShhLGIpe2IoYSk7aWYodm9pZCAwIT09YS5jaGlsZHJlbilmb3IodmFyIGMgaW4gYS5jaGlsZHJlbiltKGEuY2hpbGRyZW5bY10sYil9dmFyIGw9dGhpcyxwPVRIUkVFLkxvYWRlci5wcm90b3R5cGUuZXh0cmFjdFVybEJhc2UoYykscyx0LG4scixxLHUsdyx6LEIsRCx4LEYsQSxPPVtdLEM9YSxFO2ZvcihFIGluIHRoaXMuZ2VvbWV0cnlIYW5kbGVycylhPXRoaXMuZ2VvbWV0cnlIYW5kbGVyc1tFXS5sb2FkZXJDbGFzcyx0aGlzLmdlb21ldHJ5SGFuZGxlcnNbRV0ubG9hZGVyT2JqZWN0PW5ldyBhO2ZvcihFIGluIHRoaXMuaGllcmFyY2h5SGFuZGxlcnMpYT10aGlzLmhpZXJhcmNoeUhhbmRsZXJzW0VdLmxvYWRlckNsYXNzLHRoaXMuaGllcmFyY2h5SGFuZGxlcnNbRV0ubG9hZGVyT2JqZWN0PW5ldyBhO0Q9Qj0wO0E9e3NjZW5lOm5ldyBUSFJFRS5TY2VuZSxnZW9tZXRyaWVzOnt9LGZhY2VfbWF0ZXJpYWxzOnt9LG1hdGVyaWFsczp7fSx0ZXh0dXJlczp7fSxcbm9iamVjdHM6e30sY2FtZXJhczp7fSxsaWdodHM6e30sZm9nczp7fSxlbXB0aWVzOnt9LGdyb3Vwczp7fX07aWYoQy50cmFuc2Zvcm0mJihFPUMudHJhbnNmb3JtLnBvc2l0aW9uLGE9Qy50cmFuc2Zvcm0ucm90YXRpb24sYz1DLnRyYW5zZm9ybS5zY2FsZSxFJiZBLnNjZW5lLnBvc2l0aW9uLmZyb21BcnJheShFKSxhJiZBLnNjZW5lLnJvdGF0aW9uLmZyb21BcnJheShhKSxjJiZBLnNjZW5lLnNjYWxlLmZyb21BcnJheShjKSxFfHxhfHxjKSlBLnNjZW5lLnVwZGF0ZU1hdHJpeCgpLEEuc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtFPWZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbigpe0QtPWE7aygpO2wub25Mb2FkQ29tcGxldGUoKX19O2Zvcih2YXIgSSBpbiBDLmZvZ3MpYT1DLmZvZ3NbSV0sXCJsaW5lYXJcIj09PWEudHlwZT9yPW5ldyBUSFJFRS5Gb2coMCxhLm5lYXIsYS5mYXIpOlwiZXhwMlwiPT09YS50eXBlJiYocj1uZXcgVEhSRUUuRm9nRXhwMigwLGEuZGVuc2l0eSkpLGE9YS5jb2xvcixcbnIuY29sb3Iuc2V0UkdCKGFbMF0sYVsxXSxhWzJdKSxBLmZvZ3NbSV09cjtmb3IodmFyIHkgaW4gQy5nZW9tZXRyaWVzKXI9Qy5nZW9tZXRyaWVzW3ldLHIudHlwZSBpbiB0aGlzLmdlb21ldHJ5SGFuZGxlcnMmJihCKz0xLGwub25Mb2FkU3RhcnQoKSk7Zm9yKHZhciB2IGluIEMub2JqZWN0cyltKEMub2JqZWN0c1t2XSxmdW5jdGlvbihhKXthLnR5cGUmJmEudHlwZSBpbiBsLmhpZXJhcmNoeUhhbmRsZXJzJiYoQis9MSxsLm9uTG9hZFN0YXJ0KCkpfSk7eD1CO2Zvcih5IGluIEMuZ2VvbWV0cmllcylpZihyPUMuZ2VvbWV0cmllc1t5XSxcImN1YmVcIj09PXIudHlwZSlzPW5ldyBUSFJFRS5DdWJlR2VvbWV0cnkoci53aWR0aCxyLmhlaWdodCxyLmRlcHRoLHIud2lkdGhTZWdtZW50cyxyLmhlaWdodFNlZ21lbnRzLHIuZGVwdGhTZWdtZW50cykscy5uYW1lPXksQS5nZW9tZXRyaWVzW3ldPXM7ZWxzZSBpZihcInBsYW5lXCI9PT1yLnR5cGUpcz1uZXcgVEhSRUUuUGxhbmVHZW9tZXRyeShyLndpZHRoLFxuci5oZWlnaHQsci53aWR0aFNlZ21lbnRzLHIuaGVpZ2h0U2VnbWVudHMpLHMubmFtZT15LEEuZ2VvbWV0cmllc1t5XT1zO2Vsc2UgaWYoXCJzcGhlcmVcIj09PXIudHlwZSlzPW5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShyLnJhZGl1cyxyLndpZHRoU2VnbWVudHMsci5oZWlnaHRTZWdtZW50cykscy5uYW1lPXksQS5nZW9tZXRyaWVzW3ldPXM7ZWxzZSBpZihcImN5bGluZGVyXCI9PT1yLnR5cGUpcz1uZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeShyLnRvcFJhZCxyLmJvdFJhZCxyLmhlaWdodCxyLnJhZFNlZ3Msci5oZWlnaHRTZWdzKSxzLm5hbWU9eSxBLmdlb21ldHJpZXNbeV09cztlbHNlIGlmKFwidG9ydXNcIj09PXIudHlwZSlzPW5ldyBUSFJFRS5Ub3J1c0dlb21ldHJ5KHIucmFkaXVzLHIudHViZSxyLnNlZ21lbnRzUixyLnNlZ21lbnRzVCkscy5uYW1lPXksQS5nZW9tZXRyaWVzW3ldPXM7ZWxzZSBpZihcImljb3NhaGVkcm9uXCI9PT1yLnR5cGUpcz1uZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeShyLnJhZGl1cyxcbnIuc3ViZGl2aXNpb25zKSxzLm5hbWU9eSxBLmdlb21ldHJpZXNbeV09cztlbHNlIGlmKHIudHlwZSBpbiB0aGlzLmdlb21ldHJ5SGFuZGxlcnMpe3Y9e307Zm9yKHEgaW4gcilcInR5cGVcIiE9PXEmJlwidXJsXCIhPT1xJiYodltxXT1yW3FdKTt0aGlzLmdlb21ldHJ5SGFuZGxlcnNbci50eXBlXS5sb2FkZXJPYmplY3QubG9hZChkKHIudXJsLEMudXJsQmFzZVR5cGUpLGgoeSksdil9ZWxzZVwiZW1iZWRkZWRcIj09PXIudHlwZSYmKHY9Qy5lbWJlZHNbci5pZF0sdi5tZXRhZGF0YT1DLm1ldGFkYXRhLHYmJih2PXRoaXMuZ2VvbWV0cnlIYW5kbGVycy5hc2NpaS5sb2FkZXJPYmplY3QucGFyc2UodixcIlwiKSxpKHkpKHYuZ2VvbWV0cnksdi5tYXRlcmlhbHMpKSk7Zm9yKHZhciBHIGluIEMudGV4dHVyZXMpaWYoeT1DLnRleHR1cmVzW0ddLHkudXJsIGluc3RhbmNlb2YgQXJyYXkpe0QrPXkudXJsLmxlbmd0aDtmb3IocT0wO3E8eS51cmwubGVuZ3RoO3ErKylsLm9uTG9hZFN0YXJ0KCl9ZWxzZSBEKz1cbjEsbC5vbkxvYWRTdGFydCgpO0Y9RDtmb3IoRyBpbiBDLnRleHR1cmVzKXt5PUMudGV4dHVyZXNbR107dm9pZCAwIT09eS5tYXBwaW5nJiZ2b2lkIDAhPT1USFJFRVt5Lm1hcHBpbmddJiYoeS5tYXBwaW5nPW5ldyBUSFJFRVt5Lm1hcHBpbmddKTtpZih5LnVybCBpbnN0YW5jZW9mIEFycmF5KXt2PXkudXJsLmxlbmd0aDtyPVtdO2ZvcihxPTA7cTx2O3ErKylyW3FdPWQoeS51cmxbcV0sQy51cmxCYXNlVHlwZSk7cT0ocT0vXFwuZGRzJC9pLnRlc3QoclswXSkpP1RIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZShyLHkubWFwcGluZyxFKHYpKTpUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlQ3ViZShyLHkubWFwcGluZyxFKHYpKX1lbHNlIHE9L1xcLmRkcyQvaS50ZXN0KHkudXJsKSx2PWQoeS51cmwsQy51cmxCYXNlVHlwZSkscj1FKDEpLHE9cT9USFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZSh2LHkubWFwcGluZyxyKTpUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlKHYsXG55Lm1hcHBpbmcsciksdm9pZCAwIT09VEhSRUVbeS5taW5GaWx0ZXJdJiYocS5taW5GaWx0ZXI9VEhSRUVbeS5taW5GaWx0ZXJdKSx2b2lkIDAhPT1USFJFRVt5Lm1hZ0ZpbHRlcl0mJihxLm1hZ0ZpbHRlcj1USFJFRVt5Lm1hZ0ZpbHRlcl0pLHkuYW5pc290cm9weSYmKHEuYW5pc290cm9weT15LmFuaXNvdHJvcHkpLHkucmVwZWF0JiYocS5yZXBlYXQuc2V0KHkucmVwZWF0WzBdLHkucmVwZWF0WzFdKSwxIT09eS5yZXBlYXRbMF0mJihxLndyYXBTPVRIUkVFLlJlcGVhdFdyYXBwaW5nKSwxIT09eS5yZXBlYXRbMV0mJihxLndyYXBUPVRIUkVFLlJlcGVhdFdyYXBwaW5nKSkseS5vZmZzZXQmJnEub2Zmc2V0LnNldCh5Lm9mZnNldFswXSx5Lm9mZnNldFsxXSkseS53cmFwJiYodj17cmVwZWF0OlRIUkVFLlJlcGVhdFdyYXBwaW5nLG1pcnJvcjpUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nfSx2b2lkIDAhPT12W3kud3JhcFswXV0mJihxLndyYXBTPXZbeS53cmFwWzBdXSksdm9pZCAwIT09XG52W3kud3JhcFsxXV0mJihxLndyYXBUPXZbeS53cmFwWzFdXSkpO0EudGV4dHVyZXNbR109cX12YXIgUixKO2ZvcihSIGluIEMubWF0ZXJpYWxzKXtHPUMubWF0ZXJpYWxzW1JdO2ZvcihKIGluIEcucGFyYW1ldGVycylcImVudk1hcFwiPT09Snx8XCJtYXBcIj09PUp8fFwibGlnaHRNYXBcIj09PUp8fFwiYnVtcE1hcFwiPT09Sj9HLnBhcmFtZXRlcnNbSl09QS50ZXh0dXJlc1tHLnBhcmFtZXRlcnNbSl1dOlwic2hhZGluZ1wiPT09Sj9HLnBhcmFtZXRlcnNbSl09XCJmbGF0XCI9PT1HLnBhcmFtZXRlcnNbSl0/VEhSRUUuRmxhdFNoYWRpbmc6VEhSRUUuU21vb3RoU2hhZGluZzpcInNpZGVcIj09PUo/Ry5wYXJhbWV0ZXJzW0pdPVwiZG91YmxlXCI9PUcucGFyYW1ldGVyc1tKXT9USFJFRS5Eb3VibGVTaWRlOlwiYmFja1wiPT1HLnBhcmFtZXRlcnNbSl0/VEhSRUUuQmFja1NpZGU6VEhSRUUuRnJvbnRTaWRlOlwiYmxlbmRpbmdcIj09PUo/Ry5wYXJhbWV0ZXJzW0pdPUcucGFyYW1ldGVyc1tKXWluIFRIUkVFP1RIUkVFW0cucGFyYW1ldGVyc1tKXV06XG5USFJFRS5Ob3JtYWxCbGVuZGluZzpcImNvbWJpbmVcIj09PUo/Ry5wYXJhbWV0ZXJzW0pdPUcucGFyYW1ldGVyc1tKXWluIFRIUkVFP1RIUkVFW0cucGFyYW1ldGVyc1tKXV06VEhSRUUuTXVsdGlwbHlPcGVyYXRpb246XCJ2ZXJ0ZXhDb2xvcnNcIj09PUo/XCJmYWNlXCI9PUcucGFyYW1ldGVyc1tKXT9HLnBhcmFtZXRlcnNbSl09VEhSRUUuRmFjZUNvbG9yczpHLnBhcmFtZXRlcnNbSl0mJihHLnBhcmFtZXRlcnNbSl09VEhSRUUuVmVydGV4Q29sb3JzKTpcIndyYXBSR0JcIj09PUomJihFPUcucGFyYW1ldGVyc1tKXSxHLnBhcmFtZXRlcnNbSl09bmV3IFRIUkVFLlZlY3RvcjMoRVswXSxFWzFdLEVbMl0pKTt2b2lkIDAhPT1HLnBhcmFtZXRlcnMub3BhY2l0eSYmMT5HLnBhcmFtZXRlcnMub3BhY2l0eSYmKEcucGFyYW1ldGVycy50cmFuc3BhcmVudD0hMCk7Ry5wYXJhbWV0ZXJzLm5vcm1hbE1hcD8oRT1USFJFRS5TaGFkZXJMaWIubm9ybWFsbWFwLHk9VEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZShFLnVuaWZvcm1zKSxcbnE9Ry5wYXJhbWV0ZXJzLmNvbG9yLHY9Ry5wYXJhbWV0ZXJzLnNwZWN1bGFyLHI9Ry5wYXJhbWV0ZXJzLmFtYmllbnQsST1HLnBhcmFtZXRlcnMuc2hpbmluZXNzLHkudE5vcm1hbC52YWx1ZT1BLnRleHR1cmVzW0cucGFyYW1ldGVycy5ub3JtYWxNYXBdLEcucGFyYW1ldGVycy5ub3JtYWxTY2FsZSYmeS51Tm9ybWFsU2NhbGUudmFsdWUuc2V0KEcucGFyYW1ldGVycy5ub3JtYWxTY2FsZVswXSxHLnBhcmFtZXRlcnMubm9ybWFsU2NhbGVbMV0pLEcucGFyYW1ldGVycy5tYXAmJih5LnREaWZmdXNlLnZhbHVlPUcucGFyYW1ldGVycy5tYXAseS5lbmFibGVEaWZmdXNlLnZhbHVlPSEwKSxHLnBhcmFtZXRlcnMuZW52TWFwJiYoeS50Q3ViZS52YWx1ZT1HLnBhcmFtZXRlcnMuZW52TWFwLHkuZW5hYmxlUmVmbGVjdGlvbi52YWx1ZT0hMCx5LnVSZWZsZWN0aXZpdHkudmFsdWU9Ry5wYXJhbWV0ZXJzLnJlZmxlY3Rpdml0eSksRy5wYXJhbWV0ZXJzLmxpZ2h0TWFwJiYoeS50QU8udmFsdWU9Ry5wYXJhbWV0ZXJzLmxpZ2h0TWFwLFxueS5lbmFibGVBTy52YWx1ZT0hMCksRy5wYXJhbWV0ZXJzLnNwZWN1bGFyTWFwJiYoeS50U3BlY3VsYXIudmFsdWU9QS50ZXh0dXJlc1tHLnBhcmFtZXRlcnMuc3BlY3VsYXJNYXBdLHkuZW5hYmxlU3BlY3VsYXIudmFsdWU9ITApLEcucGFyYW1ldGVycy5kaXNwbGFjZW1lbnRNYXAmJih5LnREaXNwbGFjZW1lbnQudmFsdWU9QS50ZXh0dXJlc1tHLnBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwXSx5LmVuYWJsZURpc3BsYWNlbWVudC52YWx1ZT0hMCx5LnVEaXNwbGFjZW1lbnRCaWFzLnZhbHVlPUcucGFyYW1ldGVycy5kaXNwbGFjZW1lbnRCaWFzLHkudURpc3BsYWNlbWVudFNjYWxlLnZhbHVlPUcucGFyYW1ldGVycy5kaXNwbGFjZW1lbnRTY2FsZSkseS51RGlmZnVzZUNvbG9yLnZhbHVlLnNldEhleChxKSx5LnVTcGVjdWxhckNvbG9yLnZhbHVlLnNldEhleCh2KSx5LnVBbWJpZW50Q29sb3IudmFsdWUuc2V0SGV4KHIpLHkudVNoaW5pbmVzcy52YWx1ZT1JLEcucGFyYW1ldGVycy5vcGFjaXR5JiZcbih5LnVPcGFjaXR5LnZhbHVlPUcucGFyYW1ldGVycy5vcGFjaXR5KSx0PW5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7ZnJhZ21lbnRTaGFkZXI6RS5mcmFnbWVudFNoYWRlcix2ZXJ0ZXhTaGFkZXI6RS52ZXJ0ZXhTaGFkZXIsdW5pZm9ybXM6eSxsaWdodHM6ITAsZm9nOiEwfSkpOnQ9bmV3IFRIUkVFW0cudHlwZV0oRy5wYXJhbWV0ZXJzKTt0Lm5hbWU9UjtBLm1hdGVyaWFsc1tSXT10fWZvcihSIGluIEMubWF0ZXJpYWxzKWlmKEc9Qy5tYXRlcmlhbHNbUl0sRy5wYXJhbWV0ZXJzLm1hdGVyaWFscyl7Sj1bXTtmb3IocT0wO3E8Ry5wYXJhbWV0ZXJzLm1hdGVyaWFscy5sZW5ndGg7cSsrKUoucHVzaChBLm1hdGVyaWFsc1tHLnBhcmFtZXRlcnMubWF0ZXJpYWxzW3FdXSk7QS5tYXRlcmlhbHNbUl0ubWF0ZXJpYWxzPUp9ZSgpO0EuY2FtZXJhcyYmQy5kZWZhdWx0cy5jYW1lcmEmJihBLmN1cnJlbnRDYW1lcmE9QS5jYW1lcmFzW0MuZGVmYXVsdHMuY2FtZXJhXSk7QS5mb2dzJiZDLmRlZmF1bHRzLmZvZyYmXG4oQS5zY2VuZS5mb2c9QS5mb2dzW0MuZGVmYXVsdHMuZm9nXSk7bC5jYWxsYmFja1N5bmMoQSk7aygpfX07VEhSRUUuVGV4dHVyZUxvYWRlcj1mdW5jdGlvbihhKXt0aGlzLm1hbmFnZXI9dm9pZCAwIT09YT9hOlRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcn07VEhSRUUuVGV4dHVyZUxvYWRlci5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOlRIUkVFLlRleHR1cmVMb2FkZXIsbG9hZDpmdW5jdGlvbihhLGIpe3ZhciBjPW5ldyBUSFJFRS5JbWFnZUxvYWRlcih0aGlzLm1hbmFnZXIpO2Muc2V0Q3Jvc3NPcmlnaW4odGhpcy5jcm9zc09yaWdpbik7Yy5sb2FkKGEsZnVuY3Rpb24oYSl7YT1uZXcgVEhSRUUuVGV4dHVyZShhKTthLm5lZWRzVXBkYXRlPSEwO3ZvaWQgMCE9PWImJmIoYSl9KX0sc2V0Q3Jvc3NPcmlnaW46ZnVuY3Rpb24oYSl7dGhpcy5jcm9zc09yaWdpbj1hfX07VEhSRUUuTWF0ZXJpYWw9ZnVuY3Rpb24oKXt0aGlzLmlkPVRIUkVFLk1hdGVyaWFsSWRDb3VudCsrO3RoaXMudXVpZD1USFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO3RoaXMubmFtZT1cIlwiO3RoaXMuc2lkZT1USFJFRS5Gcm9udFNpZGU7dGhpcy5vcGFjaXR5PTE7dGhpcy50cmFuc3BhcmVudD0hMTt0aGlzLmJsZW5kaW5nPVRIUkVFLk5vcm1hbEJsZW5kaW5nO3RoaXMuYmxlbmRTcmM9VEhSRUUuU3JjQWxwaGFGYWN0b3I7dGhpcy5ibGVuZERzdD1USFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yO3RoaXMuYmxlbmRFcXVhdGlvbj1USFJFRS5BZGRFcXVhdGlvbjt0aGlzLmRlcHRoV3JpdGU9dGhpcy5kZXB0aFRlc3Q9ITA7dGhpcy5wb2x5Z29uT2Zmc2V0PSExO3RoaXMub3ZlcmRyYXc9dGhpcy5hbHBoYVRlc3Q9dGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHM9dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yPTA7dGhpcy5uZWVkc1VwZGF0ZT10aGlzLnZpc2libGU9ITB9O1xuVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5NYXRlcmlhbCxzZXRWYWx1ZXM6ZnVuY3Rpb24oYSl7aWYodm9pZCAwIT09YSlmb3IodmFyIGIgaW4gYSl7dmFyIGM9YVtiXTtpZih2b2lkIDA9PT1jKWNvbnNvbGUud2FybihcIlRIUkVFLk1hdGVyaWFsOiAnXCIrYitcIicgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZC5cIik7ZWxzZSBpZihiIGluIHRoaXMpe3ZhciBkPXRoaXNbYl07ZCBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yP2Quc2V0KGMpOmQgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzJiZjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMz9kLmNvcHkoYyk6dGhpc1tiXT1cIm92ZXJkcmF3XCI9PWI/TnVtYmVyKGMpOmN9fX0sY2xvbmU6ZnVuY3Rpb24oYSl7dm9pZCAwPT09YSYmKGE9bmV3IFRIUkVFLk1hdGVyaWFsKTthLm5hbWU9dGhpcy5uYW1lO2Euc2lkZT10aGlzLnNpZGU7YS5vcGFjaXR5PXRoaXMub3BhY2l0eTthLnRyYW5zcGFyZW50PXRoaXMudHJhbnNwYXJlbnQ7XG5hLmJsZW5kaW5nPXRoaXMuYmxlbmRpbmc7YS5ibGVuZFNyYz10aGlzLmJsZW5kU3JjO2EuYmxlbmREc3Q9dGhpcy5ibGVuZERzdDthLmJsZW5kRXF1YXRpb249dGhpcy5ibGVuZEVxdWF0aW9uO2EuZGVwdGhUZXN0PXRoaXMuZGVwdGhUZXN0O2EuZGVwdGhXcml0ZT10aGlzLmRlcHRoV3JpdGU7YS5wb2x5Z29uT2Zmc2V0PXRoaXMucG9seWdvbk9mZnNldDthLnBvbHlnb25PZmZzZXRGYWN0b3I9dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yO2EucG9seWdvbk9mZnNldFVuaXRzPXRoaXMucG9seWdvbk9mZnNldFVuaXRzO2EuYWxwaGFUZXN0PXRoaXMuYWxwaGFUZXN0O2Eub3ZlcmRyYXc9dGhpcy5vdmVyZHJhdzthLnZpc2libGU9dGhpcy52aXNpYmxlO3JldHVybiBhfSxkaXNwb3NlOmZ1bmN0aW9uKCl7dGhpcy5kaXNwYXRjaEV2ZW50KHt0eXBlOlwiZGlzcG9zZVwifSl9fTtUSFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSk7XG5USFJFRS5NYXRlcmlhbElkQ291bnQ9MDtUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbD1mdW5jdGlvbihhKXtUSFJFRS5NYXRlcmlhbC5jYWxsKHRoaXMpO3RoaXMuY29sb3I9bmV3IFRIUkVFLkNvbG9yKDE2Nzc3MjE1KTt0aGlzLmxpbmV3aWR0aD0xO3RoaXMubGluZWpvaW49dGhpcy5saW5lY2FwPVwicm91bmRcIjt0aGlzLnZlcnRleENvbG9ycz0hMTt0aGlzLmZvZz0hMDt0aGlzLnNldFZhbHVlcyhhKX07VEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlKTtcblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbDtUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO2EuY29sb3IuY29weSh0aGlzLmNvbG9yKTthLmxpbmV3aWR0aD10aGlzLmxpbmV3aWR0aDthLmxpbmVjYXA9dGhpcy5saW5lY2FwO2EubGluZWpvaW49dGhpcy5saW5lam9pbjthLnZlcnRleENvbG9ycz10aGlzLnZlcnRleENvbG9yczthLmZvZz10aGlzLmZvZztyZXR1cm4gYX07VEhSRUUuTGluZURhc2hlZE1hdGVyaWFsPWZ1bmN0aW9uKGEpe1RIUkVFLk1hdGVyaWFsLmNhbGwodGhpcyk7dGhpcy5jb2xvcj1uZXcgVEhSRUUuQ29sb3IoMTY3NzcyMTUpO3RoaXMuc2NhbGU9dGhpcy5saW5ld2lkdGg9MTt0aGlzLmRhc2hTaXplPTM7dGhpcy5nYXBTaXplPTE7dGhpcy52ZXJ0ZXhDb2xvcnM9ITE7dGhpcy5mb2c9ITA7dGhpcy5zZXRWYWx1ZXMoYSl9O1RIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUpO1xuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWw7VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyxhKTthLmNvbG9yLmNvcHkodGhpcy5jb2xvcik7YS5saW5ld2lkdGg9dGhpcy5saW5ld2lkdGg7YS5zY2FsZT10aGlzLnNjYWxlO2EuZGFzaFNpemU9dGhpcy5kYXNoU2l6ZTthLmdhcFNpemU9dGhpcy5nYXBTaXplO2EudmVydGV4Q29sb3JzPXRoaXMudmVydGV4Q29sb3JzO2EuZm9nPXRoaXMuZm9nO3JldHVybiBhfTtUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbD1mdW5jdGlvbihhKXtUSFJFRS5NYXRlcmlhbC5jYWxsKHRoaXMpO3RoaXMuY29sb3I9bmV3IFRIUkVFLkNvbG9yKDE2Nzc3MjE1KTt0aGlzLmVudk1hcD10aGlzLnNwZWN1bGFyTWFwPXRoaXMubGlnaHRNYXA9dGhpcy5tYXA9bnVsbDt0aGlzLmNvbWJpbmU9VEhSRUUuTXVsdGlwbHlPcGVyYXRpb247dGhpcy5yZWZsZWN0aXZpdHk9MTt0aGlzLnJlZnJhY3Rpb25SYXRpbz0wLjk4O3RoaXMuZm9nPSEwO3RoaXMuc2hhZGluZz1USFJFRS5TbW9vdGhTaGFkaW5nO3RoaXMud2lyZWZyYW1lPSExO3RoaXMud2lyZWZyYW1lTGluZXdpZHRoPTE7dGhpcy53aXJlZnJhbWVMaW5lam9pbj10aGlzLndpcmVmcmFtZUxpbmVjYXA9XCJyb3VuZFwiO3RoaXMudmVydGV4Q29sb3JzPVRIUkVFLk5vQ29sb3JzO3RoaXMubW9ycGhUYXJnZXRzPXRoaXMuc2tpbm5pbmc9ITE7dGhpcy5zZXRWYWx1ZXMoYSl9O1xuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlKTtcblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbDtUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO2EuY29sb3IuY29weSh0aGlzLmNvbG9yKTthLm1hcD10aGlzLm1hcDthLmxpZ2h0TWFwPXRoaXMubGlnaHRNYXA7YS5zcGVjdWxhck1hcD10aGlzLnNwZWN1bGFyTWFwO2EuZW52TWFwPXRoaXMuZW52TWFwO2EuY29tYmluZT10aGlzLmNvbWJpbmU7YS5yZWZsZWN0aXZpdHk9dGhpcy5yZWZsZWN0aXZpdHk7YS5yZWZyYWN0aW9uUmF0aW89dGhpcy5yZWZyYWN0aW9uUmF0aW87YS5mb2c9dGhpcy5mb2c7YS5zaGFkaW5nPXRoaXMuc2hhZGluZzthLndpcmVmcmFtZT10aGlzLndpcmVmcmFtZTthLndpcmVmcmFtZUxpbmV3aWR0aD10aGlzLndpcmVmcmFtZUxpbmV3aWR0aDthLndpcmVmcmFtZUxpbmVjYXA9dGhpcy53aXJlZnJhbWVMaW5lY2FwO2Eud2lyZWZyYW1lTGluZWpvaW49XG50aGlzLndpcmVmcmFtZUxpbmVqb2luO2EudmVydGV4Q29sb3JzPXRoaXMudmVydGV4Q29sb3JzO2Euc2tpbm5pbmc9dGhpcy5za2lubmluZzthLm1vcnBoVGFyZ2V0cz10aGlzLm1vcnBoVGFyZ2V0cztyZXR1cm4gYX07VEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbD1mdW5jdGlvbihhKXtUSFJFRS5NYXRlcmlhbC5jYWxsKHRoaXMpO3RoaXMuY29sb3I9bmV3IFRIUkVFLkNvbG9yKDE2Nzc3MjE1KTt0aGlzLmFtYmllbnQ9bmV3IFRIUkVFLkNvbG9yKDE2Nzc3MjE1KTt0aGlzLmVtaXNzaXZlPW5ldyBUSFJFRS5Db2xvcigwKTt0aGlzLndyYXBBcm91bmQ9ITE7dGhpcy53cmFwUkdCPW5ldyBUSFJFRS5WZWN0b3IzKDEsMSwxKTt0aGlzLmVudk1hcD10aGlzLnNwZWN1bGFyTWFwPXRoaXMubGlnaHRNYXA9dGhpcy5tYXA9bnVsbDt0aGlzLmNvbWJpbmU9VEhSRUUuTXVsdGlwbHlPcGVyYXRpb247dGhpcy5yZWZsZWN0aXZpdHk9MTt0aGlzLnJlZnJhY3Rpb25SYXRpbz0wLjk4O3RoaXMuZm9nPSEwO3RoaXMuc2hhZGluZz1USFJFRS5TbW9vdGhTaGFkaW5nO3RoaXMud2lyZWZyYW1lPSExO3RoaXMud2lyZWZyYW1lTGluZXdpZHRoPTE7dGhpcy53aXJlZnJhbWVMaW5lam9pbj10aGlzLndpcmVmcmFtZUxpbmVjYXA9XG5cInJvdW5kXCI7dGhpcy52ZXJ0ZXhDb2xvcnM9VEhSRUUuTm9Db2xvcnM7dGhpcy5tb3JwaE5vcm1hbHM9dGhpcy5tb3JwaFRhcmdldHM9dGhpcy5za2lubmluZz0hMTt0aGlzLnNldFZhbHVlcyhhKX07VEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUpO1xuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbDtUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO2EuY29sb3IuY29weSh0aGlzLmNvbG9yKTthLmFtYmllbnQuY29weSh0aGlzLmFtYmllbnQpO2EuZW1pc3NpdmUuY29weSh0aGlzLmVtaXNzaXZlKTthLndyYXBBcm91bmQ9dGhpcy53cmFwQXJvdW5kO2Eud3JhcFJHQi5jb3B5KHRoaXMud3JhcFJHQik7YS5tYXA9dGhpcy5tYXA7YS5saWdodE1hcD10aGlzLmxpZ2h0TWFwO2Euc3BlY3VsYXJNYXA9dGhpcy5zcGVjdWxhck1hcDthLmVudk1hcD10aGlzLmVudk1hcDthLmNvbWJpbmU9dGhpcy5jb21iaW5lO2EucmVmbGVjdGl2aXR5PXRoaXMucmVmbGVjdGl2aXR5O2EucmVmcmFjdGlvblJhdGlvPXRoaXMucmVmcmFjdGlvblJhdGlvO2EuZm9nPXRoaXMuZm9nO2Euc2hhZGluZz10aGlzLnNoYWRpbmc7XG5hLndpcmVmcmFtZT10aGlzLndpcmVmcmFtZTthLndpcmVmcmFtZUxpbmV3aWR0aD10aGlzLndpcmVmcmFtZUxpbmV3aWR0aDthLndpcmVmcmFtZUxpbmVjYXA9dGhpcy53aXJlZnJhbWVMaW5lY2FwO2Eud2lyZWZyYW1lTGluZWpvaW49dGhpcy53aXJlZnJhbWVMaW5lam9pbjthLnZlcnRleENvbG9ycz10aGlzLnZlcnRleENvbG9yczthLnNraW5uaW5nPXRoaXMuc2tpbm5pbmc7YS5tb3JwaFRhcmdldHM9dGhpcy5tb3JwaFRhcmdldHM7YS5tb3JwaE5vcm1hbHM9dGhpcy5tb3JwaE5vcm1hbHM7cmV0dXJuIGF9O1RIUkVFLk1lc2hQaG9uZ01hdGVyaWFsPWZ1bmN0aW9uKGEpe1RIUkVFLk1hdGVyaWFsLmNhbGwodGhpcyk7dGhpcy5jb2xvcj1uZXcgVEhSRUUuQ29sb3IoMTY3NzcyMTUpO3RoaXMuYW1iaWVudD1uZXcgVEhSRUUuQ29sb3IoMTY3NzcyMTUpO3RoaXMuZW1pc3NpdmU9bmV3IFRIUkVFLkNvbG9yKDApO3RoaXMuc3BlY3VsYXI9bmV3IFRIUkVFLkNvbG9yKDExMTg0ODEpO3RoaXMuc2hpbmluZXNzPTMwO3RoaXMubWV0YWw9ITE7dGhpcy5wZXJQaXhlbD0hMDt0aGlzLndyYXBBcm91bmQ9ITE7dGhpcy53cmFwUkdCPW5ldyBUSFJFRS5WZWN0b3IzKDEsMSwxKTt0aGlzLmJ1bXBNYXA9dGhpcy5saWdodE1hcD10aGlzLm1hcD1udWxsO3RoaXMuYnVtcFNjYWxlPTE7dGhpcy5ub3JtYWxNYXA9bnVsbDt0aGlzLm5vcm1hbFNjYWxlPW5ldyBUSFJFRS5WZWN0b3IyKDEsMSk7dGhpcy5lbnZNYXA9dGhpcy5zcGVjdWxhck1hcD1udWxsO3RoaXMuY29tYmluZT1USFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcbnRoaXMucmVmbGVjdGl2aXR5PTE7dGhpcy5yZWZyYWN0aW9uUmF0aW89MC45ODt0aGlzLmZvZz0hMDt0aGlzLnNoYWRpbmc9VEhSRUUuU21vb3RoU2hhZGluZzt0aGlzLndpcmVmcmFtZT0hMTt0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD0xO3RoaXMud2lyZWZyYW1lTGluZWpvaW49dGhpcy53aXJlZnJhbWVMaW5lY2FwPVwicm91bmRcIjt0aGlzLnZlcnRleENvbG9ycz1USFJFRS5Ob0NvbG9yczt0aGlzLm1vcnBoTm9ybWFscz10aGlzLm1vcnBoVGFyZ2V0cz10aGlzLnNraW5uaW5nPSExO3RoaXMuc2V0VmFsdWVzKGEpfTtUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUpO1xuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsO1RIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7YS5jb2xvci5jb3B5KHRoaXMuY29sb3IpO2EuYW1iaWVudC5jb3B5KHRoaXMuYW1iaWVudCk7YS5lbWlzc2l2ZS5jb3B5KHRoaXMuZW1pc3NpdmUpO2Euc3BlY3VsYXIuY29weSh0aGlzLnNwZWN1bGFyKTthLnNoaW5pbmVzcz10aGlzLnNoaW5pbmVzczthLm1ldGFsPXRoaXMubWV0YWw7YS5wZXJQaXhlbD10aGlzLnBlclBpeGVsO2Eud3JhcEFyb3VuZD10aGlzLndyYXBBcm91bmQ7YS53cmFwUkdCLmNvcHkodGhpcy53cmFwUkdCKTthLm1hcD10aGlzLm1hcDthLmxpZ2h0TWFwPXRoaXMubGlnaHRNYXA7YS5idW1wTWFwPXRoaXMuYnVtcE1hcDthLmJ1bXBTY2FsZT10aGlzLmJ1bXBTY2FsZTthLm5vcm1hbE1hcD10aGlzLm5vcm1hbE1hcDthLm5vcm1hbFNjYWxlLmNvcHkodGhpcy5ub3JtYWxTY2FsZSk7XG5hLnNwZWN1bGFyTWFwPXRoaXMuc3BlY3VsYXJNYXA7YS5lbnZNYXA9dGhpcy5lbnZNYXA7YS5jb21iaW5lPXRoaXMuY29tYmluZTthLnJlZmxlY3Rpdml0eT10aGlzLnJlZmxlY3Rpdml0eTthLnJlZnJhY3Rpb25SYXRpbz10aGlzLnJlZnJhY3Rpb25SYXRpbzthLmZvZz10aGlzLmZvZzthLnNoYWRpbmc9dGhpcy5zaGFkaW5nO2Eud2lyZWZyYW1lPXRoaXMud2lyZWZyYW1lO2Eud2lyZWZyYW1lTGluZXdpZHRoPXRoaXMud2lyZWZyYW1lTGluZXdpZHRoO2Eud2lyZWZyYW1lTGluZWNhcD10aGlzLndpcmVmcmFtZUxpbmVjYXA7YS53aXJlZnJhbWVMaW5lam9pbj10aGlzLndpcmVmcmFtZUxpbmVqb2luO2EudmVydGV4Q29sb3JzPXRoaXMudmVydGV4Q29sb3JzO2Euc2tpbm5pbmc9dGhpcy5za2lubmluZzthLm1vcnBoVGFyZ2V0cz10aGlzLm1vcnBoVGFyZ2V0czthLm1vcnBoTm9ybWFscz10aGlzLm1vcnBoTm9ybWFscztyZXR1cm4gYX07VEhSRUUuTWVzaERlcHRoTWF0ZXJpYWw9ZnVuY3Rpb24oYSl7VEhSRUUuTWF0ZXJpYWwuY2FsbCh0aGlzKTt0aGlzLndpcmVmcmFtZT0hMTt0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD0xO3RoaXMuc2V0VmFsdWVzKGEpfTtUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUpO1RIUkVFLk1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbDtUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO2Eud2lyZWZyYW1lPXRoaXMud2lyZWZyYW1lO2Eud2lyZWZyYW1lTGluZXdpZHRoPXRoaXMud2lyZWZyYW1lTGluZXdpZHRoO3JldHVybiBhfTtUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWw9ZnVuY3Rpb24oYSl7VEhSRUUuTWF0ZXJpYWwuY2FsbCh0aGlzLGEpO3RoaXMuc2hhZGluZz1USFJFRS5GbGF0U2hhZGluZzt0aGlzLndpcmVmcmFtZT0hMTt0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD0xO3RoaXMubW9ycGhUYXJnZXRzPSExO3RoaXMuc2V0VmFsdWVzKGEpfTtUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlKTtUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbDtUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO2Euc2hhZGluZz10aGlzLnNoYWRpbmc7YS53aXJlZnJhbWU9dGhpcy53aXJlZnJhbWU7YS53aXJlZnJhbWVMaW5ld2lkdGg9dGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7cmV0dXJuIGF9O1RIUkVFLk1lc2hGYWNlTWF0ZXJpYWw9ZnVuY3Rpb24oYSl7dGhpcy5tYXRlcmlhbHM9YSBpbnN0YW5jZW9mIEFycmF5P2E6W119O1RIUkVFLk1lc2hGYWNlTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPW5ldyBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsLGI9MDtiPHRoaXMubWF0ZXJpYWxzLmxlbmd0aDtiKyspYS5tYXRlcmlhbHMucHVzaCh0aGlzLm1hdGVyaWFsc1tiXS5jbG9uZSgpKTtyZXR1cm4gYX07VEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbD1mdW5jdGlvbihhKXtUSFJFRS5NYXRlcmlhbC5jYWxsKHRoaXMpO3RoaXMuY29sb3I9bmV3IFRIUkVFLkNvbG9yKDE2Nzc3MjE1KTt0aGlzLm1hcD1udWxsO3RoaXMuc2l6ZT0xO3RoaXMuc2l6ZUF0dGVudWF0aW9uPSEwO3RoaXMudmVydGV4Q29sb3JzPSExO3RoaXMuZm9nPSEwO3RoaXMuc2V0VmFsdWVzKGEpfTtUSFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSk7XG5USFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsO1RIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7YS5jb2xvci5jb3B5KHRoaXMuY29sb3IpO2EubWFwPXRoaXMubWFwO2Euc2l6ZT10aGlzLnNpemU7YS5zaXplQXR0ZW51YXRpb249dGhpcy5zaXplQXR0ZW51YXRpb247YS52ZXJ0ZXhDb2xvcnM9dGhpcy52ZXJ0ZXhDb2xvcnM7YS5mb2c9dGhpcy5mb2c7cmV0dXJuIGF9O1RIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbD1USFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsO1RIUkVFLlNoYWRlck1hdGVyaWFsPWZ1bmN0aW9uKGEpe1RIUkVFLk1hdGVyaWFsLmNhbGwodGhpcyk7dGhpcy52ZXJ0ZXhTaGFkZXI9dGhpcy5mcmFnbWVudFNoYWRlcj1cInZvaWQgbWFpbigpIHt9XCI7dGhpcy51bmlmb3Jtcz17fTt0aGlzLmRlZmluZXM9e307dGhpcy5hdHRyaWJ1dGVzPW51bGw7dGhpcy5zaGFkaW5nPVRIUkVFLlNtb290aFNoYWRpbmc7dGhpcy5saW5ld2lkdGg9MTt0aGlzLndpcmVmcmFtZT0hMTt0aGlzLndpcmVmcmFtZUxpbmV3aWR0aD0xO3RoaXMubGlnaHRzPXRoaXMuZm9nPSExO3RoaXMudmVydGV4Q29sb3JzPVRIUkVFLk5vQ29sb3JzO3RoaXMubW9ycGhOb3JtYWxzPXRoaXMubW9ycGhUYXJnZXRzPXRoaXMuc2tpbm5pbmc9ITE7dGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzPXtjb2xvcjpbMSwxLDFdLHV2OlswLDBdLHV2MjpbMCwwXX07dGhpcy5pbmRleDBBdHRyaWJ1dGVOYW1lPVwicG9zaXRpb25cIjt0aGlzLnNldFZhbHVlcyhhKX07XG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUpO1xuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsO1RIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7YS5mcmFnbWVudFNoYWRlcj10aGlzLmZyYWdtZW50U2hhZGVyO2EudmVydGV4U2hhZGVyPXRoaXMudmVydGV4U2hhZGVyO2EudW5pZm9ybXM9VEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSh0aGlzLnVuaWZvcm1zKTthLmF0dHJpYnV0ZXM9dGhpcy5hdHRyaWJ1dGVzO2EuZGVmaW5lcz10aGlzLmRlZmluZXM7YS5zaGFkaW5nPXRoaXMuc2hhZGluZzthLndpcmVmcmFtZT10aGlzLndpcmVmcmFtZTthLndpcmVmcmFtZUxpbmV3aWR0aD10aGlzLndpcmVmcmFtZUxpbmV3aWR0aDthLmZvZz10aGlzLmZvZzthLmxpZ2h0cz10aGlzLmxpZ2h0czthLnZlcnRleENvbG9ycz10aGlzLnZlcnRleENvbG9yczthLnNraW5uaW5nPXRoaXMuc2tpbm5pbmc7YS5tb3JwaFRhcmdldHM9XG50aGlzLm1vcnBoVGFyZ2V0czthLm1vcnBoTm9ybWFscz10aGlzLm1vcnBoTm9ybWFscztyZXR1cm4gYX07VEhSRUUuU3ByaXRlTWF0ZXJpYWw9ZnVuY3Rpb24oYSl7VEhSRUUuTWF0ZXJpYWwuY2FsbCh0aGlzKTt0aGlzLmNvbG9yPW5ldyBUSFJFRS5Db2xvcigxNjc3NzIxNSk7dGhpcy5tYXA9bmV3IFRIUkVFLlRleHR1cmU7dGhpcy51c2VTY3JlZW5Db29yZGluYXRlcz0hMDt0aGlzLmRlcHRoVGVzdD0hdGhpcy51c2VTY3JlZW5Db29yZGluYXRlczt0aGlzLnNpemVBdHRlbnVhdGlvbj0hdGhpcy51c2VTY3JlZW5Db29yZGluYXRlczt0aGlzLmFsaWdubWVudD1USFJFRS5TcHJpdGVBbGlnbm1lbnQuY2VudGVyLmNsb25lKCk7dGhpcy5mb2c9ITE7dGhpcy51dk9mZnNldD1uZXcgVEhSRUUuVmVjdG9yMigwLDApO3RoaXMudXZTY2FsZT1uZXcgVEhSRUUuVmVjdG9yMigxLDEpO3RoaXMuc2V0VmFsdWVzKGEpO2E9YXx8e307dm9pZCAwPT09YS5kZXB0aFRlc3QmJih0aGlzLmRlcHRoVGVzdD0hdGhpcy51c2VTY3JlZW5Db29yZGluYXRlcyk7dm9pZCAwPT09YS5zaXplQXR0ZW51YXRpb24mJih0aGlzLnNpemVBdHRlbnVhdGlvbj1cbiF0aGlzLnVzZVNjcmVlbkNvb3JkaW5hdGVzKX07VEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlKTtUSFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuU3ByaXRlTWF0ZXJpYWw7VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyxhKTthLmNvbG9yLmNvcHkodGhpcy5jb2xvcik7YS5tYXA9dGhpcy5tYXA7YS51c2VTY3JlZW5Db29yZGluYXRlcz10aGlzLnVzZVNjcmVlbkNvb3JkaW5hdGVzO2Euc2l6ZUF0dGVudWF0aW9uPXRoaXMuc2l6ZUF0dGVudWF0aW9uO2EuYWxpZ25tZW50LmNvcHkodGhpcy5hbGlnbm1lbnQpO2EudXZPZmZzZXQuY29weSh0aGlzLnV2T2Zmc2V0KTthLnV2U2NhbGUuY29weSh0aGlzLnV2U2NhbGUpO2EuZm9nPXRoaXMuZm9nO3JldHVybiBhfTtUSFJFRS5TcHJpdGVBbGlnbm1lbnQ9e307XG5USFJFRS5TcHJpdGVBbGlnbm1lbnQudG9wTGVmdD1uZXcgVEhSRUUuVmVjdG9yMigwLjUsLTAuNSk7VEhSRUUuU3ByaXRlQWxpZ25tZW50LnRvcENlbnRlcj1uZXcgVEhSRUUuVmVjdG9yMigwLC0wLjUpO1RIUkVFLlNwcml0ZUFsaWdubWVudC50b3BSaWdodD1uZXcgVEhSRUUuVmVjdG9yMigtMC41LC0wLjUpO1RIUkVFLlNwcml0ZUFsaWdubWVudC5jZW50ZXJMZWZ0PW5ldyBUSFJFRS5WZWN0b3IyKDAuNSwwKTtUSFJFRS5TcHJpdGVBbGlnbm1lbnQuY2VudGVyPW5ldyBUSFJFRS5WZWN0b3IyKDAsMCk7VEhSRUUuU3ByaXRlQWxpZ25tZW50LmNlbnRlclJpZ2h0PW5ldyBUSFJFRS5WZWN0b3IyKC0wLjUsMCk7VEhSRUUuU3ByaXRlQWxpZ25tZW50LmJvdHRvbUxlZnQ9bmV3IFRIUkVFLlZlY3RvcjIoMC41LDAuNSk7VEhSRUUuU3ByaXRlQWxpZ25tZW50LmJvdHRvbUNlbnRlcj1uZXcgVEhSRUUuVmVjdG9yMigwLDAuNSk7XG5USFJFRS5TcHJpdGVBbGlnbm1lbnQuYm90dG9tUmlnaHQ9bmV3IFRIUkVFLlZlY3RvcjIoLTAuNSwwLjUpO1RIUkVFLlNwcml0ZUNhbnZhc01hdGVyaWFsPWZ1bmN0aW9uKGEpe1RIUkVFLk1hdGVyaWFsLmNhbGwodGhpcyk7dGhpcy5jb2xvcj1uZXcgVEhSRUUuQ29sb3IoMTY3NzcyMTUpO3RoaXMucHJvZ3JhbT1mdW5jdGlvbigpe307dGhpcy5zZXRWYWx1ZXMoYSl9O1RIUkVFLlNwcml0ZUNhbnZhc01hdGVyaWFsLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSk7VEhSRUUuU3ByaXRlQ2FudmFzTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlNwcml0ZUNhbnZhc01hdGVyaWFsO1RIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7YS5jb2xvci5jb3B5KHRoaXMuY29sb3IpO2EucHJvZ3JhbT10aGlzLnByb2dyYW07cmV0dXJuIGF9O1RIUkVFLlBhcnRpY2xlQ2FudmFzTWF0ZXJpYWw9VEhSRUUuU3ByaXRlQ2FudmFzTWF0ZXJpYWw7VEhSRUUuVGV4dHVyZT1mdW5jdGlvbihhLGIsYyxkLGUsZixoLGcsaSl7dGhpcy5pZD1USFJFRS5UZXh0dXJlSWRDb3VudCsrO3RoaXMudXVpZD1USFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO3RoaXMubmFtZT1cIlwiO3RoaXMuaW1hZ2U9YTt0aGlzLm1pcG1hcHM9W107dGhpcy5tYXBwaW5nPXZvaWQgMCE9PWI/YjpuZXcgVEhSRUUuVVZNYXBwaW5nO3RoaXMud3JhcFM9dm9pZCAwIT09Yz9jOlRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7dGhpcy53cmFwVD12b2lkIDAhPT1kP2Q6VEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZzt0aGlzLm1hZ0ZpbHRlcj12b2lkIDAhPT1lP2U6VEhSRUUuTGluZWFyRmlsdGVyO3RoaXMubWluRmlsdGVyPXZvaWQgMCE9PWY/ZjpUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7dGhpcy5hbmlzb3Ryb3B5PXZvaWQgMCE9PWk/aToxO3RoaXMuZm9ybWF0PXZvaWQgMCE9PWg/aDpUSFJFRS5SR0JBRm9ybWF0O3RoaXMudHlwZT12b2lkIDAhPT1nP2c6VEhSRUUuVW5zaWduZWRCeXRlVHlwZTtcbnRoaXMub2Zmc2V0PW5ldyBUSFJFRS5WZWN0b3IyKDAsMCk7dGhpcy5yZXBlYXQ9bmV3IFRIUkVFLlZlY3RvcjIoMSwxKTt0aGlzLmdlbmVyYXRlTWlwbWFwcz0hMDt0aGlzLnByZW11bHRpcGx5QWxwaGE9ITE7dGhpcy5mbGlwWT0hMDt0aGlzLnVucGFja0FsaWdubWVudD00O3RoaXMubmVlZHNVcGRhdGU9ITE7dGhpcy5vblVwZGF0ZT1udWxsfTtcblRIUkVFLlRleHR1cmUucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpUSFJFRS5UZXh0dXJlLGNsb25lOmZ1bmN0aW9uKGEpe3ZvaWQgMD09PWEmJihhPW5ldyBUSFJFRS5UZXh0dXJlKTthLmltYWdlPXRoaXMuaW1hZ2U7YS5taXBtYXBzPXRoaXMubWlwbWFwcy5zbGljZSgwKTthLm1hcHBpbmc9dGhpcy5tYXBwaW5nO2Eud3JhcFM9dGhpcy53cmFwUzthLndyYXBUPXRoaXMud3JhcFQ7YS5tYWdGaWx0ZXI9dGhpcy5tYWdGaWx0ZXI7YS5taW5GaWx0ZXI9dGhpcy5taW5GaWx0ZXI7YS5hbmlzb3Ryb3B5PXRoaXMuYW5pc290cm9weTthLmZvcm1hdD10aGlzLmZvcm1hdDthLnR5cGU9dGhpcy50eXBlO2Eub2Zmc2V0LmNvcHkodGhpcy5vZmZzZXQpO2EucmVwZWF0LmNvcHkodGhpcy5yZXBlYXQpO2EuZ2VuZXJhdGVNaXBtYXBzPXRoaXMuZ2VuZXJhdGVNaXBtYXBzO2EucHJlbXVsdGlwbHlBbHBoYT10aGlzLnByZW11bHRpcGx5QWxwaGE7YS5mbGlwWT10aGlzLmZsaXBZO2EudW5wYWNrQWxpZ25tZW50PVxudGhpcy51bnBhY2tBbGlnbm1lbnQ7cmV0dXJuIGF9LGRpc3Bvc2U6ZnVuY3Rpb24oKXt0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJkaXNwb3NlXCJ9KX19O1RIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUpO1RIUkVFLlRleHR1cmVJZENvdW50PTA7VEhSRUUuQ29tcHJlc3NlZFRleHR1cmU9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsaCxnLGksayxtKXtUSFJFRS5UZXh0dXJlLmNhbGwodGhpcyxudWxsLGYsaCxnLGksayxkLGUsbSk7dGhpcy5pbWFnZT17d2lkdGg6YixoZWlnaHQ6Y307dGhpcy5taXBtYXBzPWE7dGhpcy5nZW5lcmF0ZU1pcG1hcHM9ITF9O1RIUkVFLkNvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLlRleHR1cmUucHJvdG90eXBlKTtUSFJFRS5Db21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmU7VEhSRUUuVGV4dHVyZS5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO3JldHVybiBhfTtUSFJFRS5EYXRhVGV4dHVyZT1mdW5jdGlvbihhLGIsYyxkLGUsZixoLGcsaSxrLG0pe1RIUkVFLlRleHR1cmUuY2FsbCh0aGlzLG51bGwsZixoLGcsaSxrLGQsZSxtKTt0aGlzLmltYWdlPXtkYXRhOmEsd2lkdGg6YixoZWlnaHQ6Y319O1RIUkVFLkRhdGFUZXh0dXJlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLlRleHR1cmUucHJvdG90eXBlKTtUSFJFRS5EYXRhVGV4dHVyZS5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuRGF0YVRleHR1cmU7VEhSRUUuVGV4dHVyZS5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO3JldHVybiBhfTtUSFJFRS5QYXJ0aWNsZVN5c3RlbT1mdW5jdGlvbihhLGIpe1RIUkVFLk9iamVjdDNELmNhbGwodGhpcyk7dGhpcy5nZW9tZXRyeT12b2lkIDAhPT1hP2E6bmV3IFRIUkVFLkdlb21ldHJ5O3RoaXMubWF0ZXJpYWw9dm9pZCAwIT09Yj9iOm5ldyBUSFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsKHtjb2xvcjoxNjc3NzIxNSpNYXRoLnJhbmRvbSgpfSk7dGhpcy5mcnVzdHVtQ3VsbGVkPXRoaXMuc29ydFBhcnRpY2xlcz0hMX07VEhSRUUuUGFydGljbGVTeXN0ZW0ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlKTtcblRIUkVFLlBhcnRpY2xlU3lzdGVtLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbihhKXt2b2lkIDA9PT1hJiYoYT1uZXcgVEhSRUUuUGFydGljbGVTeXN0ZW0odGhpcy5nZW9tZXRyeSx0aGlzLm1hdGVyaWFsKSk7YS5zb3J0UGFydGljbGVzPXRoaXMuc29ydFBhcnRpY2xlcztUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO3JldHVybiBhfTtUSFJFRS5MaW5lPWZ1bmN0aW9uKGEsYixjKXtUSFJFRS5PYmplY3QzRC5jYWxsKHRoaXMpO3RoaXMuZ2VvbWV0cnk9dm9pZCAwIT09YT9hOm5ldyBUSFJFRS5HZW9tZXRyeTt0aGlzLm1hdGVyaWFsPXZvaWQgMCE9PWI/YjpuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoe2NvbG9yOjE2Nzc3MjE1Kk1hdGgucmFuZG9tKCl9KTt0aGlzLnR5cGU9dm9pZCAwIT09Yz9jOlRIUkVFLkxpbmVTdHJpcH07VEhSRUUuTGluZVN0cmlwPTA7VEhSRUUuTGluZVBpZWNlcz0xO1RIUkVFLkxpbmUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlKTtUSFJFRS5MaW5lLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbihhKXt2b2lkIDA9PT1hJiYoYT1uZXcgVEhSRUUuTGluZSh0aGlzLmdlb21ldHJ5LHRoaXMubWF0ZXJpYWwsdGhpcy50eXBlKSk7VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyxhKTtyZXR1cm4gYX07VEhSRUUuTWVzaD1mdW5jdGlvbihhLGIpe1RIUkVFLk9iamVjdDNELmNhbGwodGhpcyk7dGhpcy5nZW9tZXRyeT12b2lkIDAhPT1hP2E6bmV3IFRIUkVFLkdlb21ldHJ5O3RoaXMubWF0ZXJpYWw9dm9pZCAwIT09Yj9iOm5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7Y29sb3I6MTY3NzcyMTUqTWF0aC5yYW5kb20oKX0pO3RoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCl9O1RIUkVFLk1lc2gucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlKTtcblRIUkVFLk1lc2gucHJvdG90eXBlLnVwZGF0ZU1vcnBoVGFyZ2V0cz1mdW5jdGlvbigpe2lmKDA8dGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoKXt0aGlzLm1vcnBoVGFyZ2V0QmFzZT0tMTt0aGlzLm1vcnBoVGFyZ2V0Rm9yY2VkT3JkZXI9W107dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM9W107dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnk9e307Zm9yKHZhciBhPTAsYj10aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7YTxiO2ErKyl0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKDApLHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5W3RoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzW2FdLm5hbWVdPWF9fTtcblRIUkVFLk1lc2gucHJvdG90eXBlLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWU9ZnVuY3Rpb24oYSl7aWYodm9pZCAwIT09dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbYV0pcmV0dXJuIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5W2FdO2NvbnNvbGUubG9nKFwiVEhSRUUuTWVzaC5nZXRNb3JwaFRhcmdldEluZGV4QnlOYW1lOiBtb3JwaCB0YXJnZXQgXCIrYStcIiBkb2VzIG5vdCBleGlzdC4gUmV0dXJuaW5nIDAuXCIpO3JldHVybiAwfTtUSFJFRS5NZXNoLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbihhKXt2b2lkIDA9PT1hJiYoYT1uZXcgVEhSRUUuTWVzaCh0aGlzLmdlb21ldHJ5LHRoaXMubWF0ZXJpYWwpKTtUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO3JldHVybiBhfTtUSFJFRS5Cb25lPWZ1bmN0aW9uKGEpe1RIUkVFLk9iamVjdDNELmNhbGwodGhpcyk7dGhpcy5za2luPWE7dGhpcy5za2luTWF0cml4PW5ldyBUSFJFRS5NYXRyaXg0fTtUSFJFRS5Cb25lLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSk7VEhSRUUuQm9uZS5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEsYil7dGhpcy5tYXRyaXhBdXRvVXBkYXRlJiYoYnw9dGhpcy51cGRhdGVNYXRyaXgoKSk7aWYoYnx8dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlKWE/dGhpcy5za2luTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoYSx0aGlzLm1hdHJpeCk6dGhpcy5za2luTWF0cml4LmNvcHkodGhpcy5tYXRyaXgpLHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMSxiPSEwO3ZhciBjLGQ9dGhpcy5jaGlsZHJlbi5sZW5ndGg7Zm9yKGM9MDtjPGQ7YysrKXRoaXMuY2hpbGRyZW5bY10udXBkYXRlKHRoaXMuc2tpbk1hdHJpeCxiKX07VEhSRUUuU2tpbm5lZE1lc2g9ZnVuY3Rpb24oYSxiLGMpe1RIUkVFLk1lc2guY2FsbCh0aGlzLGEsYik7dGhpcy51c2VWZXJ0ZXhUZXh0dXJlPXZvaWQgMCE9PWM/YzohMDt0aGlzLmlkZW50aXR5TWF0cml4PW5ldyBUSFJFRS5NYXRyaXg0O3RoaXMuYm9uZXM9W107dGhpcy5ib25lTWF0cmljZXM9W107dmFyIGQsZSxmO2lmKHRoaXMuZ2VvbWV0cnkmJnZvaWQgMCE9PXRoaXMuZ2VvbWV0cnkuYm9uZXMpe2ZvcihhPTA7YTx0aGlzLmdlb21ldHJ5LmJvbmVzLmxlbmd0aDthKyspYz10aGlzLmdlb21ldHJ5LmJvbmVzW2FdLGQ9Yy5wb3MsZT1jLnJvdHEsZj1jLnNjbCxiPXRoaXMuYWRkQm9uZSgpLGIubmFtZT1jLm5hbWUsYi5wb3NpdGlvbi5zZXQoZFswXSxkWzFdLGRbMl0pLGIucXVhdGVybmlvbi5zZXQoZVswXSxlWzFdLGVbMl0sZVszXSksdm9pZCAwIT09Zj9iLnNjYWxlLnNldChmWzBdLGZbMV0sZlsyXSk6Yi5zY2FsZS5zZXQoMSwxLDEpO2ZvcihhPTA7YTx0aGlzLmJvbmVzLmxlbmd0aDthKyspYz1cbnRoaXMuZ2VvbWV0cnkuYm9uZXNbYV0sYj10aGlzLmJvbmVzW2FdLC0xPT09Yy5wYXJlbnQ/dGhpcy5hZGQoYik6dGhpcy5ib25lc1tjLnBhcmVudF0uYWRkKGIpO2E9dGhpcy5ib25lcy5sZW5ndGg7dGhpcy51c2VWZXJ0ZXhUZXh0dXJlPyh0aGlzLmJvbmVUZXh0dXJlSGVpZ2h0PXRoaXMuYm9uZVRleHR1cmVXaWR0aD1hPTI1NjxhPzY0OjY0PGE/MzI6MTY8YT8xNjo4LHRoaXMuYm9uZU1hdHJpY2VzPW5ldyBGbG9hdDMyQXJyYXkoNCp0aGlzLmJvbmVUZXh0dXJlV2lkdGgqdGhpcy5ib25lVGV4dHVyZUhlaWdodCksdGhpcy5ib25lVGV4dHVyZT1uZXcgVEhSRUUuRGF0YVRleHR1cmUodGhpcy5ib25lTWF0cmljZXMsdGhpcy5ib25lVGV4dHVyZVdpZHRoLHRoaXMuYm9uZVRleHR1cmVIZWlnaHQsVEhSRUUuUkdCQUZvcm1hdCxUSFJFRS5GbG9hdFR5cGUpLHRoaXMuYm9uZVRleHR1cmUubWluRmlsdGVyPVRIUkVFLk5lYXJlc3RGaWx0ZXIsdGhpcy5ib25lVGV4dHVyZS5tYWdGaWx0ZXI9XG5USFJFRS5OZWFyZXN0RmlsdGVyLHRoaXMuYm9uZVRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzPSExLHRoaXMuYm9uZVRleHR1cmUuZmxpcFk9ITEpOnRoaXMuYm9uZU1hdHJpY2VzPW5ldyBGbG9hdDMyQXJyYXkoMTYqYSk7dGhpcy5wb3NlKCl9fTtUSFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5NZXNoLnByb3RvdHlwZSk7VEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmFkZEJvbmU9ZnVuY3Rpb24oYSl7dm9pZCAwPT09YSYmKGE9bmV3IFRIUkVFLkJvbmUodGhpcykpO3RoaXMuYm9uZXMucHVzaChhKTtyZXR1cm4gYX07XG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQ9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuTWF0cml4NDtyZXR1cm4gZnVuY3Rpb24oYil7dGhpcy5tYXRyaXhBdXRvVXBkYXRlJiZ0aGlzLnVwZGF0ZU1hdHJpeCgpO2lmKHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZXx8Yil0aGlzLnBhcmVudD90aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXModGhpcy5wYXJlbnQubWF0cml4V29ybGQsdGhpcy5tYXRyaXgpOnRoaXMubWF0cml4V29ybGQuY29weSh0aGlzLm1hdHJpeCksdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSExO2Zvcih2YXIgYj0wLGM9dGhpcy5jaGlsZHJlbi5sZW5ndGg7YjxjO2IrKyl7dmFyIGQ9dGhpcy5jaGlsZHJlbltiXTtkIGluc3RhbmNlb2YgVEhSRUUuQm9uZT9kLnVwZGF0ZSh0aGlzLmlkZW50aXR5TWF0cml4LCExKTpkLnVwZGF0ZU1hdHJpeFdvcmxkKCEwKX1pZih2b2lkIDA9PXRoaXMuYm9uZUludmVyc2VzKXt0aGlzLmJvbmVJbnZlcnNlcz1cbltdO2I9MDtmb3IoYz10aGlzLmJvbmVzLmxlbmd0aDtiPGM7YisrKWQ9bmV3IFRIUkVFLk1hdHJpeDQsZC5nZXRJbnZlcnNlKHRoaXMuYm9uZXNbYl0uc2tpbk1hdHJpeCksdGhpcy5ib25lSW52ZXJzZXMucHVzaChkKX1iPTA7Zm9yKGM9dGhpcy5ib25lcy5sZW5ndGg7YjxjO2IrKylhLm11bHRpcGx5TWF0cmljZXModGhpcy5ib25lc1tiXS5za2luTWF0cml4LHRoaXMuYm9uZUludmVyc2VzW2JdKSxhLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KHRoaXMuYm9uZU1hdHJpY2VzLDE2KmIpO3RoaXMudXNlVmVydGV4VGV4dHVyZSYmKHRoaXMuYm9uZVRleHR1cmUubmVlZHNVcGRhdGU9ITApfX0oKTtUSFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUucG9zZT1mdW5jdGlvbigpe3RoaXMudXBkYXRlTWF0cml4V29ybGQoITApO3RoaXMubm9ybWFsaXplU2tpbldlaWdodHMoKX07XG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUubm9ybWFsaXplU2tpbldlaWdodHM9ZnVuY3Rpb24oKXtpZih0aGlzLmdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkpZm9yKHZhciBhPTA7YTx0aGlzLmdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aDthKyspe3ZhciBiPXRoaXMuZ2VvbWV0cnkuc2tpbldlaWdodHNbYV0sYz0xL2IubGVuZ3RoTWFuaGF0dGFuKCk7SW5maW5pdHkhPT1jP2IubXVsdGlwbHlTY2FsYXIoYyk6Yi5zZXQoMSl9fTtUSFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oYSl7dm9pZCAwPT09YSYmKGE9bmV3IFRIUkVFLlNraW5uZWRNZXNoKHRoaXMuZ2VvbWV0cnksdGhpcy5tYXRlcmlhbCx0aGlzLnVzZVZlcnRleFRleHR1cmUpKTtUSFJFRS5NZXNoLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7cmV0dXJuIGF9O1RIUkVFLk1vcnBoQW5pbU1lc2g9ZnVuY3Rpb24oYSxiKXtUSFJFRS5NZXNoLmNhbGwodGhpcyxhLGIpO3RoaXMuZHVyYXRpb249MUUzO3RoaXMubWlycm9yZWRMb29wPSExO3RoaXMuY3VycmVudEtleWZyYW1lPXRoaXMubGFzdEtleWZyYW1lPXRoaXMudGltZT0wO3RoaXMuZGlyZWN0aW9uPTE7dGhpcy5kaXJlY3Rpb25CYWNrd2FyZHM9ITE7dGhpcy5zZXRGcmFtZVJhbmdlKDAsdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoLTEpfTtUSFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk1lc2gucHJvdG90eXBlKTtUSFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5zZXRGcmFtZVJhbmdlPWZ1bmN0aW9uKGEsYil7dGhpcy5zdGFydEtleWZyYW1lPWE7dGhpcy5lbmRLZXlmcmFtZT1iO3RoaXMubGVuZ3RoPXRoaXMuZW5kS2V5ZnJhbWUtdGhpcy5zdGFydEtleWZyYW1lKzF9O1xuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0RGlyZWN0aW9uRm9yd2FyZD1mdW5jdGlvbigpe3RoaXMuZGlyZWN0aW9uPTE7dGhpcy5kaXJlY3Rpb25CYWNrd2FyZHM9ITF9O1RIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnNldERpcmVjdGlvbkJhY2t3YXJkPWZ1bmN0aW9uKCl7dGhpcy5kaXJlY3Rpb249LTE7dGhpcy5kaXJlY3Rpb25CYWNrd2FyZHM9ITB9O1xuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUucGFyc2VBbmltYXRpb25zPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZW9tZXRyeTthLmFuaW1hdGlvbnN8fChhLmFuaW1hdGlvbnM9e30pO2Zvcih2YXIgYixjPWEuYW5pbWF0aW9ucyxkPS8oW2Etel0rKShcXGQrKS8sZT0wLGY9YS5tb3JwaFRhcmdldHMubGVuZ3RoO2U8ZjtlKyspe3ZhciBoPWEubW9ycGhUYXJnZXRzW2VdLm5hbWUubWF0Y2goZCk7aWYoaCYmMTxoLmxlbmd0aCl7aD1oWzFdO2NbaF18fChjW2hdPXtzdGFydDpJbmZpbml0eSxlbmQ6LUluZmluaXR5fSk7dmFyIGc9Y1toXTtlPGcuc3RhcnQmJihnLnN0YXJ0PWUpO2U+Zy5lbmQmJihnLmVuZD1lKTtifHwoYj1oKX19YS5maXJzdEFuaW1hdGlvbj1ifTtcblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkxhYmVsPWZ1bmN0aW9uKGEsYixjKXt0aGlzLmdlb21ldHJ5LmFuaW1hdGlvbnN8fCh0aGlzLmdlb21ldHJ5LmFuaW1hdGlvbnM9e30pO3RoaXMuZ2VvbWV0cnkuYW5pbWF0aW9uc1thXT17c3RhcnQ6YixlbmQ6Y319O1RIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnBsYXlBbmltYXRpb249ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdlb21ldHJ5LmFuaW1hdGlvbnNbYV07Yz8odGhpcy5zZXRGcmFtZVJhbmdlKGMuc3RhcnQsYy5lbmQpLHRoaXMuZHVyYXRpb249MUUzKigoYy5lbmQtYy5zdGFydCkvYiksdGhpcy50aW1lPTApOmNvbnNvbGUud2FybihcImFuaW1hdGlvbltcIithK1wiXSB1bmRlZmluZWRcIil9O1xuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUudXBkYXRlQW5pbWF0aW9uPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZHVyYXRpb24vdGhpcy5sZW5ndGg7dGhpcy50aW1lKz10aGlzLmRpcmVjdGlvbiphO2lmKHRoaXMubWlycm9yZWRMb29wKXtpZih0aGlzLnRpbWU+dGhpcy5kdXJhdGlvbnx8MD50aGlzLnRpbWUpdGhpcy5kaXJlY3Rpb24qPS0xLHRoaXMudGltZT50aGlzLmR1cmF0aW9uJiYodGhpcy50aW1lPXRoaXMuZHVyYXRpb24sdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHM9ITApLDA+dGhpcy50aW1lJiYodGhpcy50aW1lPTAsdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHM9ITEpfWVsc2UgdGhpcy50aW1lJT10aGlzLmR1cmF0aW9uLDA+dGhpcy50aW1lJiYodGhpcy50aW1lKz10aGlzLmR1cmF0aW9uKTthPXRoaXMuc3RhcnRLZXlmcmFtZStUSFJFRS5NYXRoLmNsYW1wKE1hdGguZmxvb3IodGhpcy50aW1lL2IpLDAsdGhpcy5sZW5ndGgtMSk7YSE9PXRoaXMuY3VycmVudEtleWZyYW1lJiZcbih0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1t0aGlzLmxhc3RLZXlmcmFtZV09MCx0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1t0aGlzLmN1cnJlbnRLZXlmcmFtZV09MSx0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1thXT0wLHRoaXMubGFzdEtleWZyYW1lPXRoaXMuY3VycmVudEtleWZyYW1lLHRoaXMuY3VycmVudEtleWZyYW1lPWEpO2I9dGhpcy50aW1lJWIvYjt0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcyYmKGI9MS1iKTt0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1t0aGlzLmN1cnJlbnRLZXlmcmFtZV09Yjt0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1t0aGlzLmxhc3RLZXlmcmFtZV09MS1ifTtcblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKGEpe3ZvaWQgMD09PWEmJihhPW5ldyBUSFJFRS5Nb3JwaEFuaW1NZXNoKHRoaXMuZ2VvbWV0cnksdGhpcy5tYXRlcmlhbCkpO2EuZHVyYXRpb249dGhpcy5kdXJhdGlvbjthLm1pcnJvcmVkTG9vcD10aGlzLm1pcnJvcmVkTG9vcDthLnRpbWU9dGhpcy50aW1lO2EubGFzdEtleWZyYW1lPXRoaXMubGFzdEtleWZyYW1lO2EuY3VycmVudEtleWZyYW1lPXRoaXMuY3VycmVudEtleWZyYW1lO2EuZGlyZWN0aW9uPXRoaXMuZGlyZWN0aW9uO2EuZGlyZWN0aW9uQmFja3dhcmRzPXRoaXMuZGlyZWN0aW9uQmFja3dhcmRzO1RIUkVFLk1lc2gucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyxhKTtyZXR1cm4gYX07VEhSRUUuTE9EPWZ1bmN0aW9uKCl7VEhSRUUuT2JqZWN0M0QuY2FsbCh0aGlzKTt0aGlzLm9iamVjdHM9W119O1RIUkVFLkxPRC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUpO1RIUkVFLkxPRC5wcm90b3R5cGUuYWRkTGV2ZWw9ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT1iJiYoYj0wKTtmb3IodmFyIGI9TWF0aC5hYnMoYiksYz0wO2M8dGhpcy5vYmplY3RzLmxlbmd0aCYmIShiPHRoaXMub2JqZWN0c1tjXS5kaXN0YW5jZSk7YysrKTt0aGlzLm9iamVjdHMuc3BsaWNlKGMsMCx7ZGlzdGFuY2U6YixvYmplY3Q6YX0pO3RoaXMuYWRkKGEpfTtUSFJFRS5MT0QucHJvdG90eXBlLmdldE9iamVjdEZvckRpc3RhbmNlPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj0xLGM9dGhpcy5vYmplY3RzLmxlbmd0aDtiPGMmJiEoYTx0aGlzLm9iamVjdHNbYl0uZGlzdGFuY2UpO2IrKyk7cmV0dXJuIHRoaXMub2JqZWN0c1tiLTFdLm9iamVjdH07XG5USFJFRS5MT0QucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbigpe3ZhciBhPW5ldyBUSFJFRS5WZWN0b3IzLGI9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKGMpe2lmKDE8dGhpcy5vYmplY3RzLmxlbmd0aCl7YS5nZXRQb3NpdGlvbkZyb21NYXRyaXgoYy5tYXRyaXhXb3JsZCk7Yi5nZXRQb3NpdGlvbkZyb21NYXRyaXgodGhpcy5tYXRyaXhXb3JsZCk7Yz1hLmRpc3RhbmNlVG8oYik7dGhpcy5vYmplY3RzWzBdLm9iamVjdC52aXNpYmxlPSEwO2Zvcih2YXIgZD0xLGU9dGhpcy5vYmplY3RzLmxlbmd0aDtkPGU7ZCsrKWlmKGM+PXRoaXMub2JqZWN0c1tkXS5kaXN0YW5jZSl0aGlzLm9iamVjdHNbZC0xXS5vYmplY3QudmlzaWJsZT0hMSx0aGlzLm9iamVjdHNbZF0ub2JqZWN0LnZpc2libGU9ITA7ZWxzZSBicmVhaztmb3IoO2Q8ZTtkKyspdGhpcy5vYmplY3RzW2RdLm9iamVjdC52aXNpYmxlPSExfX19KCk7VEhSRUUuTE9ELnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe307VEhSRUUuU3ByaXRlPWZ1bmN0aW9uKGEpe1RIUkVFLk9iamVjdDNELmNhbGwodGhpcyk7dGhpcy5tYXRlcmlhbD12b2lkIDAhPT1hP2E6bmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsO3RoaXMucm90YXRpb249MH07VEhSRUUuU3ByaXRlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSk7VEhSRUUuU3ByaXRlLnByb3RvdHlwZS51cGRhdGVNYXRyaXg9ZnVuY3Rpb24oKXt0aGlzLm1hdHJpeC5jb21wb3NlKHRoaXMucG9zaXRpb24sdGhpcy5xdWF0ZXJuaW9uLHRoaXMuc2NhbGUpO3RoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMH07VEhSRUUuU3ByaXRlLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbihhKXt2b2lkIDA9PT1hJiYoYT1uZXcgVEhSRUUuU3ByaXRlKHRoaXMubWF0ZXJpYWwpKTtUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLGEpO3JldHVybiBhfTtUSFJFRS5QYXJ0aWNsZT1USFJFRS5TcHJpdGU7VEhSRUUuU2NlbmU9ZnVuY3Rpb24oKXtUSFJFRS5PYmplY3QzRC5jYWxsKHRoaXMpO3RoaXMub3ZlcnJpZGVNYXRlcmlhbD10aGlzLmZvZz1udWxsO3RoaXMuYXV0b1VwZGF0ZT0hMDt0aGlzLm1hdHJpeEF1dG9VcGRhdGU9ITE7dGhpcy5fX2xpZ2h0cz1bXTt0aGlzLl9fb2JqZWN0c0FkZGVkPVtdO3RoaXMuX19vYmplY3RzUmVtb3ZlZD1bXX07VEhSRUUuU2NlbmUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlKTtcblRIUkVFLlNjZW5lLnByb3RvdHlwZS5fX2FkZE9iamVjdD1mdW5jdGlvbihhKXtpZihhIGluc3RhbmNlb2YgVEhSRUUuTGlnaHQpLTE9PT10aGlzLl9fbGlnaHRzLmluZGV4T2YoYSkmJnRoaXMuX19saWdodHMucHVzaChhKSxhLnRhcmdldCYmdm9pZCAwPT09YS50YXJnZXQucGFyZW50JiZ0aGlzLmFkZChhLnRhcmdldCk7ZWxzZSBpZighKGEgaW5zdGFuY2VvZiBUSFJFRS5DYW1lcmF8fGEgaW5zdGFuY2VvZiBUSFJFRS5Cb25lKSl7dGhpcy5fX29iamVjdHNBZGRlZC5wdXNoKGEpO3ZhciBiPXRoaXMuX19vYmplY3RzUmVtb3ZlZC5pbmRleE9mKGEpOy0xIT09YiYmdGhpcy5fX29iamVjdHNSZW1vdmVkLnNwbGljZShiLDEpfWZvcihiPTA7YjxhLmNoaWxkcmVuLmxlbmd0aDtiKyspdGhpcy5fX2FkZE9iamVjdChhLmNoaWxkcmVuW2JdKX07XG5USFJFRS5TY2VuZS5wcm90b3R5cGUuX19yZW1vdmVPYmplY3Q9ZnVuY3Rpb24oYSl7aWYoYSBpbnN0YW5jZW9mIFRIUkVFLkxpZ2h0KXt2YXIgYj10aGlzLl9fbGlnaHRzLmluZGV4T2YoYSk7LTEhPT1iJiZ0aGlzLl9fbGlnaHRzLnNwbGljZShiLDEpO2lmKGEuc2hhZG93Q2FzY2FkZUFycmF5KWZvcihiPTA7YjxhLnNoYWRvd0Nhc2NhZGVBcnJheS5sZW5ndGg7YisrKXRoaXMuX19yZW1vdmVPYmplY3QoYS5zaGFkb3dDYXNjYWRlQXJyYXlbYl0pfWVsc2UgYSBpbnN0YW5jZW9mIFRIUkVFLkNhbWVyYXx8KHRoaXMuX19vYmplY3RzUmVtb3ZlZC5wdXNoKGEpLGI9dGhpcy5fX29iamVjdHNBZGRlZC5pbmRleE9mKGEpLC0xIT09YiYmdGhpcy5fX29iamVjdHNBZGRlZC5zcGxpY2UoYiwxKSk7Zm9yKGI9MDtiPGEuY2hpbGRyZW4ubGVuZ3RoO2IrKyl0aGlzLl9fcmVtb3ZlT2JqZWN0KGEuY2hpbGRyZW5bYl0pfTtcblRIUkVFLlNjZW5lLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbihhKXt2b2lkIDA9PT1hJiYoYT1uZXcgVEhSRUUuU2NlbmUpO1RIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMsYSk7bnVsbCE9PXRoaXMuZm9nJiYoYS5mb2c9dGhpcy5mb2cuY2xvbmUoKSk7bnVsbCE9PXRoaXMub3ZlcnJpZGVNYXRlcmlhbCYmKGEub3ZlcnJpZGVNYXRlcmlhbD10aGlzLm92ZXJyaWRlTWF0ZXJpYWwuY2xvbmUoKSk7YS5hdXRvVXBkYXRlPXRoaXMuYXV0b1VwZGF0ZTthLm1hdHJpeEF1dG9VcGRhdGU9dGhpcy5tYXRyaXhBdXRvVXBkYXRlO3JldHVybiBhfTtUSFJFRS5Gb2c9ZnVuY3Rpb24oYSxiLGMpe3RoaXMubmFtZT1cIlwiO3RoaXMuY29sb3I9bmV3IFRIUkVFLkNvbG9yKGEpO3RoaXMubmVhcj12b2lkIDAhPT1iP2I6MTt0aGlzLmZhcj12b2lkIDAhPT1jP2M6MUUzfTtUSFJFRS5Gb2cucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBUSFJFRS5Gb2codGhpcy5jb2xvci5nZXRIZXgoKSx0aGlzLm5lYXIsdGhpcy5mYXIpfTtUSFJFRS5Gb2dFeHAyPWZ1bmN0aW9uKGEsYil7dGhpcy5uYW1lPVwiXCI7dGhpcy5jb2xvcj1uZXcgVEhSRUUuQ29sb3IoYSk7dGhpcy5kZW5zaXR5PXZvaWQgMCE9PWI/YjoyLjVFLTR9O1RIUkVFLkZvZ0V4cDIucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBUSFJFRS5Gb2dFeHAyKHRoaXMuY29sb3IuZ2V0SGV4KCksdGhpcy5kZW5zaXR5KX07VEhSRUUuQ2FudmFzUmVuZGVyZXI9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhLGIsYyl7Zm9yKHZhciBkPTAsZT16Lmxlbmd0aDtkPGU7ZCsrKXt2YXIgZj16W2RdO0xhLmNvcHkoZi5jb2xvcik7aWYoZiBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQpe3ZhciBoPXVhLmdldFBvc2l0aW9uRnJvbU1hdHJpeChmLm1hdHJpeFdvcmxkKS5ub3JtYWxpemUoKSxnPWIuZG90KGgpOzA+PWd8fChnKj1mLmludGVuc2l0eSxjLmFkZChMYS5tdWx0aXBseVNjYWxhcihnKSkpfWVsc2UgZiBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQmJihoPXVhLmdldFBvc2l0aW9uRnJvbU1hdHJpeChmLm1hdHJpeFdvcmxkKSxnPWIuZG90KHVhLnN1YlZlY3RvcnMoaCxhKS5ub3JtYWxpemUoKSksMD49Z3x8KGcqPTA9PWYuZGlzdGFuY2U/MToxLU1hdGgubWluKGEuZGlzdGFuY2VUbyhoKS9mLmRpc3RhbmNlLDEpLDAhPWcmJihnKj1mLmludGVuc2l0eSxjLmFkZChMYS5tdWx0aXBseVNjYWxhcihnKSkpKSl9fVxuZnVuY3Rpb24gYyhhLGIsYyxkKXttKGIpO2woYyk7cChkKTtzKGEuZ2V0U3R5bGUoKSk7Qy5zdHJva2UoKTtyYS5leHBhbmRCeVNjYWxhcigyKmIpfWZ1bmN0aW9uIGQoYSl7dChhLmdldFN0eWxlKCkpO0MuZmlsbCgpfWZ1bmN0aW9uIGUoYSxiLGMsZSxmLGgsZyxqLGksayxtLGwscCl7aWYoIShwIGluc3RhbmNlb2YgVEhSRUUuRGF0YVRleHR1cmV8fHZvaWQgMD09PXAuaW1hZ2V8fDA9PXAuaW1hZ2Uud2lkdGgpKXtpZighMD09PXAubmVlZHNVcGRhdGUpe3ZhciBuPXAud3JhcFM9PVRIUkVFLlJlcGVhdFdyYXBwaW5nLHI9cC53cmFwVD09VEhSRUUuUmVwZWF0V3JhcHBpbmc7R2FbcC5pZF09Qy5jcmVhdGVQYXR0ZXJuKHAuaW1hZ2UsITA9PT1uJiYhMD09PXI/XCJyZXBlYXRcIjohMD09PW4mJiExPT09cj9cInJlcGVhdC14XCI6ITE9PT1uJiYhMD09PXI/XCJyZXBlYXQteVwiOlwibm8tcmVwZWF0XCIpO3AubmVlZHNVcGRhdGU9ITF9dm9pZCAwPT09R2FbcC5pZF0/dChcInJnYmEoMCwwLDAsMSlcIik6XG50KEdhW3AuaWRdKTt2YXIgbj1wLm9mZnNldC54L3AucmVwZWF0Lngscj1wLm9mZnNldC55L3AucmVwZWF0Lnkscz1wLmltYWdlLndpZHRoKnAucmVwZWF0LngscT1wLmltYWdlLmhlaWdodCpwLnJlcGVhdC55LGc9KGcrbikqcyxqPSgxLWorcikqcSxjPWMtYSxlPWUtYixmPWYtYSxoPWgtYixpPShpK24pKnMtZyxrPSgxLWsrcikqcS1qLG09KG0rbikqcy1nLGw9KDEtbCtyKSpxLWosbj1pKmwtbSprOzA9PT1uPyh2b2lkIDA9PT1mYVtwLmlkXSYmKGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxiLndpZHRoPXAuaW1hZ2Uud2lkdGgsYi5oZWlnaHQ9cC5pbWFnZS5oZWlnaHQsYj1iLmdldENvbnRleHQoXCIyZFwiKSxiLmRyYXdJbWFnZShwLmltYWdlLDAsMCksZmFbcC5pZF09Yi5nZXRJbWFnZURhdGEoMCwwLHAuaW1hZ2Uud2lkdGgscC5pbWFnZS5oZWlnaHQpLmRhdGEpLGI9ZmFbcC5pZF0sZz00KihNYXRoLmZsb29yKGcpK01hdGguZmxvb3IoaikqcC5pbWFnZS53aWR0aCksXG5WLnNldFJHQihiW2ddLzI1NSxiW2crMV0vMjU1LGJbZysyXS8yNTUpLGQoVikpOihuPTEvbixwPShsKmMtaypmKSpuLGs9KGwqZS1rKmgpKm4sYz0oaSpmLW0qYykqbixlPShpKmgtbSplKSpuLGE9YS1wKmctYypqLGc9Yi1rKmctZSpqLEMuc2F2ZSgpLEMudHJhbnNmb3JtKHAsayxjLGUsYSxnKSxDLmZpbGwoKSxDLnJlc3RvcmUoKSl9fWZ1bmN0aW9uIGYoYSxiLGMsZCxlLGYsaCxnLGosaSxrLG0sbCl7dmFyIHAsbjtwPWwud2lkdGgtMTtuPWwuaGVpZ2h0LTE7aCo9cDtnKj1uO2MtPWE7ZC09YjtlLT1hO2YtPWI7aj1qKnAtaDtpPWkqbi1nO2s9aypwLWg7bT1tKm4tZztuPTEvKGoqbS1rKmkpO3A9KG0qYy1pKmUpKm47aT0obSpkLWkqZikqbjtjPShqKmUtaypjKSpuO2Q9KGoqZi1rKmQpKm47YT1hLXAqaC1jKmc7Yj1iLWkqaC1kKmc7Qy5zYXZlKCk7Qy50cmFuc2Zvcm0ocCxpLGMsZCxhLGIpO0MuY2xpcCgpO0MuZHJhd0ltYWdlKGwsMCwwKTtDLnJlc3RvcmUoKX1mdW5jdGlvbiBoKGEsXG5iLGMsZCl7dmFbMF09MjU1KmEucnwwO3ZhWzFdPTI1NSphLmd8MDt2YVsyXT0yNTUqYS5ifDA7dmFbNF09MjU1KmIucnwwO3ZhWzVdPTI1NSpiLmd8MDt2YVs2XT0yNTUqYi5ifDA7dmFbOF09MjU1KmMucnwwO3ZhWzldPTI1NSpjLmd8MDt2YVsxMF09MjU1KmMuYnwwO3ZhWzEyXT0yNTUqZC5yfDA7dmFbMTNdPTI1NSpkLmd8MDt2YVsxNF09MjU1KmQuYnwwO2oucHV0SW1hZ2VEYXRhKE9hLDAsMCk7RWEuZHJhd0ltYWdlKFBhLDAsMCk7cmV0dXJuIHdhfWZ1bmN0aW9uIGcoYSxiLGMpe3ZhciBkPWIueC1hLngsZT1iLnktYS55LGY9ZCpkK2UqZTswIT09ZiYmKGMvPU1hdGguc3FydChmKSxkKj1jLGUqPWMsYi54Kz1kLGIueSs9ZSxhLngtPWQsYS55LT1lKX1mdW5jdGlvbiBpKGEpe3khPT1hJiYoeT1DLmdsb2JhbEFscGhhPWEpfWZ1bmN0aW9uIGsoYSl7diE9PWEmJihhPT09VEhSRUUuTm9ybWFsQmxlbmRpbmc/Qy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJzb3VyY2Utb3ZlclwiOlxuYT09PVRIUkVFLkFkZGl0aXZlQmxlbmRpbmc/Qy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJsaWdodGVyXCI6YT09PVRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmcmJihDLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cImRhcmtlclwiKSx2PWEpfWZ1bmN0aW9uIG0oYSl7SiE9PWEmJihKPUMubGluZVdpZHRoPWEpfWZ1bmN0aW9uIGwoYSl7YmEhPT1hJiYoYmE9Qy5saW5lQ2FwPWEpfWZ1bmN0aW9uIHAoYSl7b2EhPT1hJiYob2E9Qy5saW5lSm9pbj1hKX1mdW5jdGlvbiBzKGEpe0chPT1hJiYoRz1DLnN0cm9rZVN0eWxlPWEpfWZ1bmN0aW9uIHQoYSl7UiE9PWEmJihSPUMuZmlsbFN0eWxlPWEpfWZ1bmN0aW9uIG4oYSxiKXtpZihwYSE9PWF8fE4hPT1iKUMuc2V0TGluZURhc2goW2EsYl0pLHBhPWEsTj1ifWNvbnNvbGUubG9nKFwiVEhSRUUuQ2FudmFzUmVuZGVyZXJcIixUSFJFRS5SRVZJU0lPTik7dmFyIHI9VEhSRUUuTWF0aC5zbW9vdGhzdGVwLGE9YXx8e30scT10aGlzLHUsdyx6LEI9XG5uZXcgVEhSRUUuUHJvamVjdG9yLEQ9dm9pZCAwIT09YS5jYW52YXM/YS5jYW52YXM6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSx4PUQud2lkdGgsRj1ELmhlaWdodCxBPU1hdGguZmxvb3IoeC8yKSxPPU1hdGguZmxvb3IoRi8yKSxDPUQuZ2V0Q29udGV4dChcIjJkXCIpLEU9bmV3IFRIUkVFLkNvbG9yKDApLEk9MCx5PTEsdj0wLEc9bnVsbCxSPW51bGwsSj1udWxsLGJhPW51bGwsb2E9bnVsbCxwYT1udWxsLE49MCxNLFEsSyxjYTtuZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleDtuZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleDt2YXIgRmEsQmEsZGEsQWEsJCxlYSxWPW5ldyBUSFJFRS5Db2xvcixQPW5ldyBUSFJFRS5Db2xvcixaPW5ldyBUSFJFRS5Db2xvcixVPW5ldyBUSFJFRS5Db2xvcixrYT1uZXcgVEhSRUUuQ29sb3IsdGE9bmV3IFRIUkVFLkNvbG9yLGlhPW5ldyBUSFJFRS5Db2xvcixMYT1uZXcgVEhSRUUuQ29sb3IsR2E9e30sZmE9e30sRGEsVWEsUWEseGEsYmIsXG5jYixNYSxmYixzYixwYixIYT1uZXcgVEhSRUUuQm94MixsYT1uZXcgVEhSRUUuQm94MixyYT1uZXcgVEhSRUUuQm94MixnYj1uZXcgVEhSRUUuQ29sb3Isc2E9bmV3IFRIUkVFLkNvbG9yLGdhPW5ldyBUSFJFRS5Db2xvcix1YT1uZXcgVEhSRUUuVmVjdG9yMyxQYSxqLE9hLHZhLHdhLEVhLFJhPTE2O1BhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7UGEud2lkdGg9UGEuaGVpZ2h0PTI7aj1QYS5nZXRDb250ZXh0KFwiMmRcIik7ai5maWxsU3R5bGU9XCJyZ2JhKDAsMCwwLDEpXCI7ai5maWxsUmVjdCgwLDAsMiwyKTtPYT1qLmdldEltYWdlRGF0YSgwLDAsMiwyKTt2YT1PYS5kYXRhO3dhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7d2Eud2lkdGg9d2EuaGVpZ2h0PVJhO0VhPXdhLmdldENvbnRleHQoXCIyZFwiKTtFYS50cmFuc2xhdGUoLVJhLzIsLVJhLzIpO0VhLnNjYWxlKFJhLFJhKTtSYS0tO3ZvaWQgMD09PUMuc2V0TGluZURhc2gmJihDLnNldExpbmVEYXNoPVxudm9pZCAwIT09Qy5tb3pEYXNoP2Z1bmN0aW9uKGEpe0MubW96RGFzaD1udWxsIT09YVswXT9hOm51bGx9OmZ1bmN0aW9uKCl7fSk7dGhpcy5kb21FbGVtZW50PUQ7dGhpcy5kZXZpY2VQaXhlbFJhdGlvPXZvaWQgMCE9PWEuZGV2aWNlUGl4ZWxSYXRpbz9hLmRldmljZVBpeGVsUmF0aW86dm9pZCAwIT09c2VsZi5kZXZpY2VQaXhlbFJhdGlvP3NlbGYuZGV2aWNlUGl4ZWxSYXRpbzoxO3RoaXMuc29ydEVsZW1lbnRzPXRoaXMuc29ydE9iamVjdHM9dGhpcy5hdXRvQ2xlYXI9ITA7dGhpcy5pbmZvPXtyZW5kZXI6e3ZlcnRpY2VzOjAsZmFjZXM6MH19O3RoaXMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcz1mdW5jdGlvbigpe307dGhpcy5zZXRGYWNlQ3VsbGluZz1mdW5jdGlvbigpe307dGhpcy5zZXRTaXplPWZ1bmN0aW9uKGEsYixjKXt4PWEqdGhpcy5kZXZpY2VQaXhlbFJhdGlvO0Y9Yip0aGlzLmRldmljZVBpeGVsUmF0aW87QT1NYXRoLmZsb29yKHgvMik7Tz1NYXRoLmZsb29yKEYvMik7XG5ELndpZHRoPXg7RC5oZWlnaHQ9RjsxIT09dGhpcy5kZXZpY2VQaXhlbFJhdGlvJiYhMSE9PWMmJihELnN0eWxlLndpZHRoPWErXCJweFwiLEQuc3R5bGUuaGVpZ2h0PWIrXCJweFwiKTtIYS5zZXQobmV3IFRIUkVFLlZlY3RvcjIoLUEsLU8pLG5ldyBUSFJFRS5WZWN0b3IyKEEsTykpO2xhLnNldChuZXcgVEhSRUUuVmVjdG9yMigtQSwtTyksbmV3IFRIUkVFLlZlY3RvcjIoQSxPKSk7eT0xO3Y9MDtvYT1iYT1KPVI9Rz1udWxsfTt0aGlzLnNldENsZWFyQ29sb3I9ZnVuY3Rpb24oYSxiKXtFLnNldChhKTtJPXZvaWQgMCE9PWI/YjoxO2xhLnNldChuZXcgVEhSRUUuVmVjdG9yMigtQSwtTyksbmV3IFRIUkVFLlZlY3RvcjIoQSxPKSl9O3RoaXMuc2V0Q2xlYXJDb2xvckhleD1mdW5jdGlvbihhLGIpe2NvbnNvbGUud2FybihcIkRFUFJFQ0FURUQ6IC5zZXRDbGVhckNvbG9ySGV4KCkgaXMgYmVpbmcgcmVtb3ZlZC4gVXNlIC5zZXRDbGVhckNvbG9yKCkgaW5zdGVhZC5cIik7dGhpcy5zZXRDbGVhckNvbG9yKGEsXG5iKX07dGhpcy5nZXRNYXhBbmlzb3Ryb3B5PWZ1bmN0aW9uKCl7cmV0dXJuIDB9O3RoaXMuY2xlYXI9ZnVuY3Rpb24oKXtDLnNldFRyYW5zZm9ybSgxLDAsMCwtMSxBLE8pOyExPT09bGEuZW1wdHkoKSYmKGxhLmludGVyc2VjdChIYSksbGEuZXhwYW5kQnlTY2FsYXIoMiksMT5JJiZDLmNsZWFyUmVjdChsYS5taW4ueHwwLGxhLm1pbi55fDAsbGEubWF4LngtbGEubWluLnh8MCxsYS5tYXgueS1sYS5taW4ueXwwKSwwPEkmJihrKFRIUkVFLk5vcm1hbEJsZW5kaW5nKSxpKDEpLHQoXCJyZ2JhKFwiK01hdGguZmxvb3IoMjU1KkUucikrXCIsXCIrTWF0aC5mbG9vcigyNTUqRS5nKStcIixcIitNYXRoLmZsb29yKDI1NSpFLmIpK1wiLFwiK0krXCIpXCIpLEMuZmlsbFJlY3QobGEubWluLnh8MCxsYS5taW4ueXwwLGxhLm1heC54LWxhLm1pbi54fDAsbGEubWF4LnktbGEubWluLnl8MCkpLGxhLm1ha2VFbXB0eSgpKX07dGhpcy5yZW5kZXI9ZnVuY3Rpb24oYSxqKXtpZighMT09PWogaW5zdGFuY2VvZiBUSFJFRS5DYW1lcmEpY29uc29sZS5lcnJvcihcIlRIUkVFLkNhbnZhc1JlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuXCIpO1xuZWxzZXshMD09PXRoaXMuYXV0b0NsZWFyJiZ0aGlzLmNsZWFyKCk7Qy5zZXRUcmFuc2Zvcm0oMSwwLDAsLTEsQSxPKTtxLmluZm8ucmVuZGVyLnZlcnRpY2VzPTA7cS5pbmZvLnJlbmRlci5mYWNlcz0wO3U9Qi5wcm9qZWN0U2NlbmUoYSxqLHRoaXMuc29ydE9iamVjdHMsdGhpcy5zb3J0RWxlbWVudHMpO3c9dS5lbGVtZW50czt6PXUubGlnaHRzO009ajtnYi5zZXRSR0IoMCwwLDApO3NhLnNldFJHQigwLDAsMCk7Z2Euc2V0UkdCKDAsMCwwKTtmb3IodmFyIEQ9MCxHPXoubGVuZ3RoO0Q8RztEKyspe3ZhciB5PXpbRF0sRj15LmNvbG9yO3kgaW5zdGFuY2VvZiBUSFJFRS5BbWJpZW50TGlnaHQ/Z2IuYWRkKEYpOnkgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0P3NhLmFkZChGKTp5IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCYmZ2EuYWRkKEYpfUQ9MDtmb3IoRz13Lmxlbmd0aDtEPEc7RCsrKXt2YXIgeD13W0RdLHY9eC5tYXRlcmlhbDtpZighKHZvaWQgMD09PXZ8fFxuITE9PT12LnZpc2libGUpKXtyYS5tYWtlRW1wdHkoKTtpZih4IGluc3RhbmNlb2YgVEhSRUUuUmVuZGVyYWJsZVNwcml0ZSl7UT14O1EueCo9QTtRLnkqPU87dmFyIHk9USxGPXgsSj12O2koSi5vcGFjaXR5KTtrKEouYmxlbmRpbmcpO3ZhciBOPXY9eD12b2lkIDAsRT12b2lkIDAsST12b2lkIDAsUj12b2lkIDAsYmE9dm9pZCAwO0ogaW5zdGFuY2VvZiBUSFJFRS5TcHJpdGVNYXRlcmlhbHx8SiBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlU3lzdGVtTWF0ZXJpYWw/dm9pZCAwIT09Si5tYXAuaW1hZ2U/KEk9Si5tYXAuaW1hZ2UsUj1JLndpZHRoPj4xLGJhPUkuaGVpZ2h0Pj4xLE49Ri5zY2FsZS54KkEsRT1GLnNjYWxlLnkqTyx4PU4qUix2PUUqYmEscmEubWluLnNldCh5LngteCx5LnktdikscmEubWF4LnNldCh5LngreCx5LnkrdiksITE9PT1IYS5pc0ludGVyc2VjdGlvbkJveChyYSk/cmEubWFrZUVtcHR5KCk6KEMuc2F2ZSgpLEMudHJhbnNsYXRlKHkueCx5LnkpLEMucm90YXRlKC1GLnJvdGF0aW9uKSxcbkMuc2NhbGUoTiwtRSksQy50cmFuc2xhdGUoLVIsLWJhKSxDLmRyYXdJbWFnZShJLDAsMCksQy5yZXN0b3JlKCkpKTooTj1GLm9iamVjdC5zY2FsZS54LEU9Ri5vYmplY3Quc2NhbGUueSxOKj1GLnNjYWxlLngqQSxFKj1GLnNjYWxlLnkqTyxyYS5taW4uc2V0KHkueC1OLHkueS1FKSxyYS5tYXguc2V0KHkueCtOLHkueStFKSwhMT09PUhhLmlzSW50ZXJzZWN0aW9uQm94KHJhKT9yYS5tYWtlRW1wdHkoKToodChKLmNvbG9yLmdldFN0eWxlKCkpLEMuc2F2ZSgpLEMudHJhbnNsYXRlKHkueCx5LnkpLEMucm90YXRlKC1GLnJvdGF0aW9uKSxDLnNjYWxlKE4sRSksQy5maWxsUmVjdCgtMSwtMSwyLDIpLEMucmVzdG9yZSgpKSk6SiBpbnN0YW5jZW9mIFRIUkVFLlNwcml0ZUNhbnZhc01hdGVyaWFsJiYoeD1GLnNjYWxlLngqQSx2PUYuc2NhbGUueSpPLHJhLm1pbi5zZXQoeS54LXgseS55LXYpLHJhLm1heC5zZXQoeS54K3gseS55K3YpLCExPT09SGEuaXNJbnRlcnNlY3Rpb25Cb3gocmEpP1xucmEubWFrZUVtcHR5KCk6KHMoSi5jb2xvci5nZXRTdHlsZSgpKSx0KEouY29sb3IuZ2V0U3R5bGUoKSksQy5zYXZlKCksQy50cmFuc2xhdGUoeS54LHkueSksQy5yb3RhdGUoLUYucm90YXRpb24pLEMuc2NhbGUoeCx2KSxKLnByb2dyYW0oQyksQy5yZXN0b3JlKCkpKX1lbHNlIGlmKHggaW5zdGFuY2VvZiBUSFJFRS5SZW5kZXJhYmxlTGluZSl7aWYoUT14LnYxLEs9eC52MixRLnBvc2l0aW9uU2NyZWVuLngqPUEsUS5wb3NpdGlvblNjcmVlbi55Kj1PLEsucG9zaXRpb25TY3JlZW4ueCo9QSxLLnBvc2l0aW9uU2NyZWVuLnkqPU8scmEuc2V0RnJvbVBvaW50cyhbUS5wb3NpdGlvblNjcmVlbixLLnBvc2l0aW9uU2NyZWVuXSksITA9PT1IYS5pc0ludGVyc2VjdGlvbkJveChyYSkpaWYoeT1RLEY9SyxKPXgseD12LGkoeC5vcGFjaXR5KSxrKHguYmxlbmRpbmcpLEMuYmVnaW5QYXRoKCksQy5tb3ZlVG8oeS5wb3NpdGlvblNjcmVlbi54LHkucG9zaXRpb25TY3JlZW4ueSksQy5saW5lVG8oRi5wb3NpdGlvblNjcmVlbi54LFxuRi5wb3NpdGlvblNjcmVlbi55KSx4IGluc3RhbmNlb2YgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwpe20oeC5saW5ld2lkdGgpO2woeC5saW5lY2FwKTtwKHgubGluZWpvaW4pO2lmKHgudmVydGV4Q29sb3JzIT09VEhSRUUuVmVydGV4Q29sb3JzKXMoeC5jb2xvci5nZXRTdHlsZSgpKTtlbHNlIGlmKHY9Si52ZXJ0ZXhDb2xvcnNbMF0uZ2V0U3R5bGUoKSxKPUoudmVydGV4Q29sb3JzWzFdLmdldFN0eWxlKCksdj09PUopcyh2KTtlbHNle3RyeXt2YXIgZmE9Qy5jcmVhdGVMaW5lYXJHcmFkaWVudCh5LnBvc2l0aW9uU2NyZWVuLngseS5wb3NpdGlvblNjcmVlbi55LEYucG9zaXRpb25TY3JlZW4ueCxGLnBvc2l0aW9uU2NyZWVuLnkpO2ZhLmFkZENvbG9yU3RvcCgwLHYpO2ZhLmFkZENvbG9yU3RvcCgxLEopfWNhdGNoKG9hKXtmYT12fXMoZmEpfUMuc3Ryb2tlKCk7cmEuZXhwYW5kQnlTY2FsYXIoMip4LmxpbmV3aWR0aCl9ZWxzZSB4IGluc3RhbmNlb2YgVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsJiZcbihtKHgubGluZXdpZHRoKSxsKHgubGluZWNhcCkscCh4LmxpbmVqb2luKSxzKHguY29sb3IuZ2V0U3R5bGUoKSksbih4LmRhc2hTaXplLHguZ2FwU2l6ZSksQy5zdHJva2UoKSxyYS5leHBhbmRCeVNjYWxhcigyKngubGluZXdpZHRoKSxuKG51bGwsbnVsbCkpfWVsc2UgaWYoeCBpbnN0YW5jZW9mIFRIUkVFLlJlbmRlcmFibGVGYWNlMyl7UT14LnYxO0s9eC52MjtjYT14LnYzO2lmKC0xPlEucG9zaXRpb25TY3JlZW4uenx8MTxRLnBvc2l0aW9uU2NyZWVuLnopY29udGludWU7aWYoLTE+Sy5wb3NpdGlvblNjcmVlbi56fHwxPEsucG9zaXRpb25TY3JlZW4ueiljb250aW51ZTtpZigtMT5jYS5wb3NpdGlvblNjcmVlbi56fHwxPGNhLnBvc2l0aW9uU2NyZWVuLnopY29udGludWU7US5wb3NpdGlvblNjcmVlbi54Kj1BO1EucG9zaXRpb25TY3JlZW4ueSo9TztLLnBvc2l0aW9uU2NyZWVuLngqPUE7Sy5wb3NpdGlvblNjcmVlbi55Kj1PO2NhLnBvc2l0aW9uU2NyZWVuLngqPUE7Y2EucG9zaXRpb25TY3JlZW4ueSo9XG5POzA8di5vdmVyZHJhdyYmKGcoUS5wb3NpdGlvblNjcmVlbixLLnBvc2l0aW9uU2NyZWVuLHYub3ZlcmRyYXcpLGcoSy5wb3NpdGlvblNjcmVlbixjYS5wb3NpdGlvblNjcmVlbix2Lm92ZXJkcmF3KSxnKGNhLnBvc2l0aW9uU2NyZWVuLFEucG9zaXRpb25TY3JlZW4sdi5vdmVyZHJhdykpO3JhLnNldEZyb21Qb2ludHMoW1EucG9zaXRpb25TY3JlZW4sSy5wb3NpdGlvblNjcmVlbixjYS5wb3NpdGlvblNjcmVlbl0pO2lmKCEwPT09SGEuaXNJbnRlcnNlY3Rpb25Cb3gocmEpKXt5PVE7Rj1LO0o9Y2E7cS5pbmZvLnJlbmRlci52ZXJ0aWNlcys9MztxLmluZm8ucmVuZGVyLmZhY2VzKys7aSh2Lm9wYWNpdHkpO2sodi5ibGVuZGluZyk7RmE9eS5wb3NpdGlvblNjcmVlbi54O0JhPXkucG9zaXRpb25TY3JlZW4ueTtkYT1GLnBvc2l0aW9uU2NyZWVuLng7QWE9Ri5wb3NpdGlvblNjcmVlbi55OyQ9Si5wb3NpdGlvblNjcmVlbi54O2VhPUoucG9zaXRpb25TY3JlZW4ueTt2YXIgTj1GYSxFPUJhLFxuST1kYSxSPUFhLGJhPSQscGE9ZWE7Qy5iZWdpblBhdGgoKTtDLm1vdmVUbyhOLEUpO0MubGluZVRvKEksUik7Qy5saW5lVG8oYmEscGEpO0MuY2xvc2VQYXRoKCk7KHYgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsfHx2IGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwpJiZudWxsPT09di5tYXA/KHRhLmNvcHkodi5jb2xvciksaWEuY29weSh2LmVtaXNzaXZlKSx2LnZlcnRleENvbG9ycz09PVRIUkVFLkZhY2VDb2xvcnMmJnRhLm11bHRpcGx5KHguY29sb3IpLCExPT09di53aXJlZnJhbWUmJnYuc2hhZGluZz09VEhSRUUuU21vb3RoU2hhZGluZyYmMz09eC52ZXJ0ZXhOb3JtYWxzTGVuZ3RoPyhQLmNvcHkoZ2IpLFouY29weShnYiksVS5jb3B5KGdiKSxiKHgudjEucG9zaXRpb25Xb3JsZCx4LnZlcnRleE5vcm1hbHNNb2RlbFswXSxQKSxiKHgudjIucG9zaXRpb25Xb3JsZCx4LnZlcnRleE5vcm1hbHNNb2RlbFsxXSxaKSxiKHgudjMucG9zaXRpb25Xb3JsZCxcbngudmVydGV4Tm9ybWFsc01vZGVsWzJdLFUpLFAubXVsdGlwbHkodGEpLmFkZChpYSksWi5tdWx0aXBseSh0YSkuYWRkKGlhKSxVLm11bHRpcGx5KHRhKS5hZGQoaWEpLGthLmFkZENvbG9ycyhaLFUpLm11bHRpcGx5U2NhbGFyKDAuNSksUWE9aChQLFosVSxrYSksZihGYSxCYSxkYSxBYSwkLGVhLDAsMCwxLDAsMCwxLFFhKSk6KFYuY29weShnYiksYih4LmNlbnRyb2lkTW9kZWwseC5ub3JtYWxNb2RlbCxWKSxWLm11bHRpcGx5KHRhKS5hZGQoaWEpLCEwPT09di53aXJlZnJhbWU/YyhWLHYud2lyZWZyYW1lTGluZXdpZHRoLHYud2lyZWZyYW1lTGluZWNhcCx2LndpcmVmcmFtZUxpbmVqb2luKTpkKFYpKSk6diBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsfHx2IGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbHx8diBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsP251bGwhPT12Lm1hcD92Lm1hcC5tYXBwaW5nIGluc3RhbmNlb2YgVEhSRUUuVVZNYXBwaW5nJiZcbih4YT14LnV2c1swXSxlKEZhLEJhLGRhLEFhLCQsZWEseGFbMF0ueCx4YVswXS55LHhhWzFdLngseGFbMV0ueSx4YVsyXS54LHhhWzJdLnksdi5tYXApKTpudWxsIT09di5lbnZNYXA/di5lbnZNYXAubWFwcGluZyBpbnN0YW5jZW9mIFRIUkVFLlNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nJiYodWEuY29weSh4LnZlcnRleE5vcm1hbHNNb2RlbFZpZXdbMF0pLGJiPTAuNSp1YS54KzAuNSxjYj0wLjUqdWEueSswLjUsdWEuY29weSh4LnZlcnRleE5vcm1hbHNNb2RlbFZpZXdbMV0pLE1hPTAuNSp1YS54KzAuNSxmYj0wLjUqdWEueSswLjUsdWEuY29weSh4LnZlcnRleE5vcm1hbHNNb2RlbFZpZXdbMl0pLHNiPTAuNSp1YS54KzAuNSxwYj0wLjUqdWEueSswLjUsZShGYSxCYSxkYSxBYSwkLGVhLGJiLGNiLE1hLGZiLHNiLHBiLHYuZW52TWFwKSk6KFYuY29weSh2LmNvbG9yKSx2LnZlcnRleENvbG9ycz09PVRIUkVFLkZhY2VDb2xvcnMmJlYubXVsdGlwbHkoeC5jb2xvciksITA9PT12LndpcmVmcmFtZT9cbmMoVix2LndpcmVmcmFtZUxpbmV3aWR0aCx2LndpcmVmcmFtZUxpbmVjYXAsdi53aXJlZnJhbWVMaW5lam9pbik6ZChWKSk6diBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsPyhEYT1NLm5lYXIsVWE9TS5mYXIsUC5yPVAuZz1QLmI9MS1yKHkucG9zaXRpb25TY3JlZW4ueip5LnBvc2l0aW9uU2NyZWVuLncsRGEsVWEpLFoucj1aLmc9Wi5iPTEtcihGLnBvc2l0aW9uU2NyZWVuLnoqRi5wb3NpdGlvblNjcmVlbi53LERhLFVhKSxVLnI9VS5nPVUuYj0xLXIoSi5wb3NpdGlvblNjcmVlbi56KkoucG9zaXRpb25TY3JlZW4udyxEYSxVYSksa2EuYWRkQ29sb3JzKFosVSkubXVsdGlwbHlTY2FsYXIoMC41KSxRYT1oKFAsWixVLGthKSxmKEZhLEJhLGRhLEFhLCQsZWEsMCwwLDEsMCwwLDEsUWEpKTp2IGluc3RhbmNlb2YgVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsJiYoeT12b2lkIDAsdi5zaGFkaW5nPT1USFJFRS5GbGF0U2hhZGluZz8oeT14Lm5vcm1hbE1vZGVsVmlldyxWLnNldFJHQih5LngsXG55LnkseS56KS5tdWx0aXBseVNjYWxhcigwLjUpLmFkZFNjYWxhcigwLjUpLCEwPT09di53aXJlZnJhbWU/YyhWLHYud2lyZWZyYW1lTGluZXdpZHRoLHYud2lyZWZyYW1lTGluZWNhcCx2LndpcmVmcmFtZUxpbmVqb2luKTpkKFYpKTp2LnNoYWRpbmc9PVRIUkVFLlNtb290aFNoYWRpbmcmJih5PXgudmVydGV4Tm9ybWFsc01vZGVsVmlld1swXSxQLnNldFJHQih5LngseS55LHkueikubXVsdGlwbHlTY2FsYXIoMC41KS5hZGRTY2FsYXIoMC41KSx5PXgudmVydGV4Tm9ybWFsc01vZGVsVmlld1sxXSxaLnNldFJHQih5LngseS55LHkueikubXVsdGlwbHlTY2FsYXIoMC41KS5hZGRTY2FsYXIoMC41KSx5PXgudmVydGV4Tm9ybWFsc01vZGVsVmlld1syXSxVLnNldFJHQih5LngseS55LHkueikubXVsdGlwbHlTY2FsYXIoMC41KS5hZGRTY2FsYXIoMC41KSxrYS5hZGRDb2xvcnMoWixVKS5tdWx0aXBseVNjYWxhcigwLjUpLFFhPWgoUCxaLFUsa2EpLGYoRmEsQmEsZGEsQWEsJCxlYSwwLDAsXG4xLDAsMCwxLFFhKSkpfX1sYS51bmlvbihyYSl9fUMuc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKX19fTtUSFJFRS5TaGFkZXJDaHVuaz17Zm9nX3BhcnNfZnJhZ21lbnQ6XCIjaWZkZWYgVVNFX0ZPR1xcbnVuaWZvcm0gdmVjMyBmb2dDb2xvcjtcXG4jaWZkZWYgRk9HX0VYUDJcXG51bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7XFxuI2Vsc2VcXG51bmlmb3JtIGZsb2F0IGZvZ05lYXI7XFxudW5pZm9ybSBmbG9hdCBmb2dGYXI7XFxuI2VuZGlmXFxuI2VuZGlmXCIsZm9nX2ZyYWdtZW50OlwiI2lmZGVmIFVTRV9GT0dcXG5mbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XFxuI2lmZGVmIEZPR19FWFAyXFxuY29uc3QgZmxvYXQgTE9HMiA9IDEuNDQyNjk1O1xcbmZsb2F0IGZvZ0ZhY3RvciA9IGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBkZXB0aCAqIGRlcHRoICogTE9HMiApO1xcbmZvZ0ZhY3RvciA9IDEuMCAtIGNsYW1wKCBmb2dGYWN0b3IsIDAuMCwgMS4wICk7XFxuI2Vsc2VcXG5mbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7XFxuI2VuZGlmXFxuZ2xfRnJhZ0NvbG9yID0gbWl4KCBnbF9GcmFnQ29sb3IsIHZlYzQoIGZvZ0NvbG9yLCBnbF9GcmFnQ29sb3IudyApLCBmb2dGYWN0b3IgKTtcXG4jZW5kaWZcIixcbmVudm1hcF9wYXJzX2ZyYWdtZW50OlwiI2lmZGVmIFVTRV9FTlZNQVBcXG51bmlmb3JtIGZsb2F0IHJlZmxlY3Rpdml0eTtcXG51bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG51bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7XFxudW5pZm9ybSBpbnQgY29tYmluZTtcXG4jaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQIClcXG51bmlmb3JtIGJvb2wgdXNlUmVmcmFjdDtcXG51bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG4jZWxzZVxcbnZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG4jZW5kaWZcXG4jZW5kaWZcIixlbnZtYXBfZnJhZ21lbnQ6XCIjaWZkZWYgVVNFX0VOVk1BUFxcbnZlYzMgcmVmbGVjdFZlYztcXG4jaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQIClcXG52ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuaWYgKCB1c2VSZWZyYWN0ICkge1xcbnJlZmxlY3RWZWMgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgbm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG59IGVsc2UgeyBcXG5yZWZsZWN0VmVjID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIG5vcm1hbCApO1xcbn1cXG4jZWxzZVxcbnJlZmxlY3RWZWMgPSB2UmVmbGVjdDtcXG4jZW5kaWZcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuZmxvYXQgZmxpcE5vcm1hbCA9ICggLTEuMCArIDIuMCAqIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICk7XFxudmVjNCBjdWJlQ29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBmbGlwTm9ybWFsICogdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7XFxuI2Vsc2VcXG52ZWM0IGN1YmVDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKSApO1xcbiNlbmRpZlxcbiNpZmRlZiBHQU1NQV9JTlBVVFxcbmN1YmVDb2xvci54eXogKj0gY3ViZUNvbG9yLnh5ejtcXG4jZW5kaWZcXG5pZiAoIGNvbWJpbmUgPT0gMSApIHtcXG5nbF9GcmFnQ29sb3IueHl6ID0gbWl4KCBnbF9GcmFnQ29sb3IueHl6LCBjdWJlQ29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxufSBlbHNlIGlmICggY29tYmluZSA9PSAyICkge1xcbmdsX0ZyYWdDb2xvci54eXogKz0gY3ViZUNvbG9yLnh5eiAqIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHk7XFxufSBlbHNlIHtcXG5nbF9GcmFnQ29sb3IueHl6ID0gbWl4KCBnbF9GcmFnQ29sb3IueHl6LCBnbF9GcmFnQ29sb3IueHl6ICogY3ViZUNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcbn1cXG4jZW5kaWZcIixcbmVudm1hcF9wYXJzX3ZlcnRleDpcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfQlVNUE1BUCApICYmICEgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApXFxudmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcbnVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1xcbnVuaWZvcm0gYm9vbCB1c2VSZWZyYWN0O1xcbiNlbmRpZlwiLHdvcmxkcG9zX3ZlcnRleDpcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKSB8fCBkZWZpbmVkKCBMQU1CRVJUICkgfHwgZGVmaW5lZCAoIFVTRV9TSEFET1dNQVAgKVxcbiNpZmRlZiBVU0VfU0tJTk5JTkdcXG52ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHNraW5uZWQ7XFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoIFVTRV9NT1JQSFRBUkdFVFMgKSAmJiAhIGRlZmluZWQoIFVTRV9TS0lOTklORyApXFxudmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCBtb3JwaGVkLCAxLjAgKTtcXG4jZW5kaWZcXG4jaWYgISBkZWZpbmVkKCBVU0VfTU9SUEhUQVJHRVRTICkgJiYgISBkZWZpbmVkKCBVU0VfU0tJTk5JTkcgKVxcbnZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbiNlbmRpZlxcbiNlbmRpZlwiLFxuZW52bWFwX3ZlcnRleDpcIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfQlVNUE1BUCApICYmICEgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApXFxudmVjMyB3b3JsZE5vcm1hbCA9IG1hdDMoIG1vZGVsTWF0cml4WyAwIF0ueHl6LCBtb2RlbE1hdHJpeFsgMSBdLnh5eiwgbW9kZWxNYXRyaXhbIDIgXS54eXogKSAqIG9iamVjdE5vcm1hbDtcXG53b3JsZE5vcm1hbCA9IG5vcm1hbGl6ZSggd29ybGROb3JtYWwgKTtcXG52ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB3b3JsZFBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuaWYgKCB1c2VSZWZyYWN0ICkge1xcbnZSZWZsZWN0ID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG59IGVsc2Uge1xcbnZSZWZsZWN0ID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxufVxcbiNlbmRpZlwiLG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50OlwiI2lmZGVmIFVTRV9NQVBcXG51bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxuI2VuZGlmXCIsXG5tYXBfcGFydGljbGVfZnJhZ21lbnQ6XCIjaWZkZWYgVVNFX01BUFxcbmdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvciAqIHRleHR1cmUyRCggbWFwLCB2ZWMyKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSApICk7XFxuI2VuZGlmXCIsbWFwX3BhcnNfdmVydGV4OlwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKVxcbnZhcnlpbmcgdmVjMiB2VXY7XFxudW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcXG4jZW5kaWZcIixtYXBfcGFyc19mcmFnbWVudDpcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQIClcXG52YXJ5aW5nIHZlYzIgdlV2O1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTUFQXFxudW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcbiNlbmRpZlwiLFxubWFwX3ZlcnRleDpcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQIClcXG52VXYgPSB1diAqIG9mZnNldFJlcGVhdC56dyArIG9mZnNldFJlcGVhdC54eTtcXG4jZW5kaWZcIixtYXBfZnJhZ21lbnQ6XCIjaWZkZWYgVVNFX01BUFxcbnZlYzQgdGV4ZWxDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VXYgKTtcXG4jaWZkZWYgR0FNTUFfSU5QVVRcXG50ZXhlbENvbG9yLnh5eiAqPSB0ZXhlbENvbG9yLnh5ejtcXG4jZW5kaWZcXG5nbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3IgKiB0ZXhlbENvbG9yO1xcbiNlbmRpZlwiLGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ6XCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxudmFyeWluZyB2ZWMyIHZVdjI7XFxudW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7XFxuI2VuZGlmXCIsbGlnaHRtYXBfcGFyc192ZXJ0ZXg6XCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxudmFyeWluZyB2ZWMyIHZVdjI7XFxuI2VuZGlmXCIsXG5saWdodG1hcF9mcmFnbWVudDpcIiNpZmRlZiBVU0VfTElHSFRNQVBcXG5nbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3IgKiB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICk7XFxuI2VuZGlmXCIsbGlnaHRtYXBfdmVydGV4OlwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcbnZVdjIgPSB1djI7XFxuI2VuZGlmXCIsYnVtcG1hcF9wYXJzX2ZyYWdtZW50OlwiI2lmZGVmIFVTRV9CVU1QTUFQXFxudW5pZm9ybSBzYW1wbGVyMkQgYnVtcE1hcDtcXG51bmlmb3JtIGZsb2F0IGJ1bXBTY2FsZTtcXG52ZWMyIGRIZHh5X2Z3ZCgpIHtcXG52ZWMyIGRTVGR4ID0gZEZkeCggdlV2ICk7XFxudmVjMiBkU1RkeSA9IGRGZHkoIHZVdiApO1xcbmZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICkueDtcXG5mbG9hdCBkQnggPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR4ICkueCAtIEhsbDtcXG5mbG9hdCBkQnkgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR5ICkueCAtIEhsbDtcXG5yZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTtcXG59XFxudmVjMyBwZXJ0dXJiTm9ybWFsQXJiKCB2ZWMzIHN1cmZfcG9zLCB2ZWMzIHN1cmZfbm9ybSwgdmVjMiBkSGR4eSApIHtcXG52ZWMzIHZTaWdtYVggPSBkRmR4KCBzdXJmX3BvcyApO1xcbnZlYzMgdlNpZ21hWSA9IGRGZHkoIHN1cmZfcG9zICk7XFxudmVjMyB2TiA9IHN1cmZfbm9ybTtcXG52ZWMzIFIxID0gY3Jvc3MoIHZTaWdtYVksIHZOICk7XFxudmVjMyBSMiA9IGNyb3NzKCB2TiwgdlNpZ21hWCApO1xcbmZsb2F0IGZEZXQgPSBkb3QoIHZTaWdtYVgsIFIxICk7XFxudmVjMyB2R3JhZCA9IHNpZ24oIGZEZXQgKSAqICggZEhkeHkueCAqIFIxICsgZEhkeHkueSAqIFIyICk7XFxucmV0dXJuIG5vcm1hbGl6ZSggYWJzKCBmRGV0ICkgKiBzdXJmX25vcm0gLSB2R3JhZCApO1xcbn1cXG4jZW5kaWZcIixcbm5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50OlwiI2lmZGVmIFVTRV9OT1JNQUxNQVBcXG51bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxudW5pZm9ybSB2ZWMyIG5vcm1hbFNjYWxlO1xcbnZlYzMgcGVydHVyYk5vcm1hbDJBcmIoIHZlYzMgZXllX3BvcywgdmVjMyBzdXJmX25vcm0gKSB7XFxudmVjMyBxMCA9IGRGZHgoIGV5ZV9wb3MueHl6ICk7XFxudmVjMyBxMSA9IGRGZHkoIGV5ZV9wb3MueHl6ICk7XFxudmVjMiBzdDAgPSBkRmR4KCB2VXYuc3QgKTtcXG52ZWMyIHN0MSA9IGRGZHkoIHZVdi5zdCApO1xcbnZlYzMgUyA9IG5vcm1hbGl6ZSggIHEwICogc3QxLnQgLSBxMSAqIHN0MC50ICk7XFxudmVjMyBUID0gbm9ybWFsaXplKCAtcTAgKiBzdDEucyArIHExICogc3QwLnMgKTtcXG52ZWMzIE4gPSBub3JtYWxpemUoIHN1cmZfbm9ybSApO1xcbnZlYzMgbWFwTiA9IHRleHR1cmUyRCggbm9ybWFsTWFwLCB2VXYgKS54eXogKiAyLjAgLSAxLjA7XFxubWFwTi54eSA9IG5vcm1hbFNjYWxlICogbWFwTi54eTtcXG5tYXQzIHRzbiA9IG1hdDMoIFMsIFQsIE4gKTtcXG5yZXR1cm4gbm9ybWFsaXplKCB0c24gKiBtYXBOICk7XFxufVxcbiNlbmRpZlwiLFxuc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudDpcIiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG51bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhck1hcDtcXG4jZW5kaWZcIixzcGVjdWxhcm1hcF9mcmFnbWVudDpcImZsb2F0IHNwZWN1bGFyU3RyZW5ndGg7XFxuI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcbnZlYzQgdGV4ZWxTcGVjdWxhciA9IHRleHR1cmUyRCggc3BlY3VsYXJNYXAsIHZVdiApO1xcbnNwZWN1bGFyU3RyZW5ndGggPSB0ZXhlbFNwZWN1bGFyLnI7XFxuI2Vsc2VcXG5zcGVjdWxhclN0cmVuZ3RoID0gMS4wO1xcbiNlbmRpZlwiLGxpZ2h0c19sYW1iZXJ0X3BhcnNfdmVydGV4OlwidW5pZm9ybSB2ZWMzIGFtYmllbnQ7XFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gdmVjMyBhbWJpZW50TGlnaHRDb2xvcjtcXG4jaWYgTUFYX0RJUl9MSUdIVFMgPiAwXFxudW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgTUFYX0RJUl9MSUdIVFMgXTtcXG51bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgTUFYX0RJUl9MSUdIVFMgXTtcXG4jZW5kaWZcXG4jaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcbnVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XFxudW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG51bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG4jZW5kaWZcXG4jaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG51bmlmb3JtIHZlYzMgcG9pbnRMaWdodENvbG9yWyBNQVhfUE9JTlRfTElHSFRTIF07XFxudW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRQb3NpdGlvblsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcbnVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERpc3RhbmNlWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuI2VuZGlmXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG51bmlmb3JtIHZlYzMgc3BvdExpZ2h0Q29sb3JbIE1BWF9TUE9UX0xJR0hUUyBdO1xcbnVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XFxudW5pZm9ybSB2ZWMzIHNwb3RMaWdodERpcmVjdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XFxudW5pZm9ybSBmbG9hdCBzcG90TGlnaHREaXN0YW5jZVsgTUFYX1NQT1RfTElHSFRTIF07XFxudW5pZm9ybSBmbG9hdCBzcG90TGlnaHRBbmdsZUNvc1sgTUFYX1NQT1RfTElHSFRTIF07XFxudW5pZm9ybSBmbG9hdCBzcG90TGlnaHRFeHBvbmVudFsgTUFYX1NQT1RfTElHSFRTIF07XFxuI2VuZGlmXFxuI2lmZGVmIFdSQVBfQVJPVU5EXFxudW5pZm9ybSB2ZWMzIHdyYXBSR0I7XFxuI2VuZGlmXCIsXG5saWdodHNfbGFtYmVydF92ZXJ0ZXg6XCJ2TGlnaHRGcm9udCA9IHZlYzMoIDAuMCApO1xcbiNpZmRlZiBET1VCTEVfU0lERURcXG52TGlnaHRCYWNrID0gdmVjMyggMC4wICk7XFxuI2VuZGlmXFxudHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcbmZvciggaW50IGkgPSAwOyBpIDwgTUFYX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxudmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXSwgMC4wICk7XFxudmVjMyBkaXJWZWN0b3IgPSBub3JtYWxpemUoIGxEaXJlY3Rpb24ueHl6ICk7XFxuZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggdHJhbnNmb3JtZWROb3JtYWwsIGRpclZlY3RvciApO1xcbnZlYzMgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZyA9IHZlYzMoIG1heCggZG90UHJvZHVjdCwgMC4wICkgKTtcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxudmVjMyBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nQmFjayA9IHZlYzMoIG1heCggLWRvdFByb2R1Y3QsIDAuMCApICk7XFxuI2lmZGVmIFdSQVBfQVJPVU5EXFxudmVjMyBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nSGFsZkJhY2sgPSB2ZWMzKCBtYXgoIC0wLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKSApO1xcbiNlbmRpZlxcbiNlbmRpZlxcbiNpZmRlZiBXUkFQX0FST1VORFxcbnZlYzMgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0hhbGYgPSB2ZWMzKCBtYXgoIDAuNSAqIGRvdFByb2R1Y3QgKyAwLjUsIDAuMCApICk7XFxuZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZyA9IG1peCggZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZywgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0hhbGYsIHdyYXBSR0IgKTtcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0JhY2sgPSBtaXgoIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdCYWNrLCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nSGFsZkJhY2ssIHdyYXBSR0IgKTtcXG4jZW5kaWZcXG4jZW5kaWZcXG52TGlnaHRGcm9udCArPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmc7XFxuI2lmZGVmIERPVUJMRV9TSURFRFxcbnZMaWdodEJhY2sgKz0gZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nQmFjaztcXG4jZW5kaWZcXG59XFxuI2VuZGlmXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1xcbnZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHBvaW50TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcXG52ZWMzIGxWZWN0b3IgPSBsUG9zaXRpb24ueHl6IC0gbXZQb3NpdGlvbi54eXo7XFxuZmxvYXQgbERpc3RhbmNlID0gMS4wO1xcbmlmICggcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gPiAwLjAgKVxcbmxEaXN0YW5jZSA9IDEuMCAtIG1pbiggKCBsZW5ndGgoIGxWZWN0b3IgKSAvIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdICksIDEuMCApO1xcbmxWZWN0b3IgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5mbG9hdCBkb3RQcm9kdWN0ID0gZG90KCB0cmFuc2Zvcm1lZE5vcm1hbCwgbFZlY3RvciApO1xcbnZlYzMgcG9pbnRMaWdodFdlaWdodGluZyA9IHZlYzMoIG1heCggZG90UHJvZHVjdCwgMC4wICkgKTtcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxudmVjMyBwb2ludExpZ2h0V2VpZ2h0aW5nQmFjayA9IHZlYzMoIG1heCggLWRvdFByb2R1Y3QsIDAuMCApICk7XFxuI2lmZGVmIFdSQVBfQVJPVU5EXFxudmVjMyBwb2ludExpZ2h0V2VpZ2h0aW5nSGFsZkJhY2sgPSB2ZWMzKCBtYXgoIC0wLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKSApO1xcbiNlbmRpZlxcbiNlbmRpZlxcbiNpZmRlZiBXUkFQX0FST1VORFxcbnZlYzMgcG9pbnRMaWdodFdlaWdodGluZ0hhbGYgPSB2ZWMzKCBtYXgoIDAuNSAqIGRvdFByb2R1Y3QgKyAwLjUsIDAuMCApICk7XFxucG9pbnRMaWdodFdlaWdodGluZyA9IG1peCggcG9pbnRMaWdodFdlaWdodGluZywgcG9pbnRMaWdodFdlaWdodGluZ0hhbGYsIHdyYXBSR0IgKTtcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxucG9pbnRMaWdodFdlaWdodGluZ0JhY2sgPSBtaXgoIHBvaW50TGlnaHRXZWlnaHRpbmdCYWNrLCBwb2ludExpZ2h0V2VpZ2h0aW5nSGFsZkJhY2ssIHdyYXBSR0IgKTtcXG4jZW5kaWZcXG4jZW5kaWZcXG52TGlnaHRGcm9udCArPSBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50TGlnaHRXZWlnaHRpbmcgKiBsRGlzdGFuY2U7XFxuI2lmZGVmIERPVUJMRV9TSURFRFxcbnZMaWdodEJhY2sgKz0gcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludExpZ2h0V2VpZ2h0aW5nQmFjayAqIGxEaXN0YW5jZTtcXG4jZW5kaWZcXG59XFxuI2VuZGlmXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5mb3IoIGludCBpID0gMDsgaSA8IE1BWF9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG52ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBzcG90TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcXG52ZWMzIGxWZWN0b3IgPSBsUG9zaXRpb24ueHl6IC0gbXZQb3NpdGlvbi54eXo7XFxuZmxvYXQgc3BvdEVmZmVjdCA9IGRvdCggc3BvdExpZ2h0RGlyZWN0aW9uWyBpIF0sIG5vcm1hbGl6ZSggc3BvdExpZ2h0UG9zaXRpb25bIGkgXSAtIHdvcmxkUG9zaXRpb24ueHl6ICkgKTtcXG5pZiAoIHNwb3RFZmZlY3QgPiBzcG90TGlnaHRBbmdsZUNvc1sgaSBdICkge1xcbnNwb3RFZmZlY3QgPSBtYXgoIHBvdyggc3BvdEVmZmVjdCwgc3BvdExpZ2h0RXhwb25lbnRbIGkgXSApLCAwLjAgKTtcXG5mbG9hdCBsRGlzdGFuY2UgPSAxLjA7XFxuaWYgKCBzcG90TGlnaHREaXN0YW5jZVsgaSBdID4gMC4wIClcXG5sRGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBsVmVjdG9yICkgLyBzcG90TGlnaHREaXN0YW5jZVsgaSBdICksIDEuMCApO1xcbmxWZWN0b3IgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5mbG9hdCBkb3RQcm9kdWN0ID0gZG90KCB0cmFuc2Zvcm1lZE5vcm1hbCwgbFZlY3RvciApO1xcbnZlYzMgc3BvdExpZ2h0V2VpZ2h0aW5nID0gdmVjMyggbWF4KCBkb3RQcm9kdWN0LCAwLjAgKSApO1xcbiNpZmRlZiBET1VCTEVfU0lERURcXG52ZWMzIHNwb3RMaWdodFdlaWdodGluZ0JhY2sgPSB2ZWMzKCBtYXgoIC1kb3RQcm9kdWN0LCAwLjAgKSApO1xcbiNpZmRlZiBXUkFQX0FST1VORFxcbnZlYzMgc3BvdExpZ2h0V2VpZ2h0aW5nSGFsZkJhY2sgPSB2ZWMzKCBtYXgoIC0wLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKSApO1xcbiNlbmRpZlxcbiNlbmRpZlxcbiNpZmRlZiBXUkFQX0FST1VORFxcbnZlYzMgc3BvdExpZ2h0V2VpZ2h0aW5nSGFsZiA9IHZlYzMoIG1heCggMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICkgKTtcXG5zcG90TGlnaHRXZWlnaHRpbmcgPSBtaXgoIHNwb3RMaWdodFdlaWdodGluZywgc3BvdExpZ2h0V2VpZ2h0aW5nSGFsZiwgd3JhcFJHQiApO1xcbiNpZmRlZiBET1VCTEVfU0lERURcXG5zcG90TGlnaHRXZWlnaHRpbmdCYWNrID0gbWl4KCBzcG90TGlnaHRXZWlnaHRpbmdCYWNrLCBzcG90TGlnaHRXZWlnaHRpbmdIYWxmQmFjaywgd3JhcFJHQiApO1xcbiNlbmRpZlxcbiNlbmRpZlxcbnZMaWdodEZyb250ICs9IHNwb3RMaWdodENvbG9yWyBpIF0gKiBzcG90TGlnaHRXZWlnaHRpbmcgKiBsRGlzdGFuY2UgKiBzcG90RWZmZWN0O1xcbiNpZmRlZiBET1VCTEVfU0lERURcXG52TGlnaHRCYWNrICs9IHNwb3RMaWdodENvbG9yWyBpIF0gKiBzcG90TGlnaHRXZWlnaHRpbmdCYWNrICogbERpc3RhbmNlICogc3BvdEVmZmVjdDtcXG4jZW5kaWZcXG59XFxufVxcbiNlbmRpZlxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxuZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxudmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgaSBdLCAwLjAgKTtcXG52ZWMzIGxWZWN0b3IgPSBub3JtYWxpemUoIGxEaXJlY3Rpb24ueHl6ICk7XFxuZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggdHJhbnNmb3JtZWROb3JtYWwsIGxWZWN0b3IgKTtcXG5mbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdFByb2R1Y3QgKyAwLjU7XFxuZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHRCYWNrID0gLTAuNSAqIGRvdFByb2R1Y3QgKyAwLjU7XFxudkxpZ2h0RnJvbnQgKz0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodCApO1xcbiNpZmRlZiBET1VCTEVfU0lERURcXG52TGlnaHRCYWNrICs9IG1peCggaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIGkgXSwgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIGkgXSwgaGVtaURpZmZ1c2VXZWlnaHRCYWNrICk7XFxuI2VuZGlmXFxufVxcbiNlbmRpZlxcbnZMaWdodEZyb250ID0gdkxpZ2h0RnJvbnQgKiBkaWZmdXNlICsgYW1iaWVudCAqIGFtYmllbnRMaWdodENvbG9yICsgZW1pc3NpdmU7XFxuI2lmZGVmIERPVUJMRV9TSURFRFxcbnZMaWdodEJhY2sgPSB2TGlnaHRCYWNrICogZGlmZnVzZSArIGFtYmllbnQgKiBhbWJpZW50TGlnaHRDb2xvciArIGVtaXNzaXZlO1xcbiNlbmRpZlwiLFxubGlnaHRzX3Bob25nX3BhcnNfdmVydGV4OlwiI2lmbmRlZiBQSE9OR19QRVJfUElYRUxcXG4jaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG51bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XFxudW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGlzdGFuY2VbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG52YXJ5aW5nIHZlYzQgdlBvaW50TGlnaHRbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG4jZW5kaWZcXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMFxcbnVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XFxudW5pZm9ybSBmbG9hdCBzcG90TGlnaHREaXN0YW5jZVsgTUFYX1NQT1RfTElHSFRTIF07XFxudmFyeWluZyB2ZWM0IHZTcG90TGlnaHRbIE1BWF9TUE9UX0xJR0hUUyBdO1xcbiNlbmRpZlxcbiNlbmRpZlxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQIClcXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuI2VuZGlmXCIsXG5saWdodHNfcGhvbmdfdmVydGV4OlwiI2lmbmRlZiBQSE9OR19QRVJfUElYRUxcXG4jaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5mb3IoIGludCBpID0gMDsgaSA8IE1BWF9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxudmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggcG9pbnRMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1xcbnZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogLSBtdlBvc2l0aW9uLnh5ejtcXG5mbG9hdCBsRGlzdGFuY2UgPSAxLjA7XFxuaWYgKCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSA+IDAuMCApXFxubERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggbFZlY3RvciApIC8gcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gKSwgMS4wICk7XFxudlBvaW50TGlnaHRbIGkgXSA9IHZlYzQoIGxWZWN0b3IsIGxEaXN0YW5jZSApO1xcbn1cXG4jZW5kaWZcXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMFxcbmZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NQT1RfTElHSFRTOyBpICsrICkge1xcbnZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1xcbnZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogLSBtdlBvc2l0aW9uLnh5ejtcXG5mbG9hdCBsRGlzdGFuY2UgPSAxLjA7XFxuaWYgKCBzcG90TGlnaHREaXN0YW5jZVsgaSBdID4gMC4wIClcXG5sRGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBsVmVjdG9yICkgLyBzcG90TGlnaHREaXN0YW5jZVsgaSBdICksIDEuMCApO1xcbnZTcG90TGlnaHRbIGkgXSA9IHZlYzQoIGxWZWN0b3IsIGxEaXN0YW5jZSApO1xcbn1cXG4jZW5kaWZcXG4jZW5kaWZcXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMCB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApXFxudldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcXG4jZW5kaWZcIixcbmxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50OlwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1xcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG51bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yWyBNQVhfRElSX0xJR0hUUyBdO1xcbnVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBNQVhfRElSX0xJR0hUUyBdO1xcbiNlbmRpZlxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxudW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG51bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcbnVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIE1BWF9IRU1JX0xJR0hUUyBdO1xcbiNlbmRpZlxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcbnVuaWZvcm0gdmVjMyBwb2ludExpZ2h0Q29sb3JbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG4jaWZkZWYgUEhPTkdfUEVSX1BJWEVMXFxudW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRQb3NpdGlvblsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcbnVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERpc3RhbmNlWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuI2Vsc2VcXG52YXJ5aW5nIHZlYzQgdlBvaW50TGlnaHRbIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG4jZW5kaWZcXG4jZW5kaWZcXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMFxcbnVuaWZvcm0gdmVjMyBzcG90TGlnaHRDb2xvclsgTUFYX1NQT1RfTElHSFRTIF07XFxudW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG51bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGlyZWN0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG51bmlmb3JtIGZsb2F0IHNwb3RMaWdodEFuZ2xlQ29zWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG51bmlmb3JtIGZsb2F0IHNwb3RMaWdodEV4cG9uZW50WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG4jaWZkZWYgUEhPTkdfUEVSX1BJWEVMXFxudW5pZm9ybSBmbG9hdCBzcG90TGlnaHREaXN0YW5jZVsgTUFYX1NQT1RfTElHSFRTIF07XFxuI2Vsc2VcXG52YXJ5aW5nIHZlYzQgdlNwb3RMaWdodFsgTUFYX1NQT1RfTElHSFRTIF07XFxuI2VuZGlmXFxuI2VuZGlmXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDAgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVxcbnZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4jZW5kaWZcXG4jaWZkZWYgV1JBUF9BUk9VTkRcXG51bmlmb3JtIHZlYzMgd3JhcFJHQjtcXG4jZW5kaWZcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcbmxpZ2h0c19waG9uZ19mcmFnbWVudDpcInZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7XFxudmVjMyB2aWV3UG9zaXRpb24gPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxubm9ybWFsID0gbm9ybWFsICogKCAtMS4wICsgMi4wICogZmxvYXQoIGdsX0Zyb250RmFjaW5nICkgKTtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX05PUk1BTE1BUFxcbm5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsICk7XFxuI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVxcbm5vcm1hbCA9IHBlcnR1cmJOb3JtYWxBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwsIGRIZHh5X2Z3ZCgpICk7XFxuI2VuZGlmXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxudmVjMyBwb2ludERpZmZ1c2UgID0gdmVjMyggMC4wICk7XFxudmVjMyBwb2ludFNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuZm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG4jaWZkZWYgUEhPTkdfUEVSX1BJWEVMXFxudmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggcG9pbnRMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1xcbnZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogKyB2Vmlld1Bvc2l0aW9uLnh5ejtcXG5mbG9hdCBsRGlzdGFuY2UgPSAxLjA7XFxuaWYgKCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSA+IDAuMCApXFxubERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggbFZlY3RvciApIC8gcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gKSwgMS4wICk7XFxubFZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcbiNlbHNlXFxudmVjMyBsVmVjdG9yID0gbm9ybWFsaXplKCB2UG9pbnRMaWdodFsgaSBdLnh5eiApO1xcbmZsb2F0IGxEaXN0YW5jZSA9IHZQb2ludExpZ2h0WyBpIF0udztcXG4jZW5kaWZcXG5mbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxWZWN0b3IgKTtcXG4jaWZkZWYgV1JBUF9BUk9VTkRcXG5mbG9hdCBwb2ludERpZmZ1c2VXZWlnaHRGdWxsID0gbWF4KCBkb3RQcm9kdWN0LCAwLjAgKTtcXG5mbG9hdCBwb2ludERpZmZ1c2VXZWlnaHRIYWxmID0gbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKTtcXG52ZWMzIHBvaW50RGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyAoIHBvaW50RGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggcG9pbnREaWZmdXNlV2VpZ2h0SGFsZiApLCB3cmFwUkdCICk7XFxuI2Vsc2VcXG5mbG9hdCBwb2ludERpZmZ1c2VXZWlnaHQgPSBtYXgoIGRvdFByb2R1Y3QsIDAuMCApO1xcbiNlbmRpZlxcbnBvaW50RGlmZnVzZSAgKz0gZGlmZnVzZSAqIHBvaW50TGlnaHRDb2xvclsgaSBdICogcG9pbnREaWZmdXNlV2VpZ2h0ICogbERpc3RhbmNlO1xcbnZlYzMgcG9pbnRIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBsVmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XFxuZmxvYXQgcG9pbnREb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgcG9pbnRIYWxmVmVjdG9yICksIDAuMCApO1xcbmZsb2F0IHBvaW50U3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIHBvaW50RG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1xcbiNpZmRlZiBQSFlTSUNBTExZX0JBU0VEX1NIQURJTkdcXG5mbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMDAwMSApIC8gOC4wO1xcbnZlYzMgc2NobGljayA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggMS4wIC0gZG90KCBsVmVjdG9yLCBwb2ludEhhbGZWZWN0b3IgKSwgNS4wICk7XFxucG9pbnRTcGVjdWxhciArPSBzY2hsaWNrICogcG9pbnRMaWdodENvbG9yWyBpIF0gKiBwb2ludFNwZWN1bGFyV2VpZ2h0ICogcG9pbnREaWZmdXNlV2VpZ2h0ICogbERpc3RhbmNlICogc3BlY3VsYXJOb3JtYWxpemF0aW9uO1xcbiNlbHNlXFxucG9pbnRTcGVjdWxhciArPSBzcGVjdWxhciAqIHBvaW50TGlnaHRDb2xvclsgaSBdICogcG9pbnRTcGVjdWxhcldlaWdodCAqIHBvaW50RGlmZnVzZVdlaWdodCAqIGxEaXN0YW5jZTtcXG4jZW5kaWZcXG59XFxuI2VuZGlmXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG52ZWMzIHNwb3REaWZmdXNlICA9IHZlYzMoIDAuMCApO1xcbnZlYzMgc3BvdFNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuZm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1NQT1RfTElHSFRTOyBpICsrICkge1xcbiNpZmRlZiBQSE9OR19QRVJfUElYRUxcXG52ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBzcG90TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcXG52ZWMzIGxWZWN0b3IgPSBsUG9zaXRpb24ueHl6ICsgdlZpZXdQb3NpdGlvbi54eXo7XFxuZmxvYXQgbERpc3RhbmNlID0gMS4wO1xcbmlmICggc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSA+IDAuMCApXFxubERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggbFZlY3RvciApIC8gc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcXG5sVmVjdG9yID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuI2Vsc2VcXG52ZWMzIGxWZWN0b3IgPSBub3JtYWxpemUoIHZTcG90TGlnaHRbIGkgXS54eXogKTtcXG5mbG9hdCBsRGlzdGFuY2UgPSB2U3BvdExpZ2h0WyBpIF0udztcXG4jZW5kaWZcXG5mbG9hdCBzcG90RWZmZWN0ID0gZG90KCBzcG90TGlnaHREaXJlY3Rpb25bIGkgXSwgbm9ybWFsaXplKCBzcG90TGlnaHRQb3NpdGlvblsgaSBdIC0gdldvcmxkUG9zaXRpb24gKSApO1xcbmlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodEFuZ2xlQ29zWyBpIF0gKSB7XFxuc3BvdEVmZmVjdCA9IG1heCggcG93KCBzcG90RWZmZWN0LCBzcG90TGlnaHRFeHBvbmVudFsgaSBdICksIDAuMCApO1xcbmZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbFZlY3RvciApO1xcbiNpZmRlZiBXUkFQX0FST1VORFxcbmZsb2F0IHNwb3REaWZmdXNlV2VpZ2h0RnVsbCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuZmxvYXQgc3BvdERpZmZ1c2VXZWlnaHRIYWxmID0gbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKTtcXG52ZWMzIHNwb3REaWZmdXNlV2VpZ2h0ID0gbWl4KCB2ZWMzICggc3BvdERpZmZ1c2VXZWlnaHRGdWxsICksIHZlYzMoIHNwb3REaWZmdXNlV2VpZ2h0SGFsZiApLCB3cmFwUkdCICk7XFxuI2Vsc2VcXG5mbG9hdCBzcG90RGlmZnVzZVdlaWdodCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuI2VuZGlmXFxuc3BvdERpZmZ1c2UgKz0gZGlmZnVzZSAqIHNwb3RMaWdodENvbG9yWyBpIF0gKiBzcG90RGlmZnVzZVdlaWdodCAqIGxEaXN0YW5jZSAqIHNwb3RFZmZlY3Q7XFxudmVjMyBzcG90SGFsZlZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciArIHZpZXdQb3NpdGlvbiApO1xcbmZsb2F0IHNwb3REb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgc3BvdEhhbGZWZWN0b3IgKSwgMC4wICk7XFxuZmxvYXQgc3BvdFNwZWN1bGFyV2VpZ2h0ID0gc3BlY3VsYXJTdHJlbmd0aCAqIG1heCggcG93KCBzcG90RG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1xcbiNpZmRlZiBQSFlTSUNBTExZX0JBU0VEX1NIQURJTkdcXG5mbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMDAwMSApIC8gOC4wO1xcbnZlYzMgc2NobGljayA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggMS4wIC0gZG90KCBsVmVjdG9yLCBzcG90SGFsZlZlY3RvciApLCA1LjAgKTtcXG5zcG90U3BlY3VsYXIgKz0gc2NobGljayAqIHNwb3RMaWdodENvbG9yWyBpIF0gKiBzcG90U3BlY3VsYXJXZWlnaHQgKiBzcG90RGlmZnVzZVdlaWdodCAqIGxEaXN0YW5jZSAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbiAqIHNwb3RFZmZlY3Q7XFxuI2Vsc2VcXG5zcG90U3BlY3VsYXIgKz0gc3BlY3VsYXIgKiBzcG90TGlnaHRDb2xvclsgaSBdICogc3BvdFNwZWN1bGFyV2VpZ2h0ICogc3BvdERpZmZ1c2VXZWlnaHQgKiBsRGlzdGFuY2UgKiBzcG90RWZmZWN0O1xcbiNlbmRpZlxcbn1cXG59XFxuI2VuZGlmXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcbnZlYzMgZGlyRGlmZnVzZSAgPSB2ZWMzKCAwLjAgKTtcXG52ZWMzIGRpclNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSArKyApIHtcXG52ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgaSBdLCAwLjAgKTtcXG52ZWMzIGRpclZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcXG5mbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGRpclZlY3RvciApO1xcbiNpZmRlZiBXUkFQX0FST1VORFxcbmZsb2F0IGRpckRpZmZ1c2VXZWlnaHRGdWxsID0gbWF4KCBkb3RQcm9kdWN0LCAwLjAgKTtcXG5mbG9hdCBkaXJEaWZmdXNlV2VpZ2h0SGFsZiA9IG1heCggMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICk7XFxudmVjMyBkaXJEaWZmdXNlV2VpZ2h0ID0gbWl4KCB2ZWMzKCBkaXJEaWZmdXNlV2VpZ2h0RnVsbCApLCB2ZWMzKCBkaXJEaWZmdXNlV2VpZ2h0SGFsZiApLCB3cmFwUkdCICk7XFxuI2Vsc2VcXG5mbG9hdCBkaXJEaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3RQcm9kdWN0LCAwLjAgKTtcXG4jZW5kaWZcXG5kaXJEaWZmdXNlICArPSBkaWZmdXNlICogZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJEaWZmdXNlV2VpZ2h0O1xcbnZlYzMgZGlySGFsZlZlY3RvciA9IG5vcm1hbGl6ZSggZGlyVmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XFxuZmxvYXQgZGlyRG90Tm9ybWFsSGFsZiA9IG1heCggZG90KCBub3JtYWwsIGRpckhhbGZWZWN0b3IgKSwgMC4wICk7XFxuZmxvYXQgZGlyU3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIGRpckRvdE5vcm1hbEhhbGYsIHNoaW5pbmVzcyApLCAwLjAgKTtcXG4jaWZkZWYgUEhZU0lDQUxMWV9CQVNFRF9TSEFESU5HXFxuZmxvYXQgc3BlY3VsYXJOb3JtYWxpemF0aW9uID0gKCBzaGluaW5lc3MgKyAyLjAwMDEgKSAvIDguMDtcXG52ZWMzIHNjaGxpY2sgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIDEuMCAtIGRvdCggZGlyVmVjdG9yLCBkaXJIYWxmVmVjdG9yICksIDUuMCApO1xcbmRpclNwZWN1bGFyICs9IHNjaGxpY2sgKiBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpclNwZWN1bGFyV2VpZ2h0ICogZGlyRGlmZnVzZVdlaWdodCAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbjtcXG4jZWxzZVxcbmRpclNwZWN1bGFyICs9IHNwZWN1bGFyICogZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJTcGVjdWxhcldlaWdodCAqIGRpckRpZmZ1c2VXZWlnaHQ7XFxuI2VuZGlmXFxufVxcbiNlbmRpZlxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxudmVjMyBoZW1pRGlmZnVzZSAgPSB2ZWMzKCAwLjAgKTtcXG52ZWMzIGhlbWlTcGVjdWxhciA9IHZlYzMoIDAuMCApO1xcbmZvciggaW50IGkgPSAwOyBpIDwgTUFYX0hFTUlfTElHSFRTOyBpICsrICkge1xcbnZlYzQgbERpcmVjdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIGkgXSwgMC4wICk7XFxudmVjMyBsVmVjdG9yID0gbm9ybWFsaXplKCBsRGlyZWN0aW9uLnh5eiApO1xcbmZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbFZlY3RvciApO1xcbmZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90UHJvZHVjdCArIDAuNTtcXG52ZWMzIGhlbWlDb2xvciA9IG1peCggaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIGkgXSwgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIGkgXSwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcXG5oZW1pRGlmZnVzZSArPSBkaWZmdXNlICogaGVtaUNvbG9yO1xcbnZlYzMgaGVtaUhhbGZWZWN0b3JTa3kgPSBub3JtYWxpemUoIGxWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcXG5mbG9hdCBoZW1pRG90Tm9ybWFsSGFsZlNreSA9IDAuNSAqIGRvdCggbm9ybWFsLCBoZW1pSGFsZlZlY3RvclNreSApICsgMC41O1xcbmZsb2F0IGhlbWlTcGVjdWxhcldlaWdodFNreSA9IHNwZWN1bGFyU3RyZW5ndGggKiBtYXgoIHBvdyggaGVtaURvdE5vcm1hbEhhbGZTa3ksIHNoaW5pbmVzcyApLCAwLjAgKTtcXG52ZWMzIGxWZWN0b3JHcm91bmQgPSAtbFZlY3RvcjtcXG52ZWMzIGhlbWlIYWxmVmVjdG9yR3JvdW5kID0gbm9ybWFsaXplKCBsVmVjdG9yR3JvdW5kICsgdmlld1Bvc2l0aW9uICk7XFxuZmxvYXQgaGVtaURvdE5vcm1hbEhhbGZHcm91bmQgPSAwLjUgKiBkb3QoIG5vcm1hbCwgaGVtaUhhbGZWZWN0b3JHcm91bmQgKSArIDAuNTtcXG5mbG9hdCBoZW1pU3BlY3VsYXJXZWlnaHRHcm91bmQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIGhlbWlEb3ROb3JtYWxIYWxmR3JvdW5kLCBzaGluaW5lc3MgKSwgMC4wICk7XFxuI2lmZGVmIFBIWVNJQ0FMTFlfQkFTRURfU0hBRElOR1xcbmZsb2F0IGRvdFByb2R1Y3RHcm91bmQgPSBkb3QoIG5vcm1hbCwgbFZlY3Rvckdyb3VuZCApO1xcbmZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wMDAxICkgLyA4LjA7XFxudmVjMyBzY2hsaWNrU2t5ID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCAxLjAgLSBkb3QoIGxWZWN0b3IsIGhlbWlIYWxmVmVjdG9yU2t5ICksIDUuMCApO1xcbnZlYzMgc2NobGlja0dyb3VuZCA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggMS4wIC0gZG90KCBsVmVjdG9yR3JvdW5kLCBoZW1pSGFsZlZlY3Rvckdyb3VuZCApLCA1LjAgKTtcXG5oZW1pU3BlY3VsYXIgKz0gaGVtaUNvbG9yICogc3BlY3VsYXJOb3JtYWxpemF0aW9uICogKCBzY2hsaWNrU2t5ICogaGVtaVNwZWN1bGFyV2VpZ2h0U2t5ICogbWF4KCBkb3RQcm9kdWN0LCAwLjAgKSArIHNjaGxpY2tHcm91bmQgKiBoZW1pU3BlY3VsYXJXZWlnaHRHcm91bmQgKiBtYXgoIGRvdFByb2R1Y3RHcm91bmQsIDAuMCApICk7XFxuI2Vsc2VcXG5oZW1pU3BlY3VsYXIgKz0gc3BlY3VsYXIgKiBoZW1pQ29sb3IgKiAoIGhlbWlTcGVjdWxhcldlaWdodFNreSArIGhlbWlTcGVjdWxhcldlaWdodEdyb3VuZCApICogaGVtaURpZmZ1c2VXZWlnaHQ7XFxuI2VuZGlmXFxufVxcbiNlbmRpZlxcbnZlYzMgdG90YWxEaWZmdXNlID0gdmVjMyggMC4wICk7XFxudmVjMyB0b3RhbFNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcbnRvdGFsRGlmZnVzZSArPSBkaXJEaWZmdXNlO1xcbnRvdGFsU3BlY3VsYXIgKz0gZGlyU3BlY3VsYXI7XFxuI2VuZGlmXFxuI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcXG50b3RhbERpZmZ1c2UgKz0gaGVtaURpZmZ1c2U7XFxudG90YWxTcGVjdWxhciArPSBoZW1pU3BlY3VsYXI7XFxuI2VuZGlmXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxudG90YWxEaWZmdXNlICs9IHBvaW50RGlmZnVzZTtcXG50b3RhbFNwZWN1bGFyICs9IHBvaW50U3BlY3VsYXI7XFxuI2VuZGlmXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG50b3RhbERpZmZ1c2UgKz0gc3BvdERpZmZ1c2U7XFxudG90YWxTcGVjdWxhciArPSBzcG90U3BlY3VsYXI7XFxuI2VuZGlmXFxuI2lmZGVmIE1FVEFMXFxuZ2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiAoIGVtaXNzaXZlICsgdG90YWxEaWZmdXNlICsgYW1iaWVudExpZ2h0Q29sb3IgKiBhbWJpZW50ICsgdG90YWxTcGVjdWxhciApO1xcbiNlbHNlXFxuZ2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiAoIGVtaXNzaXZlICsgdG90YWxEaWZmdXNlICsgYW1iaWVudExpZ2h0Q29sb3IgKiBhbWJpZW50ICkgKyB0b3RhbFNwZWN1bGFyO1xcbiNlbmRpZlwiLFxuY29sb3JfcGFyc19mcmFnbWVudDpcIiNpZmRlZiBVU0VfQ09MT1JcXG52YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbiNlbmRpZlwiLGNvbG9yX2ZyYWdtZW50OlwiI2lmZGVmIFVTRV9DT0xPUlxcbmdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvciAqIHZlYzQoIHZDb2xvciwgMS4wICk7XFxuI2VuZGlmXCIsY29sb3JfcGFyc192ZXJ0ZXg6XCIjaWZkZWYgVVNFX0NPTE9SXFxudmFyeWluZyB2ZWMzIHZDb2xvcjtcXG4jZW5kaWZcIixjb2xvcl92ZXJ0ZXg6XCIjaWZkZWYgVVNFX0NPTE9SXFxuI2lmZGVmIEdBTU1BX0lOUFVUXFxudkNvbG9yID0gY29sb3IgKiBjb2xvcjtcXG4jZWxzZVxcbnZDb2xvciA9IGNvbG9yO1xcbiNlbmRpZlxcbiNlbmRpZlwiLHNraW5uaW5nX3BhcnNfdmVydGV4OlwiI2lmZGVmIFVTRV9TS0lOTklOR1xcbiNpZmRlZiBCT05FX1RFWFRVUkVcXG51bmlmb3JtIHNhbXBsZXIyRCBib25lVGV4dHVyZTtcXG51bmlmb3JtIGludCBib25lVGV4dHVyZVdpZHRoO1xcbnVuaWZvcm0gaW50IGJvbmVUZXh0dXJlSGVpZ2h0O1xcbm1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXG5mbG9hdCBqID0gaSAqIDQuMDtcXG5mbG9hdCB4ID0gbW9kKCBqLCBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApICk7XFxuZmxvYXQgeSA9IGZsb29yKCBqIC8gZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKSApO1xcbmZsb2F0IGR4ID0gMS4wIC8gZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKTtcXG5mbG9hdCBkeSA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZUhlaWdodCApO1xcbnkgPSBkeSAqICggeSArIDAuNSApO1xcbnZlYzQgdjEgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDAuNSApLCB5ICkgKTtcXG52ZWM0IHYyID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAxLjUgKSwgeSApICk7XFxudmVjNCB2MyA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMi41ICksIHkgKSApO1xcbnZlYzQgdjQgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDMuNSApLCB5ICkgKTtcXG5tYXQ0IGJvbmUgPSBtYXQ0KCB2MSwgdjIsIHYzLCB2NCApO1xcbnJldHVybiBib25lO1xcbn1cXG4jZWxzZVxcbnVuaWZvcm0gbWF0NCBib25lR2xvYmFsTWF0cmljZXNbIE1BWF9CT05FUyBdO1xcbm1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXG5tYXQ0IGJvbmUgPSBib25lR2xvYmFsTWF0cmljZXNbIGludChpKSBdO1xcbnJldHVybiBib25lO1xcbn1cXG4jZW5kaWZcXG4jZW5kaWZcIixcbnNraW5iYXNlX3ZlcnRleDpcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5tYXQ0IGJvbmVNYXRYID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnggKTtcXG5tYXQ0IGJvbmVNYXRZID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnkgKTtcXG4jZW5kaWZcIixza2lubmluZ192ZXJ0ZXg6XCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcXG52ZWM0IHNraW5WZXJ0ZXggPSB2ZWM0KCBtb3JwaGVkLCAxLjAgKTtcXG4jZWxzZVxcbnZlYzQgc2tpblZlcnRleCA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG4jZW5kaWZcXG52ZWM0IHNraW5uZWQgID0gYm9uZU1hdFggKiBza2luVmVydGV4ICogc2tpbldlaWdodC54O1xcbnNraW5uZWQgXFx0ICArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XFxuI2VuZGlmXCIsbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg6XCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcbiNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcbnVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA4IF07XFxuI2Vsc2VcXG51bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcbiNlbmRpZlxcbiNlbmRpZlwiLFxubW9ycGh0YXJnZXRfdmVydGV4OlwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcXG52ZWMzIG1vcnBoZWQgPSB2ZWMzKCAwLjAgKTtcXG5tb3JwaGVkICs9ICggbW9ycGhUYXJnZXQwIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcbm1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDEgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxubW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0MiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG5tb3JwaGVkICs9ICggbW9ycGhUYXJnZXQzIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcbiNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcbm1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDQgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxubW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0NSAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDUgXTtcXG5tb3JwaGVkICs9ICggbW9ycGhUYXJnZXQ2IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNiBdO1xcbm1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDcgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA3IF07XFxuI2VuZGlmXFxubW9ycGhlZCArPSBwb3NpdGlvbjtcXG4jZW5kaWZcIixcbmRlZmF1bHRfdmVydGV4OlwidmVjNCBtdlBvc2l0aW9uO1xcbiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5tdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogc2tpbm5lZDtcXG4jZW5kaWZcXG4jaWYgIWRlZmluZWQoIFVTRV9TS0lOTklORyApICYmIGRlZmluZWQoIFVTRV9NT1JQSFRBUkdFVFMgKVxcbm12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBtb3JwaGVkLCAxLjAgKTtcXG4jZW5kaWZcXG4jaWYgIWRlZmluZWQoIFVTRV9TS0lOTklORyApICYmICEgZGVmaW5lZCggVVNFX01PUlBIVEFSR0VUUyApXFxubXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG4jZW5kaWZcXG5nbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLG1vcnBobm9ybWFsX3ZlcnRleDpcIiNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxudmVjMyBtb3JwaGVkTm9ybWFsID0gdmVjMyggMC4wICk7XFxubW9ycGhlZE5vcm1hbCArPSAgKCBtb3JwaE5vcm1hbDAgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcbm1vcnBoZWROb3JtYWwgKz0gICggbW9ycGhOb3JtYWwxIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXG5tb3JwaGVkTm9ybWFsICs9ICAoIG1vcnBoTm9ybWFsMiAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XFxubW9ycGhlZE5vcm1hbCArPSAgKCBtb3JwaE5vcm1hbDMgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcbm1vcnBoZWROb3JtYWwgKz0gbm9ybWFsO1xcbiNlbmRpZlwiLFxuc2tpbm5vcm1hbF92ZXJ0ZXg6XCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxubWF0NCBza2luTWF0cml4ID0gc2tpbldlaWdodC54ICogYm9uZU1hdFg7XFxuc2tpbk1hdHJpeCBcXHQrPSBza2luV2VpZ2h0LnkgKiBib25lTWF0WTtcXG4jaWZkZWYgVVNFX01PUlBITk9STUFMU1xcbnZlYzQgc2tpbm5lZE5vcm1hbCA9IHNraW5NYXRyaXggKiB2ZWM0KCBtb3JwaGVkTm9ybWFsLCAwLjAgKTtcXG4jZWxzZVxcbnZlYzQgc2tpbm5lZE5vcm1hbCA9IHNraW5NYXRyaXggKiB2ZWM0KCBub3JtYWwsIDAuMCApO1xcbiNlbmRpZlxcbiNlbmRpZlwiLGRlZmF1bHRub3JtYWxfdmVydGV4OlwidmVjMyBvYmplY3ROb3JtYWw7XFxuI2lmZGVmIFVTRV9TS0lOTklOR1xcbm9iamVjdE5vcm1hbCA9IHNraW5uZWROb3JtYWwueHl6O1xcbiNlbmRpZlxcbiNpZiAhZGVmaW5lZCggVVNFX1NLSU5OSU5HICkgJiYgZGVmaW5lZCggVVNFX01PUlBITk9STUFMUyApXFxub2JqZWN0Tm9ybWFsID0gbW9ycGhlZE5vcm1hbDtcXG4jZW5kaWZcXG4jaWYgIWRlZmluZWQoIFVTRV9TS0lOTklORyApICYmICEgZGVmaW5lZCggVVNFX01PUlBITk9STUFMUyApXFxub2JqZWN0Tm9ybWFsID0gbm9ybWFsO1xcbiNlbmRpZlxcbiNpZmRlZiBGTElQX1NJREVEXFxub2JqZWN0Tm9ybWFsID0gLW9iamVjdE5vcm1hbDtcXG4jZW5kaWZcXG52ZWMzIHRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsTWF0cml4ICogb2JqZWN0Tm9ybWFsO1wiLFxuc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ6XCIjaWZkZWYgVVNFX1NIQURPV01BUFxcbnVuaWZvcm0gc2FtcGxlcjJEIHNoYWRvd01hcFsgTUFYX1NIQURPV1MgXTtcXG51bmlmb3JtIHZlYzIgc2hhZG93TWFwU2l6ZVsgTUFYX1NIQURPV1MgXTtcXG51bmlmb3JtIGZsb2F0IHNoYWRvd0RhcmtuZXNzWyBNQVhfU0hBRE9XUyBdO1xcbnVuaWZvcm0gZmxvYXQgc2hhZG93Qmlhc1sgTUFYX1NIQURPV1MgXTtcXG52YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkWyBNQVhfU0hBRE9XUyBdO1xcbmZsb2F0IHVucGFja0RlcHRoKCBjb25zdCBpbiB2ZWM0IHJnYmFfZGVwdGggKSB7XFxuY29uc3QgdmVjNCBiaXRfc2hpZnQgPSB2ZWM0KCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gMjU2LjAsIDEuMCApO1xcbmZsb2F0IGRlcHRoID0gZG90KCByZ2JhX2RlcHRoLCBiaXRfc2hpZnQgKTtcXG5yZXR1cm4gZGVwdGg7XFxufVxcbiNlbmRpZlwiLHNoYWRvd21hcF9mcmFnbWVudDpcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuI2lmZGVmIFNIQURPV01BUF9ERUJVR1xcbnZlYzMgZnJ1c3R1bUNvbG9yc1szXTtcXG5mcnVzdHVtQ29sb3JzWzBdID0gdmVjMyggMS4wLCAwLjUsIDAuMCApO1xcbmZydXN0dW1Db2xvcnNbMV0gPSB2ZWMzKCAwLjAsIDEuMCwgMC44ICk7XFxuZnJ1c3R1bUNvbG9yc1syXSA9IHZlYzMoIDAuMCwgMC41LCAxLjAgKTtcXG4jZW5kaWZcXG4jaWZkZWYgU0hBRE9XTUFQX0NBU0NBREVcXG5pbnQgaW5GcnVzdHVtQ291bnQgPSAwO1xcbiNlbmRpZlxcbmZsb2F0IGZEZXB0aDtcXG52ZWMzIHNoYWRvd0NvbG9yID0gdmVjMyggMS4wICk7XFxuZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfU0hBRE9XUzsgaSArKyApIHtcXG52ZWMzIHNoYWRvd0Nvb3JkID0gdlNoYWRvd0Nvb3JkWyBpIF0ueHl6IC8gdlNoYWRvd0Nvb3JkWyBpIF0udztcXG5idmVjNCBpbkZydXN0dW1WZWMgPSBidmVjNCAoIHNoYWRvd0Nvb3JkLnggPj0gMC4wLCBzaGFkb3dDb29yZC54IDw9IDEuMCwgc2hhZG93Q29vcmQueSA+PSAwLjAsIHNoYWRvd0Nvb3JkLnkgPD0gMS4wICk7XFxuYm9vbCBpbkZydXN0dW0gPSBhbGwoIGluRnJ1c3R1bVZlYyApO1xcbiNpZmRlZiBTSEFET1dNQVBfQ0FTQ0FERVxcbmluRnJ1c3R1bUNvdW50ICs9IGludCggaW5GcnVzdHVtICk7XFxuYnZlYzMgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMyggaW5GcnVzdHVtLCBpbkZydXN0dW1Db3VudCA9PSAxLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1xcbiNlbHNlXFxuYnZlYzIgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMiggaW5GcnVzdHVtLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1xcbiNlbmRpZlxcbmJvb2wgZnJ1c3R1bVRlc3QgPSBhbGwoIGZydXN0dW1UZXN0VmVjICk7XFxuaWYgKCBmcnVzdHVtVGVzdCApIHtcXG5zaGFkb3dDb29yZC56ICs9IHNoYWRvd0JpYXNbIGkgXTtcXG4jaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcXG5mbG9hdCBzaGFkb3cgPSAwLjA7XFxuY29uc3QgZmxvYXQgc2hhZG93RGVsdGEgPSAxLjAgLyA5LjA7XFxuZmxvYXQgeFBpeGVsT2Zmc2V0ID0gMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLng7XFxuZmxvYXQgeVBpeGVsT2Zmc2V0ID0gMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLnk7XFxuZmxvYXQgZHgwID0gLTEuMjUgKiB4UGl4ZWxPZmZzZXQ7XFxuZmxvYXQgZHkwID0gLTEuMjUgKiB5UGl4ZWxPZmZzZXQ7XFxuZmxvYXQgZHgxID0gMS4yNSAqIHhQaXhlbE9mZnNldDtcXG5mbG9hdCBkeTEgPSAxLjI1ICogeVBpeGVsT2Zmc2V0O1xcbmZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICkgKSApO1xcbmlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5mRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApICkgKTtcXG5pZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSApICk7XFxuaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcbmZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICkgKSApO1xcbmlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5mRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKSApO1xcbmlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5mRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApICkgKTtcXG5pZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTEgKSApICk7XFxuaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcbmZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICkgKSApO1xcbmlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5mRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApICkgKTtcXG5pZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvciAqIHZlYzMoICggMS4wIC0gc2hhZG93RGFya25lc3NbIGkgXSAqIHNoYWRvdyApICk7XFxuI2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcbmZsb2F0IHNoYWRvdyA9IDAuMDtcXG5mbG9hdCB4UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueDtcXG5mbG9hdCB5UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueTtcXG5mbG9hdCBkeDAgPSAtMS4wICogeFBpeGVsT2Zmc2V0O1xcbmZsb2F0IGR5MCA9IC0xLjAgKiB5UGl4ZWxPZmZzZXQ7XFxuZmxvYXQgZHgxID0gMS4wICogeFBpeGVsT2Zmc2V0O1xcbmZsb2F0IGR5MSA9IDEuMCAqIHlQaXhlbE9mZnNldDtcXG5tYXQzIHNoYWRvd0tlcm5lbDtcXG5tYXQzIGRlcHRoS2VybmVsO1xcbmRlcHRoS2VybmVsWzBdWzBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSApICk7XFxuZGVwdGhLZXJuZWxbMF1bMV0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApICkgKTtcXG5kZXB0aEtlcm5lbFswXVsyXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICkgKSApO1xcbmRlcHRoS2VybmVsWzFdWzBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSApICk7XFxuZGVwdGhLZXJuZWxbMV1bMV0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKSApO1xcbmRlcHRoS2VybmVsWzFdWzJdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSApICk7XFxuZGVwdGhLZXJuZWxbMl1bMF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApICkgKTtcXG5kZXB0aEtlcm5lbFsyXVsxXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICkgKSApO1xcbmRlcHRoS2VybmVsWzJdWzJdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSApICk7XFxudmVjMyBzaGFkb3daID0gdmVjMyggc2hhZG93Q29vcmQueiApO1xcbnNoYWRvd0tlcm5lbFswXSA9IHZlYzMobGVzc1RoYW4oZGVwdGhLZXJuZWxbMF0sIHNoYWRvd1ogKSk7XFxuc2hhZG93S2VybmVsWzBdICo9IHZlYzMoMC4yNSk7XFxuc2hhZG93S2VybmVsWzFdID0gdmVjMyhsZXNzVGhhbihkZXB0aEtlcm5lbFsxXSwgc2hhZG93WiApKTtcXG5zaGFkb3dLZXJuZWxbMV0gKj0gdmVjMygwLjI1KTtcXG5zaGFkb3dLZXJuZWxbMl0gPSB2ZWMzKGxlc3NUaGFuKGRlcHRoS2VybmVsWzJdLCBzaGFkb3daICkpO1xcbnNoYWRvd0tlcm5lbFsyXSAqPSB2ZWMzKDAuMjUpO1xcbnZlYzIgZnJhY3Rpb25hbENvb3JkID0gMS4wIC0gZnJhY3QoIHNoYWRvd0Nvb3JkLnh5ICogc2hhZG93TWFwU2l6ZVtpXS54eSApO1xcbnNoYWRvd0tlcm5lbFswXSA9IG1peCggc2hhZG93S2VybmVsWzFdLCBzaGFkb3dLZXJuZWxbMF0sIGZyYWN0aW9uYWxDb29yZC54ICk7XFxuc2hhZG93S2VybmVsWzFdID0gbWl4KCBzaGFkb3dLZXJuZWxbMl0sIHNoYWRvd0tlcm5lbFsxXSwgZnJhY3Rpb25hbENvb3JkLnggKTtcXG52ZWM0IHNoYWRvd1ZhbHVlcztcXG5zaGFkb3dWYWx1ZXMueCA9IG1peCggc2hhZG93S2VybmVsWzBdWzFdLCBzaGFkb3dLZXJuZWxbMF1bMF0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuc2hhZG93VmFsdWVzLnkgPSBtaXgoIHNoYWRvd0tlcm5lbFswXVsyXSwgc2hhZG93S2VybmVsWzBdWzFdLCBmcmFjdGlvbmFsQ29vcmQueSApO1xcbnNoYWRvd1ZhbHVlcy56ID0gbWl4KCBzaGFkb3dLZXJuZWxbMV1bMV0sIHNoYWRvd0tlcm5lbFsxXVswXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG5zaGFkb3dWYWx1ZXMudyA9IG1peCggc2hhZG93S2VybmVsWzFdWzJdLCBzaGFkb3dLZXJuZWxbMV1bMV0sIGZyYWN0aW9uYWxDb29yZC55ICk7XFxuc2hhZG93ID0gZG90KCBzaGFkb3dWYWx1ZXMsIHZlYzQoIDEuMCApICk7XFxuc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvciAqIHZlYzMoICggMS4wIC0gc2hhZG93RGFya25lc3NbIGkgXSAqIHNoYWRvdyApICk7XFxuI2Vsc2VcXG52ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICk7XFxuZmxvYXQgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHJnYmFEZXB0aCApO1xcbmlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApXFxuc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvciAqIHZlYzMoIDEuMCAtIHNoYWRvd0RhcmtuZXNzWyBpIF0gKTtcXG4jZW5kaWZcXG59XFxuI2lmZGVmIFNIQURPV01BUF9ERUJVR1xcbiNpZmRlZiBTSEFET1dNQVBfQ0FTQ0FERVxcbmlmICggaW5GcnVzdHVtICYmIGluRnJ1c3R1bUNvdW50ID09IDEgKSBnbF9GcmFnQ29sb3IueHl6ICo9IGZydXN0dW1Db2xvcnNbIGkgXTtcXG4jZWxzZVxcbmlmICggaW5GcnVzdHVtICkgZ2xfRnJhZ0NvbG9yLnh5eiAqPSBmcnVzdHVtQ29sb3JzWyBpIF07XFxuI2VuZGlmXFxuI2VuZGlmXFxufVxcbiNpZmRlZiBHQU1NQV9PVVRQVVRcXG5zaGFkb3dDb2xvciAqPSBzaGFkb3dDb2xvcjtcXG4jZW5kaWZcXG5nbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqIHNoYWRvd0NvbG9yO1xcbiNlbmRpZlwiLFxuc2hhZG93bWFwX3BhcnNfdmVydGV4OlwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG52YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkWyBNQVhfU0hBRE9XUyBdO1xcbnVuaWZvcm0gbWF0NCBzaGFkb3dNYXRyaXhbIE1BWF9TSEFET1dTIF07XFxuI2VuZGlmXCIsc2hhZG93bWFwX3ZlcnRleDpcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfU0hBRE9XUzsgaSArKyApIHtcXG52U2hhZG93Q29vcmRbIGkgXSA9IHNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG59XFxuI2VuZGlmXCIsYWxwaGF0ZXN0X2ZyYWdtZW50OlwiI2lmZGVmIEFMUEhBVEVTVFxcbmlmICggZ2xfRnJhZ0NvbG9yLmEgPCBBTFBIQVRFU1QgKSBkaXNjYXJkO1xcbiNlbmRpZlwiLGxpbmVhcl90b19nYW1tYV9mcmFnbWVudDpcIiNpZmRlZiBHQU1NQV9PVVRQVVRcXG5nbF9GcmFnQ29sb3IueHl6ID0gc3FydCggZ2xfRnJhZ0NvbG9yLnh5eiApO1xcbiNlbmRpZlwifTtcblRIUkVFLlVuaWZvcm1zVXRpbHM9e21lcmdlOmZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlPXt9O2ZvcihiPTA7YjxhLmxlbmd0aDtiKyspZm9yKGMgaW4gZD10aGlzLmNsb25lKGFbYl0pLGQpZVtjXT1kW2NdO3JldHVybiBlfSxjbG9uZTpmdW5jdGlvbihhKXt2YXIgYixjLGQsZT17fTtmb3IoYiBpbiBhKWZvcihjIGluIGVbYl09e30sYVtiXSlkPWFbYl1bY10sZVtiXVtjXT1kIGluc3RhbmNlb2YgVEhSRUUuQ29sb3J8fGQgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IyfHxkIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yM3x8ZCBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjR8fGQgaW5zdGFuY2VvZiBUSFJFRS5NYXRyaXg0fHxkIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZT9kLmNsb25lKCk6ZCBpbnN0YW5jZW9mIEFycmF5P2Quc2xpY2UoKTpkO3JldHVybiBlfX07XG5USFJFRS5Vbmlmb3Jtc0xpYj17Y29tbW9uOntkaWZmdXNlOnt0eXBlOlwiY1wiLHZhbHVlOm5ldyBUSFJFRS5Db2xvcigxNTY1ODczNCl9LG9wYWNpdHk6e3R5cGU6XCJmXCIsdmFsdWU6MX0sbWFwOnt0eXBlOlwidFwiLHZhbHVlOm51bGx9LG9mZnNldFJlcGVhdDp7dHlwZTpcInY0XCIsdmFsdWU6bmV3IFRIUkVFLlZlY3RvcjQoMCwwLDEsMSl9LGxpZ2h0TWFwOnt0eXBlOlwidFwiLHZhbHVlOm51bGx9LHNwZWN1bGFyTWFwOnt0eXBlOlwidFwiLHZhbHVlOm51bGx9LGVudk1hcDp7dHlwZTpcInRcIix2YWx1ZTpudWxsfSxmbGlwRW52TWFwOnt0eXBlOlwiZlwiLHZhbHVlOi0xfSx1c2VSZWZyYWN0Ont0eXBlOlwiaVwiLHZhbHVlOjB9LHJlZmxlY3Rpdml0eTp7dHlwZTpcImZcIix2YWx1ZToxfSxyZWZyYWN0aW9uUmF0aW86e3R5cGU6XCJmXCIsdmFsdWU6MC45OH0sY29tYmluZTp7dHlwZTpcImlcIix2YWx1ZTowfSxtb3JwaFRhcmdldEluZmx1ZW5jZXM6e3R5cGU6XCJmXCIsdmFsdWU6MH19LGJ1bXA6e2J1bXBNYXA6e3R5cGU6XCJ0XCIsXG52YWx1ZTpudWxsfSxidW1wU2NhbGU6e3R5cGU6XCJmXCIsdmFsdWU6MX19LG5vcm1hbG1hcDp7bm9ybWFsTWFwOnt0eXBlOlwidFwiLHZhbHVlOm51bGx9LG5vcm1hbFNjYWxlOnt0eXBlOlwidjJcIix2YWx1ZTpuZXcgVEhSRUUuVmVjdG9yMigxLDEpfX0sZm9nOntmb2dEZW5zaXR5Ont0eXBlOlwiZlwiLHZhbHVlOjIuNUUtNH0sZm9nTmVhcjp7dHlwZTpcImZcIix2YWx1ZToxfSxmb2dGYXI6e3R5cGU6XCJmXCIsdmFsdWU6MkUzfSxmb2dDb2xvcjp7dHlwZTpcImNcIix2YWx1ZTpuZXcgVEhSRUUuQ29sb3IoMTY3NzcyMTUpfX0sbGlnaHRzOnthbWJpZW50TGlnaHRDb2xvcjp7dHlwZTpcImZ2XCIsdmFsdWU6W119LGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb246e3R5cGU6XCJmdlwiLHZhbHVlOltdfSxkaXJlY3Rpb25hbExpZ2h0Q29sb3I6e3R5cGU6XCJmdlwiLHZhbHVlOltdfSxoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb246e3R5cGU6XCJmdlwiLHZhbHVlOltdfSxoZW1pc3BoZXJlTGlnaHRTa3lDb2xvcjp7dHlwZTpcImZ2XCIsXG52YWx1ZTpbXX0saGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3I6e3R5cGU6XCJmdlwiLHZhbHVlOltdfSxwb2ludExpZ2h0Q29sb3I6e3R5cGU6XCJmdlwiLHZhbHVlOltdfSxwb2ludExpZ2h0UG9zaXRpb246e3R5cGU6XCJmdlwiLHZhbHVlOltdfSxwb2ludExpZ2h0RGlzdGFuY2U6e3R5cGU6XCJmdjFcIix2YWx1ZTpbXX0sc3BvdExpZ2h0Q29sb3I6e3R5cGU6XCJmdlwiLHZhbHVlOltdfSxzcG90TGlnaHRQb3NpdGlvbjp7dHlwZTpcImZ2XCIsdmFsdWU6W119LHNwb3RMaWdodERpcmVjdGlvbjp7dHlwZTpcImZ2XCIsdmFsdWU6W119LHNwb3RMaWdodERpc3RhbmNlOnt0eXBlOlwiZnYxXCIsdmFsdWU6W119LHNwb3RMaWdodEFuZ2xlQ29zOnt0eXBlOlwiZnYxXCIsdmFsdWU6W119LHNwb3RMaWdodEV4cG9uZW50Ont0eXBlOlwiZnYxXCIsdmFsdWU6W119fSxwYXJ0aWNsZTp7cHNDb2xvcjp7dHlwZTpcImNcIix2YWx1ZTpuZXcgVEhSRUUuQ29sb3IoMTU2NTg3MzQpfSxvcGFjaXR5Ont0eXBlOlwiZlwiLHZhbHVlOjF9LHNpemU6e3R5cGU6XCJmXCIsXG52YWx1ZToxfSxzY2FsZTp7dHlwZTpcImZcIix2YWx1ZToxfSxtYXA6e3R5cGU6XCJ0XCIsdmFsdWU6bnVsbH0sZm9nRGVuc2l0eTp7dHlwZTpcImZcIix2YWx1ZToyLjVFLTR9LGZvZ05lYXI6e3R5cGU6XCJmXCIsdmFsdWU6MX0sZm9nRmFyOnt0eXBlOlwiZlwiLHZhbHVlOjJFM30sZm9nQ29sb3I6e3R5cGU6XCJjXCIsdmFsdWU6bmV3IFRIUkVFLkNvbG9yKDE2Nzc3MjE1KX19LHNoYWRvd21hcDp7c2hhZG93TWFwOnt0eXBlOlwidHZcIix2YWx1ZTpbXX0sc2hhZG93TWFwU2l6ZTp7dHlwZTpcInYydlwiLHZhbHVlOltdfSxzaGFkb3dCaWFzOnt0eXBlOlwiZnYxXCIsdmFsdWU6W119LHNoYWRvd0RhcmtuZXNzOnt0eXBlOlwiZnYxXCIsdmFsdWU6W119LHNoYWRvd01hdHJpeDp7dHlwZTpcIm00dlwiLHZhbHVlOltdfX19O1xuVEhSRUUuU2hhZGVyTGliPXtiYXNpYzp7dW5pZm9ybXM6VEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZShbVEhSRUUuVW5pZm9ybXNMaWIuY29tbW9uLFRIUkVFLlVuaWZvcm1zTGliLmZvZyxUSFJFRS5Vbmlmb3Jtc0xpYi5zaGFkb3dtYXBdKSx2ZXJ0ZXhTaGFkZXI6W1RIUkVFLlNoYWRlckNodW5rLm1hcF9wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5saWdodG1hcF9wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5lbnZtYXBfcGFyc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuY29sb3JfcGFyc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsubW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuc2tpbm5pbmdfcGFyc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX3BhcnNfdmVydGV4LFwidm9pZCBtYWluKCkge1wiLFRIUkVFLlNoYWRlckNodW5rLm1hcF92ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsubGlnaHRtYXBfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmNvbG9yX3ZlcnRleCxcblRIUkVFLlNoYWRlckNodW5rLnNraW5iYXNlX3ZlcnRleCxcIiNpZmRlZiBVU0VfRU5WTUFQXCIsVEhSRUUuU2hhZGVyQ2h1bmsubW9ycGhub3JtYWxfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLnNraW5ub3JtYWxfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmRlZmF1bHRub3JtYWxfdmVydGV4LFwiI2VuZGlmXCIsVEhSRUUuU2hhZGVyQ2h1bmsubW9ycGh0YXJnZXRfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLnNraW5uaW5nX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5kZWZhdWx0X3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay53b3JsZHBvc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuZW52bWFwX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5zaGFkb3dtYXBfdmVydGV4LFwifVwiXS5qb2luKFwiXFxuXCIpLGZyYWdtZW50U2hhZGVyOltcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixUSFJFRS5TaGFkZXJDaHVuay5jb2xvcl9wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLm1hcF9wYXJzX2ZyYWdtZW50LFxuVEhSRUUuU2hhZGVyQ2h1bmsubGlnaHRtYXBfcGFyc19mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5lbnZtYXBfcGFyc19mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5mb2dfcGFyc19mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5zaGFkb3dtYXBfcGFyc19mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5zcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50LFwidm9pZCBtYWluKCkge1xcbmdsX0ZyYWdDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixUSFJFRS5TaGFkZXJDaHVuay5tYXBfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsuYWxwaGF0ZXN0X2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLnNwZWN1bGFybWFwX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmxpZ2h0bWFwX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmNvbG9yX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmVudm1hcF9mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5zaGFkb3dtYXBfZnJhZ21lbnQsXG5USFJFRS5TaGFkZXJDaHVuay5saW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsuZm9nX2ZyYWdtZW50LFwifVwiXS5qb2luKFwiXFxuXCIpfSxsYW1iZXJ0Ont1bmlmb3JtczpUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKFtUSFJFRS5Vbmlmb3Jtc0xpYi5jb21tb24sVEhSRUUuVW5pZm9ybXNMaWIuZm9nLFRIUkVFLlVuaWZvcm1zTGliLmxpZ2h0cyxUSFJFRS5Vbmlmb3Jtc0xpYi5zaGFkb3dtYXAse2FtYmllbnQ6e3R5cGU6XCJjXCIsdmFsdWU6bmV3IFRIUkVFLkNvbG9yKDE2Nzc3MjE1KX0sZW1pc3NpdmU6e3R5cGU6XCJjXCIsdmFsdWU6bmV3IFRIUkVFLkNvbG9yKDApfSx3cmFwUkdCOnt0eXBlOlwidjNcIix2YWx1ZTpuZXcgVEhSRUUuVmVjdG9yMygxLDEsMSl9fV0pLHZlcnRleFNoYWRlcjpbXCIjZGVmaW5lIExBTUJFUlRcXG52YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XFxuI2lmZGVmIERPVUJMRV9TSURFRFxcbnZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1xcbiNlbmRpZlwiLFxuVEhSRUUuU2hhZGVyQ2h1bmsubWFwX3BhcnNfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmxpZ2h0bWFwX3BhcnNfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmVudm1hcF9wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5saWdodHNfbGFtYmVydF9wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5jb2xvcl9wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5tb3JwaHRhcmdldF9wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5za2lubmluZ19wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5zaGFkb3dtYXBfcGFyc192ZXJ0ZXgsXCJ2b2lkIG1haW4oKSB7XCIsVEhSRUUuU2hhZGVyQ2h1bmsubWFwX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5saWdodG1hcF92ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuY29sb3JfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLm1vcnBobm9ybWFsX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5za2luYmFzZV92ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuc2tpbm5vcm1hbF92ZXJ0ZXgsXG5USFJFRS5TaGFkZXJDaHVuay5kZWZhdWx0bm9ybWFsX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5tb3JwaHRhcmdldF92ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuc2tpbm5pbmdfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmRlZmF1bHRfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLndvcmxkcG9zX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5lbnZtYXBfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmxpZ2h0c19sYW1iZXJ0X3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5zaGFkb3dtYXBfdmVydGV4LFwifVwiXS5qb2luKFwiXFxuXCIpLGZyYWdtZW50U2hhZGVyOltcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG52YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XFxuI2lmZGVmIERPVUJMRV9TSURFRFxcbnZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1xcbiNlbmRpZlwiLFRIUkVFLlNoYWRlckNodW5rLmNvbG9yX3BhcnNfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsubWFwX3BhcnNfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsubGlnaHRtYXBfcGFyc19mcmFnbWVudCxcblRIUkVFLlNoYWRlckNodW5rLmVudm1hcF9wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmZvZ19wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLnNoYWRvd21hcF9wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLnNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQsXCJ2b2lkIG1haW4oKSB7XFxuZ2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyAoIDEuMCApLCBvcGFjaXR5ICk7XCIsVEhSRUUuU2hhZGVyQ2h1bmsubWFwX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmFscGhhdGVzdF9mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5zcGVjdWxhcm1hcF9mcmFnbWVudCxcIiNpZmRlZiBET1VCTEVfU0lERURcXG5pZiAoIGdsX0Zyb250RmFjaW5nIClcXG5nbF9GcmFnQ29sb3IueHl6ICo9IHZMaWdodEZyb250O1xcbmVsc2VcXG5nbF9GcmFnQ29sb3IueHl6ICo9IHZMaWdodEJhY2s7XFxuI2Vsc2VcXG5nbF9GcmFnQ29sb3IueHl6ICo9IHZMaWdodEZyb250O1xcbiNlbmRpZlwiLFRIUkVFLlNoYWRlckNodW5rLmxpZ2h0bWFwX2ZyYWdtZW50LFxuVEhSRUUuU2hhZGVyQ2h1bmsuY29sb3JfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsuZW52bWFwX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLnNoYWRvd21hcF9mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5saW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsuZm9nX2ZyYWdtZW50LFwifVwiXS5qb2luKFwiXFxuXCIpfSxwaG9uZzp7dW5pZm9ybXM6VEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZShbVEhSRUUuVW5pZm9ybXNMaWIuY29tbW9uLFRIUkVFLlVuaWZvcm1zTGliLmJ1bXAsVEhSRUUuVW5pZm9ybXNMaWIubm9ybWFsbWFwLFRIUkVFLlVuaWZvcm1zTGliLmZvZyxUSFJFRS5Vbmlmb3Jtc0xpYi5saWdodHMsVEhSRUUuVW5pZm9ybXNMaWIuc2hhZG93bWFwLHthbWJpZW50Ont0eXBlOlwiY1wiLHZhbHVlOm5ldyBUSFJFRS5Db2xvcigxNjc3NzIxNSl9LGVtaXNzaXZlOnt0eXBlOlwiY1wiLHZhbHVlOm5ldyBUSFJFRS5Db2xvcigwKX0sc3BlY3VsYXI6e3R5cGU6XCJjXCIsXG52YWx1ZTpuZXcgVEhSRUUuQ29sb3IoMTExODQ4MSl9LHNoaW5pbmVzczp7dHlwZTpcImZcIix2YWx1ZTozMH0sd3JhcFJHQjp7dHlwZTpcInYzXCIsdmFsdWU6bmV3IFRIUkVFLlZlY3RvcjMoMSwxLDEpfX1dKSx2ZXJ0ZXhTaGFkZXI6W1wiI2RlZmluZSBQSE9OR1xcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFRIUkVFLlNoYWRlckNodW5rLm1hcF9wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5saWdodG1hcF9wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5lbnZtYXBfcGFyc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsubGlnaHRzX3Bob25nX3BhcnNfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmNvbG9yX3BhcnNfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLnNraW5uaW5nX3BhcnNfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLnNoYWRvd21hcF9wYXJzX3ZlcnRleCxcblwidm9pZCBtYWluKCkge1wiLFRIUkVFLlNoYWRlckNodW5rLm1hcF92ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsubGlnaHRtYXBfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmNvbG9yX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5tb3JwaG5vcm1hbF92ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuc2tpbmJhc2VfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLnNraW5ub3JtYWxfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmRlZmF1bHRub3JtYWxfdmVydGV4LFwidk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcIixUSFJFRS5TaGFkZXJDaHVuay5tb3JwaHRhcmdldF92ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuc2tpbm5pbmdfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLmRlZmF1bHRfdmVydGV4LFwidlZpZXdQb3NpdGlvbiA9IC1tdlBvc2l0aW9uLnh5ejtcIixUSFJFRS5TaGFkZXJDaHVuay53b3JsZHBvc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuZW52bWFwX3ZlcnRleCxcblRIUkVFLlNoYWRlckNodW5rLmxpZ2h0c19waG9uZ192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX3ZlcnRleCxcIn1cIl0uam9pbihcIlxcblwiKSxmcmFnbWVudFNoYWRlcjpbXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSB2ZWMzIGFtYmllbnQ7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcXG51bmlmb3JtIGZsb2F0IHNoaW5pbmVzcztcIixUSFJFRS5TaGFkZXJDaHVuay5jb2xvcl9wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLm1hcF9wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsuZW52bWFwX3BhcnNfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsuZm9nX3BhcnNfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsubGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQsXG5USFJFRS5TaGFkZXJDaHVuay5idW1wbWFwX3BhcnNfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsubm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsuc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudCxcInZvaWQgbWFpbigpIHtcXG5nbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzICggMS4wICksIG9wYWNpdHkgKTtcIixUSFJFRS5TaGFkZXJDaHVuay5tYXBfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsuYWxwaGF0ZXN0X2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLnNwZWN1bGFybWFwX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmxpZ2h0c19waG9uZ19mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5saWdodG1hcF9mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5jb2xvcl9mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5lbnZtYXBfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmxpbmVhcl90b19nYW1tYV9mcmFnbWVudCxcblRIUkVFLlNoYWRlckNodW5rLmZvZ19mcmFnbWVudCxcIn1cIl0uam9pbihcIlxcblwiKX0scGFydGljbGVfYmFzaWM6e3VuaWZvcm1zOlRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoW1RIUkVFLlVuaWZvcm1zTGliLnBhcnRpY2xlLFRIUkVFLlVuaWZvcm1zTGliLnNoYWRvd21hcF0pLHZlcnRleFNoYWRlcjpbXCJ1bmlmb3JtIGZsb2F0IHNpemU7XFxudW5pZm9ybSBmbG9hdCBzY2FsZTtcIixUSFJFRS5TaGFkZXJDaHVuay5jb2xvcl9wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5zaGFkb3dtYXBfcGFyc192ZXJ0ZXgsXCJ2b2lkIG1haW4oKSB7XCIsVEhSRUUuU2hhZGVyQ2h1bmsuY29sb3JfdmVydGV4LFwidmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbiNpZmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OXFxuZ2xfUG9pbnRTaXplID0gc2l6ZSAqICggc2NhbGUgLyBsZW5ndGgoIG12UG9zaXRpb24ueHl6ICkgKTtcXG4jZWxzZVxcbmdsX1BvaW50U2l6ZSA9IHNpemU7XFxuI2VuZGlmXFxuZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcIixcblRIUkVFLlNoYWRlckNodW5rLndvcmxkcG9zX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5zaGFkb3dtYXBfdmVydGV4LFwifVwiXS5qb2luKFwiXFxuXCIpLGZyYWdtZW50U2hhZGVyOltcInVuaWZvcm0gdmVjMyBwc0NvbG9yO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixUSFJFRS5TaGFkZXJDaHVuay5jb2xvcl9wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLm1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmZvZ19wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLnNoYWRvd21hcF9wYXJzX2ZyYWdtZW50LFwidm9pZCBtYWluKCkge1xcbmdsX0ZyYWdDb2xvciA9IHZlYzQoIHBzQ29sb3IsIG9wYWNpdHkgKTtcIixUSFJFRS5TaGFkZXJDaHVuay5tYXBfcGFydGljbGVfZnJhZ21lbnQsVEhSRUUuU2hhZGVyQ2h1bmsuYWxwaGF0ZXN0X2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmNvbG9yX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLnNoYWRvd21hcF9mcmFnbWVudCxcblRIUkVFLlNoYWRlckNodW5rLmZvZ19mcmFnbWVudCxcIn1cIl0uam9pbihcIlxcblwiKX0sZGFzaGVkOnt1bmlmb3JtczpUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKFtUSFJFRS5Vbmlmb3Jtc0xpYi5jb21tb24sVEhSRUUuVW5pZm9ybXNMaWIuZm9nLHtzY2FsZTp7dHlwZTpcImZcIix2YWx1ZToxfSxkYXNoU2l6ZTp7dHlwZTpcImZcIix2YWx1ZToxfSx0b3RhbFNpemU6e3R5cGU6XCJmXCIsdmFsdWU6Mn19XSksdmVydGV4U2hhZGVyOltcInVuaWZvcm0gZmxvYXQgc2NhbGU7XFxuYXR0cmlidXRlIGZsb2F0IGxpbmVEaXN0YW5jZTtcXG52YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XCIsVEhSRUUuU2hhZGVyQ2h1bmsuY29sb3JfcGFyc192ZXJ0ZXgsXCJ2b2lkIG1haW4oKSB7XCIsVEhSRUUuU2hhZGVyQ2h1bmsuY29sb3JfdmVydGV4LFwidkxpbmVEaXN0YW5jZSA9IHNjYWxlICogbGluZURpc3RhbmNlO1xcbnZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG5nbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xcbn1cIl0uam9pbihcIlxcblwiKSxcbmZyYWdtZW50U2hhZGVyOltcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIGZsb2F0IGRhc2hTaXplO1xcbnVuaWZvcm0gZmxvYXQgdG90YWxTaXplO1xcbnZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcIixUSFJFRS5TaGFkZXJDaHVuay5jb2xvcl9wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmZvZ19wYXJzX2ZyYWdtZW50LFwidm9pZCBtYWluKCkge1xcbmlmICggbW9kKCB2TGluZURpc3RhbmNlLCB0b3RhbFNpemUgKSA+IGRhc2hTaXplICkge1xcbmRpc2NhcmQ7XFxufVxcbmdsX0ZyYWdDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixUSFJFRS5TaGFkZXJDaHVuay5jb2xvcl9mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5mb2dfZnJhZ21lbnQsXCJ9XCJdLmpvaW4oXCJcXG5cIil9LGRlcHRoOnt1bmlmb3Jtczp7bU5lYXI6e3R5cGU6XCJmXCIsdmFsdWU6MX0sbUZhcjp7dHlwZTpcImZcIix2YWx1ZToyRTN9LG9wYWNpdHk6e3R5cGU6XCJmXCIsXG52YWx1ZToxfX0sdmVydGV4U2hhZGVyOlwidm9pZCBtYWluKCkge1xcbmdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG59XCIsZnJhZ21lbnRTaGFkZXI6XCJ1bmlmb3JtIGZsb2F0IG1OZWFyO1xcbnVuaWZvcm0gZmxvYXQgbUZhcjtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudm9pZCBtYWluKCkge1xcbmZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcXG5mbG9hdCBjb2xvciA9IDEuMCAtIHNtb290aHN0ZXAoIG1OZWFyLCBtRmFyLCBkZXB0aCApO1xcbmdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIGNvbG9yICksIG9wYWNpdHkgKTtcXG59XCJ9LG5vcm1hbDp7dW5pZm9ybXM6e29wYWNpdHk6e3R5cGU6XCJmXCIsdmFsdWU6MX19LHZlcnRleFNoYWRlcjpbXCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixUSFJFRS5TaGFkZXJDaHVuay5tb3JwaHRhcmdldF9wYXJzX3ZlcnRleCxcInZvaWQgbWFpbigpIHtcXG52Tm9ybWFsID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBub3JtYWwgKTtcIixcblRIUkVFLlNoYWRlckNodW5rLm1vcnBodGFyZ2V0X3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5kZWZhdWx0X3ZlcnRleCxcIn1cIl0uam9pbihcIlxcblwiKSxmcmFnbWVudFNoYWRlcjpcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG52b2lkIG1haW4oKSB7XFxuZ2xfRnJhZ0NvbG9yID0gdmVjNCggMC41ICogbm9ybWFsaXplKCB2Tm9ybWFsICkgKyAwLjUsIG9wYWNpdHkgKTtcXG59XCJ9LG5vcm1hbG1hcDp7dW5pZm9ybXM6VEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZShbVEhSRUUuVW5pZm9ybXNMaWIuZm9nLFRIUkVFLlVuaWZvcm1zTGliLmxpZ2h0cyxUSFJFRS5Vbmlmb3Jtc0xpYi5zaGFkb3dtYXAse2VuYWJsZUFPOnt0eXBlOlwiaVwiLHZhbHVlOjB9LGVuYWJsZURpZmZ1c2U6e3R5cGU6XCJpXCIsdmFsdWU6MH0sZW5hYmxlU3BlY3VsYXI6e3R5cGU6XCJpXCIsdmFsdWU6MH0sZW5hYmxlUmVmbGVjdGlvbjp7dHlwZTpcImlcIix2YWx1ZTowfSxlbmFibGVEaXNwbGFjZW1lbnQ6e3R5cGU6XCJpXCIsXG52YWx1ZTowfSx0RGlzcGxhY2VtZW50Ont0eXBlOlwidFwiLHZhbHVlOm51bGx9LHREaWZmdXNlOnt0eXBlOlwidFwiLHZhbHVlOm51bGx9LHRDdWJlOnt0eXBlOlwidFwiLHZhbHVlOm51bGx9LHROb3JtYWw6e3R5cGU6XCJ0XCIsdmFsdWU6bnVsbH0sdFNwZWN1bGFyOnt0eXBlOlwidFwiLHZhbHVlOm51bGx9LHRBTzp7dHlwZTpcInRcIix2YWx1ZTpudWxsfSx1Tm9ybWFsU2NhbGU6e3R5cGU6XCJ2MlwiLHZhbHVlOm5ldyBUSFJFRS5WZWN0b3IyKDEsMSl9LHVEaXNwbGFjZW1lbnRCaWFzOnt0eXBlOlwiZlwiLHZhbHVlOjB9LHVEaXNwbGFjZW1lbnRTY2FsZTp7dHlwZTpcImZcIix2YWx1ZToxfSx1RGlmZnVzZUNvbG9yOnt0eXBlOlwiY1wiLHZhbHVlOm5ldyBUSFJFRS5Db2xvcigxNjc3NzIxNSl9LHVTcGVjdWxhckNvbG9yOnt0eXBlOlwiY1wiLHZhbHVlOm5ldyBUSFJFRS5Db2xvcigxMTE4NDgxKX0sdUFtYmllbnRDb2xvcjp7dHlwZTpcImNcIix2YWx1ZTpuZXcgVEhSRUUuQ29sb3IoMTY3NzcyMTUpfSx1U2hpbmluZXNzOnt0eXBlOlwiZlwiLFxudmFsdWU6MzB9LHVPcGFjaXR5Ont0eXBlOlwiZlwiLHZhbHVlOjF9LHVzZVJlZnJhY3Q6e3R5cGU6XCJpXCIsdmFsdWU6MH0sdVJlZnJhY3Rpb25SYXRpbzp7dHlwZTpcImZcIix2YWx1ZTowLjk4fSx1UmVmbGVjdGl2aXR5Ont0eXBlOlwiZlwiLHZhbHVlOjAuNX0sdU9mZnNldDp7dHlwZTpcInYyXCIsdmFsdWU6bmV3IFRIUkVFLlZlY3RvcjIoMCwwKX0sdVJlcGVhdDp7dHlwZTpcInYyXCIsdmFsdWU6bmV3IFRIUkVFLlZlY3RvcjIoMSwxKX0sd3JhcFJHQjp7dHlwZTpcInYzXCIsdmFsdWU6bmV3IFRIUkVFLlZlY3RvcjMoMSwxLDEpfX1dKSxmcmFnbWVudFNoYWRlcjpbXCJ1bmlmb3JtIHZlYzMgdUFtYmllbnRDb2xvcjtcXG51bmlmb3JtIHZlYzMgdURpZmZ1c2VDb2xvcjtcXG51bmlmb3JtIHZlYzMgdVNwZWN1bGFyQ29sb3I7XFxudW5pZm9ybSBmbG9hdCB1U2hpbmluZXNzO1xcbnVuaWZvcm0gZmxvYXQgdU9wYWNpdHk7XFxudW5pZm9ybSBib29sIGVuYWJsZURpZmZ1c2U7XFxudW5pZm9ybSBib29sIGVuYWJsZVNwZWN1bGFyO1xcbnVuaWZvcm0gYm9vbCBlbmFibGVBTztcXG51bmlmb3JtIGJvb2wgZW5hYmxlUmVmbGVjdGlvbjtcXG51bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB0Tm9ybWFsO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRTcGVjdWxhcjtcXG51bmlmb3JtIHNhbXBsZXIyRCB0QU87XFxudW5pZm9ybSBzYW1wbGVyQ3ViZSB0Q3ViZTtcXG51bmlmb3JtIHZlYzIgdU5vcm1hbFNjYWxlO1xcbnVuaWZvcm0gYm9vbCB1c2VSZWZyYWN0O1xcbnVuaWZvcm0gZmxvYXQgdVJlZnJhY3Rpb25SYXRpbztcXG51bmlmb3JtIGZsb2F0IHVSZWZsZWN0aXZpdHk7XFxudmFyeWluZyB2ZWMzIHZUYW5nZW50O1xcbnZhcnlpbmcgdmVjMyB2Qmlub3JtYWw7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxudmFyeWluZyB2ZWMyIHZVdjtcXG51bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcbnVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIE1BWF9ESVJfTElHSFRTIF07XFxudW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIE1BWF9ESVJfTElHSFRTIF07XFxuI2VuZGlmXFxuI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcXG51bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcbnVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XFxudW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgTUFYX0hFTUlfTElHSFRTIF07XFxuI2VuZGlmXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxudW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRDb2xvclsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcbnVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG51bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREaXN0YW5jZVsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcbiNlbmRpZlxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXFxudW5pZm9ybSB2ZWMzIHNwb3RMaWdodENvbG9yWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG51bmlmb3JtIHZlYzMgc3BvdExpZ2h0UG9zaXRpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcbnVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcbnVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0QW5nbGVDb3NbIE1BWF9TUE9UX0xJR0hUUyBdO1xcbnVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RXhwb25lbnRbIE1BWF9TUE9UX0xJR0hUUyBdO1xcbnVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGlzdGFuY2VbIE1BWF9TUE9UX0xJR0hUUyBdO1xcbiNlbmRpZlxcbiNpZmRlZiBXUkFQX0FST1VORFxcbnVuaWZvcm0gdmVjMyB3cmFwUkdCO1xcbiNlbmRpZlxcbnZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcblRIUkVFLlNoYWRlckNodW5rLnNoYWRvd21hcF9wYXJzX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmZvZ19wYXJzX2ZyYWdtZW50LFwidm9pZCBtYWluKCkge1xcbmdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIDEuMCApLCB1T3BhY2l0eSApO1xcbnZlYzMgc3BlY3VsYXJUZXggPSB2ZWMzKCAxLjAgKTtcXG52ZWMzIG5vcm1hbFRleCA9IHRleHR1cmUyRCggdE5vcm1hbCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1xcbm5vcm1hbFRleC54eSAqPSB1Tm9ybWFsU2NhbGU7XFxubm9ybWFsVGV4ID0gbm9ybWFsaXplKCBub3JtYWxUZXggKTtcXG5pZiggZW5hYmxlRGlmZnVzZSApIHtcXG4jaWZkZWYgR0FNTUFfSU5QVVRcXG52ZWM0IHRleGVsQ29sb3IgPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2VXYgKTtcXG50ZXhlbENvbG9yLnh5eiAqPSB0ZXhlbENvbG9yLnh5ejtcXG5nbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3IgKiB0ZXhlbENvbG9yO1xcbiNlbHNlXFxuZ2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yICogdGV4dHVyZTJEKCB0RGlmZnVzZSwgdlV2ICk7XFxuI2VuZGlmXFxufVxcbmlmKCBlbmFibGVBTyApIHtcXG4jaWZkZWYgR0FNTUFfSU5QVVRcXG52ZWM0IGFvQ29sb3IgPSB0ZXh0dXJlMkQoIHRBTywgdlV2ICk7XFxuYW9Db2xvci54eXogKj0gYW9Db2xvci54eXo7XFxuZ2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiBhb0NvbG9yLnh5ejtcXG4jZWxzZVxcbmdsX0ZyYWdDb2xvci54eXogPSBnbF9GcmFnQ29sb3IueHl6ICogdGV4dHVyZTJEKCB0QU8sIHZVdiApLnh5ejtcXG4jZW5kaWZcXG59XFxuaWYoIGVuYWJsZVNwZWN1bGFyIClcXG5zcGVjdWxhclRleCA9IHRleHR1cmUyRCggdFNwZWN1bGFyLCB2VXYgKS54eXo7XFxubWF0MyB0c2IgPSBtYXQzKCBub3JtYWxpemUoIHZUYW5nZW50ICksIG5vcm1hbGl6ZSggdkJpbm9ybWFsICksIG5vcm1hbGl6ZSggdk5vcm1hbCApICk7XFxudmVjMyBmaW5hbE5vcm1hbCA9IHRzYiAqIG5vcm1hbFRleDtcXG4jaWZkZWYgRkxJUF9TSURFRFxcbmZpbmFsTm9ybWFsID0gLWZpbmFsTm9ybWFsO1xcbiNlbmRpZlxcbnZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCBmaW5hbE5vcm1hbCApO1xcbnZlYzMgdmlld1Bvc2l0aW9uID0gbm9ybWFsaXplKCB2Vmlld1Bvc2l0aW9uICk7XFxuI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxudmVjMyBwb2ludERpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcXG52ZWMzIHBvaW50U3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcXG5mb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1xcbnZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHBvaW50TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcXG52ZWMzIHBvaW50VmVjdG9yID0gbFBvc2l0aW9uLnh5eiArIHZWaWV3UG9zaXRpb24ueHl6O1xcbmZsb2F0IHBvaW50RGlzdGFuY2UgPSAxLjA7XFxuaWYgKCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSA+IDAuMCApXFxucG9pbnREaXN0YW5jZSA9IDEuMCAtIG1pbiggKCBsZW5ndGgoIHBvaW50VmVjdG9yICkgLyBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcXG5wb2ludFZlY3RvciA9IG5vcm1hbGl6ZSggcG9pbnRWZWN0b3IgKTtcXG4jaWZkZWYgV1JBUF9BUk9VTkRcXG5mbG9hdCBwb2ludERpZmZ1c2VXZWlnaHRGdWxsID0gbWF4KCBkb3QoIG5vcm1hbCwgcG9pbnRWZWN0b3IgKSwgMC4wICk7XFxuZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0SGFsZiA9IG1heCggMC41ICogZG90KCBub3JtYWwsIHBvaW50VmVjdG9yICkgKyAwLjUsIDAuMCApO1xcbnZlYzMgcG9pbnREaWZmdXNlV2VpZ2h0ID0gbWl4KCB2ZWMzICggcG9pbnREaWZmdXNlV2VpZ2h0RnVsbCApLCB2ZWMzKCBwb2ludERpZmZ1c2VXZWlnaHRIYWxmICksIHdyYXBSR0IgKTtcXG4jZWxzZVxcbmZsb2F0IHBvaW50RGlmZnVzZVdlaWdodCA9IG1heCggZG90KCBub3JtYWwsIHBvaW50VmVjdG9yICksIDAuMCApO1xcbiNlbmRpZlxcbnBvaW50RGlmZnVzZSArPSBwb2ludERpc3RhbmNlICogcG9pbnRMaWdodENvbG9yWyBpIF0gKiB1RGlmZnVzZUNvbG9yICogcG9pbnREaWZmdXNlV2VpZ2h0O1xcbnZlYzMgcG9pbnRIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBwb2ludFZlY3RvciArIHZpZXdQb3NpdGlvbiApO1xcbmZsb2F0IHBvaW50RG90Tm9ybWFsSGFsZiA9IG1heCggZG90KCBub3JtYWwsIHBvaW50SGFsZlZlY3RvciApLCAwLjAgKTtcXG5mbG9hdCBwb2ludFNwZWN1bGFyV2VpZ2h0ID0gc3BlY3VsYXJUZXguciAqIG1heCggcG93KCBwb2ludERvdE5vcm1hbEhhbGYsIHVTaGluaW5lc3MgKSwgMC4wICk7XFxuI2lmZGVmIFBIWVNJQ0FMTFlfQkFTRURfU0hBRElOR1xcbmZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggdVNoaW5pbmVzcyArIDIuMDAwMSApIC8gOC4wO1xcbnZlYzMgc2NobGljayA9IHVTcGVjdWxhckNvbG9yICsgdmVjMyggMS4wIC0gdVNwZWN1bGFyQ29sb3IgKSAqIHBvdyggMS4wIC0gZG90KCBwb2ludFZlY3RvciwgcG9pbnRIYWxmVmVjdG9yICksIDUuMCApO1xcbnBvaW50U3BlY3VsYXIgKz0gc2NobGljayAqIHBvaW50TGlnaHRDb2xvclsgaSBdICogcG9pbnRTcGVjdWxhcldlaWdodCAqIHBvaW50RGlmZnVzZVdlaWdodCAqIHBvaW50RGlzdGFuY2UgKiBzcGVjdWxhck5vcm1hbGl6YXRpb247XFxuI2Vsc2VcXG5wb2ludFNwZWN1bGFyICs9IHBvaW50RGlzdGFuY2UgKiBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHVTcGVjdWxhckNvbG9yICogcG9pbnRTcGVjdWxhcldlaWdodCAqIHBvaW50RGlmZnVzZVdlaWdodDtcXG4jZW5kaWZcXG59XFxuI2VuZGlmXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG52ZWMzIHNwb3REaWZmdXNlID0gdmVjMyggMC4wICk7XFxudmVjMyBzcG90U3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcXG5mb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxudmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggc3BvdExpZ2h0UG9zaXRpb25bIGkgXSwgMS4wICk7XFxudmVjMyBzcG90VmVjdG9yID0gbFBvc2l0aW9uLnh5eiArIHZWaWV3UG9zaXRpb24ueHl6O1xcbmZsb2F0IHNwb3REaXN0YW5jZSA9IDEuMDtcXG5pZiAoIHNwb3RMaWdodERpc3RhbmNlWyBpIF0gPiAwLjAgKVxcbnNwb3REaXN0YW5jZSA9IDEuMCAtIG1pbiggKCBsZW5ndGgoIHNwb3RWZWN0b3IgKSAvIHNwb3RMaWdodERpc3RhbmNlWyBpIF0gKSwgMS4wICk7XFxuc3BvdFZlY3RvciA9IG5vcm1hbGl6ZSggc3BvdFZlY3RvciApO1xcbmZsb2F0IHNwb3RFZmZlY3QgPSBkb3QoIHNwb3RMaWdodERpcmVjdGlvblsgaSBdLCBub3JtYWxpemUoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0gLSB2V29ybGRQb3NpdGlvbiApICk7XFxuaWYgKCBzcG90RWZmZWN0ID4gc3BvdExpZ2h0QW5nbGVDb3NbIGkgXSApIHtcXG5zcG90RWZmZWN0ID0gbWF4KCBwb3coIHNwb3RFZmZlY3QsIHNwb3RMaWdodEV4cG9uZW50WyBpIF0gKSwgMC4wICk7XFxuI2lmZGVmIFdSQVBfQVJPVU5EXFxuZmxvYXQgc3BvdERpZmZ1c2VXZWlnaHRGdWxsID0gbWF4KCBkb3QoIG5vcm1hbCwgc3BvdFZlY3RvciApLCAwLjAgKTtcXG5mbG9hdCBzcG90RGlmZnVzZVdlaWdodEhhbGYgPSBtYXgoIDAuNSAqIGRvdCggbm9ybWFsLCBzcG90VmVjdG9yICkgKyAwLjUsIDAuMCApO1xcbnZlYzMgc3BvdERpZmZ1c2VXZWlnaHQgPSBtaXgoIHZlYzMgKCBzcG90RGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggc3BvdERpZmZ1c2VXZWlnaHRIYWxmICksIHdyYXBSR0IgKTtcXG4jZWxzZVxcbmZsb2F0IHNwb3REaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3QoIG5vcm1hbCwgc3BvdFZlY3RvciApLCAwLjAgKTtcXG4jZW5kaWZcXG5zcG90RGlmZnVzZSArPSBzcG90RGlzdGFuY2UgKiBzcG90TGlnaHRDb2xvclsgaSBdICogdURpZmZ1c2VDb2xvciAqIHNwb3REaWZmdXNlV2VpZ2h0ICogc3BvdEVmZmVjdDtcXG52ZWMzIHNwb3RIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBzcG90VmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XFxuZmxvYXQgc3BvdERvdE5vcm1hbEhhbGYgPSBtYXgoIGRvdCggbm9ybWFsLCBzcG90SGFsZlZlY3RvciApLCAwLjAgKTtcXG5mbG9hdCBzcG90U3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclRleC5yICogbWF4KCBwb3coIHNwb3REb3ROb3JtYWxIYWxmLCB1U2hpbmluZXNzICksIDAuMCApO1xcbiNpZmRlZiBQSFlTSUNBTExZX0JBU0VEX1NIQURJTkdcXG5mbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHVTaGluaW5lc3MgKyAyLjAwMDEgKSAvIDguMDtcXG52ZWMzIHNjaGxpY2sgPSB1U3BlY3VsYXJDb2xvciArIHZlYzMoIDEuMCAtIHVTcGVjdWxhckNvbG9yICkgKiBwb3coIDEuMCAtIGRvdCggc3BvdFZlY3Rvciwgc3BvdEhhbGZWZWN0b3IgKSwgNS4wICk7XFxuc3BvdFNwZWN1bGFyICs9IHNjaGxpY2sgKiBzcG90TGlnaHRDb2xvclsgaSBdICogc3BvdFNwZWN1bGFyV2VpZ2h0ICogc3BvdERpZmZ1c2VXZWlnaHQgKiBzcG90RGlzdGFuY2UgKiBzcGVjdWxhck5vcm1hbGl6YXRpb24gKiBzcG90RWZmZWN0O1xcbiNlbHNlXFxuc3BvdFNwZWN1bGFyICs9IHNwb3REaXN0YW5jZSAqIHNwb3RMaWdodENvbG9yWyBpIF0gKiB1U3BlY3VsYXJDb2xvciAqIHNwb3RTcGVjdWxhcldlaWdodCAqIHNwb3REaWZmdXNlV2VpZ2h0ICogc3BvdEVmZmVjdDtcXG4jZW5kaWZcXG59XFxufVxcbiNlbmRpZlxcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG52ZWMzIGRpckRpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcXG52ZWMzIGRpclNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSsrICkge1xcbnZlYzQgbERpcmVjdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBpIF0sIDAuMCApO1xcbnZlYzMgZGlyVmVjdG9yID0gbm9ybWFsaXplKCBsRGlyZWN0aW9uLnh5eiApO1xcbiNpZmRlZiBXUkFQX0FST1VORFxcbmZsb2F0IGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdGdWxsID0gbWF4KCBkb3QoIG5vcm1hbCwgZGlyVmVjdG9yICksIDAuMCApO1xcbmZsb2F0IGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdIYWxmID0gbWF4KCAwLjUgKiBkb3QoIG5vcm1hbCwgZGlyVmVjdG9yICkgKyAwLjUsIDAuMCApO1xcbnZlYzMgZGlyRGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyggZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0Z1bGwgKSwgdmVjMyggZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0hhbGYgKSwgd3JhcFJHQiApO1xcbiNlbHNlXFxuZmxvYXQgZGlyRGlmZnVzZVdlaWdodCA9IG1heCggZG90KCBub3JtYWwsIGRpclZlY3RvciApLCAwLjAgKTtcXG4jZW5kaWZcXG5kaXJEaWZmdXNlICs9IGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdICogdURpZmZ1c2VDb2xvciAqIGRpckRpZmZ1c2VXZWlnaHQ7XFxudmVjMyBkaXJIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBkaXJWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcXG5mbG9hdCBkaXJEb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgZGlySGFsZlZlY3RvciApLCAwLjAgKTtcXG5mbG9hdCBkaXJTcGVjdWxhcldlaWdodCA9IHNwZWN1bGFyVGV4LnIgKiBtYXgoIHBvdyggZGlyRG90Tm9ybWFsSGFsZiwgdVNoaW5pbmVzcyApLCAwLjAgKTtcXG4jaWZkZWYgUEhZU0lDQUxMWV9CQVNFRF9TSEFESU5HXFxuZmxvYXQgc3BlY3VsYXJOb3JtYWxpemF0aW9uID0gKCB1U2hpbmluZXNzICsgMi4wMDAxICkgLyA4LjA7XFxudmVjMyBzY2hsaWNrID0gdVNwZWN1bGFyQ29sb3IgKyB2ZWMzKCAxLjAgLSB1U3BlY3VsYXJDb2xvciApICogcG93KCAxLjAgLSBkb3QoIGRpclZlY3RvciwgZGlySGFsZlZlY3RvciApLCA1LjAgKTtcXG5kaXJTcGVjdWxhciArPSBzY2hsaWNrICogZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJTcGVjdWxhcldlaWdodCAqIGRpckRpZmZ1c2VXZWlnaHQgKiBzcGVjdWxhck5vcm1hbGl6YXRpb247XFxuI2Vsc2VcXG5kaXJTcGVjdWxhciArPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIHVTcGVjdWxhckNvbG9yICogZGlyU3BlY3VsYXJXZWlnaHQgKiBkaXJEaWZmdXNlV2VpZ2h0O1xcbiNlbmRpZlxcbn1cXG4jZW5kaWZcXG4jaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcbnZlYzMgaGVtaURpZmZ1c2UgID0gdmVjMyggMC4wICk7XFxudmVjMyBoZW1pU3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcXG5mb3IoIGludCBpID0gMDsgaSA8IE1BWF9IRU1JX0xJR0hUUzsgaSArKyApIHtcXG52ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBpIF0sIDAuMCApO1xcbnZlYzMgbFZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcXG5mbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxWZWN0b3IgKTtcXG5mbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdFByb2R1Y3QgKyAwLjU7XFxudmVjMyBoZW1pQ29sb3IgPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxuaGVtaURpZmZ1c2UgKz0gdURpZmZ1c2VDb2xvciAqIGhlbWlDb2xvcjtcXG52ZWMzIGhlbWlIYWxmVmVjdG9yU2t5ID0gbm9ybWFsaXplKCBsVmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XFxuZmxvYXQgaGVtaURvdE5vcm1hbEhhbGZTa3kgPSAwLjUgKiBkb3QoIG5vcm1hbCwgaGVtaUhhbGZWZWN0b3JTa3kgKSArIDAuNTtcXG5mbG9hdCBoZW1pU3BlY3VsYXJXZWlnaHRTa3kgPSBzcGVjdWxhclRleC5yICogbWF4KCBwb3coIGhlbWlEb3ROb3JtYWxIYWxmU2t5LCB1U2hpbmluZXNzICksIDAuMCApO1xcbnZlYzMgbFZlY3Rvckdyb3VuZCA9IC1sVmVjdG9yO1xcbnZlYzMgaGVtaUhhbGZWZWN0b3JHcm91bmQgPSBub3JtYWxpemUoIGxWZWN0b3JHcm91bmQgKyB2aWV3UG9zaXRpb24gKTtcXG5mbG9hdCBoZW1pRG90Tm9ybWFsSGFsZkdyb3VuZCA9IDAuNSAqIGRvdCggbm9ybWFsLCBoZW1pSGFsZlZlY3Rvckdyb3VuZCApICsgMC41O1xcbmZsb2F0IGhlbWlTcGVjdWxhcldlaWdodEdyb3VuZCA9IHNwZWN1bGFyVGV4LnIgKiBtYXgoIHBvdyggaGVtaURvdE5vcm1hbEhhbGZHcm91bmQsIHVTaGluaW5lc3MgKSwgMC4wICk7XFxuI2lmZGVmIFBIWVNJQ0FMTFlfQkFTRURfU0hBRElOR1xcbmZsb2F0IGRvdFByb2R1Y3RHcm91bmQgPSBkb3QoIG5vcm1hbCwgbFZlY3Rvckdyb3VuZCApO1xcbmZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggdVNoaW5pbmVzcyArIDIuMDAwMSApIC8gOC4wO1xcbnZlYzMgc2NobGlja1NreSA9IHVTcGVjdWxhckNvbG9yICsgdmVjMyggMS4wIC0gdVNwZWN1bGFyQ29sb3IgKSAqIHBvdyggMS4wIC0gZG90KCBsVmVjdG9yLCBoZW1pSGFsZlZlY3RvclNreSApLCA1LjAgKTtcXG52ZWMzIHNjaGxpY2tHcm91bmQgPSB1U3BlY3VsYXJDb2xvciArIHZlYzMoIDEuMCAtIHVTcGVjdWxhckNvbG9yICkgKiBwb3coIDEuMCAtIGRvdCggbFZlY3Rvckdyb3VuZCwgaGVtaUhhbGZWZWN0b3JHcm91bmQgKSwgNS4wICk7XFxuaGVtaVNwZWN1bGFyICs9IGhlbWlDb2xvciAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbiAqICggc2NobGlja1NreSAqIGhlbWlTcGVjdWxhcldlaWdodFNreSAqIG1heCggZG90UHJvZHVjdCwgMC4wICkgKyBzY2hsaWNrR3JvdW5kICogaGVtaVNwZWN1bGFyV2VpZ2h0R3JvdW5kICogbWF4KCBkb3RQcm9kdWN0R3JvdW5kLCAwLjAgKSApO1xcbiNlbHNlXFxuaGVtaVNwZWN1bGFyICs9IHVTcGVjdWxhckNvbG9yICogaGVtaUNvbG9yICogKCBoZW1pU3BlY3VsYXJXZWlnaHRTa3kgKyBoZW1pU3BlY3VsYXJXZWlnaHRHcm91bmQgKSAqIGhlbWlEaWZmdXNlV2VpZ2h0O1xcbiNlbmRpZlxcbn1cXG4jZW5kaWZcXG52ZWMzIHRvdGFsRGlmZnVzZSA9IHZlYzMoIDAuMCApO1xcbnZlYzMgdG90YWxTcGVjdWxhciA9IHZlYzMoIDAuMCApO1xcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG50b3RhbERpZmZ1c2UgKz0gZGlyRGlmZnVzZTtcXG50b3RhbFNwZWN1bGFyICs9IGRpclNwZWN1bGFyO1xcbiNlbmRpZlxcbiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXFxudG90YWxEaWZmdXNlICs9IGhlbWlEaWZmdXNlO1xcbnRvdGFsU3BlY3VsYXIgKz0gaGVtaVNwZWN1bGFyO1xcbiNlbmRpZlxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcbnRvdGFsRGlmZnVzZSArPSBwb2ludERpZmZ1c2U7XFxudG90YWxTcGVjdWxhciArPSBwb2ludFNwZWN1bGFyO1xcbiNlbmRpZlxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXFxudG90YWxEaWZmdXNlICs9IHNwb3REaWZmdXNlO1xcbnRvdGFsU3BlY3VsYXIgKz0gc3BvdFNwZWN1bGFyO1xcbiNlbmRpZlxcbiNpZmRlZiBNRVRBTFxcbmdsX0ZyYWdDb2xvci54eXogPSBnbF9GcmFnQ29sb3IueHl6ICogKCB0b3RhbERpZmZ1c2UgKyBhbWJpZW50TGlnaHRDb2xvciAqIHVBbWJpZW50Q29sb3IgKyB0b3RhbFNwZWN1bGFyICk7XFxuI2Vsc2VcXG5nbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqICggdG90YWxEaWZmdXNlICsgYW1iaWVudExpZ2h0Q29sb3IgKiB1QW1iaWVudENvbG9yICkgKyB0b3RhbFNwZWN1bGFyO1xcbiNlbmRpZlxcbmlmICggZW5hYmxlUmVmbGVjdGlvbiApIHtcXG52ZWMzIHZSZWZsZWN0O1xcbnZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcXG5pZiAoIHVzZVJlZnJhY3QgKSB7XFxudlJlZmxlY3QgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgbm9ybWFsLCB1UmVmcmFjdGlvblJhdGlvICk7XFxufSBlbHNlIHtcXG52UmVmbGVjdCA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCBub3JtYWwgKTtcXG59XFxudmVjNCBjdWJlQ29sb3IgPSB0ZXh0dXJlQ3ViZSggdEN1YmUsIHZlYzMoIC12UmVmbGVjdC54LCB2UmVmbGVjdC55eiApICk7XFxuI2lmZGVmIEdBTU1BX0lOUFVUXFxuY3ViZUNvbG9yLnh5eiAqPSBjdWJlQ29sb3IueHl6O1xcbiNlbmRpZlxcbmdsX0ZyYWdDb2xvci54eXogPSBtaXgoIGdsX0ZyYWdDb2xvci54eXosIGN1YmVDb2xvci54eXosIHNwZWN1bGFyVGV4LnIgKiB1UmVmbGVjdGl2aXR5ICk7XFxufVwiLFxuVEhSRUUuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX2ZyYWdtZW50LFRIUkVFLlNoYWRlckNodW5rLmxpbmVhcl90b19nYW1tYV9mcmFnbWVudCxUSFJFRS5TaGFkZXJDaHVuay5mb2dfZnJhZ21lbnQsXCJ9XCJdLmpvaW4oXCJcXG5cIiksdmVydGV4U2hhZGVyOltcImF0dHJpYnV0ZSB2ZWM0IHRhbmdlbnQ7XFxudW5pZm9ybSB2ZWMyIHVPZmZzZXQ7XFxudW5pZm9ybSB2ZWMyIHVSZXBlYXQ7XFxudW5pZm9ybSBib29sIGVuYWJsZURpc3BsYWNlbWVudDtcXG4jaWZkZWYgVkVSVEVYX1RFWFRVUkVTXFxudW5pZm9ybSBzYW1wbGVyMkQgdERpc3BsYWNlbWVudDtcXG51bmlmb3JtIGZsb2F0IHVEaXNwbGFjZW1lbnRTY2FsZTtcXG51bmlmb3JtIGZsb2F0IHVEaXNwbGFjZW1lbnRCaWFzO1xcbiNlbmRpZlxcbnZhcnlpbmcgdmVjMyB2VGFuZ2VudDtcXG52YXJ5aW5nIHZlYzMgdkJpbm9ybWFsO1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbnZhcnlpbmcgdmVjMiB2VXY7XFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiLFxuVEhSRUUuU2hhZGVyQ2h1bmsuc2tpbm5pbmdfcGFyc192ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsuc2hhZG93bWFwX3BhcnNfdmVydGV4LFwidm9pZCBtYWluKCkge1wiLFRIUkVFLlNoYWRlckNodW5rLnNraW5iYXNlX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5za2lubm9ybWFsX3ZlcnRleCxcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG52Tm9ybWFsID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBza2lubmVkTm9ybWFsLnh5eiApO1xcbnZlYzQgc2tpbm5lZFRhbmdlbnQgPSBza2luTWF0cml4ICogdmVjNCggdGFuZ2VudC54eXosIDAuMCApO1xcbnZUYW5nZW50ID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBza2lubmVkVGFuZ2VudC54eXogKTtcXG4jZWxzZVxcbnZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApO1xcbnZUYW5nZW50ID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiB0YW5nZW50Lnh5eiApO1xcbiNlbmRpZlxcbnZCaW5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIHZOb3JtYWwsIHZUYW5nZW50ICkgKiB0YW5nZW50LncgKTtcXG52VXYgPSB1diAqIHVSZXBlYXQgKyB1T2Zmc2V0O1xcbnZlYzMgZGlzcGxhY2VkUG9zaXRpb247XFxuI2lmZGVmIFZFUlRFWF9URVhUVVJFU1xcbmlmICggZW5hYmxlRGlzcGxhY2VtZW50ICkge1xcbnZlYzMgZHYgPSB0ZXh0dXJlMkQoIHREaXNwbGFjZW1lbnQsIHV2ICkueHl6O1xcbmZsb2F0IGRmID0gdURpc3BsYWNlbWVudFNjYWxlICogZHYueCArIHVEaXNwbGFjZW1lbnRCaWFzO1xcbmRpc3BsYWNlZFBvc2l0aW9uID0gcG9zaXRpb24gKyBub3JtYWxpemUoIG5vcm1hbCApICogZGY7XFxufSBlbHNlIHtcXG4jaWZkZWYgVVNFX1NLSU5OSU5HXFxudmVjNCBza2luVmVydGV4ID0gdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbnZlYzQgc2tpbm5lZCAgPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XFxuc2tpbm5lZCBcXHQgICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcXG5kaXNwbGFjZWRQb3NpdGlvbiAgPSBza2lubmVkLnh5ejtcXG4jZWxzZVxcbmRpc3BsYWNlZFBvc2l0aW9uID0gcG9zaXRpb247XFxuI2VuZGlmXFxufVxcbiNlbHNlXFxuI2lmZGVmIFVTRV9TS0lOTklOR1xcbnZlYzQgc2tpblZlcnRleCA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG52ZWM0IHNraW5uZWQgID0gYm9uZU1hdFggKiBza2luVmVydGV4ICogc2tpbldlaWdodC54O1xcbnNraW5uZWQgXFx0ICArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XFxuZGlzcGxhY2VkUG9zaXRpb24gID0gc2tpbm5lZC54eXo7XFxuI2Vsc2VcXG5kaXNwbGFjZWRQb3NpdGlvbiA9IHBvc2l0aW9uO1xcbiNlbmRpZlxcbiNlbmRpZlxcbnZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIGRpc3BsYWNlZFBvc2l0aW9uLCAxLjAgKTtcXG52ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoIGRpc3BsYWNlZFBvc2l0aW9uLCAxLjAgKTtcXG5nbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xcbnZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XFxudlZpZXdQb3NpdGlvbiA9IC1tdlBvc2l0aW9uLnh5ejtcXG4jaWZkZWYgVVNFX1NIQURPV01BUFxcbmZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NIQURPV1M7IGkgKysgKSB7XFxudlNoYWRvd0Nvb3JkWyBpIF0gPSBzaGFkb3dNYXRyaXhbIGkgXSAqIHdvcmxkUG9zaXRpb247XFxufVxcbiNlbmRpZlxcbn1cIl0uam9pbihcIlxcblwiKX0sXG5jdWJlOnt1bmlmb3Jtczp7dEN1YmU6e3R5cGU6XCJ0XCIsdmFsdWU6bnVsbH0sdEZsaXA6e3R5cGU6XCJmXCIsdmFsdWU6LTF9fSx2ZXJ0ZXhTaGFkZXI6XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxudm9pZCBtYWluKCkge1xcbnZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbnZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XFxuZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbn1cIixmcmFnbWVudFNoYWRlcjpcInVuaWZvcm0gc2FtcGxlckN1YmUgdEN1YmU7XFxudW5pZm9ybSBmbG9hdCB0RmxpcDtcXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxudm9pZCBtYWluKCkge1xcbmdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XFxufVwifSxcbmRlcHRoUkdCQTp7dW5pZm9ybXM6e30sdmVydGV4U2hhZGVyOltUSFJFRS5TaGFkZXJDaHVuay5tb3JwaHRhcmdldF9wYXJzX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5za2lubmluZ19wYXJzX3ZlcnRleCxcInZvaWQgbWFpbigpIHtcIixUSFJFRS5TaGFkZXJDaHVuay5za2luYmFzZV92ZXJ0ZXgsVEhSRUUuU2hhZGVyQ2h1bmsubW9ycGh0YXJnZXRfdmVydGV4LFRIUkVFLlNoYWRlckNodW5rLnNraW5uaW5nX3ZlcnRleCxUSFJFRS5TaGFkZXJDaHVuay5kZWZhdWx0X3ZlcnRleCxcIn1cIl0uam9pbihcIlxcblwiKSxmcmFnbWVudFNoYWRlcjpcInZlYzQgcGFja19kZXB0aCggY29uc3QgaW4gZmxvYXQgZGVwdGggKSB7XFxuY29uc3QgdmVjNCBiaXRfc2hpZnQgPSB2ZWM0KCAyNTYuMCAqIDI1Ni4wICogMjU2LjAsIDI1Ni4wICogMjU2LjAsIDI1Ni4wLCAxLjAgKTtcXG5jb25zdCB2ZWM0IGJpdF9tYXNrICA9IHZlYzQoIDAuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCApO1xcbnZlYzQgcmVzID0gZnJhY3QoIGRlcHRoICogYml0X3NoaWZ0ICk7XFxucmVzIC09IHJlcy54eHl6ICogYml0X21hc2s7XFxucmV0dXJuIHJlcztcXG59XFxudm9pZCBtYWluKCkge1xcbmdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCBnbF9GcmFnQ29vcmQueiApO1xcbn1cIn19O1RIUkVFLldlYkdMUmVuZGVyZXI9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhLGIpe3ZhciBjPWEudmVydGljZXMubGVuZ3RoLGQ9Yi5tYXRlcmlhbDtpZihkLmF0dHJpYnV0ZXMpe3ZvaWQgMD09PWEuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0JiYoYS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3Q9W10pO2Zvcih2YXIgZSBpbiBkLmF0dHJpYnV0ZXMpe3ZhciBmPWQuYXR0cmlidXRlc1tlXTtpZighZi5fX3dlYmdsSW5pdGlhbGl6ZWR8fGYuY3JlYXRlVW5pcXVlQnVmZmVycyl7Zi5fX3dlYmdsSW5pdGlhbGl6ZWQ9ITA7dmFyIGg9MTtcInYyXCI9PT1mLnR5cGU/aD0yOlwidjNcIj09PWYudHlwZT9oPTM6XCJ2NFwiPT09Zi50eXBlP2g9NDpcImNcIj09PWYudHlwZSYmKGg9Myk7Zi5zaXplPWg7Zi5hcnJheT1uZXcgRmxvYXQzMkFycmF5KGMqaCk7Zi5idWZmZXI9ai5jcmVhdGVCdWZmZXIoKTtmLmJ1ZmZlci5iZWxvbmdzVG9BdHRyaWJ1dGU9ZTtmLm5lZWRzVXBkYXRlPSEwfWEuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0LnB1c2goZil9fX1cbmZ1bmN0aW9uIGMoYSxiKXt2YXIgYz1iLmdlb21ldHJ5LGg9YS5mYWNlczMsZz0zKmgubGVuZ3RoLGk9MSpoLmxlbmd0aCxrPTMqaC5sZW5ndGgsaD1kKGIsYSksbT1mKGgpLGw9ZShoKSxwPWgudmVydGV4Q29sb3JzP2gudmVydGV4Q29sb3JzOiExO2EuX192ZXJ0ZXhBcnJheT1uZXcgRmxvYXQzMkFycmF5KDMqZyk7bCYmKGEuX19ub3JtYWxBcnJheT1uZXcgRmxvYXQzMkFycmF5KDMqZykpO2MuaGFzVGFuZ2VudHMmJihhLl9fdGFuZ2VudEFycmF5PW5ldyBGbG9hdDMyQXJyYXkoNCpnKSk7cCYmKGEuX19jb2xvckFycmF5PW5ldyBGbG9hdDMyQXJyYXkoMypnKSk7bSYmKDA8Yy5mYWNlVmVydGV4VXZzLmxlbmd0aCYmKGEuX191dkFycmF5PW5ldyBGbG9hdDMyQXJyYXkoMipnKSksMTxjLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoJiYoYS5fX3V2MkFycmF5PW5ldyBGbG9hdDMyQXJyYXkoMipnKSkpO2IuZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoJiZiLmdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCYmXG4oYS5fX3NraW5JbmRleEFycmF5PW5ldyBGbG9hdDMyQXJyYXkoNCpnKSxhLl9fc2tpbldlaWdodEFycmF5PW5ldyBGbG9hdDMyQXJyYXkoNCpnKSk7YS5fX2ZhY2VBcnJheT1uZXcgVWludDE2QXJyYXkoMyppKTthLl9fbGluZUFycmF5PW5ldyBVaW50MTZBcnJheSgyKmspO2lmKGEubnVtTW9ycGhUYXJnZXRzKXthLl9fbW9ycGhUYXJnZXRzQXJyYXlzPVtdO2M9MDtmb3IobT1hLm51bU1vcnBoVGFyZ2V0cztjPG07YysrKWEuX19tb3JwaFRhcmdldHNBcnJheXMucHVzaChuZXcgRmxvYXQzMkFycmF5KDMqZykpfWlmKGEubnVtTW9ycGhOb3JtYWxzKXthLl9fbW9ycGhOb3JtYWxzQXJyYXlzPVtdO2M9MDtmb3IobT1hLm51bU1vcnBoTm9ybWFscztjPG07YysrKWEuX19tb3JwaE5vcm1hbHNBcnJheXMucHVzaChuZXcgRmxvYXQzMkFycmF5KDMqZykpfWEuX193ZWJnbEZhY2VDb3VudD0zKmk7YS5fX3dlYmdsTGluZUNvdW50PTIqaztpZihoLmF0dHJpYnV0ZXMpe3ZvaWQgMD09PWEuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0JiZcbihhLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdD1bXSk7Zm9yKHZhciBuIGluIGguYXR0cmlidXRlcyl7dmFyIGk9aC5hdHRyaWJ1dGVzW25dLGs9e30scjtmb3IociBpbiBpKWtbcl09aVtyXTtpZighay5fX3dlYmdsSW5pdGlhbGl6ZWR8fGsuY3JlYXRlVW5pcXVlQnVmZmVycylrLl9fd2ViZ2xJbml0aWFsaXplZD0hMCxjPTEsXCJ2MlwiPT09ay50eXBlP2M9MjpcInYzXCI9PT1rLnR5cGU/Yz0zOlwidjRcIj09PWsudHlwZT9jPTQ6XCJjXCI9PT1rLnR5cGUmJihjPTMpLGsuc2l6ZT1jLGsuYXJyYXk9bmV3IEZsb2F0MzJBcnJheShnKmMpLGsuYnVmZmVyPWouY3JlYXRlQnVmZmVyKCksay5idWZmZXIuYmVsb25nc1RvQXR0cmlidXRlPW4saS5uZWVkc1VwZGF0ZT0hMCxrLl9fb3JpZ2luYWw9aTthLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdC5wdXNoKGspfX1hLl9faW5pdHRlZEFycmF5cz0hMH1mdW5jdGlvbiBkKGEsYil7cmV0dXJuIGEubWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsP1xuYS5tYXRlcmlhbC5tYXRlcmlhbHNbYi5tYXRlcmlhbEluZGV4XTphLm1hdGVyaWFsfWZ1bmN0aW9uIGUoYSl7cmV0dXJuIGEgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCYmIWEuZW52TWFwfHxhIGluc3RhbmNlb2YgVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWw/ITE6YSYmdm9pZCAwIT09YS5zaGFkaW5nJiZhLnNoYWRpbmc9PT1USFJFRS5TbW9vdGhTaGFkaW5nP1RIUkVFLlNtb290aFNoYWRpbmc6VEhSRUUuRmxhdFNoYWRpbmd9ZnVuY3Rpb24gZihhKXtyZXR1cm4gYS5tYXB8fGEubGlnaHRNYXB8fGEuYnVtcE1hcHx8YS5ub3JtYWxNYXB8fGEuc3BlY3VsYXJNYXB8fGEgaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbD8hMDohMX1mdW5jdGlvbiBoKGEpe0hhW2FdfHwoai5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhKSxIYVthXT0hMCl9ZnVuY3Rpb24gZygpe2Zvcih2YXIgYSBpbiBIYSlIYVthXSYmKGouZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGEpLEhhW2FdPVxuITEpfWZ1bmN0aW9uIGkoYSxiKXtyZXR1cm4gYS56IT09Yi56P2Iuei1hLno6YS5pZC1iLmlkfWZ1bmN0aW9uIGsoYSxiKXtyZXR1cm4gYlswXS1hWzBdfWZ1bmN0aW9uIG0oYSxiLGMpe2lmKGEubGVuZ3RoKWZvcih2YXIgZD0wLGU9YS5sZW5ndGg7ZDxlO2QrKyllYT1CYT1udWxsLEFhPSQ9VT1aPWZhPUdhPWthPS0xLHVhPSEwLGFbZF0ucmVuZGVyKGIsYyxzYixwYiksZWE9QmE9bnVsbCxBYT0kPVU9Wj1mYT1HYT1rYT0tMSx1YT0hMH1mdW5jdGlvbiBsKGEsYixjLGQsZSxmLGgsZyl7dmFyIGosaSxrLG07Yj8oaT1hLmxlbmd0aC0xLG09Yj0tMSk6KGk9MCxiPWEubGVuZ3RoLG09MSk7Zm9yKHZhciBsPWk7bCE9PWI7bCs9bSlpZihqPWFbbF0sai5yZW5kZXIpe2k9ai5vYmplY3Q7az1qLmJ1ZmZlcjtpZihnKWo9ZztlbHNle2o9altjXTtpZighailjb250aW51ZTtoJiZLLnNldEJsZW5kaW5nKGouYmxlbmRpbmcsai5ibGVuZEVxdWF0aW9uLGouYmxlbmRTcmMsai5ibGVuZERzdCk7XG5LLnNldERlcHRoVGVzdChqLmRlcHRoVGVzdCk7Sy5zZXREZXB0aFdyaXRlKGouZGVwdGhXcml0ZSk7QShqLnBvbHlnb25PZmZzZXQsai5wb2x5Z29uT2Zmc2V0RmFjdG9yLGoucG9seWdvbk9mZnNldFVuaXRzKX1LLnNldE1hdGVyaWFsRmFjZXMoaik7ayBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5P0sucmVuZGVyQnVmZmVyRGlyZWN0KGQsZSxmLGosayxpKTpLLnJlbmRlckJ1ZmZlcihkLGUsZixqLGssaSl9fWZ1bmN0aW9uIHAoYSxiLGMsZCxlLGYsaCl7Zm9yKHZhciBnLGosaT0wLGs9YS5sZW5ndGg7aTxrO2krKylpZihnPWFbaV0saj1nLm9iamVjdCxqLnZpc2libGUpe2lmKGgpZz1oO2Vsc2V7Zz1nW2JdO2lmKCFnKWNvbnRpbnVlO2YmJksuc2V0QmxlbmRpbmcoZy5ibGVuZGluZyxnLmJsZW5kRXF1YXRpb24sZy5ibGVuZFNyYyxnLmJsZW5kRHN0KTtLLnNldERlcHRoVGVzdChnLmRlcHRoVGVzdCk7Sy5zZXREZXB0aFdyaXRlKGcuZGVwdGhXcml0ZSk7QShnLnBvbHlnb25PZmZzZXQsXG5nLnBvbHlnb25PZmZzZXRGYWN0b3IsZy5wb2x5Z29uT2Zmc2V0VW5pdHMpfUsucmVuZGVySW1tZWRpYXRlT2JqZWN0KGMsZCxlLGcsail9fWZ1bmN0aW9uIHMoYSxkKXt2YXIgZSxmLGgsZztpZih2b2lkIDA9PT1hLl9fd2ViZ2xJbml0JiYoYS5fX3dlYmdsSW5pdD0hMCxhLl9tb2RlbFZpZXdNYXRyaXg9bmV3IFRIUkVFLk1hdHJpeDQsYS5fbm9ybWFsTWF0cml4PW5ldyBUSFJFRS5NYXRyaXgzLHZvaWQgMCE9PWEuZ2VvbWV0cnkmJnZvaWQgMD09PWEuZ2VvbWV0cnkuX193ZWJnbEluaXQmJihhLmdlb21ldHJ5Ll9fd2ViZ2xJbml0PSEwLGEuZ2VvbWV0cnkuYWRkRXZlbnRMaXN0ZW5lcihcImRpc3Bvc2VcIixDYikpLGY9YS5nZW9tZXRyeSx2b2lkIDAhPT1mKSlpZihmIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkpe3ZhciBpLGs7Zm9yKGkgaW4gZi5hdHRyaWJ1dGVzKWs9XCJpbmRleFwiPT09aT9qLkVMRU1FTlRfQVJSQVlfQlVGRkVSOmouQVJSQVlfQlVGRkVSLGc9Zi5hdHRyaWJ1dGVzW2ldLFxudm9pZCAwPT09Zy5udW1JdGVtcyYmKGcubnVtSXRlbXM9Zy5hcnJheS5sZW5ndGgpLGcuYnVmZmVyPWouY3JlYXRlQnVmZmVyKCksai5iaW5kQnVmZmVyKGssZy5idWZmZXIpLGouYnVmZmVyRGF0YShrLGcuYXJyYXksai5TVEFUSUNfRFJBVyl9ZWxzZSBpZihhIGluc3RhbmNlb2YgVEhSRUUuTWVzaCl7aD1hLm1hdGVyaWFsO2lmKHZvaWQgMD09PWYuZ2VvbWV0cnlHcm91cHMpe2k9Zjt2YXIgbSxsLHA7az17fTt2YXIgbj1pLm1vcnBoVGFyZ2V0cy5sZW5ndGgscj1pLm1vcnBoTm9ybWFscy5sZW5ndGgscz1oIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbDtpLmdlb21ldHJ5R3JvdXBzPXt9O2g9MDtmb3IobT1pLmZhY2VzLmxlbmd0aDtoPG07aCsrKWw9aS5mYWNlc1toXSxsPXM/bC5tYXRlcmlhbEluZGV4OjAsdm9pZCAwPT09a1tsXSYmKGtbbF09e2hhc2g6bCxjb3VudGVyOjB9KSxwPWtbbF0uaGFzaCtcIl9cIitrW2xdLmNvdW50ZXIsdm9pZCAwPT09aS5nZW9tZXRyeUdyb3Vwc1twXSYmXG4oaS5nZW9tZXRyeUdyb3Vwc1twXT17ZmFjZXMzOltdLG1hdGVyaWFsSW5kZXg6bCx2ZXJ0aWNlczowLG51bU1vcnBoVGFyZ2V0czpuLG51bU1vcnBoTm9ybWFsczpyfSksNjU1MzU8aS5nZW9tZXRyeUdyb3Vwc1twXS52ZXJ0aWNlcyszJiYoa1tsXS5jb3VudGVyKz0xLHA9a1tsXS5oYXNoK1wiX1wiK2tbbF0uY291bnRlcix2b2lkIDA9PT1pLmdlb21ldHJ5R3JvdXBzW3BdJiYoaS5nZW9tZXRyeUdyb3Vwc1twXT17ZmFjZXMzOltdLG1hdGVyaWFsSW5kZXg6bCx2ZXJ0aWNlczowLG51bU1vcnBoVGFyZ2V0czpuLG51bU1vcnBoTm9ybWFsczpyfSkpLGkuZ2VvbWV0cnlHcm91cHNbcF0uZmFjZXMzLnB1c2goaCksaS5nZW9tZXRyeUdyb3Vwc1twXS52ZXJ0aWNlcys9MztpLmdlb21ldHJ5R3JvdXBzTGlzdD1bXTtmb3IoZyBpbiBpLmdlb21ldHJ5R3JvdXBzKWkuZ2VvbWV0cnlHcm91cHNbZ10uaWQ9VisrLGkuZ2VvbWV0cnlHcm91cHNMaXN0LnB1c2goaS5nZW9tZXRyeUdyb3Vwc1tnXSl9Zm9yKGUgaW4gZi5nZW9tZXRyeUdyb3VwcylpZihnPVxuZi5nZW9tZXRyeUdyb3Vwc1tlXSwhZy5fX3dlYmdsVmVydGV4QnVmZmVyKXtpPWc7aS5fX3dlYmdsVmVydGV4QnVmZmVyPWouY3JlYXRlQnVmZmVyKCk7aS5fX3dlYmdsTm9ybWFsQnVmZmVyPWouY3JlYXRlQnVmZmVyKCk7aS5fX3dlYmdsVGFuZ2VudEJ1ZmZlcj1qLmNyZWF0ZUJ1ZmZlcigpO2kuX193ZWJnbENvbG9yQnVmZmVyPWouY3JlYXRlQnVmZmVyKCk7aS5fX3dlYmdsVVZCdWZmZXI9ai5jcmVhdGVCdWZmZXIoKTtpLl9fd2ViZ2xVVjJCdWZmZXI9ai5jcmVhdGVCdWZmZXIoKTtpLl9fd2ViZ2xTa2luSW5kaWNlc0J1ZmZlcj1qLmNyZWF0ZUJ1ZmZlcigpO2kuX193ZWJnbFNraW5XZWlnaHRzQnVmZmVyPWouY3JlYXRlQnVmZmVyKCk7aS5fX3dlYmdsRmFjZUJ1ZmZlcj1qLmNyZWF0ZUJ1ZmZlcigpO2kuX193ZWJnbExpbmVCdWZmZXI9ai5jcmVhdGVCdWZmZXIoKTtuPWs9dm9pZCAwO2lmKGkubnVtTW9ycGhUYXJnZXRzKXtpLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzPVtdO1xuaz0wO2ZvcihuPWkubnVtTW9ycGhUYXJnZXRzO2s8bjtrKyspaS5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVycy5wdXNoKGouY3JlYXRlQnVmZmVyKCkpfWlmKGkubnVtTW9ycGhOb3JtYWxzKXtpLl9fd2ViZ2xNb3JwaE5vcm1hbHNCdWZmZXJzPVtdO2s9MDtmb3Iobj1pLm51bU1vcnBoTm9ybWFscztrPG47aysrKWkuX193ZWJnbE1vcnBoTm9ybWFsc0J1ZmZlcnMucHVzaChqLmNyZWF0ZUJ1ZmZlcigpKX1LLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMrKztjKGcsYSk7Zi52ZXJ0aWNlc05lZWRVcGRhdGU9ITA7Zi5tb3JwaFRhcmdldHNOZWVkVXBkYXRlPSEwO2YuZWxlbWVudHNOZWVkVXBkYXRlPSEwO2YudXZzTmVlZFVwZGF0ZT0hMDtmLm5vcm1hbHNOZWVkVXBkYXRlPSEwO2YudGFuZ2VudHNOZWVkVXBkYXRlPSEwO2YuY29sb3JzTmVlZFVwZGF0ZT0hMH19ZWxzZSBhIGluc3RhbmNlb2YgVEhSRUUuTGluZT9mLl9fd2ViZ2xWZXJ0ZXhCdWZmZXJ8fChnPWYsZy5fX3dlYmdsVmVydGV4QnVmZmVyPVxuai5jcmVhdGVCdWZmZXIoKSxnLl9fd2ViZ2xDb2xvckJ1ZmZlcj1qLmNyZWF0ZUJ1ZmZlcigpLGcuX193ZWJnbExpbmVEaXN0YW5jZUJ1ZmZlcj1qLmNyZWF0ZUJ1ZmZlcigpLEsuaW5mby5tZW1vcnkuZ2VvbWV0cmllcysrLGc9ZixpPWcudmVydGljZXMubGVuZ3RoLGcuX192ZXJ0ZXhBcnJheT1uZXcgRmxvYXQzMkFycmF5KDMqaSksZy5fX2NvbG9yQXJyYXk9bmV3IEZsb2F0MzJBcnJheSgzKmkpLGcuX19saW5lRGlzdGFuY2VBcnJheT1uZXcgRmxvYXQzMkFycmF5KDEqaSksZy5fX3dlYmdsTGluZUNvdW50PWksYihnLGEpLGYudmVydGljZXNOZWVkVXBkYXRlPSEwLGYuY29sb3JzTmVlZFVwZGF0ZT0hMCxmLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlPSEwKTphIGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVTeXN0ZW0mJiFmLl9fd2ViZ2xWZXJ0ZXhCdWZmZXImJihnPWYsZy5fX3dlYmdsVmVydGV4QnVmZmVyPWouY3JlYXRlQnVmZmVyKCksZy5fX3dlYmdsQ29sb3JCdWZmZXI9ai5jcmVhdGVCdWZmZXIoKSxcbksuaW5mby5tZW1vcnkuZ2VvbWV0cmllcysrLGc9ZixpPWcudmVydGljZXMubGVuZ3RoLGcuX192ZXJ0ZXhBcnJheT1uZXcgRmxvYXQzMkFycmF5KDMqaSksZy5fX2NvbG9yQXJyYXk9bmV3IEZsb2F0MzJBcnJheSgzKmkpLGcuX19zb3J0QXJyYXk9W10sZy5fX3dlYmdsUGFydGljbGVDb3VudD1pLGIoZyxhKSxmLnZlcnRpY2VzTmVlZFVwZGF0ZT0hMCxmLmNvbG9yc05lZWRVcGRhdGU9ITApO2lmKHZvaWQgMD09PWEuX193ZWJnbEFjdGl2ZSl7aWYoYSBpbnN0YW5jZW9mIFRIUkVFLk1lc2gpaWYoZj1hLmdlb21ldHJ5LGYgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSl0KGQuX193ZWJnbE9iamVjdHMsZixhKTtlbHNle2lmKGYgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSlmb3IoZSBpbiBmLmdlb21ldHJ5R3JvdXBzKWc9Zi5nZW9tZXRyeUdyb3Vwc1tlXSx0KGQuX193ZWJnbE9iamVjdHMsZyxhKX1lbHNlIGEgaW5zdGFuY2VvZiBUSFJFRS5MaW5lfHxhIGluc3RhbmNlb2ZcblRIUkVFLlBhcnRpY2xlU3lzdGVtPyhmPWEuZ2VvbWV0cnksdChkLl9fd2ViZ2xPYmplY3RzLGYsYSkpOmEgaW5zdGFuY2VvZiBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3R8fGEuaW1tZWRpYXRlUmVuZGVyQ2FsbGJhY2s/ZC5fX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZS5wdXNoKHtpZDpudWxsLG9iamVjdDphLG9wYXF1ZTpudWxsLHRyYW5zcGFyZW50Om51bGwsejowfSk6YSBpbnN0YW5jZW9mIFRIUkVFLlNwcml0ZT9kLl9fd2ViZ2xTcHJpdGVzLnB1c2goYSk6YSBpbnN0YW5jZW9mIFRIUkVFLkxlbnNGbGFyZSYmZC5fX3dlYmdsRmxhcmVzLnB1c2goYSk7YS5fX3dlYmdsQWN0aXZlPSEwfX1mdW5jdGlvbiB0KGEsYixjKXthLnB1c2goe2lkOm51bGwsYnVmZmVyOmIsb2JqZWN0OmMsb3BhcXVlOm51bGwsdHJhbnNwYXJlbnQ6bnVsbCx6OjB9KX1mdW5jdGlvbiBuKGEpe2Zvcih2YXIgYiBpbiBhLmF0dHJpYnV0ZXMpaWYoYS5hdHRyaWJ1dGVzW2JdLm5lZWRzVXBkYXRlKXJldHVybiEwO1xucmV0dXJuITF9ZnVuY3Rpb24gcihhKXtmb3IodmFyIGIgaW4gYS5hdHRyaWJ1dGVzKWEuYXR0cmlidXRlc1tiXS5uZWVkc1VwZGF0ZT0hMX1mdW5jdGlvbiBxKGEsYil7YSBpbnN0YW5jZW9mIFRIUkVFLk1lc2h8fGEgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZVN5c3RlbXx8YSBpbnN0YW5jZW9mIFRIUkVFLkxpbmU/dShiLl9fd2ViZ2xPYmplY3RzLGEpOmEgaW5zdGFuY2VvZiBUSFJFRS5TcHJpdGU/dyhiLl9fd2ViZ2xTcHJpdGVzLGEpOmEgaW5zdGFuY2VvZiBUSFJFRS5MZW5zRmxhcmU/dyhiLl9fd2ViZ2xGbGFyZXMsYSk6KGEgaW5zdGFuY2VvZiBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3R8fGEuaW1tZWRpYXRlUmVuZGVyQ2FsbGJhY2spJiZ1KGIuX193ZWJnbE9iamVjdHNJbW1lZGlhdGUsYSk7ZGVsZXRlIGEuX193ZWJnbEFjdGl2ZX1mdW5jdGlvbiB1KGEsYil7Zm9yKHZhciBjPWEubGVuZ3RoLTE7MDw9YztjLS0pYVtjXS5vYmplY3Q9PT1iJiZhLnNwbGljZShjLDEpfVxuZnVuY3Rpb24gdyhhLGIpe2Zvcih2YXIgYz1hLmxlbmd0aC0xOzA8PWM7Yy0tKWFbY109PT1iJiZhLnNwbGljZShjLDEpfWZ1bmN0aW9uIHooYSxiLGMsZCxlKXtQPTA7ZC5uZWVkc1VwZGF0ZSYmKGQucHJvZ3JhbSYmR2IoZCksSy5pbml0TWF0ZXJpYWwoZCxiLGMsZSksZC5uZWVkc1VwZGF0ZT0hMSk7ZC5tb3JwaFRhcmdldHMmJiFlLl9fd2ViZ2xNb3JwaFRhcmdldEluZmx1ZW5jZXMmJihlLl9fd2ViZ2xNb3JwaFRhcmdldEluZmx1ZW5jZXM9bmV3IEZsb2F0MzJBcnJheShLLm1heE1vcnBoVGFyZ2V0cykpO3ZhciBmPSExLGc9ZC5wcm9ncmFtLGg9Zy51bmlmb3JtcyxpPWQudW5pZm9ybXM7ZyE9PUJhJiYoai51c2VQcm9ncmFtKGcpLEJhPWcsZj0hMCk7ZC5pZCE9PUFhJiYoQWE9ZC5pZCxmPSEwKTtpZihmfHxhIT09ZWEpai51bmlmb3JtTWF0cml4NGZ2KGgucHJvamVjdGlvbk1hdHJpeCwhMSxhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMpLGEhPT1lYSYmKGVhPWEpO2lmKGQuc2tpbm5pbmcpaWYoeWImJlxuZS51c2VWZXJ0ZXhUZXh0dXJlKXtpZihudWxsIT09aC5ib25lVGV4dHVyZSl7dmFyIGs9QigpO2oudW5pZm9ybTFpKGguYm9uZVRleHR1cmUsayk7Sy5zZXRUZXh0dXJlKGUuYm9uZVRleHR1cmUsayl9bnVsbCE9PWguYm9uZVRleHR1cmVXaWR0aCYmai51bmlmb3JtMWkoaC5ib25lVGV4dHVyZVdpZHRoLGUuYm9uZVRleHR1cmVXaWR0aCk7bnVsbCE9PWguYm9uZVRleHR1cmVIZWlnaHQmJmoudW5pZm9ybTFpKGguYm9uZVRleHR1cmVIZWlnaHQsZS5ib25lVGV4dHVyZUhlaWdodCl9ZWxzZSBudWxsIT09aC5ib25lR2xvYmFsTWF0cmljZXMmJmoudW5pZm9ybU1hdHJpeDRmdihoLmJvbmVHbG9iYWxNYXRyaWNlcywhMSxlLmJvbmVNYXRyaWNlcyk7aWYoZil7YyYmZC5mb2cmJihpLmZvZ0NvbG9yLnZhbHVlPWMuY29sb3IsYyBpbnN0YW5jZW9mIFRIUkVFLkZvZz8oaS5mb2dOZWFyLnZhbHVlPWMubmVhcixpLmZvZ0Zhci52YWx1ZT1jLmZhcik6YyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDImJlxuKGkuZm9nRGVuc2l0eS52YWx1ZT1jLmRlbnNpdHkpKTtpZihkIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWx8fGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsfHxkLmxpZ2h0cyl7aWYodWEpe2Zvcih2YXIgbSxsPWs9MCxwPTAsbixyLHMscT1QYSx0PXEuZGlyZWN0aW9uYWwuY29sb3JzLHU9cS5kaXJlY3Rpb25hbC5wb3NpdGlvbnMsdz1xLnBvaW50LmNvbG9ycyx6PXEucG9pbnQucG9zaXRpb25zLHk9cS5wb2ludC5kaXN0YW5jZXMsQT1xLnNwb3QuY29sb3JzLEM9cS5zcG90LnBvc2l0aW9ucyxGPXEuc3BvdC5kaXN0YW5jZXMsSj1xLnNwb3QuZGlyZWN0aW9ucyxOPXEuc3BvdC5hbmdsZXNDb3MsTz1xLnNwb3QuZXhwb25lbnRzLEk9cS5oZW1pLnNreUNvbG9ycyxWPXEuaGVtaS5ncm91bmRDb2xvcnMsUj1xLmhlbWkucG9zaXRpb25zLE09MCxVPTAsZGE9MCxaPTAsRmE9MCxkYz0wLFg9MCxXPTAsUT1tPTAsYz1zPVE9MCxmPWIubGVuZ3RoO2M8XG5mO2MrKyltPWJbY10sbS5vbmx5U2hhZG93fHwobj1tLmNvbG9yLHI9bS5pbnRlbnNpdHkscz1tLmRpc3RhbmNlLG0gaW5zdGFuY2VvZiBUSFJFRS5BbWJpZW50TGlnaHQ/bS52aXNpYmxlJiYoSy5nYW1tYUlucHV0PyhrKz1uLnIqbi5yLGwrPW4uZypuLmcscCs9bi5iKm4uYik6KGsrPW4ucixsKz1uLmcscCs9bi5iKSk6bSBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQ/KEZhKz0xLG0udmlzaWJsZSYmKGdhLmdldFBvc2l0aW9uRnJvbU1hdHJpeChtLm1hdHJpeFdvcmxkKSxzYS5nZXRQb3NpdGlvbkZyb21NYXRyaXgobS50YXJnZXQubWF0cml4V29ybGQpLGdhLnN1YihzYSksZ2Eubm9ybWFsaXplKCksMD09PWdhLngmJjA9PT1nYS55JiYwPT09Z2Euenx8KG09MypNLHVbbV09Z2EueCx1W20rMV09Z2EueSx1W20rMl09Z2EueixLLmdhbW1hSW5wdXQ/RCh0LG0sbixyKnIpOngodCxtLG4sciksTSs9MSkpKTptIGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodD8oZGMrPTEsXG5tLnZpc2libGUmJihRPTMqVSxLLmdhbW1hSW5wdXQ/RCh3LFEsbixyKnIpOngodyxRLG4sciksc2EuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KG0ubWF0cml4V29ybGQpLHpbUV09c2EueCx6W1ErMV09c2EueSx6W1ErMl09c2Eueix5W1VdPXMsVSs9MSkpOm0gaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQ/KFgrPTEsbS52aXNpYmxlJiYoUT0zKmRhLEsuZ2FtbWFJbnB1dD9EKEEsUSxuLHIqcik6eChBLFEsbixyKSxzYS5nZXRQb3NpdGlvbkZyb21NYXRyaXgobS5tYXRyaXhXb3JsZCksQ1tRXT1zYS54LENbUSsxXT1zYS55LENbUSsyXT1zYS56LEZbZGFdPXMsZ2EuY29weShzYSksc2EuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KG0udGFyZ2V0Lm1hdHJpeFdvcmxkKSxnYS5zdWIoc2EpLGdhLm5vcm1hbGl6ZSgpLEpbUV09Z2EueCxKW1ErMV09Z2EueSxKW1ErMl09Z2EueixOW2RhXT1NYXRoLmNvcyhtLmFuZ2xlKSxPW2RhXT1tLmV4cG9uZW50LGRhKz0xKSk6bSBpbnN0YW5jZW9mIFRIUkVFLkhlbWlzcGhlcmVMaWdodCYmXG4oVys9MSxtLnZpc2libGUmJihnYS5nZXRQb3NpdGlvbkZyb21NYXRyaXgobS5tYXRyaXhXb3JsZCksZ2Eubm9ybWFsaXplKCksMD09PWdhLngmJjA9PT1nYS55JiYwPT09Z2Euenx8KHM9MypaLFJbc109Z2EueCxSW3MrMV09Z2EueSxSW3MrMl09Z2EueixuPW0uY29sb3IsbT1tLmdyb3VuZENvbG9yLEsuZ2FtbWFJbnB1dD8ocio9cixEKEkscyxuLHIpLEQoVixzLG0scikpOih4KEkscyxuLHIpLHgoVixzLG0scikpLForPTEpKSkpO2M9MypNO2ZvcihmPU1hdGgubWF4KHQubGVuZ3RoLDMqRmEpO2M8ZjtjKyspdFtjXT0wO2M9MypVO2ZvcihmPU1hdGgubWF4KHcubGVuZ3RoLDMqZGMpO2M8ZjtjKyspd1tjXT0wO2M9MypkYTtmb3IoZj1NYXRoLm1heChBLmxlbmd0aCwzKlgpO2M8ZjtjKyspQVtjXT0wO2M9MypaO2ZvcihmPU1hdGgubWF4KEkubGVuZ3RoLDMqVyk7YzxmO2MrKylJW2NdPTA7Yz0zKlo7Zm9yKGY9TWF0aC5tYXgoVi5sZW5ndGgsMypXKTtjPGY7YysrKVZbY109MDtxLmRpcmVjdGlvbmFsLmxlbmd0aD1cbk07cS5wb2ludC5sZW5ndGg9VTtxLnNwb3QubGVuZ3RoPWRhO3EuaGVtaS5sZW5ndGg9WjtxLmFtYmllbnRbMF09aztxLmFtYmllbnRbMV09bDtxLmFtYmllbnRbMl09cDt1YT0hMX1jPVBhO2kuYW1iaWVudExpZ2h0Q29sb3IudmFsdWU9Yy5hbWJpZW50O2kuZGlyZWN0aW9uYWxMaWdodENvbG9yLnZhbHVlPWMuZGlyZWN0aW9uYWwuY29sb3JzO2kuZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbi52YWx1ZT1jLmRpcmVjdGlvbmFsLnBvc2l0aW9ucztpLnBvaW50TGlnaHRDb2xvci52YWx1ZT1jLnBvaW50LmNvbG9ycztpLnBvaW50TGlnaHRQb3NpdGlvbi52YWx1ZT1jLnBvaW50LnBvc2l0aW9ucztpLnBvaW50TGlnaHREaXN0YW5jZS52YWx1ZT1jLnBvaW50LmRpc3RhbmNlcztpLnNwb3RMaWdodENvbG9yLnZhbHVlPWMuc3BvdC5jb2xvcnM7aS5zcG90TGlnaHRQb3NpdGlvbi52YWx1ZT1jLnNwb3QucG9zaXRpb25zO2kuc3BvdExpZ2h0RGlzdGFuY2UudmFsdWU9Yy5zcG90LmRpc3RhbmNlcztcbmkuc3BvdExpZ2h0RGlyZWN0aW9uLnZhbHVlPWMuc3BvdC5kaXJlY3Rpb25zO2kuc3BvdExpZ2h0QW5nbGVDb3MudmFsdWU9Yy5zcG90LmFuZ2xlc0NvcztpLnNwb3RMaWdodEV4cG9uZW50LnZhbHVlPWMuc3BvdC5leHBvbmVudHM7aS5oZW1pc3BoZXJlTGlnaHRTa3lDb2xvci52YWx1ZT1jLmhlbWkuc2t5Q29sb3JzO2kuaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3IudmFsdWU9Yy5oZW1pLmdyb3VuZENvbG9ycztpLmhlbWlzcGhlcmVMaWdodERpcmVjdGlvbi52YWx1ZT1jLmhlbWkucG9zaXRpb25zfWlmKGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbHx8ZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWx8fGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCl7aS5vcGFjaXR5LnZhbHVlPWQub3BhY2l0eTtLLmdhbW1hSW5wdXQ/aS5kaWZmdXNlLnZhbHVlLmNvcHlHYW1tYVRvTGluZWFyKGQuY29sb3IpOmkuZGlmZnVzZS52YWx1ZT1cbmQuY29sb3I7aS5tYXAudmFsdWU9ZC5tYXA7aS5saWdodE1hcC52YWx1ZT1kLmxpZ2h0TWFwO2kuc3BlY3VsYXJNYXAudmFsdWU9ZC5zcGVjdWxhck1hcDtkLmJ1bXBNYXAmJihpLmJ1bXBNYXAudmFsdWU9ZC5idW1wTWFwLGkuYnVtcFNjYWxlLnZhbHVlPWQuYnVtcFNjYWxlKTtkLm5vcm1hbE1hcCYmKGkubm9ybWFsTWFwLnZhbHVlPWQubm9ybWFsTWFwLGkubm9ybWFsU2NhbGUudmFsdWUuY29weShkLm5vcm1hbFNjYWxlKSk7dmFyICQ7ZC5tYXA/JD1kLm1hcDpkLnNwZWN1bGFyTWFwPyQ9ZC5zcGVjdWxhck1hcDpkLm5vcm1hbE1hcD8kPWQubm9ybWFsTWFwOmQuYnVtcE1hcCYmKCQ9ZC5idW1wTWFwKTt2b2lkIDAhPT0kJiYoYz0kLm9mZnNldCwkPSQucmVwZWF0LGkub2Zmc2V0UmVwZWF0LnZhbHVlLnNldChjLngsYy55LCQueCwkLnkpKTtpLmVudk1hcC52YWx1ZT1kLmVudk1hcDtpLmZsaXBFbnZNYXAudmFsdWU9ZC5lbnZNYXAgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmU/XG4xOi0xO2kucmVmbGVjdGl2aXR5LnZhbHVlPWQucmVmbGVjdGl2aXR5O2kucmVmcmFjdGlvblJhdGlvLnZhbHVlPWQucmVmcmFjdGlvblJhdGlvO2kuY29tYmluZS52YWx1ZT1kLmNvbWJpbmU7aS51c2VSZWZyYWN0LnZhbHVlPWQuZW52TWFwJiZkLmVudk1hcC5tYXBwaW5nIGluc3RhbmNlb2YgVEhSRUUuQ3ViZVJlZnJhY3Rpb25NYXBwaW5nfWQgaW5zdGFuY2VvZiBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbD8oaS5kaWZmdXNlLnZhbHVlPWQuY29sb3IsaS5vcGFjaXR5LnZhbHVlPWQub3BhY2l0eSk6ZCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbD8oaS5kaWZmdXNlLnZhbHVlPWQuY29sb3IsaS5vcGFjaXR5LnZhbHVlPWQub3BhY2l0eSxpLmRhc2hTaXplLnZhbHVlPWQuZGFzaFNpemUsaS50b3RhbFNpemUudmFsdWU9ZC5kYXNoU2l6ZStkLmdhcFNpemUsaS5zY2FsZS52YWx1ZT1kLnNjYWxlKTpkIGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbD9cbihpLnBzQ29sb3IudmFsdWU9ZC5jb2xvcixpLm9wYWNpdHkudmFsdWU9ZC5vcGFjaXR5LGkuc2l6ZS52YWx1ZT1kLnNpemUsaS5zY2FsZS52YWx1ZT1HLmhlaWdodC8yLGkubWFwLnZhbHVlPWQubWFwKTpkIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWw/KGkuc2hpbmluZXNzLnZhbHVlPWQuc2hpbmluZXNzLEsuZ2FtbWFJbnB1dD8oaS5hbWJpZW50LnZhbHVlLmNvcHlHYW1tYVRvTGluZWFyKGQuYW1iaWVudCksaS5lbWlzc2l2ZS52YWx1ZS5jb3B5R2FtbWFUb0xpbmVhcihkLmVtaXNzaXZlKSxpLnNwZWN1bGFyLnZhbHVlLmNvcHlHYW1tYVRvTGluZWFyKGQuc3BlY3VsYXIpKTooaS5hbWJpZW50LnZhbHVlPWQuYW1iaWVudCxpLmVtaXNzaXZlLnZhbHVlPWQuZW1pc3NpdmUsaS5zcGVjdWxhci52YWx1ZT1kLnNwZWN1bGFyKSxkLndyYXBBcm91bmQmJmkud3JhcFJHQi52YWx1ZS5jb3B5KGQud3JhcFJHQikpOmQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsP1xuKEsuZ2FtbWFJbnB1dD8oaS5hbWJpZW50LnZhbHVlLmNvcHlHYW1tYVRvTGluZWFyKGQuYW1iaWVudCksaS5lbWlzc2l2ZS52YWx1ZS5jb3B5R2FtbWFUb0xpbmVhcihkLmVtaXNzaXZlKSk6KGkuYW1iaWVudC52YWx1ZT1kLmFtYmllbnQsaS5lbWlzc2l2ZS52YWx1ZT1kLmVtaXNzaXZlKSxkLndyYXBBcm91bmQmJmkud3JhcFJHQi52YWx1ZS5jb3B5KGQud3JhcFJHQikpOmQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbD8oaS5tTmVhci52YWx1ZT1hLm5lYXIsaS5tRmFyLnZhbHVlPWEuZmFyLGkub3BhY2l0eS52YWx1ZT1kLm9wYWNpdHkpOmQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwmJihpLm9wYWNpdHkudmFsdWU9ZC5vcGFjaXR5KTtpZihlLnJlY2VpdmVTaGFkb3cmJiFkLl9zaGFkb3dQYXNzJiZpLnNoYWRvd01hdHJpeCl7Yz0kPTA7Zm9yKGY9Yi5sZW5ndGg7YzxmO2MrKylpZihrPWJbY10say5jYXN0U2hhZG93JiYoayBpbnN0YW5jZW9mXG5USFJFRS5TcG90TGlnaHR8fGsgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0JiYhay5zaGFkb3dDYXNjYWRlKSlpLnNoYWRvd01hcC52YWx1ZVskXT1rLnNoYWRvd01hcCxpLnNoYWRvd01hcFNpemUudmFsdWVbJF09ay5zaGFkb3dNYXBTaXplLGkuc2hhZG93TWF0cml4LnZhbHVlWyRdPWsuc2hhZG93TWF0cml4LGkuc2hhZG93RGFya25lc3MudmFsdWVbJF09ay5zaGFkb3dEYXJrbmVzcyxpLnNoYWRvd0JpYXMudmFsdWVbJF09ay5zaGFkb3dCaWFzLCQrK31iPWQudW5pZm9ybXNMaXN0O2k9MDtmb3IoJD1iLmxlbmd0aDtpPCQ7aSsrKWlmKGY9Zy51bmlmb3Jtc1tiW2ldWzFdXSlpZihjPWJbaV1bMF0sbD1jLnR5cGUsaz1jLnZhbHVlLFwiaVwiPT09bClqLnVuaWZvcm0xaShmLGspO2Vsc2UgaWYoXCJmXCI9PT1sKWoudW5pZm9ybTFmKGYsayk7ZWxzZSBpZihcInYyXCI9PT1sKWoudW5pZm9ybTJmKGYsay54LGsueSk7ZWxzZSBpZihcInYzXCI9PT1sKWoudW5pZm9ybTNmKGYsay54LFxuay55LGsueik7ZWxzZSBpZihcInY0XCI9PT1sKWoudW5pZm9ybTRmKGYsay54LGsueSxrLnosay53KTtlbHNlIGlmKFwiY1wiPT09bClqLnVuaWZvcm0zZihmLGsucixrLmcsay5iKTtlbHNlIGlmKFwiaXYxXCI9PT1sKWoudW5pZm9ybTFpdihmLGspO2Vsc2UgaWYoXCJpdlwiPT09bClqLnVuaWZvcm0zaXYoZixrKTtlbHNlIGlmKFwiZnYxXCI9PT1sKWoudW5pZm9ybTFmdihmLGspO2Vsc2UgaWYoXCJmdlwiPT09bClqLnVuaWZvcm0zZnYoZixrKTtlbHNlIGlmKFwidjJ2XCI9PT1sKXt2b2lkIDA9PT1jLl9hcnJheSYmKGMuX2FycmF5PW5ldyBGbG9hdDMyQXJyYXkoMiprLmxlbmd0aCkpO2w9MDtmb3IocD1rLmxlbmd0aDtsPHA7bCsrKXE9MipsLGMuX2FycmF5W3FdPWtbbF0ueCxjLl9hcnJheVtxKzFdPWtbbF0ueTtqLnVuaWZvcm0yZnYoZixjLl9hcnJheSl9ZWxzZSBpZihcInYzdlwiPT09bCl7dm9pZCAwPT09Yy5fYXJyYXkmJihjLl9hcnJheT1uZXcgRmxvYXQzMkFycmF5KDMqay5sZW5ndGgpKTtsPTA7Zm9yKHA9XG5rLmxlbmd0aDtsPHA7bCsrKXE9MypsLGMuX2FycmF5W3FdPWtbbF0ueCxjLl9hcnJheVtxKzFdPWtbbF0ueSxjLl9hcnJheVtxKzJdPWtbbF0uejtqLnVuaWZvcm0zZnYoZixjLl9hcnJheSl9ZWxzZSBpZihcInY0dlwiPT09bCl7dm9pZCAwPT09Yy5fYXJyYXkmJihjLl9hcnJheT1uZXcgRmxvYXQzMkFycmF5KDQqay5sZW5ndGgpKTtsPTA7Zm9yKHA9ay5sZW5ndGg7bDxwO2wrKylxPTQqbCxjLl9hcnJheVtxXT1rW2xdLngsYy5fYXJyYXlbcSsxXT1rW2xdLnksYy5fYXJyYXlbcSsyXT1rW2xdLnosYy5fYXJyYXlbcSszXT1rW2xdLnc7ai51bmlmb3JtNGZ2KGYsYy5fYXJyYXkpfWVsc2UgaWYoXCJtNFwiPT09bCl2b2lkIDA9PT1jLl9hcnJheSYmKGMuX2FycmF5PW5ldyBGbG9hdDMyQXJyYXkoMTYpKSxrLmZsYXR0ZW5Ub0FycmF5KGMuX2FycmF5KSxqLnVuaWZvcm1NYXRyaXg0ZnYoZiwhMSxjLl9hcnJheSk7ZWxzZSBpZihcIm00dlwiPT09bCl7dm9pZCAwPT09Yy5fYXJyYXkmJihjLl9hcnJheT1cbm5ldyBGbG9hdDMyQXJyYXkoMTYqay5sZW5ndGgpKTtsPTA7Zm9yKHA9ay5sZW5ndGg7bDxwO2wrKylrW2xdLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KGMuX2FycmF5LDE2KmwpO2oudW5pZm9ybU1hdHJpeDRmdihmLCExLGMuX2FycmF5KX1lbHNlIGlmKFwidFwiPT09bCl7aWYocT1rLGs9QigpLGoudW5pZm9ybTFpKGYsaykscSlpZihxLmltYWdlIGluc3RhbmNlb2YgQXJyYXkmJjY9PT1xLmltYWdlLmxlbmd0aCl7aWYoYz1xLGY9ayw2PT09Yy5pbWFnZS5sZW5ndGgpaWYoYy5uZWVkc1VwZGF0ZSl7Yy5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmV8fChjLmFkZEV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsRGIpLGMuaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlPWouY3JlYXRlVGV4dHVyZSgpLEsuaW5mby5tZW1vcnkudGV4dHVyZXMrKyk7ai5hY3RpdmVUZXh0dXJlKGouVEVYVFVSRTArZik7ai5iaW5kVGV4dHVyZShqLlRFWFRVUkVfQ1VCRV9NQVAsYy5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmUpO1xuai5waXhlbFN0b3JlaShqLlVOUEFDS19GTElQX1lfV0VCR0wsYy5mbGlwWSk7Zj1jIGluc3RhbmNlb2YgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmU7az1bXTtmb3IobD0wOzY+bDtsKyspSy5hdXRvU2NhbGVDdWJlbWFwcyYmIWY/KHA9ayxxPWwsdD1jLmltYWdlW2xdLHc9YWMsdC53aWR0aDw9dyYmdC5oZWlnaHQ8PXd8fCh6PU1hdGgubWF4KHQud2lkdGgsdC5oZWlnaHQpLHU9TWF0aC5mbG9vcih0LndpZHRoKncveiksdz1NYXRoLmZsb29yKHQuaGVpZ2h0Kncveiksej1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLHoud2lkdGg9dSx6LmhlaWdodD13LHouZ2V0Q29udGV4dChcIjJkXCIpLmRyYXdJbWFnZSh0LDAsMCx0LndpZHRoLHQuaGVpZ2h0LDAsMCx1LHcpLHQ9eikscFtxXT10KTprW2xdPWMuaW1hZ2VbbF07bD1rWzBdO3A9MD09PShsLndpZHRoJmwud2lkdGgtMSkmJjA9PT0obC5oZWlnaHQmbC5oZWlnaHQtMSk7cT12KGMuZm9ybWF0KTt0PXYoYy50eXBlKTtFKGouVEVYVFVSRV9DVUJFX01BUCxcbmMscCk7Zm9yKGw9MDs2Pmw7bCsrKWlmKGYpe3c9a1tsXS5taXBtYXBzO3o9MDtmb3IoeT13Lmxlbmd0aDt6PHk7eisrKXU9d1t6XSxjLmZvcm1hdCE9PVRIUkVFLlJHQkFGb3JtYXQ/ai5jb21wcmVzc2VkVGV4SW1hZ2UyRChqLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCtsLHoscSx1LndpZHRoLHUuaGVpZ2h0LDAsdS5kYXRhKTpqLnRleEltYWdlMkQoai5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1grbCx6LHEsdS53aWR0aCx1LmhlaWdodCwwLHEsdCx1LmRhdGEpfWVsc2Ugai50ZXhJbWFnZTJEKGouVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YK2wsMCxxLHEsdCxrW2xdKTtjLmdlbmVyYXRlTWlwbWFwcyYmcCYmai5nZW5lcmF0ZU1pcG1hcChqLlRFWFRVUkVfQ1VCRV9NQVApO2MubmVlZHNVcGRhdGU9ITE7aWYoYy5vblVwZGF0ZSljLm9uVXBkYXRlKCl9ZWxzZSBqLmFjdGl2ZVRleHR1cmUoai5URVhUVVJFMCtmKSxqLmJpbmRUZXh0dXJlKGouVEVYVFVSRV9DVUJFX01BUCxcbmMuaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlKX1lbHNlIHEgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmU/KGM9cSxqLmFjdGl2ZVRleHR1cmUoai5URVhUVVJFMCtrKSxqLmJpbmRUZXh0dXJlKGouVEVYVFVSRV9DVUJFX01BUCxjLl9fd2ViZ2xUZXh0dXJlKSk6Sy5zZXRUZXh0dXJlKHEsayl9ZWxzZSBpZihcInR2XCI9PT1sKXt2b2lkIDA9PT1jLl9hcnJheSYmKGMuX2FycmF5PVtdKTtsPTA7Zm9yKHA9Yy52YWx1ZS5sZW5ndGg7bDxwO2wrKyljLl9hcnJheVtsXT1CKCk7ai51bmlmb3JtMWl2KGYsYy5fYXJyYXkpO2w9MDtmb3IocD1jLnZhbHVlLmxlbmd0aDtsPHA7bCsrKXE9Yy52YWx1ZVtsXSxrPWMuX2FycmF5W2xdLHEmJksuc2V0VGV4dHVyZShxLGspfWVsc2UgY29uc29sZS53YXJuKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogVW5rbm93biB1bmlmb3JtIHR5cGU6IFwiK2wpO2lmKChkIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWx8fGQgaW5zdGFuY2VvZlxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWx8fGQuZW52TWFwKSYmbnVsbCE9PWguY2FtZXJhUG9zaXRpb24pc2EuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KGEubWF0cml4V29ybGQpLGoudW5pZm9ybTNmKGguY2FtZXJhUG9zaXRpb24sc2EueCxzYS55LHNhLnopOyhkIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWx8fGQgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsfHxkIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWx8fGQuc2tpbm5pbmcpJiZudWxsIT09aC52aWV3TWF0cml4JiZqLnVuaWZvcm1NYXRyaXg0ZnYoaC52aWV3TWF0cml4LCExLGEubWF0cml4V29ybGRJbnZlcnNlLmVsZW1lbnRzKX1qLnVuaWZvcm1NYXRyaXg0ZnYoaC5tb2RlbFZpZXdNYXRyaXgsITEsZS5fbW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzKTtoLm5vcm1hbE1hdHJpeCYmai51bmlmb3JtTWF0cml4M2Z2KGgubm9ybWFsTWF0cml4LCExLGUuX25vcm1hbE1hdHJpeC5lbGVtZW50cyk7XG5udWxsIT09aC5tb2RlbE1hdHJpeCYmai51bmlmb3JtTWF0cml4NGZ2KGgubW9kZWxNYXRyaXgsITEsZS5tYXRyaXhXb3JsZC5lbGVtZW50cyk7cmV0dXJuIGd9ZnVuY3Rpb24gQigpe3ZhciBhPVA7YT49TWImJmNvbnNvbGUud2FybihcIldlYkdMUmVuZGVyZXI6IHRyeWluZyB0byB1c2UgXCIrYStcIiB0ZXh0dXJlIHVuaXRzIHdoaWxlIHRoaXMgR1BVIHN1cHBvcnRzIG9ubHkgXCIrTWIpO1ArPTE7cmV0dXJuIGF9ZnVuY3Rpb24gRChhLGIsYyxkKXthW2JdPWMucipjLnIqZDthW2IrMV09Yy5nKmMuZypkO2FbYisyXT1jLmIqYy5iKmR9ZnVuY3Rpb24geChhLGIsYyxkKXthW2JdPWMucipkO2FbYisxXT1jLmcqZDthW2IrMl09Yy5iKmR9ZnVuY3Rpb24gRihhKXthIT09eGEmJihqLmxpbmVXaWR0aChhKSx4YT1hKX1mdW5jdGlvbiBBKGEsYixjKXtEYSE9PWEmJihhP2ouZW5hYmxlKGouUE9MWUdPTl9PRkZTRVRfRklMTCk6ai5kaXNhYmxlKGouUE9MWUdPTl9PRkZTRVRfRklMTCksRGE9YSk7XG5pZihhJiYoVWEhPT1ifHxRYSE9PWMpKWoucG9seWdvbk9mZnNldChiLGMpLFVhPWIsUWE9Y31mdW5jdGlvbiBPKGEpe2Zvcih2YXIgYT1hLnNwbGl0KFwiXFxuXCIpLGI9MCxjPWEubGVuZ3RoO2I8YztiKyspYVtiXT1iKzErXCI6IFwiK2FbYl07cmV0dXJuIGEuam9pbihcIlxcblwiKX1mdW5jdGlvbiBDKGEsYil7dmFyIGM7XCJmcmFnbWVudFwiPT09YT9jPWouY3JlYXRlU2hhZGVyKGouRlJBR01FTlRfU0hBREVSKTpcInZlcnRleFwiPT09YSYmKGM9ai5jcmVhdGVTaGFkZXIoai5WRVJURVhfU0hBREVSKSk7ai5zaGFkZXJTb3VyY2UoYyxiKTtqLmNvbXBpbGVTaGFkZXIoYyk7cmV0dXJuIWouZ2V0U2hhZGVyUGFyYW1ldGVyKGMsai5DT01QSUxFX1NUQVRVUyk/KGNvbnNvbGUuZXJyb3Ioai5nZXRTaGFkZXJJbmZvTG9nKGMpKSxjb25zb2xlLmVycm9yKE8oYikpLG51bGwpOmN9ZnVuY3Rpb24gRShhLGIsYyl7Yz8oai50ZXhQYXJhbWV0ZXJpKGEsai5URVhUVVJFX1dSQVBfUyx2KGIud3JhcFMpKSxqLnRleFBhcmFtZXRlcmkoYSxcbmouVEVYVFVSRV9XUkFQX1QsdihiLndyYXBUKSksai50ZXhQYXJhbWV0ZXJpKGEsai5URVhUVVJFX01BR19GSUxURVIsdihiLm1hZ0ZpbHRlcikpLGoudGV4UGFyYW1ldGVyaShhLGouVEVYVFVSRV9NSU5fRklMVEVSLHYoYi5taW5GaWx0ZXIpKSk6KGoudGV4UGFyYW1ldGVyaShhLGouVEVYVFVSRV9XUkFQX1Msai5DTEFNUF9UT19FREdFKSxqLnRleFBhcmFtZXRlcmkoYSxqLlRFWFRVUkVfV1JBUF9ULGouQ0xBTVBfVE9fRURHRSksai50ZXhQYXJhbWV0ZXJpKGEsai5URVhUVVJFX01BR19GSUxURVIseShiLm1hZ0ZpbHRlcikpLGoudGV4UGFyYW1ldGVyaShhLGouVEVYVFVSRV9NSU5fRklMVEVSLHkoYi5taW5GaWx0ZXIpKSk7aWYod2EmJmIudHlwZSE9PVRIUkVFLkZsb2F0VHlwZSYmKDE8Yi5hbmlzb3Ryb3B5fHxiLl9fb2xkQW5pc290cm9weSkpai50ZXhQYXJhbWV0ZXJmKGEsd2EuVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsTWF0aC5taW4oYi5hbmlzb3Ryb3B5LE5iKSksYi5fX29sZEFuaXNvdHJvcHk9XG5iLmFuaXNvdHJvcHl9ZnVuY3Rpb24gSShhLGIpe2ouYmluZFJlbmRlcmJ1ZmZlcihqLlJFTkRFUkJVRkZFUixhKTtiLmRlcHRoQnVmZmVyJiYhYi5zdGVuY2lsQnVmZmVyPyhqLnJlbmRlcmJ1ZmZlclN0b3JhZ2Uoai5SRU5ERVJCVUZGRVIsai5ERVBUSF9DT01QT05FTlQxNixiLndpZHRoLGIuaGVpZ2h0KSxqLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGouRlJBTUVCVUZGRVIsai5ERVBUSF9BVFRBQ0hNRU5ULGouUkVOREVSQlVGRkVSLGEpKTpiLmRlcHRoQnVmZmVyJiZiLnN0ZW5jaWxCdWZmZXI/KGoucmVuZGVyYnVmZmVyU3RvcmFnZShqLlJFTkRFUkJVRkZFUixqLkRFUFRIX1NURU5DSUwsYi53aWR0aCxiLmhlaWdodCksai5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihqLkZSQU1FQlVGRkVSLGouREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULGouUkVOREVSQlVGRkVSLGEpKTpqLnJlbmRlcmJ1ZmZlclN0b3JhZ2Uoai5SRU5ERVJCVUZGRVIsai5SR0JBNCxiLndpZHRoLGIuaGVpZ2h0KX1cbmZ1bmN0aW9uIHkoYSl7cmV0dXJuIGE9PT1USFJFRS5OZWFyZXN0RmlsdGVyfHxhPT09VEhSRUUuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXJ8fGE9PT1USFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyP2ouTkVBUkVTVDpqLkxJTkVBUn1mdW5jdGlvbiB2KGEpe2lmKGE9PT1USFJFRS5SZXBlYXRXcmFwcGluZylyZXR1cm4gai5SRVBFQVQ7aWYoYT09PVRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcpcmV0dXJuIGouQ0xBTVBfVE9fRURHRTtpZihhPT09VEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZylyZXR1cm4gai5NSVJST1JFRF9SRVBFQVQ7aWYoYT09PVRIUkVFLk5lYXJlc3RGaWx0ZXIpcmV0dXJuIGouTkVBUkVTVDtpZihhPT09VEhSRUUuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIpcmV0dXJuIGouTkVBUkVTVF9NSVBNQVBfTkVBUkVTVDtpZihhPT09VEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlcilyZXR1cm4gai5ORUFSRVNUX01JUE1BUF9MSU5FQVI7aWYoYT09PVxuVEhSRUUuTGluZWFyRmlsdGVyKXJldHVybiBqLkxJTkVBUjtpZihhPT09VEhSRUUuTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlcilyZXR1cm4gai5MSU5FQVJfTUlQTUFQX05FQVJFU1Q7aWYoYT09PVRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlcilyZXR1cm4gai5MSU5FQVJfTUlQTUFQX0xJTkVBUjtpZihhPT09VEhSRUUuVW5zaWduZWRCeXRlVHlwZSlyZXR1cm4gai5VTlNJR05FRF9CWVRFO2lmKGE9PT1USFJFRS5VbnNpZ25lZFNob3J0NDQ0NFR5cGUpcmV0dXJuIGouVU5TSUdORURfU0hPUlRfNF80XzRfNDtpZihhPT09VEhSRUUuVW5zaWduZWRTaG9ydDU1NTFUeXBlKXJldHVybiBqLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE7aWYoYT09PVRIUkVFLlVuc2lnbmVkU2hvcnQ1NjVUeXBlKXJldHVybiBqLlVOU0lHTkVEX1NIT1JUXzVfNl81O2lmKGE9PT1USFJFRS5CeXRlVHlwZSlyZXR1cm4gai5CWVRFO2lmKGE9PT1USFJFRS5TaG9ydFR5cGUpcmV0dXJuIGouU0hPUlQ7aWYoYT09PVxuVEhSRUUuVW5zaWduZWRTaG9ydFR5cGUpcmV0dXJuIGouVU5TSUdORURfU0hPUlQ7aWYoYT09PVRIUkVFLkludFR5cGUpcmV0dXJuIGouSU5UO2lmKGE9PT1USFJFRS5VbnNpZ25lZEludFR5cGUpcmV0dXJuIGouVU5TSUdORURfSU5UO2lmKGE9PT1USFJFRS5GbG9hdFR5cGUpcmV0dXJuIGouRkxPQVQ7aWYoYT09PVRIUkVFLkFscGhhRm9ybWF0KXJldHVybiBqLkFMUEhBO2lmKGE9PT1USFJFRS5SR0JGb3JtYXQpcmV0dXJuIGouUkdCO2lmKGE9PT1USFJFRS5SR0JBRm9ybWF0KXJldHVybiBqLlJHQkE7aWYoYT09PVRIUkVFLkx1bWluYW5jZUZvcm1hdClyZXR1cm4gai5MVU1JTkFOQ0U7aWYoYT09PVRIUkVFLkx1bWluYW5jZUFscGhhRm9ybWF0KXJldHVybiBqLkxVTUlOQU5DRV9BTFBIQTtpZihhPT09VEhSRUUuQWRkRXF1YXRpb24pcmV0dXJuIGouRlVOQ19BREQ7aWYoYT09PVRIUkVFLlN1YnRyYWN0RXF1YXRpb24pcmV0dXJuIGouRlVOQ19TVUJUUkFDVDtpZihhPT09VEhSRUUuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24pcmV0dXJuIGouRlVOQ19SRVZFUlNFX1NVQlRSQUNUO1xuaWYoYT09PVRIUkVFLlplcm9GYWN0b3IpcmV0dXJuIGouWkVSTztpZihhPT09VEhSRUUuT25lRmFjdG9yKXJldHVybiBqLk9ORTtpZihhPT09VEhSRUUuU3JjQ29sb3JGYWN0b3IpcmV0dXJuIGouU1JDX0NPTE9SO2lmKGE9PT1USFJFRS5PbmVNaW51c1NyY0NvbG9yRmFjdG9yKXJldHVybiBqLk9ORV9NSU5VU19TUkNfQ09MT1I7aWYoYT09PVRIUkVFLlNyY0FscGhhRmFjdG9yKXJldHVybiBqLlNSQ19BTFBIQTtpZihhPT09VEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvcilyZXR1cm4gai5PTkVfTUlOVVNfU1JDX0FMUEhBO2lmKGE9PT1USFJFRS5Ec3RBbHBoYUZhY3RvcilyZXR1cm4gai5EU1RfQUxQSEE7aWYoYT09PVRIUkVFLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IpcmV0dXJuIGouT05FX01JTlVTX0RTVF9BTFBIQTtpZihhPT09VEhSRUUuRHN0Q29sb3JGYWN0b3IpcmV0dXJuIGouRFNUX0NPTE9SO2lmKGE9PT1USFJFRS5PbmVNaW51c0RzdENvbG9yRmFjdG9yKXJldHVybiBqLk9ORV9NSU5VU19EU1RfQ09MT1I7XG5pZihhPT09VEhSRUUuU3JjQWxwaGFTYXR1cmF0ZUZhY3RvcilyZXR1cm4gai5TUkNfQUxQSEFfU0FUVVJBVEU7aWYodm9pZCAwIT09RWEpe2lmKGE9PT1USFJFRS5SR0JfUzNUQ19EWFQxX0Zvcm1hdClyZXR1cm4gRWEuQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVDtpZihhPT09VEhSRUUuUkdCQV9TM1RDX0RYVDFfRm9ybWF0KXJldHVybiBFYS5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVDtpZihhPT09VEhSRUUuUkdCQV9TM1RDX0RYVDNfRm9ybWF0KXJldHVybiBFYS5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVDtpZihhPT09VEhSRUUuUkdCQV9TM1RDX0RYVDVfRm9ybWF0KXJldHVybiBFYS5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVH1yZXR1cm4gMH1jb25zb2xlLmxvZyhcIlRIUkVFLldlYkdMUmVuZGVyZXJcIixUSFJFRS5SRVZJU0lPTik7dmFyIGE9YXx8e30sRz12b2lkIDAhPT1hLmNhbnZhcz9hLmNhbnZhczpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLFxuUj12b2lkIDAhPT1hLnByZWNpc2lvbj9hLnByZWNpc2lvbjpcImhpZ2hwXCIsSj12b2lkIDAhPT1hLmFscGhhP2EuYWxwaGE6ITAsYmE9dm9pZCAwIT09YS5wcmVtdWx0aXBsaWVkQWxwaGE/YS5wcmVtdWx0aXBsaWVkQWxwaGE6ITAsb2E9dm9pZCAwIT09YS5hbnRpYWxpYXM/YS5hbnRpYWxpYXM6ITEscGE9dm9pZCAwIT09YS5zdGVuY2lsP2Euc3RlbmNpbDohMCxOPXZvaWQgMCE9PWEucHJlc2VydmVEcmF3aW5nQnVmZmVyP2EucHJlc2VydmVEcmF3aW5nQnVmZmVyOiExLE09bmV3IFRIUkVFLkNvbG9yKDApLFE9MDt0aGlzLmRvbUVsZW1lbnQ9Rzt0aGlzLmNvbnRleHQ9bnVsbDt0aGlzLmRldmljZVBpeGVsUmF0aW89dm9pZCAwIT09YS5kZXZpY2VQaXhlbFJhdGlvP2EuZGV2aWNlUGl4ZWxSYXRpbzp2b2lkIDAhPT1zZWxmLmRldmljZVBpeGVsUmF0aW8/c2VsZi5kZXZpY2VQaXhlbFJhdGlvOjE7dGhpcy5hdXRvVXBkYXRlT2JqZWN0cz10aGlzLnNvcnRPYmplY3RzPXRoaXMuYXV0b0NsZWFyU3RlbmNpbD1cbnRoaXMuYXV0b0NsZWFyRGVwdGg9dGhpcy5hdXRvQ2xlYXJDb2xvcj10aGlzLmF1dG9DbGVhcj0hMDt0aGlzLnNoYWRvd01hcEVuYWJsZWQ9dGhpcy5waHlzaWNhbGx5QmFzZWRTaGFkaW5nPXRoaXMuZ2FtbWFPdXRwdXQ9dGhpcy5nYW1tYUlucHV0PSExO3RoaXMuc2hhZG93TWFwQXV0b1VwZGF0ZT0hMDt0aGlzLnNoYWRvd01hcFR5cGU9VEhSRUUuUENGU2hhZG93TWFwO3RoaXMuc2hhZG93TWFwQ3VsbEZhY2U9VEhSRUUuQ3VsbEZhY2VGcm9udDt0aGlzLnNoYWRvd01hcENhc2NhZGU9dGhpcy5zaGFkb3dNYXBEZWJ1Zz0hMTt0aGlzLm1heE1vcnBoVGFyZ2V0cz04O3RoaXMubWF4TW9ycGhOb3JtYWxzPTQ7dGhpcy5hdXRvU2NhbGVDdWJlbWFwcz0hMDt0aGlzLnJlbmRlclBsdWdpbnNQcmU9W107dGhpcy5yZW5kZXJQbHVnaW5zUG9zdD1bXTt0aGlzLmluZm89e21lbW9yeTp7cHJvZ3JhbXM6MCxnZW9tZXRyaWVzOjAsdGV4dHVyZXM6MH0scmVuZGVyOntjYWxsczowLHZlcnRpY2VzOjAsXG5mYWNlczowLHBvaW50czowfX07dmFyIEs9dGhpcyxjYT1bXSxGYT0wLEJhPW51bGwsZGE9bnVsbCxBYT0tMSwkPW51bGwsZWE9bnVsbCxWPTAsUD0wLFo9LTEsVT0tMSxrYT0tMSx0YT0tMSxpYT0tMSxMYT0tMSxHYT0tMSxmYT0tMSxEYT1udWxsLFVhPW51bGwsUWE9bnVsbCx4YT1udWxsLGJiPTAsY2I9MCxNYT1HLndpZHRoLGZiPUcuaGVpZ2h0LHNiPTAscGI9MCxIYT17fSxsYT1uZXcgVEhSRUUuRnJ1c3R1bSxyYT1uZXcgVEhSRUUuTWF0cml4NCxnYj1uZXcgVEhSRUUuTWF0cml4NCxzYT1uZXcgVEhSRUUuVmVjdG9yMyxnYT1uZXcgVEhSRUUuVmVjdG9yMyx1YT0hMCxQYT17YW1iaWVudDpbMCwwLDBdLGRpcmVjdGlvbmFsOntsZW5ndGg6MCxjb2xvcnM6W10scG9zaXRpb25zOltdfSxwb2ludDp7bGVuZ3RoOjAsY29sb3JzOltdLHBvc2l0aW9uczpbXSxkaXN0YW5jZXM6W119LHNwb3Q6e2xlbmd0aDowLGNvbG9yczpbXSxwb3NpdGlvbnM6W10sZGlzdGFuY2VzOltdLGRpcmVjdGlvbnM6W10sXG5hbmdsZXNDb3M6W10sZXhwb25lbnRzOltdfSxoZW1pOntsZW5ndGg6MCxza3lDb2xvcnM6W10sZ3JvdW5kQ29sb3JzOltdLHBvc2l0aW9uczpbXX19LGosT2EsdmEsd2EsRWE7dHJ5e3ZhciBSYT17YWxwaGE6SixwcmVtdWx0aXBsaWVkQWxwaGE6YmEsYW50aWFsaWFzOm9hLHN0ZW5jaWw6cGEscHJlc2VydmVEcmF3aW5nQnVmZmVyOk59O2o9Ry5nZXRDb250ZXh0KFwid2ViZ2xcIixSYSl8fEcuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLFJhKTtpZihudWxsPT09ail0aHJvd1wiRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC5cIjt9Y2F0Y2goWmIpe2NvbnNvbGUuZXJyb3IoWmIpfU9hPWouZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRcIik7ai5nZXRFeHRlbnNpb24oXCJPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXJcIik7dmE9ai5nZXRFeHRlbnNpb24oXCJPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcIik7d2E9ai5nZXRFeHRlbnNpb24oXCJFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIil8fFxuai5nZXRFeHRlbnNpb24oXCJNT1pfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpfHxqLmdldEV4dGVuc2lvbihcIldFQktJVF9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIik7RWE9ai5nZXRFeHRlbnNpb24oXCJXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1wiKXx8ai5nZXRFeHRlbnNpb24oXCJNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcIil8fGouZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXCIpO09hfHxjb25zb2xlLmxvZyhcIlRIUkVFLldlYkdMUmVuZGVyZXI6IEZsb2F0IHRleHR1cmVzIG5vdCBzdXBwb3J0ZWQuXCIpO3ZhfHxjb25zb2xlLmxvZyhcIlRIUkVFLldlYkdMUmVuZGVyZXI6IFN0YW5kYXJkIGRlcml2YXRpdmVzIG5vdCBzdXBwb3J0ZWQuXCIpO3dhfHxjb25zb2xlLmxvZyhcIlRIUkVFLldlYkdMUmVuZGVyZXI6IEFuaXNvdHJvcGljIHRleHR1cmUgZmlsdGVyaW5nIG5vdCBzdXBwb3J0ZWQuXCIpO1xuRWF8fGNvbnNvbGUubG9nKFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogUzNUQyBjb21wcmVzc2VkIHRleHR1cmVzIG5vdCBzdXBwb3J0ZWQuXCIpO3ZvaWQgMD09PWouZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0JiYoai5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQ9ZnVuY3Rpb24oKXtyZXR1cm57cmFuZ2VNaW46MSxyYW5nZU1heDoxLHByZWNpc2lvbjoxfX0pO2ouY2xlYXJDb2xvcigwLDAsMCwxKTtqLmNsZWFyRGVwdGgoMSk7ai5jbGVhclN0ZW5jaWwoMCk7ai5lbmFibGUoai5ERVBUSF9URVNUKTtqLmRlcHRoRnVuYyhqLkxFUVVBTCk7ai5mcm9udEZhY2Uoai5DQ1cpO2ouY3VsbEZhY2Uoai5CQUNLKTtqLmVuYWJsZShqLkNVTExfRkFDRSk7ai5lbmFibGUoai5CTEVORCk7ai5ibGVuZEVxdWF0aW9uKGouRlVOQ19BREQpO2ouYmxlbmRGdW5jKGouU1JDX0FMUEhBLGouT05FX01JTlVTX1NSQ19BTFBIQSk7ai52aWV3cG9ydChiYixjYixNYSxmYik7ai5jbGVhckNvbG9yKE0ucixNLmcsTS5iLFxuUSk7dGhpcy5jb250ZXh0PWo7dmFyIE1iPWouZ2V0UGFyYW1ldGVyKGouTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpLCRiPWouZ2V0UGFyYW1ldGVyKGouTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtqLmdldFBhcmFtZXRlcihqLk1BWF9URVhUVVJFX1NJWkUpO3ZhciBhYz1qLmdldFBhcmFtZXRlcihqLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUpLE5iPXdhP2ouZ2V0UGFyYW1ldGVyKHdhLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCk6MCxCYj0wPCRiLHliPUJiJiZPYTtFYSYmai5nZXRQYXJhbWV0ZXIoai5DT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUyk7dmFyIGJjPWouZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGouVkVSVEVYX1NIQURFUixqLkhJR0hfRkxPQVQpLGNjPWouZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGouVkVSVEVYX1NIQURFUixqLk1FRElVTV9GTE9BVCk7ai5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoai5WRVJURVhfU0hBREVSLGouTE9XX0ZMT0FUKTtcbnZhciBxYz1qLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChqLkZSQUdNRU5UX1NIQURFUixqLkhJR0hfRkxPQVQpLHJjPWouZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGouRlJBR01FTlRfU0hBREVSLGouTUVESVVNX0ZMT0FUKTtqLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChqLkZSQUdNRU5UX1NIQURFUixqLkxPV19GTE9BVCk7ai5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoai5WRVJURVhfU0hBREVSLGouSElHSF9JTlQpO2ouZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGouVkVSVEVYX1NIQURFUixqLk1FRElVTV9JTlQpO2ouZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGouVkVSVEVYX1NIQURFUixqLkxPV19JTlQpO2ouZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGouRlJBR01FTlRfU0hBREVSLGouSElHSF9JTlQpO2ouZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGouRlJBR01FTlRfU0hBREVSLGouTUVESVVNX0lOVCk7ai5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoai5GUkFHTUVOVF9TSEFERVIsXG5qLkxPV19JTlQpO3ZhciBzYz0wPGJjLnByZWNpc2lvbiYmMDxxYy5wcmVjaXNpb24sT2I9MDxjYy5wcmVjaXNpb24mJjA8cmMucHJlY2lzaW9uO1wiaGlnaHBcIj09PVImJiFzYyYmKE9iPyhSPVwibWVkaXVtcFwiLGNvbnNvbGUud2FybihcIldlYkdMUmVuZGVyZXI6IGhpZ2hwIG5vdCBzdXBwb3J0ZWQsIHVzaW5nIG1lZGl1bXBcIikpOihSPVwibG93cFwiLGNvbnNvbGUud2FybihcIldlYkdMUmVuZGVyZXI6IGhpZ2hwIGFuZCBtZWRpdW1wIG5vdCBzdXBwb3J0ZWQsIHVzaW5nIGxvd3BcIikpKTtcIm1lZGl1bXBcIj09PVImJiFPYiYmKFI9XCJsb3dwXCIsY29uc29sZS53YXJuKFwiV2ViR0xSZW5kZXJlcjogbWVkaXVtcCBub3Qgc3VwcG9ydGVkLCB1c2luZyBsb3dwXCIpKTt0aGlzLmdldENvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gan07dGhpcy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzPWZ1bmN0aW9uKCl7cmV0dXJuIEJifTt0aGlzLnN1cHBvcnRzRmxvYXRUZXh0dXJlcz1mdW5jdGlvbigpe3JldHVybiBPYX07XG50aGlzLnN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlcz1mdW5jdGlvbigpe3JldHVybiB2YX07dGhpcy5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQz1mdW5jdGlvbigpe3JldHVybiBFYX07dGhpcy5nZXRNYXhBbmlzb3Ryb3B5PWZ1bmN0aW9uKCl7cmV0dXJuIE5ifTt0aGlzLmdldFByZWNpc2lvbj1mdW5jdGlvbigpe3JldHVybiBSfTt0aGlzLnNldFNpemU9ZnVuY3Rpb24oYSxiLGMpe0cud2lkdGg9YSp0aGlzLmRldmljZVBpeGVsUmF0aW87Ry5oZWlnaHQ9Yip0aGlzLmRldmljZVBpeGVsUmF0aW87MSE9PXRoaXMuZGV2aWNlUGl4ZWxSYXRpbyYmITEhPT1jJiYoRy5zdHlsZS53aWR0aD1hK1wicHhcIixHLnN0eWxlLmhlaWdodD1iK1wicHhcIik7dGhpcy5zZXRWaWV3cG9ydCgwLDAsRy53aWR0aCxHLmhlaWdodCl9O3RoaXMuc2V0Vmlld3BvcnQ9ZnVuY3Rpb24oYSxiLGMsZCl7YmI9dm9pZCAwIT09YT9hOjA7Y2I9dm9pZCAwIT09Yj9iOjA7TWE9dm9pZCAwIT09Yz9jOkcud2lkdGg7XG5mYj12b2lkIDAhPT1kP2Q6Ry5oZWlnaHQ7ai52aWV3cG9ydChiYixjYixNYSxmYil9O3RoaXMuc2V0U2Npc3Nvcj1mdW5jdGlvbihhLGIsYyxkKXtqLnNjaXNzb3IoYSxiLGMsZCl9O3RoaXMuZW5hYmxlU2Npc3NvclRlc3Q9ZnVuY3Rpb24oYSl7YT9qLmVuYWJsZShqLlNDSVNTT1JfVEVTVCk6ai5kaXNhYmxlKGouU0NJU1NPUl9URVNUKX07dGhpcy5zZXRDbGVhckNvbG9yPWZ1bmN0aW9uKGEsYil7TS5zZXQoYSk7UT12b2lkIDAhPT1iP2I6MTtqLmNsZWFyQ29sb3IoTS5yLE0uZyxNLmIsUSl9O3RoaXMuc2V0Q2xlYXJDb2xvckhleD1mdW5jdGlvbihhLGIpe2NvbnNvbGUud2FybihcIkRFUFJFQ0FURUQ6IC5zZXRDbGVhckNvbG9ySGV4KCkgaXMgYmVpbmcgcmVtb3ZlZC4gVXNlIC5zZXRDbGVhckNvbG9yKCkgaW5zdGVhZC5cIik7dGhpcy5zZXRDbGVhckNvbG9yKGEsYil9O3RoaXMuZ2V0Q2xlYXJDb2xvcj1mdW5jdGlvbigpe3JldHVybiBNfTt0aGlzLmdldENsZWFyQWxwaGE9ZnVuY3Rpb24oKXtyZXR1cm4gUX07XG50aGlzLmNsZWFyPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD0wO2lmKHZvaWQgMD09PWF8fGEpZHw9ai5DT0xPUl9CVUZGRVJfQklUO2lmKHZvaWQgMD09PWJ8fGIpZHw9ai5ERVBUSF9CVUZGRVJfQklUO2lmKHZvaWQgMD09PWN8fGMpZHw9ai5TVEVOQ0lMX0JVRkZFUl9CSVQ7ai5jbGVhcihkKX07dGhpcy5jbGVhclRhcmdldD1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLnNldFJlbmRlclRhcmdldChhKTt0aGlzLmNsZWFyKGIsYyxkKX07dGhpcy5hZGRQb3N0UGx1Z2luPWZ1bmN0aW9uKGEpe2EuaW5pdCh0aGlzKTt0aGlzLnJlbmRlclBsdWdpbnNQb3N0LnB1c2goYSl9O3RoaXMuYWRkUHJlUGx1Z2luPWZ1bmN0aW9uKGEpe2EuaW5pdCh0aGlzKTt0aGlzLnJlbmRlclBsdWdpbnNQcmUucHVzaChhKX07dGhpcy51cGRhdGVTaGFkb3dNYXA9ZnVuY3Rpb24oYSxiKXtCYT1udWxsO0FhPSQ9ZmE9R2E9a2E9LTE7dWE9ITA7VT1aPS0xO3RoaXMuc2hhZG93TWFwUGx1Z2luLnVwZGF0ZShhLGIpfTtcbnZhciBDYj1mdW5jdGlvbihhKXthPWEudGFyZ2V0O2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRpc3Bvc2VcIixDYik7YS5fX3dlYmdsSW5pdD12b2lkIDA7aWYoYSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5KXt2YXIgYj1hLmF0dHJpYnV0ZXMsYztmb3IoYyBpbiBiKXZvaWQgMCE9PWJbY10uYnVmZmVyJiZqLmRlbGV0ZUJ1ZmZlcihiW2NdLmJ1ZmZlcik7Sy5pbmZvLm1lbW9yeS5nZW9tZXRyaWVzLS19ZWxzZSBpZih2b2lkIDAhPT1hLmdlb21ldHJ5R3JvdXBzKWZvcihiIGluIGEuZ2VvbWV0cnlHcm91cHMpe2M9YS5nZW9tZXRyeUdyb3Vwc1tiXTtpZih2b2lkIDAhPT1jLm51bU1vcnBoVGFyZ2V0cylmb3IodmFyIGQ9MCxlPWMubnVtTW9ycGhUYXJnZXRzO2Q8ZTtkKyspai5kZWxldGVCdWZmZXIoYy5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVyc1tkXSk7aWYodm9pZCAwIT09Yy5udW1Nb3JwaE5vcm1hbHMpe2Q9MDtmb3IoZT1jLm51bU1vcnBoTm9ybWFscztkPGU7ZCsrKWouZGVsZXRlQnVmZmVyKGMuX193ZWJnbE1vcnBoTm9ybWFsc0J1ZmZlcnNbZF0pfUhiKGMpfWVsc2UgSGIoYSl9LFxuRGI9ZnVuY3Rpb24oYSl7YT1hLnRhcmdldDthLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsRGIpO2EuaW1hZ2UmJmEuaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlP2ouZGVsZXRlVGV4dHVyZShhLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSk6YS5fX3dlYmdsSW5pdCYmKGEuX193ZWJnbEluaXQ9ITEsai5kZWxldGVUZXh0dXJlKGEuX193ZWJnbFRleHR1cmUpKTtLLmluZm8ubWVtb3J5LnRleHR1cmVzLS19LEViPWZ1bmN0aW9uKGEpe2E9YS50YXJnZXQ7YS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLEViKTtpZihhJiZhLl9fd2ViZ2xUZXh0dXJlKWlmKGouZGVsZXRlVGV4dHVyZShhLl9fd2ViZ2xUZXh0dXJlKSxhIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlKWZvcih2YXIgYj0wOzY+YjtiKyspai5kZWxldGVGcmFtZWJ1ZmZlcihhLl9fd2ViZ2xGcmFtZWJ1ZmZlcltiXSksai5kZWxldGVSZW5kZXJidWZmZXIoYS5fX3dlYmdsUmVuZGVyYnVmZmVyW2JdKTtcbmVsc2Ugai5kZWxldGVGcmFtZWJ1ZmZlcihhLl9fd2ViZ2xGcmFtZWJ1ZmZlciksai5kZWxldGVSZW5kZXJidWZmZXIoYS5fX3dlYmdsUmVuZGVyYnVmZmVyKTtLLmluZm8ubWVtb3J5LnRleHR1cmVzLS19LEZiPWZ1bmN0aW9uKGEpe2E9YS50YXJnZXQ7YS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLEZiKTtHYihhKX0sSGI9ZnVuY3Rpb24oYSl7dm9pZCAwIT09YS5fX3dlYmdsVmVydGV4QnVmZmVyJiZqLmRlbGV0ZUJ1ZmZlcihhLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIpO3ZvaWQgMCE9PWEuX193ZWJnbE5vcm1hbEJ1ZmZlciYmai5kZWxldGVCdWZmZXIoYS5fX3dlYmdsTm9ybWFsQnVmZmVyKTt2b2lkIDAhPT1hLl9fd2ViZ2xUYW5nZW50QnVmZmVyJiZqLmRlbGV0ZUJ1ZmZlcihhLl9fd2ViZ2xUYW5nZW50QnVmZmVyKTt2b2lkIDAhPT1hLl9fd2ViZ2xDb2xvckJ1ZmZlciYmai5kZWxldGVCdWZmZXIoYS5fX3dlYmdsQ29sb3JCdWZmZXIpO3ZvaWQgMCE9PWEuX193ZWJnbFVWQnVmZmVyJiZcbmouZGVsZXRlQnVmZmVyKGEuX193ZWJnbFVWQnVmZmVyKTt2b2lkIDAhPT1hLl9fd2ViZ2xVVjJCdWZmZXImJmouZGVsZXRlQnVmZmVyKGEuX193ZWJnbFVWMkJ1ZmZlcik7dm9pZCAwIT09YS5fX3dlYmdsU2tpbkluZGljZXNCdWZmZXImJmouZGVsZXRlQnVmZmVyKGEuX193ZWJnbFNraW5JbmRpY2VzQnVmZmVyKTt2b2lkIDAhPT1hLl9fd2ViZ2xTa2luV2VpZ2h0c0J1ZmZlciYmai5kZWxldGVCdWZmZXIoYS5fX3dlYmdsU2tpbldlaWdodHNCdWZmZXIpO3ZvaWQgMCE9PWEuX193ZWJnbEZhY2VCdWZmZXImJmouZGVsZXRlQnVmZmVyKGEuX193ZWJnbEZhY2VCdWZmZXIpO3ZvaWQgMCE9PWEuX193ZWJnbExpbmVCdWZmZXImJmouZGVsZXRlQnVmZmVyKGEuX193ZWJnbExpbmVCdWZmZXIpO3ZvaWQgMCE9PWEuX193ZWJnbExpbmVEaXN0YW5jZUJ1ZmZlciYmai5kZWxldGVCdWZmZXIoYS5fX3dlYmdsTGluZURpc3RhbmNlQnVmZmVyKTtpZih2b2lkIDAhPT1hLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdClmb3IodmFyIGIgaW4gYS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3Qpai5kZWxldGVCdWZmZXIoYS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3RbYl0uYnVmZmVyKTtcbksuaW5mby5tZW1vcnkuZ2VvbWV0cmllcy0tfSxHYj1mdW5jdGlvbihhKXt2YXIgYj1hLnByb2dyYW07aWYodm9pZCAwIT09Yil7YS5wcm9ncmFtPXZvaWQgMDt2YXIgYyxkLGU9ITEsYT0wO2ZvcihjPWNhLmxlbmd0aDthPGM7YSsrKWlmKGQ9Y2FbYV0sZC5wcm9ncmFtPT09Yil7ZC51c2VkVGltZXMtLTswPT09ZC51c2VkVGltZXMmJihlPSEwKTticmVha31pZighMD09PWUpe2U9W107YT0wO2ZvcihjPWNhLmxlbmd0aDthPGM7YSsrKWQ9Y2FbYV0sZC5wcm9ncmFtIT09YiYmZS5wdXNoKGQpO2NhPWU7ai5kZWxldGVQcm9ncmFtKGIpO0suaW5mby5tZW1vcnkucHJvZ3JhbXMtLX19fTt0aGlzLnJlbmRlckJ1ZmZlckltbWVkaWF0ZT1mdW5jdGlvbihhLGIsYyl7YS5oYXNQb3NpdGlvbnMmJiFhLl9fd2ViZ2xWZXJ0ZXhCdWZmZXImJihhLl9fd2ViZ2xWZXJ0ZXhCdWZmZXI9ai5jcmVhdGVCdWZmZXIoKSk7YS5oYXNOb3JtYWxzJiYhYS5fX3dlYmdsTm9ybWFsQnVmZmVyJiYoYS5fX3dlYmdsTm9ybWFsQnVmZmVyPVxuai5jcmVhdGVCdWZmZXIoKSk7YS5oYXNVdnMmJiFhLl9fd2ViZ2xVdkJ1ZmZlciYmKGEuX193ZWJnbFV2QnVmZmVyPWouY3JlYXRlQnVmZmVyKCkpO2EuaGFzQ29sb3JzJiYhYS5fX3dlYmdsQ29sb3JCdWZmZXImJihhLl9fd2ViZ2xDb2xvckJ1ZmZlcj1qLmNyZWF0ZUJ1ZmZlcigpKTthLmhhc1Bvc2l0aW9ucyYmKGouYmluZEJ1ZmZlcihqLkFSUkFZX0JVRkZFUixhLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIpLGouYnVmZmVyRGF0YShqLkFSUkFZX0JVRkZFUixhLnBvc2l0aW9uQXJyYXksai5EWU5BTUlDX0RSQVcpLGouZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYi5hdHRyaWJ1dGVzLnBvc2l0aW9uKSxqLnZlcnRleEF0dHJpYlBvaW50ZXIoYi5hdHRyaWJ1dGVzLnBvc2l0aW9uLDMsai5GTE9BVCwhMSwwLDApKTtpZihhLmhhc05vcm1hbHMpe2ouYmluZEJ1ZmZlcihqLkFSUkFZX0JVRkZFUixhLl9fd2ViZ2xOb3JtYWxCdWZmZXIpO2lmKGMuc2hhZGluZz09PVRIUkVFLkZsYXRTaGFkaW5nKXt2YXIgZCxcbmUsZixoLGcsaSxrLGwsbSxwLG4scT0zKmEuY291bnQ7Zm9yKG49MDtuPHE7bis9OSlwPWEubm9ybWFsQXJyYXksZD1wW25dLGU9cFtuKzFdLGY9cFtuKzJdLGg9cFtuKzNdLGk9cFtuKzRdLGw9cFtuKzVdLGc9cFtuKzZdLGs9cFtuKzddLG09cFtuKzhdLGQ9KGQraCtnKS8zLGU9KGUraStrKS8zLGY9KGYrbCttKS8zLHBbbl09ZCxwW24rMV09ZSxwW24rMl09ZixwW24rM109ZCxwW24rNF09ZSxwW24rNV09ZixwW24rNl09ZCxwW24rN109ZSxwW24rOF09Zn1qLmJ1ZmZlckRhdGEoai5BUlJBWV9CVUZGRVIsYS5ub3JtYWxBcnJheSxqLkRZTkFNSUNfRFJBVyk7ai5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShiLmF0dHJpYnV0ZXMubm9ybWFsKTtqLnZlcnRleEF0dHJpYlBvaW50ZXIoYi5hdHRyaWJ1dGVzLm5vcm1hbCwzLGouRkxPQVQsITEsMCwwKX1hLmhhc1V2cyYmYy5tYXAmJihqLmJpbmRCdWZmZXIoai5BUlJBWV9CVUZGRVIsYS5fX3dlYmdsVXZCdWZmZXIpLGouYnVmZmVyRGF0YShqLkFSUkFZX0JVRkZFUixcbmEudXZBcnJheSxqLkRZTkFNSUNfRFJBVyksai5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShiLmF0dHJpYnV0ZXMudXYpLGoudmVydGV4QXR0cmliUG9pbnRlcihiLmF0dHJpYnV0ZXMudXYsMixqLkZMT0FULCExLDAsMCkpO2EuaGFzQ29sb3JzJiZjLnZlcnRleENvbG9ycyE9PVRIUkVFLk5vQ29sb3JzJiYoai5iaW5kQnVmZmVyKGouQVJSQVlfQlVGRkVSLGEuX193ZWJnbENvbG9yQnVmZmVyKSxqLmJ1ZmZlckRhdGEoai5BUlJBWV9CVUZGRVIsYS5jb2xvckFycmF5LGouRFlOQU1JQ19EUkFXKSxqLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGIuYXR0cmlidXRlcy5jb2xvciksai52ZXJ0ZXhBdHRyaWJQb2ludGVyKGIuYXR0cmlidXRlcy5jb2xvciwzLGouRkxPQVQsITEsMCwwKSk7ai5kcmF3QXJyYXlzKGouVFJJQU5HTEVTLDAsYS5jb3VudCk7YS5jb3VudD0wfTt0aGlzLnJlbmRlckJ1ZmZlckRpcmVjdD1mdW5jdGlvbihhLGIsYyxkLGUsZil7aWYoITEhPT1kLnZpc2libGUpe3ZhciBpLFxuayxsLG07aT16KGEsYixjLGQsZik7Yj1pLmF0dHJpYnV0ZXM7YT1lLmF0dHJpYnV0ZXM7Yz0hMTtpPTE2Nzc3MjE1KmUuaWQrMippLmlkKyhkLndpcmVmcmFtZT8xOjApO2khPT0kJiYoJD1pLGM9ITApO2MmJmcoKTtpZihmIGluc3RhbmNlb2YgVEhSRUUuTWVzaClpZihmPWEuaW5kZXgpe2U9ZS5vZmZzZXRzOzE8ZS5sZW5ndGgmJihjPSEwKTtmb3IodmFyIHA9MCxuPWUubGVuZ3RoO3A8bjtwKyspe3ZhciBxPWVbcF0uaW5kZXg7aWYoYyl7Zm9yKGsgaW4gYilsPWJba10saT1hW2tdLDA8PWwmJihpPyhtPWkuaXRlbVNpemUsai5iaW5kQnVmZmVyKGouQVJSQVlfQlVGRkVSLGkuYnVmZmVyKSxoKGwpLGoudmVydGV4QXR0cmliUG9pbnRlcihsLG0sai5GTE9BVCwhMSwwLDQqcSptKSk6ZC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzJiYoMj09PWQuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1trXS5sZW5ndGg/ai52ZXJ0ZXhBdHRyaWIyZnYobCxkLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNba10pOlxuMz09PWQuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1trXS5sZW5ndGgmJmoudmVydGV4QXR0cmliM2Z2KGwsZC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzW2tdKSkpO2ouYmluZEJ1ZmZlcihqLkVMRU1FTlRfQVJSQVlfQlVGRkVSLGYuYnVmZmVyKX1qLmRyYXdFbGVtZW50cyhqLlRSSUFOR0xFUyxlW3BdLmNvdW50LGouVU5TSUdORURfU0hPUlQsMiplW3BdLnN0YXJ0KTtLLmluZm8ucmVuZGVyLmNhbGxzKys7Sy5pbmZvLnJlbmRlci52ZXJ0aWNlcys9ZVtwXS5jb3VudDtLLmluZm8ucmVuZGVyLmZhY2VzKz1lW3BdLmNvdW50LzN9fWVsc2V7aWYoYylmb3IoayBpbiBiKVwiaW5kZXhcIiE9PWsmJihsPWJba10saT1hW2tdLDA8PWwmJihpPyhtPWkuaXRlbVNpemUsai5iaW5kQnVmZmVyKGouQVJSQVlfQlVGRkVSLGkuYnVmZmVyKSxoKGwpLGoudmVydGV4QXR0cmliUG9pbnRlcihsLG0sai5GTE9BVCwhMSwwLDApKTpkLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMmJmQuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1trXSYmXG4oMj09PWQuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1trXS5sZW5ndGg/ai52ZXJ0ZXhBdHRyaWIyZnYobCxkLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNba10pOjM9PT1kLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNba10ubGVuZ3RoJiZqLnZlcnRleEF0dHJpYjNmdihsLGQuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1trXSkpKSk7ZD1lLmF0dHJpYnV0ZXMucG9zaXRpb247ai5kcmF3QXJyYXlzKGouVFJJQU5HTEVTLDAsZC5udW1JdGVtcy8zKTtLLmluZm8ucmVuZGVyLmNhbGxzKys7Sy5pbmZvLnJlbmRlci52ZXJ0aWNlcys9ZC5udW1JdGVtcy8zO0suaW5mby5yZW5kZXIuZmFjZXMrPWQubnVtSXRlbXMvMy8zfWVsc2UgaWYoZiBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlU3lzdGVtKXtpZihjKXtmb3IoayBpbiBiKWw9YltrXSxpPWFba10sMDw9bCYmKGk/KG09aS5pdGVtU2l6ZSxqLmJpbmRCdWZmZXIoai5BUlJBWV9CVUZGRVIsaS5idWZmZXIpLGgobCksai52ZXJ0ZXhBdHRyaWJQb2ludGVyKGwsXG5tLGouRkxPQVQsITEsMCwwKSk6ZC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzJiZkLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNba10mJigyPT09ZC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzW2tdLmxlbmd0aD9qLnZlcnRleEF0dHJpYjJmdihsLGQuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1trXSk6Mz09PWQuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1trXS5sZW5ndGgmJmoudmVydGV4QXR0cmliM2Z2KGwsZC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzW2tdKSkpO2Q9YS5wb3NpdGlvbjtqLmRyYXdBcnJheXMoai5QT0lOVFMsMCxkLm51bUl0ZW1zLzMpO0suaW5mby5yZW5kZXIuY2FsbHMrKztLLmluZm8ucmVuZGVyLnBvaW50cys9ZC5udW1JdGVtcy8zfX1lbHNlIGlmKGYgaW5zdGFuY2VvZiBUSFJFRS5MaW5lJiZjKXtmb3IoayBpbiBiKWw9YltrXSxpPWFba10sMDw9bCYmKGk/KG09aS5pdGVtU2l6ZSxqLmJpbmRCdWZmZXIoai5BUlJBWV9CVUZGRVIsaS5idWZmZXIpLGgobCksai52ZXJ0ZXhBdHRyaWJQb2ludGVyKGwsXG5tLGouRkxPQVQsITEsMCwwKSk6ZC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzJiZkLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNba10mJigyPT09ZC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzW2tdLmxlbmd0aD9qLnZlcnRleEF0dHJpYjJmdihsLGQuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1trXSk6Mz09PWQuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1trXS5sZW5ndGgmJmoudmVydGV4QXR0cmliM2Z2KGwsZC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzW2tdKSkpO2s9Zi50eXBlPT09VEhSRUUuTGluZVN0cmlwP2ouTElORV9TVFJJUDpqLkxJTkVTO0YoZC5saW5ld2lkdGgpO2Q9YS5wb3NpdGlvbjtqLmRyYXdBcnJheXMoaywwLGQubnVtSXRlbXMvMyk7Sy5pbmZvLnJlbmRlci5jYWxscysrO0suaW5mby5yZW5kZXIucG9pbnRzKz1kLm51bUl0ZW1zfX19O3RoaXMucmVuZGVyQnVmZmVyPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtpZighMSE9PWQudmlzaWJsZSl7dmFyIGksbCxjPXooYSxiLGMsZCxmKSxcbmE9Yy5hdHRyaWJ1dGVzLGI9ITEsYz0xNjc3NzIxNSplLmlkKzIqYy5pZCsoZC53aXJlZnJhbWU/MTowKTtjIT09JCYmKCQ9YyxiPSEwKTtiJiZnKCk7aWYoIWQubW9ycGhUYXJnZXRzJiYwPD1hLnBvc2l0aW9uKWImJihqLmJpbmRCdWZmZXIoai5BUlJBWV9CVUZGRVIsZS5fX3dlYmdsVmVydGV4QnVmZmVyKSxoKGEucG9zaXRpb24pLGoudmVydGV4QXR0cmliUG9pbnRlcihhLnBvc2l0aW9uLDMsai5GTE9BVCwhMSwwLDApKTtlbHNlIGlmKGYubW9ycGhUYXJnZXRCYXNlKXtjPWQucHJvZ3JhbS5hdHRyaWJ1dGVzOy0xIT09Zi5tb3JwaFRhcmdldEJhc2UmJjA8PWMucG9zaXRpb24/KGouYmluZEJ1ZmZlcihqLkFSUkFZX0JVRkZFUixlLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzW2YubW9ycGhUYXJnZXRCYXNlXSksaChjLnBvc2l0aW9uKSxqLnZlcnRleEF0dHJpYlBvaW50ZXIoYy5wb3NpdGlvbiwzLGouRkxPQVQsITEsMCwwKSk6MDw9Yy5wb3NpdGlvbiYmKGouYmluZEJ1ZmZlcihqLkFSUkFZX0JVRkZFUixcbmUuX193ZWJnbFZlcnRleEJ1ZmZlciksaChjLnBvc2l0aW9uKSxqLnZlcnRleEF0dHJpYlBvaW50ZXIoYy5wb3NpdGlvbiwzLGouRkxPQVQsITEsMCwwKSk7aWYoZi5tb3JwaFRhcmdldEZvcmNlZE9yZGVyLmxlbmd0aCl7dmFyIG09MDtsPWYubW9ycGhUYXJnZXRGb3JjZWRPcmRlcjtmb3IoaT1mLm1vcnBoVGFyZ2V0SW5mbHVlbmNlczttPGQubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzJiZtPGwubGVuZ3RoOykwPD1jW1wibW9ycGhUYXJnZXRcIittXSYmKGouYmluZEJ1ZmZlcihqLkFSUkFZX0JVRkZFUixlLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzW2xbbV1dKSxoKGNbXCJtb3JwaFRhcmdldFwiK21dKSxqLnZlcnRleEF0dHJpYlBvaW50ZXIoY1tcIm1vcnBoVGFyZ2V0XCIrbV0sMyxqLkZMT0FULCExLDAsMCkpLDA8PWNbXCJtb3JwaE5vcm1hbFwiK21dJiZkLm1vcnBoTm9ybWFscyYmKGouYmluZEJ1ZmZlcihqLkFSUkFZX0JVRkZFUixlLl9fd2ViZ2xNb3JwaE5vcm1hbHNCdWZmZXJzW2xbbV1dKSxcbmgoY1tcIm1vcnBoTm9ybWFsXCIrbV0pLGoudmVydGV4QXR0cmliUG9pbnRlcihjW1wibW9ycGhOb3JtYWxcIittXSwzLGouRkxPQVQsITEsMCwwKSksZi5fX3dlYmdsTW9ycGhUYXJnZXRJbmZsdWVuY2VzW21dPWlbbFttXV0sbSsrfWVsc2V7bD1bXTtpPWYubW9ycGhUYXJnZXRJbmZsdWVuY2VzO3ZhciBwLG49aS5sZW5ndGg7Zm9yKHA9MDtwPG47cCsrKW09aVtwXSwwPG0mJmwucHVzaChbbSxwXSk7bC5sZW5ndGg+ZC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHM/KGwuc29ydChrKSxsLmxlbmd0aD1kLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyk6bC5sZW5ndGg+ZC5udW1TdXBwb3J0ZWRNb3JwaE5vcm1hbHM/bC5zb3J0KGspOjA9PT1sLmxlbmd0aCYmbC5wdXNoKFswLDBdKTtmb3IobT0wO208ZC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHM7KWxbbV0/KHA9bFttXVsxXSwwPD1jW1wibW9ycGhUYXJnZXRcIittXSYmKGouYmluZEJ1ZmZlcihqLkFSUkFZX0JVRkZFUixlLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzW3BdKSxcbmgoY1tcIm1vcnBoVGFyZ2V0XCIrbV0pLGoudmVydGV4QXR0cmliUG9pbnRlcihjW1wibW9ycGhUYXJnZXRcIittXSwzLGouRkxPQVQsITEsMCwwKSksMDw9Y1tcIm1vcnBoTm9ybWFsXCIrbV0mJmQubW9ycGhOb3JtYWxzJiYoai5iaW5kQnVmZmVyKGouQVJSQVlfQlVGRkVSLGUuX193ZWJnbE1vcnBoTm9ybWFsc0J1ZmZlcnNbcF0pLGgoY1tcIm1vcnBoTm9ybWFsXCIrbV0pLGoudmVydGV4QXR0cmliUG9pbnRlcihjW1wibW9ycGhOb3JtYWxcIittXSwzLGouRkxPQVQsITEsMCwwKSksZi5fX3dlYmdsTW9ycGhUYXJnZXRJbmZsdWVuY2VzW21dPWlbcF0pOmYuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlc1ttXT0wLG0rK31udWxsIT09ZC5wcm9ncmFtLnVuaWZvcm1zLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyYmai51bmlmb3JtMWZ2KGQucHJvZ3JhbS51bmlmb3Jtcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMsZi5fX3dlYmdsTW9ycGhUYXJnZXRJbmZsdWVuY2VzKX1pZihiKXtpZihlLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdCl7aT1cbjA7Zm9yKGw9ZS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QubGVuZ3RoO2k8bDtpKyspYz1lLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdFtpXSwwPD1hW2MuYnVmZmVyLmJlbG9uZ3NUb0F0dHJpYnV0ZV0mJihqLmJpbmRCdWZmZXIoai5BUlJBWV9CVUZGRVIsYy5idWZmZXIpLGgoYVtjLmJ1ZmZlci5iZWxvbmdzVG9BdHRyaWJ1dGVdKSxqLnZlcnRleEF0dHJpYlBvaW50ZXIoYVtjLmJ1ZmZlci5iZWxvbmdzVG9BdHRyaWJ1dGVdLGMuc2l6ZSxqLkZMT0FULCExLDAsMCkpfTA8PWEuY29sb3ImJigwPGYuZ2VvbWV0cnkuY29sb3JzLmxlbmd0aHx8MDxmLmdlb21ldHJ5LmZhY2VzLmxlbmd0aD8oai5iaW5kQnVmZmVyKGouQVJSQVlfQlVGRkVSLGUuX193ZWJnbENvbG9yQnVmZmVyKSxoKGEuY29sb3IpLGoudmVydGV4QXR0cmliUG9pbnRlcihhLmNvbG9yLDMsai5GTE9BVCwhMSwwLDApKTpkLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMmJmoudmVydGV4QXR0cmliM2Z2KGEuY29sb3IsXG5kLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMuY29sb3IpKTswPD1hLm5vcm1hbCYmKGouYmluZEJ1ZmZlcihqLkFSUkFZX0JVRkZFUixlLl9fd2ViZ2xOb3JtYWxCdWZmZXIpLGgoYS5ub3JtYWwpLGoudmVydGV4QXR0cmliUG9pbnRlcihhLm5vcm1hbCwzLGouRkxPQVQsITEsMCwwKSk7MDw9YS50YW5nZW50JiYoai5iaW5kQnVmZmVyKGouQVJSQVlfQlVGRkVSLGUuX193ZWJnbFRhbmdlbnRCdWZmZXIpLGgoYS50YW5nZW50KSxqLnZlcnRleEF0dHJpYlBvaW50ZXIoYS50YW5nZW50LDQsai5GTE9BVCwhMSwwLDApKTswPD1hLnV2JiYoZi5nZW9tZXRyeS5mYWNlVmVydGV4VXZzWzBdPyhqLmJpbmRCdWZmZXIoai5BUlJBWV9CVUZGRVIsZS5fX3dlYmdsVVZCdWZmZXIpLGgoYS51diksai52ZXJ0ZXhBdHRyaWJQb2ludGVyKGEudXYsMixqLkZMT0FULCExLDAsMCkpOmQuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyYmai52ZXJ0ZXhBdHRyaWIyZnYoYS51dixkLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMudXYpKTtcbjA8PWEudXYyJiYoZi5nZW9tZXRyeS5mYWNlVmVydGV4VXZzWzFdPyhqLmJpbmRCdWZmZXIoai5BUlJBWV9CVUZGRVIsZS5fX3dlYmdsVVYyQnVmZmVyKSxoKGEudXYyKSxqLnZlcnRleEF0dHJpYlBvaW50ZXIoYS51djIsMixqLkZMT0FULCExLDAsMCkpOmQuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyYmai52ZXJ0ZXhBdHRyaWIyZnYoYS51djIsZC5kZWZhdWx0QXR0cmlidXRlVmFsdWVzLnV2MikpO2Quc2tpbm5pbmcmJigwPD1hLnNraW5JbmRleCYmMDw9YS5za2luV2VpZ2h0KSYmKGouYmluZEJ1ZmZlcihqLkFSUkFZX0JVRkZFUixlLl9fd2ViZ2xTa2luSW5kaWNlc0J1ZmZlciksaChhLnNraW5JbmRleCksai52ZXJ0ZXhBdHRyaWJQb2ludGVyKGEuc2tpbkluZGV4LDQsai5GTE9BVCwhMSwwLDApLGouYmluZEJ1ZmZlcihqLkFSUkFZX0JVRkZFUixlLl9fd2ViZ2xTa2luV2VpZ2h0c0J1ZmZlciksaChhLnNraW5XZWlnaHQpLGoudmVydGV4QXR0cmliUG9pbnRlcihhLnNraW5XZWlnaHQsXG40LGouRkxPQVQsITEsMCwwKSk7MDw9YS5saW5lRGlzdGFuY2UmJihqLmJpbmRCdWZmZXIoai5BUlJBWV9CVUZGRVIsZS5fX3dlYmdsTGluZURpc3RhbmNlQnVmZmVyKSxoKGEubGluZURpc3RhbmNlKSxqLnZlcnRleEF0dHJpYlBvaW50ZXIoYS5saW5lRGlzdGFuY2UsMSxqLkZMT0FULCExLDAsMCkpfWYgaW5zdGFuY2VvZiBUSFJFRS5NZXNoPyhkLndpcmVmcmFtZT8oRihkLndpcmVmcmFtZUxpbmV3aWR0aCksYiYmai5iaW5kQnVmZmVyKGouRUxFTUVOVF9BUlJBWV9CVUZGRVIsZS5fX3dlYmdsTGluZUJ1ZmZlciksai5kcmF3RWxlbWVudHMoai5MSU5FUyxlLl9fd2ViZ2xMaW5lQ291bnQsai5VTlNJR05FRF9TSE9SVCwwKSk6KGImJmouYmluZEJ1ZmZlcihqLkVMRU1FTlRfQVJSQVlfQlVGRkVSLGUuX193ZWJnbEZhY2VCdWZmZXIpLGouZHJhd0VsZW1lbnRzKGouVFJJQU5HTEVTLGUuX193ZWJnbEZhY2VDb3VudCxqLlVOU0lHTkVEX1NIT1JULDApKSxLLmluZm8ucmVuZGVyLmNhbGxzKyssXG5LLmluZm8ucmVuZGVyLnZlcnRpY2VzKz1lLl9fd2ViZ2xGYWNlQ291bnQsSy5pbmZvLnJlbmRlci5mYWNlcys9ZS5fX3dlYmdsRmFjZUNvdW50LzMpOmYgaW5zdGFuY2VvZiBUSFJFRS5MaW5lPyhmPWYudHlwZT09PVRIUkVFLkxpbmVTdHJpcD9qLkxJTkVfU1RSSVA6ai5MSU5FUyxGKGQubGluZXdpZHRoKSxqLmRyYXdBcnJheXMoZiwwLGUuX193ZWJnbExpbmVDb3VudCksSy5pbmZvLnJlbmRlci5jYWxscysrKTpmIGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVTeXN0ZW0mJihqLmRyYXdBcnJheXMoai5QT0lOVFMsMCxlLl9fd2ViZ2xQYXJ0aWNsZUNvdW50KSxLLmluZm8ucmVuZGVyLmNhbGxzKyssSy5pbmZvLnJlbmRlci5wb2ludHMrPWUuX193ZWJnbFBhcnRpY2xlQ291bnQpfX07dGhpcy5yZW5kZXI9ZnVuY3Rpb24oYSxiLGMsZCl7aWYoITE9PT1iIGluc3RhbmNlb2YgVEhSRUUuQ2FtZXJhKWNvbnNvbGUuZXJyb3IoXCJUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuXCIpO1xuZWxzZXt2YXIgZSxmLGgsZyxrPWEuX19saWdodHMsbj1hLmZvZztBYT0tMTt1YT0hMDshMD09PWEuYXV0b1VwZGF0ZSYmYS51cGRhdGVNYXRyaXhXb3JsZCgpO3ZvaWQgMD09PWIucGFyZW50JiZiLnVwZGF0ZU1hdHJpeFdvcmxkKCk7Yi5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZShiLm1hdHJpeFdvcmxkKTtyYS5tdWx0aXBseU1hdHJpY2VzKGIucHJvamVjdGlvbk1hdHJpeCxiLm1hdHJpeFdvcmxkSW52ZXJzZSk7bGEuc2V0RnJvbU1hdHJpeChyYSk7dGhpcy5hdXRvVXBkYXRlT2JqZWN0cyYmdGhpcy5pbml0V2ViR0xPYmplY3RzKGEpO20odGhpcy5yZW5kZXJQbHVnaW5zUHJlLGEsYik7Sy5pbmZvLnJlbmRlci5jYWxscz0wO0suaW5mby5yZW5kZXIudmVydGljZXM9MDtLLmluZm8ucmVuZGVyLmZhY2VzPTA7Sy5pbmZvLnJlbmRlci5wb2ludHM9MDt0aGlzLnNldFJlbmRlclRhcmdldChjKTsodGhpcy5hdXRvQ2xlYXJ8fGQpJiZ0aGlzLmNsZWFyKHRoaXMuYXV0b0NsZWFyQ29sb3IsXG50aGlzLmF1dG9DbGVhckRlcHRoLHRoaXMuYXV0b0NsZWFyU3RlbmNpbCk7Zz1hLl9fd2ViZ2xPYmplY3RzO2Q9MDtmb3IoZT1nLmxlbmd0aDtkPGU7ZCsrKWlmKGY9Z1tkXSxoPWYub2JqZWN0LGYuaWQ9ZCxmLnJlbmRlcj0hMSxoLnZpc2libGUmJighKGggaW5zdGFuY2VvZiBUSFJFRS5NZXNofHxoIGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVTeXN0ZW0pfHwhaC5mcnVzdHVtQ3VsbGVkfHxsYS5pbnRlcnNlY3RzT2JqZWN0KGgpKSl7dmFyIHE9aDtxLl9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhiLm1hdHJpeFdvcmxkSW52ZXJzZSxxLm1hdHJpeFdvcmxkKTtxLl9ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KHEuX21vZGVsVmlld01hdHJpeCk7dmFyIHE9ZixyPXEuYnVmZmVyLHM9dm9pZCAwLHQ9cz12b2lkIDAsdD1xLm9iamVjdC5tYXRlcmlhbDtpZih0IGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbClzPXIubWF0ZXJpYWxJbmRleCxzPXQubWF0ZXJpYWxzW3NdLFxucy50cmFuc3BhcmVudD8ocS50cmFuc3BhcmVudD1zLHEub3BhcXVlPW51bGwpOihxLm9wYXF1ZT1zLHEudHJhbnNwYXJlbnQ9bnVsbCk7ZWxzZSBpZihzPXQpcy50cmFuc3BhcmVudD8ocS50cmFuc3BhcmVudD1zLHEub3BhcXVlPW51bGwpOihxLm9wYXF1ZT1zLHEudHJhbnNwYXJlbnQ9bnVsbCk7Zi5yZW5kZXI9ITA7ITA9PT10aGlzLnNvcnRPYmplY3RzJiYobnVsbCE9PWgucmVuZGVyRGVwdGg/Zi56PWgucmVuZGVyRGVwdGg6KHNhLmdldFBvc2l0aW9uRnJvbU1hdHJpeChoLm1hdHJpeFdvcmxkKSxzYS5hcHBseVByb2plY3Rpb24ocmEpLGYuej1zYS56KSl9dGhpcy5zb3J0T2JqZWN0cyYmZy5zb3J0KGkpO2c9YS5fX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZTtkPTA7Zm9yKGU9Zy5sZW5ndGg7ZDxlO2QrKylmPWdbZF0saD1mLm9iamVjdCxoLnZpc2libGUmJihoLl9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhiLm1hdHJpeFdvcmxkSW52ZXJzZSxoLm1hdHJpeFdvcmxkKSxcbmguX25vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoaC5fbW9kZWxWaWV3TWF0cml4KSxoPWYub2JqZWN0Lm1hdGVyaWFsLGgudHJhbnNwYXJlbnQ/KGYudHJhbnNwYXJlbnQ9aCxmLm9wYXF1ZT1udWxsKTooZi5vcGFxdWU9aCxmLnRyYW5zcGFyZW50PW51bGwpKTthLm92ZXJyaWRlTWF0ZXJpYWw/KGQ9YS5vdmVycmlkZU1hdGVyaWFsLHRoaXMuc2V0QmxlbmRpbmcoZC5ibGVuZGluZyxkLmJsZW5kRXF1YXRpb24sZC5ibGVuZFNyYyxkLmJsZW5kRHN0KSx0aGlzLnNldERlcHRoVGVzdChkLmRlcHRoVGVzdCksdGhpcy5zZXREZXB0aFdyaXRlKGQuZGVwdGhXcml0ZSksQShkLnBvbHlnb25PZmZzZXQsZC5wb2x5Z29uT2Zmc2V0RmFjdG9yLGQucG9seWdvbk9mZnNldFVuaXRzKSxsKGEuX193ZWJnbE9iamVjdHMsITEsXCJcIixiLGssbiwhMCxkKSxwKGEuX193ZWJnbE9iamVjdHNJbW1lZGlhdGUsXCJcIixiLGssbiwhMSxkKSk6KGQ9bnVsbCx0aGlzLnNldEJsZW5kaW5nKFRIUkVFLk5vQmxlbmRpbmcpLFxubChhLl9fd2ViZ2xPYmplY3RzLCEwLFwib3BhcXVlXCIsYixrLG4sITEsZCkscChhLl9fd2ViZ2xPYmplY3RzSW1tZWRpYXRlLFwib3BhcXVlXCIsYixrLG4sITEsZCksbChhLl9fd2ViZ2xPYmplY3RzLCExLFwidHJhbnNwYXJlbnRcIixiLGssbiwhMCxkKSxwKGEuX193ZWJnbE9iamVjdHNJbW1lZGlhdGUsXCJ0cmFuc3BhcmVudFwiLGIsayxuLCEwLGQpKTttKHRoaXMucmVuZGVyUGx1Z2luc1Bvc3QsYSxiKTtjJiYoYy5nZW5lcmF0ZU1pcG1hcHMmJmMubWluRmlsdGVyIT09VEhSRUUuTmVhcmVzdEZpbHRlciYmYy5taW5GaWx0ZXIhPT1USFJFRS5MaW5lYXJGaWx0ZXIpJiYoYyBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZT8oai5iaW5kVGV4dHVyZShqLlRFWFRVUkVfQ1VCRV9NQVAsYy5fX3dlYmdsVGV4dHVyZSksai5nZW5lcmF0ZU1pcG1hcChqLlRFWFRVUkVfQ1VCRV9NQVApLGouYmluZFRleHR1cmUoai5URVhUVVJFX0NVQkVfTUFQLG51bGwpKTooai5iaW5kVGV4dHVyZShqLlRFWFRVUkVfMkQsXG5jLl9fd2ViZ2xUZXh0dXJlKSxqLmdlbmVyYXRlTWlwbWFwKGouVEVYVFVSRV8yRCksai5iaW5kVGV4dHVyZShqLlRFWFRVUkVfMkQsbnVsbCkpKTt0aGlzLnNldERlcHRoVGVzdCghMCk7dGhpcy5zZXREZXB0aFdyaXRlKCEwKX19O3RoaXMucmVuZGVySW1tZWRpYXRlT2JqZWN0PWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9eihhLGIsYyxkLGUpOyQ9LTE7Sy5zZXRNYXRlcmlhbEZhY2VzKGQpO2UuaW1tZWRpYXRlUmVuZGVyQ2FsbGJhY2s/ZS5pbW1lZGlhdGVSZW5kZXJDYWxsYmFjayhmLGosbGEpOmUucmVuZGVyKGZ1bmN0aW9uKGEpe0sucmVuZGVyQnVmZmVySW1tZWRpYXRlKGEsZixkKX0pfTt0aGlzLmluaXRXZWJHTE9iamVjdHM9ZnVuY3Rpb24oYSl7YS5fX3dlYmdsT2JqZWN0c3x8KGEuX193ZWJnbE9iamVjdHM9W10sYS5fX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZT1bXSxhLl9fd2ViZ2xTcHJpdGVzPVtdLGEuX193ZWJnbEZsYXJlcz1bXSk7Zm9yKDthLl9fb2JqZWN0c0FkZGVkLmxlbmd0aDspcyhhLl9fb2JqZWN0c0FkZGVkWzBdLFxuYSksYS5fX29iamVjdHNBZGRlZC5zcGxpY2UoMCwxKTtmb3IoO2EuX19vYmplY3RzUmVtb3ZlZC5sZW5ndGg7KXEoYS5fX29iamVjdHNSZW1vdmVkWzBdLGEpLGEuX19vYmplY3RzUmVtb3ZlZC5zcGxpY2UoMCwxKTtmb3IodmFyIGI9MCxoPWEuX193ZWJnbE9iamVjdHMubGVuZ3RoO2I8aDtiKyspe3ZhciBnPWEuX193ZWJnbE9iamVjdHNbYl0ub2JqZWN0O3ZvaWQgMD09PWcuX193ZWJnbEluaXQmJih2b2lkIDAhPT1nLl9fd2ViZ2xBY3RpdmUmJnEoZyxhKSxzKGcsYSkpO3ZhciBpPWcsbD1pLmdlb21ldHJ5LG09dm9pZCAwLHA9dm9pZCAwLHQ9dm9pZCAwO2lmKGwgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSl7dmFyIHU9ai5EWU5BTUlDX0RSQVcsdz0hbC5keW5hbWljLHo9bC5hdHRyaWJ1dGVzLHk9dm9pZCAwLHg9dm9pZCAwO2Zvcih5IGluIHopeD16W3ldLHgubmVlZHNVcGRhdGUmJihcImluZGV4XCI9PT15PyhqLmJpbmRCdWZmZXIoai5FTEVNRU5UX0FSUkFZX0JVRkZFUixcbnguYnVmZmVyKSxqLmJ1ZmZlckRhdGEoai5FTEVNRU5UX0FSUkFZX0JVRkZFUix4LmFycmF5LHUpKTooai5iaW5kQnVmZmVyKGouQVJSQVlfQlVGRkVSLHguYnVmZmVyKSxqLmJ1ZmZlckRhdGEoai5BUlJBWV9CVUZGRVIseC5hcnJheSx1KSkseC5uZWVkc1VwZGF0ZT0hMSksdyYmIXguZHluYW1pYyYmKHguYXJyYXk9bnVsbCl9ZWxzZSBpZihpIGluc3RhbmNlb2YgVEhSRUUuTWVzaCl7Zm9yKHZhciBBPTAsQj1sLmdlb21ldHJ5R3JvdXBzTGlzdC5sZW5ndGg7QTxCO0ErKylpZihtPWwuZ2VvbWV0cnlHcm91cHNMaXN0W0FdLHQ9ZChpLG0pLGwuYnVmZmVyc05lZWRVcGRhdGUmJmMobSxpKSxwPXQuYXR0cmlidXRlcyYmbih0KSxsLnZlcnRpY2VzTmVlZFVwZGF0ZXx8bC5tb3JwaFRhcmdldHNOZWVkVXBkYXRlfHxsLmVsZW1lbnRzTmVlZFVwZGF0ZXx8bC51dnNOZWVkVXBkYXRlfHxsLm5vcm1hbHNOZWVkVXBkYXRlfHxsLmNvbG9yc05lZWRVcGRhdGV8fGwudGFuZ2VudHNOZWVkVXBkYXRlfHxcbnApe3ZhciB2PW0sQz1pLEQ9ai5EWU5BTUlDX0RSQVcsRj0hbC5keW5hbWljLEc9dDtpZih2Ll9faW5pdHRlZEFycmF5cyl7dmFyIEo9ZShHKSxLPUcudmVydGV4Q29sb3JzP0cudmVydGV4Q29sb3JzOiExLE49ZihHKSxPPUo9PT1USFJFRS5TbW9vdGhTaGFkaW5nLEU9dm9pZCAwLEk9dm9pZCAwLFY9dm9pZCAwLE09dm9pZCAwLFI9dm9pZCAwLFU9dm9pZCAwLFE9dm9pZCAwLGRhPXZvaWQgMCxaPXZvaWQgMCwkPXZvaWQgMCxGYT12b2lkIDAsUD12b2lkIDAsWD12b2lkIDAsVz12b2lkIDAsQmE9dm9pZCAwLGVhPXZvaWQgMCxBYT12b2lkIDAsYmE9dm9pZCAwLGNhPXZvaWQgMCxpYT12b2lkIDAsZmE9dm9pZCAwLGdhPXZvaWQgMCxrYT12b2lkIDAsbGE9dm9pZCAwLG9hPXZvaWQgMCxwYT12b2lkIDAsdGE9dm9pZCAwLHVhPXZvaWQgMCx2YT12b2lkIDAsQ2E9dm9pZCAwLERhPXZvaWQgMCxHYT12b2lkIDAsRWE9dm9pZCAwLExhPXZvaWQgMCxTYT12b2lkIDAsSGE9dm9pZCAwLHdhPVxudm9pZCAwLHhhPXZvaWQgMCxRYT12b2lkIDAsUmE9dm9pZCAwLGRiPTAsZWI9MCxPYT0wLFBhPTAsVWE9MCxoYj0wLFRhPTAsdGI9MCxaYT0wLHFhPTAseWE9MCxMPTAsTmE9dm9pZCAwLGliPXYuX192ZXJ0ZXhBcnJheSxiYj12Ll9fdXZBcnJheSxjYj12Ll9fdXYyQXJyYXksTWE9di5fX25vcm1hbEFycmF5LFZhPXYuX190YW5nZW50QXJyYXksamI9di5fX2NvbG9yQXJyYXksV2E9di5fX3NraW5JbmRleEFycmF5LFhhPXYuX19za2luV2VpZ2h0QXJyYXksZmI9di5fX21vcnBoVGFyZ2V0c0FycmF5cyxzYj12Ll9fbW9ycGhOb3JtYWxzQXJyYXlzLHBiPXYuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0LEg9dm9pZCAwLFBiPXYuX19mYWNlQXJyYXksdmI9di5fX2xpbmVBcnJheSxJYT1DLmdlb21ldHJ5LEJiPUlhLmVsZW1lbnRzTmVlZFVwZGF0ZSx5Yj1JYS51dnNOZWVkVXBkYXRlLERiPUlhLm5vcm1hbHNOZWVkVXBkYXRlLE1iPUlhLnRhbmdlbnRzTmVlZFVwZGF0ZSxOYj1JYS5jb2xvcnNOZWVkVXBkYXRlLFxuT2I9SWEubW9ycGhUYXJnZXRzTmVlZFVwZGF0ZSxlYz1JYS52ZXJ0aWNlcyxhYT12LmZhY2VzMyxrYj1JYS5mYWNlcyxDYj1JYS5mYWNlVmVydGV4VXZzWzBdLEViPUlhLmZhY2VWZXJ0ZXhVdnNbMV0sZmM9SWEuc2tpbkluZGljZXMsUWI9SWEuc2tpbldlaWdodHMsUmI9SWEubW9ycGhUYXJnZXRzLEZiPUlhLm1vcnBoTm9ybWFscztpZihJYS52ZXJ0aWNlc05lZWRVcGRhdGUpe0U9MDtmb3IoST1hYS5sZW5ndGg7RTxJO0UrKylNPWtiW2FhW0VdXSxQPWVjW00uYV0sWD1lY1tNLmJdLFc9ZWNbTS5jXSxpYltlYl09UC54LGliW2ViKzFdPVAueSxpYltlYisyXT1QLnosaWJbZWIrM109WC54LGliW2ViKzRdPVgueSxpYltlYis1XT1YLnosaWJbZWIrNl09Vy54LGliW2ViKzddPVcueSxpYltlYis4XT1XLnosZWIrPTk7ai5iaW5kQnVmZmVyKGouQVJSQVlfQlVGRkVSLHYuX193ZWJnbFZlcnRleEJ1ZmZlcik7ai5idWZmZXJEYXRhKGouQVJSQVlfQlVGRkVSLGliLEQpfWlmKE9iKXtTYT0wO1xuZm9yKEhhPVJiLmxlbmd0aDtTYTxIYTtTYSsrKXtFPXlhPTA7Zm9yKEk9YWEubGVuZ3RoO0U8STtFKyspUWE9YWFbRV0sTT1rYltRYV0sUD1SYltTYV0udmVydGljZXNbTS5hXSxYPVJiW1NhXS52ZXJ0aWNlc1tNLmJdLFc9UmJbU2FdLnZlcnRpY2VzW00uY10sd2E9ZmJbU2FdLHdhW3lhXT1QLngsd2FbeWErMV09UC55LHdhW3lhKzJdPVAueix3YVt5YSszXT1YLngsd2FbeWErNF09WC55LHdhW3lhKzVdPVgueix3YVt5YSs2XT1XLngsd2FbeWErN109Vy55LHdhW3lhKzhdPVcueixHLm1vcnBoTm9ybWFscyYmKE8/KFJhPUZiW1NhXS52ZXJ0ZXhOb3JtYWxzW1FhXSxiYT1SYS5hLGNhPVJhLmIsaWE9UmEuYyk6aWE9Y2E9YmE9RmJbU2FdLmZhY2VOb3JtYWxzW1FhXSx4YT1zYltTYV0seGFbeWFdPWJhLngseGFbeWErMV09YmEueSx4YVt5YSsyXT1iYS56LHhhW3lhKzNdPWNhLngseGFbeWErNF09Y2EueSx4YVt5YSs1XT1jYS56LHhhW3lhKzZdPWlhLngseGFbeWErN109aWEueSx4YVt5YStcbjhdPWlhLnopLHlhKz05O2ouYmluZEJ1ZmZlcihqLkFSUkFZX0JVRkZFUix2Ll9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzW1NhXSk7ai5idWZmZXJEYXRhKGouQVJSQVlfQlVGRkVSLGZiW1NhXSxEKTtHLm1vcnBoTm9ybWFscyYmKGouYmluZEJ1ZmZlcihqLkFSUkFZX0JVRkZFUix2Ll9fd2ViZ2xNb3JwaE5vcm1hbHNCdWZmZXJzW1NhXSksai5idWZmZXJEYXRhKGouQVJSQVlfQlVGRkVSLHNiW1NhXSxEKSl9fWlmKFFiLmxlbmd0aCl7RT0wO2ZvcihJPWFhLmxlbmd0aDtFPEk7RSsrKU09a2JbYWFbRV1dLGxhPVFiW00uYV0sb2E9UWJbTS5iXSxwYT1RYltNLmNdLFhhW3FhXT1sYS54LFhhW3FhKzFdPWxhLnksWGFbcWErMl09bGEueixYYVtxYSszXT1sYS53LFhhW3FhKzRdPW9hLngsWGFbcWErNV09b2EueSxYYVtxYSs2XT1vYS56LFhhW3FhKzddPW9hLncsWGFbcWErOF09cGEueCxYYVtxYSs5XT1wYS55LFhhW3FhKzEwXT1wYS56LFhhW3FhKzExXT1wYS53LHRhPWZjW00uYV0sdWE9XG5mY1tNLmJdLHZhPWZjW00uY10sV2FbcWFdPXRhLngsV2FbcWErMV09dGEueSxXYVtxYSsyXT10YS56LFdhW3FhKzNdPXRhLncsV2FbcWErNF09dWEueCxXYVtxYSs1XT11YS55LFdhW3FhKzZdPXVhLnosV2FbcWErN109dWEudyxXYVtxYSs4XT12YS54LFdhW3FhKzldPXZhLnksV2FbcWErMTBdPXZhLnosV2FbcWErMTFdPXZhLncscWErPTEyOzA8cWEmJihqLmJpbmRCdWZmZXIoai5BUlJBWV9CVUZGRVIsdi5fX3dlYmdsU2tpbkluZGljZXNCdWZmZXIpLGouYnVmZmVyRGF0YShqLkFSUkFZX0JVRkZFUixXYSxEKSxqLmJpbmRCdWZmZXIoai5BUlJBWV9CVUZGRVIsdi5fX3dlYmdsU2tpbldlaWdodHNCdWZmZXIpLGouYnVmZmVyRGF0YShqLkFSUkFZX0JVRkZFUixYYSxEKSl9aWYoTmImJkspe0U9MDtmb3IoST1hYS5sZW5ndGg7RTxJO0UrKylNPWtiW2FhW0VdXSxRPU0udmVydGV4Q29sb3JzLGRhPU0uY29sb3IsMz09PVEubGVuZ3RoJiZLPT09VEhSRUUuVmVydGV4Q29sb3JzPyhmYT1cblFbMF0sZ2E9UVsxXSxrYT1RWzJdKTprYT1nYT1mYT1kYSxqYltaYV09ZmEucixqYltaYSsxXT1mYS5nLGpiW1phKzJdPWZhLmIsamJbWmErM109Z2EucixqYltaYSs0XT1nYS5nLGpiW1phKzVdPWdhLmIsamJbWmErNl09a2EucixqYltaYSs3XT1rYS5nLGpiW1phKzhdPWthLmIsWmErPTk7MDxaYSYmKGouYmluZEJ1ZmZlcihqLkFSUkFZX0JVRkZFUix2Ll9fd2ViZ2xDb2xvckJ1ZmZlciksai5idWZmZXJEYXRhKGouQVJSQVlfQlVGRkVSLGpiLEQpKX1pZihNYiYmSWEuaGFzVGFuZ2VudHMpe0U9MDtmb3IoST1hYS5sZW5ndGg7RTxJO0UrKylNPWtiW2FhW0VdXSxaPU0udmVydGV4VGFuZ2VudHMsQmE9WlswXSxlYT1aWzFdLEFhPVpbMl0sVmFbVGFdPUJhLngsVmFbVGErMV09QmEueSxWYVtUYSsyXT1CYS56LFZhW1RhKzNdPUJhLncsVmFbVGErNF09ZWEueCxWYVtUYSs1XT1lYS55LFZhW1RhKzZdPWVhLnosVmFbVGErN109ZWEudyxWYVtUYSs4XT1BYS54LFZhW1RhKzldPUFhLnksVmFbVGErXG4xMF09QWEueixWYVtUYSsxMV09QWEudyxUYSs9MTI7ai5iaW5kQnVmZmVyKGouQVJSQVlfQlVGRkVSLHYuX193ZWJnbFRhbmdlbnRCdWZmZXIpO2ouYnVmZmVyRGF0YShqLkFSUkFZX0JVRkZFUixWYSxEKX1pZihEYiYmSil7RT0wO2ZvcihJPWFhLmxlbmd0aDtFPEk7RSsrKWlmKE09a2JbYWFbRV1dLFI9TS52ZXJ0ZXhOb3JtYWxzLFU9TS5ub3JtYWwsMz09PVIubGVuZ3RoJiZPKWZvcihDYT0wOzM+Q2E7Q2ErKylHYT1SW0NhXSxNYVtoYl09R2EueCxNYVtoYisxXT1HYS55LE1hW2hiKzJdPUdhLnosaGIrPTM7ZWxzZSBmb3IoQ2E9MDszPkNhO0NhKyspTWFbaGJdPVUueCxNYVtoYisxXT1VLnksTWFbaGIrMl09VS56LGhiKz0zO2ouYmluZEJ1ZmZlcihqLkFSUkFZX0JVRkZFUix2Ll9fd2ViZ2xOb3JtYWxCdWZmZXIpO2ouYnVmZmVyRGF0YShqLkFSUkFZX0JVRkZFUixNYSxEKX1pZih5YiYmQ2ImJk4pe0U9MDtmb3IoST1hYS5sZW5ndGg7RTxJO0UrKylpZihWPWFhW0VdLCQ9Q2JbVl0sXG52b2lkIDAhPT0kKWZvcihDYT0wOzM+Q2E7Q2ErKylFYT0kW0NhXSxiYltPYV09RWEueCxiYltPYSsxXT1FYS55LE9hKz0yOzA8T2EmJihqLmJpbmRCdWZmZXIoai5BUlJBWV9CVUZGRVIsdi5fX3dlYmdsVVZCdWZmZXIpLGouYnVmZmVyRGF0YShqLkFSUkFZX0JVRkZFUixiYixEKSl9aWYoeWImJkViJiZOKXtFPTA7Zm9yKEk9YWEubGVuZ3RoO0U8STtFKyspaWYoVj1hYVtFXSxGYT1FYltWXSx2b2lkIDAhPT1GYSlmb3IoQ2E9MDszPkNhO0NhKyspTGE9RmFbQ2FdLGNiW1BhXT1MYS54LGNiW1BhKzFdPUxhLnksUGErPTI7MDxQYSYmKGouYmluZEJ1ZmZlcihqLkFSUkFZX0JVRkZFUix2Ll9fd2ViZ2xVVjJCdWZmZXIpLGouYnVmZmVyRGF0YShqLkFSUkFZX0JVRkZFUixjYixEKSl9aWYoQmIpe0U9MDtmb3IoST1hYS5sZW5ndGg7RTxJO0UrKylQYltVYV09ZGIsUGJbVWErMV09ZGIrMSxQYltVYSsyXT1kYisyLFVhKz0zLHZiW3RiXT1kYix2Ylt0YisxXT1kYisxLHZiW3RiKzJdPWRiLHZiW3RiK1xuM109ZGIrMix2Ylt0Yis0XT1kYisxLHZiW3RiKzVdPWRiKzIsdGIrPTYsZGIrPTM7ai5iaW5kQnVmZmVyKGouRUxFTUVOVF9BUlJBWV9CVUZGRVIsdi5fX3dlYmdsRmFjZUJ1ZmZlcik7ai5idWZmZXJEYXRhKGouRUxFTUVOVF9BUlJBWV9CVUZGRVIsUGIsRCk7ai5iaW5kQnVmZmVyKGouRUxFTUVOVF9BUlJBWV9CVUZGRVIsdi5fX3dlYmdsTGluZUJ1ZmZlcik7ai5idWZmZXJEYXRhKGouRUxFTUVOVF9BUlJBWV9CVUZGRVIsdmIsRCl9aWYocGIpe0NhPTA7Zm9yKERhPXBiLmxlbmd0aDtDYTxEYTtDYSsrKWlmKEg9cGJbQ2FdLEguX19vcmlnaW5hbC5uZWVkc1VwZGF0ZSl7TD0wO2lmKDE9PT1ILnNpemUpaWYodm9pZCAwPT09SC5ib3VuZFRvfHxcInZlcnRpY2VzXCI9PT1ILmJvdW5kVG8pe0U9MDtmb3IoST1hYS5sZW5ndGg7RTxJO0UrKylNPWtiW2FhW0VdXSxILmFycmF5W0xdPUgudmFsdWVbTS5hXSxILmFycmF5W0wrMV09SC52YWx1ZVtNLmJdLEguYXJyYXlbTCsyXT1ILnZhbHVlW00uY10sXG5MKz0zfWVsc2V7aWYoXCJmYWNlc1wiPT09SC5ib3VuZFRvKXtFPTA7Zm9yKEk9YWEubGVuZ3RoO0U8STtFKyspTmE9SC52YWx1ZVthYVtFXV0sSC5hcnJheVtMXT1OYSxILmFycmF5W0wrMV09TmEsSC5hcnJheVtMKzJdPU5hLEwrPTN9fWVsc2UgaWYoMj09PUguc2l6ZSlpZih2b2lkIDA9PT1ILmJvdW5kVG98fFwidmVydGljZXNcIj09PUguYm91bmRUbyl7RT0wO2ZvcihJPWFhLmxlbmd0aDtFPEk7RSsrKU09a2JbYWFbRV1dLFA9SC52YWx1ZVtNLmFdLFg9SC52YWx1ZVtNLmJdLFc9SC52YWx1ZVtNLmNdLEguYXJyYXlbTF09UC54LEguYXJyYXlbTCsxXT1QLnksSC5hcnJheVtMKzJdPVgueCxILmFycmF5W0wrM109WC55LEguYXJyYXlbTCs0XT1XLngsSC5hcnJheVtMKzVdPVcueSxMKz02fWVsc2V7aWYoXCJmYWNlc1wiPT09SC5ib3VuZFRvKXtFPTA7Zm9yKEk9YWEubGVuZ3RoO0U8STtFKyspVz1YPVA9TmE9SC52YWx1ZVthYVtFXV0sSC5hcnJheVtMXT1QLngsSC5hcnJheVtMKzFdPVAueSxcbkguYXJyYXlbTCsyXT1YLngsSC5hcnJheVtMKzNdPVgueSxILmFycmF5W0wrNF09Vy54LEguYXJyYXlbTCs1XT1XLnksTCs9Nn19ZWxzZSBpZigzPT09SC5zaXplKXt2YXIgbmE7bmE9XCJjXCI9PT1ILnR5cGU/W1wiclwiLFwiZ1wiLFwiYlwiXTpbXCJ4XCIsXCJ5XCIsXCJ6XCJdO2lmKHZvaWQgMD09PUguYm91bmRUb3x8XCJ2ZXJ0aWNlc1wiPT09SC5ib3VuZFRvKXtFPTA7Zm9yKEk9YWEubGVuZ3RoO0U8STtFKyspTT1rYlthYVtFXV0sUD1ILnZhbHVlW00uYV0sWD1ILnZhbHVlW00uYl0sVz1ILnZhbHVlW00uY10sSC5hcnJheVtMXT1QW25hWzBdXSxILmFycmF5W0wrMV09UFtuYVsxXV0sSC5hcnJheVtMKzJdPVBbbmFbMl1dLEguYXJyYXlbTCszXT1YW25hWzBdXSxILmFycmF5W0wrNF09WFtuYVsxXV0sSC5hcnJheVtMKzVdPVhbbmFbMl1dLEguYXJyYXlbTCs2XT1XW25hWzBdXSxILmFycmF5W0wrN109V1tuYVsxXV0sSC5hcnJheVtMKzhdPVdbbmFbMl1dLEwrPTl9ZWxzZSBpZihcImZhY2VzXCI9PT1ILmJvdW5kVG8pe0U9XG4wO2ZvcihJPWFhLmxlbmd0aDtFPEk7RSsrKVc9WD1QPU5hPUgudmFsdWVbYWFbRV1dLEguYXJyYXlbTF09UFtuYVswXV0sSC5hcnJheVtMKzFdPVBbbmFbMV1dLEguYXJyYXlbTCsyXT1QW25hWzJdXSxILmFycmF5W0wrM109WFtuYVswXV0sSC5hcnJheVtMKzRdPVhbbmFbMV1dLEguYXJyYXlbTCs1XT1YW25hWzJdXSxILmFycmF5W0wrNl09V1tuYVswXV0sSC5hcnJheVtMKzddPVdbbmFbMV1dLEguYXJyYXlbTCs4XT1XW25hWzJdXSxMKz05fWVsc2UgaWYoXCJmYWNlVmVydGljZXNcIj09PUguYm91bmRUbyl7RT0wO2ZvcihJPWFhLmxlbmd0aDtFPEk7RSsrKU5hPUgudmFsdWVbYWFbRV1dLFA9TmFbMF0sWD1OYVsxXSxXPU5hWzJdLEguYXJyYXlbTF09UFtuYVswXV0sSC5hcnJheVtMKzFdPVBbbmFbMV1dLEguYXJyYXlbTCsyXT1QW25hWzJdXSxILmFycmF5W0wrM109WFtuYVswXV0sSC5hcnJheVtMKzRdPVhbbmFbMV1dLEguYXJyYXlbTCs1XT1YW25hWzJdXSxILmFycmF5W0wrNl09V1tuYVswXV0sXG5ILmFycmF5W0wrN109V1tuYVsxXV0sSC5hcnJheVtMKzhdPVdbbmFbMl1dLEwrPTl9fWVsc2UgaWYoND09PUguc2l6ZSlpZih2b2lkIDA9PT1ILmJvdW5kVG98fFwidmVydGljZXNcIj09PUguYm91bmRUbyl7RT0wO2ZvcihJPWFhLmxlbmd0aDtFPEk7RSsrKU09a2JbYWFbRV1dLFA9SC52YWx1ZVtNLmFdLFg9SC52YWx1ZVtNLmJdLFc9SC52YWx1ZVtNLmNdLEguYXJyYXlbTF09UC54LEguYXJyYXlbTCsxXT1QLnksSC5hcnJheVtMKzJdPVAueixILmFycmF5W0wrM109UC53LEguYXJyYXlbTCs0XT1YLngsSC5hcnJheVtMKzVdPVgueSxILmFycmF5W0wrNl09WC56LEguYXJyYXlbTCs3XT1YLncsSC5hcnJheVtMKzhdPVcueCxILmFycmF5W0wrOV09Vy55LEguYXJyYXlbTCsxMF09Vy56LEguYXJyYXlbTCsxMV09Vy53LEwrPTEyfWVsc2UgaWYoXCJmYWNlc1wiPT09SC5ib3VuZFRvKXtFPTA7Zm9yKEk9YWEubGVuZ3RoO0U8STtFKyspVz1YPVA9TmE9SC52YWx1ZVthYVtFXV0sSC5hcnJheVtMXT1cblAueCxILmFycmF5W0wrMV09UC55LEguYXJyYXlbTCsyXT1QLnosSC5hcnJheVtMKzNdPVAudyxILmFycmF5W0wrNF09WC54LEguYXJyYXlbTCs1XT1YLnksSC5hcnJheVtMKzZdPVgueixILmFycmF5W0wrN109WC53LEguYXJyYXlbTCs4XT1XLngsSC5hcnJheVtMKzldPVcueSxILmFycmF5W0wrMTBdPVcueixILmFycmF5W0wrMTFdPVcudyxMKz0xMn1lbHNlIGlmKFwiZmFjZVZlcnRpY2VzXCI9PT1ILmJvdW5kVG8pe0U9MDtmb3IoST1hYS5sZW5ndGg7RTxJO0UrKylOYT1ILnZhbHVlW2FhW0VdXSxQPU5hWzBdLFg9TmFbMV0sVz1OYVsyXSxILmFycmF5W0xdPVAueCxILmFycmF5W0wrMV09UC55LEguYXJyYXlbTCsyXT1QLnosSC5hcnJheVtMKzNdPVAudyxILmFycmF5W0wrNF09WC54LEguYXJyYXlbTCs1XT1YLnksSC5hcnJheVtMKzZdPVgueixILmFycmF5W0wrN109WC53LEguYXJyYXlbTCs4XT1XLngsSC5hcnJheVtMKzldPVcueSxILmFycmF5W0wrMTBdPVcueixILmFycmF5W0wrXG4xMV09Vy53LEwrPTEyfWouYmluZEJ1ZmZlcihqLkFSUkFZX0JVRkZFUixILmJ1ZmZlcik7ai5idWZmZXJEYXRhKGouQVJSQVlfQlVGRkVSLEguYXJyYXksRCl9fUYmJihkZWxldGUgdi5fX2luaXR0ZWRBcnJheXMsZGVsZXRlIHYuX19jb2xvckFycmF5LGRlbGV0ZSB2Ll9fbm9ybWFsQXJyYXksZGVsZXRlIHYuX190YW5nZW50QXJyYXksZGVsZXRlIHYuX191dkFycmF5LGRlbGV0ZSB2Ll9fdXYyQXJyYXksZGVsZXRlIHYuX19mYWNlQXJyYXksZGVsZXRlIHYuX192ZXJ0ZXhBcnJheSxkZWxldGUgdi5fX2xpbmVBcnJheSxkZWxldGUgdi5fX3NraW5JbmRleEFycmF5LGRlbGV0ZSB2Ll9fc2tpbldlaWdodEFycmF5KX19bC52ZXJ0aWNlc05lZWRVcGRhdGU9ITE7bC5tb3JwaFRhcmdldHNOZWVkVXBkYXRlPSExO2wuZWxlbWVudHNOZWVkVXBkYXRlPSExO2wudXZzTmVlZFVwZGF0ZT0hMTtsLm5vcm1hbHNOZWVkVXBkYXRlPSExO2wuY29sb3JzTmVlZFVwZGF0ZT0hMTtsLnRhbmdlbnRzTmVlZFVwZGF0ZT1cbiExO2wuYnVmZmVyc05lZWRVcGRhdGU9ITE7dC5hdHRyaWJ1dGVzJiZyKHQpfWVsc2UgaWYoaSBpbnN0YW5jZW9mIFRIUkVFLkxpbmUpe3Q9ZChpLGwpO3A9dC5hdHRyaWJ1dGVzJiZuKHQpO2lmKGwudmVydGljZXNOZWVkVXBkYXRlfHxsLmNvbG9yc05lZWRVcGRhdGV8fGwubGluZURpc3RhbmNlc05lZWRVcGRhdGV8fHApe3ZhciBZYT1sLFNiPWouRFlOQU1JQ19EUkFXLEliPXZvaWQgMCxKYj12b2lkIDAsS2I9dm9pZCAwLFRiPXZvaWQgMCxtYT12b2lkIDAsVWI9dm9pZCAwLEdiPVlhLnZlcnRpY2VzLEhiPVlhLmNvbG9ycyxrYz1ZYS5saW5lRGlzdGFuY2VzLFpiPUdiLmxlbmd0aCwkYj1IYi5sZW5ndGgsYWM9a2MubGVuZ3RoLFZiPVlhLl9fdmVydGV4QXJyYXksV2I9WWEuX19jb2xvckFycmF5LGxjPVlhLl9fbGluZURpc3RhbmNlQXJyYXksYmM9WWEuY29sb3JzTmVlZFVwZGF0ZSxjYz1ZYS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSxnYz1ZYS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QsXG5YYj12b2lkIDAsbWM9dm9pZCAwLHphPXZvaWQgMCx6Yj12b2lkIDAsSmE9dm9pZCAwLGphPXZvaWQgMDtpZihZYS52ZXJ0aWNlc05lZWRVcGRhdGUpe2ZvcihJYj0wO0liPFpiO0liKyspVGI9R2JbSWJdLG1hPTMqSWIsVmJbbWFdPVRiLngsVmJbbWErMV09VGIueSxWYlttYSsyXT1UYi56O2ouYmluZEJ1ZmZlcihqLkFSUkFZX0JVRkZFUixZYS5fX3dlYmdsVmVydGV4QnVmZmVyKTtqLmJ1ZmZlckRhdGEoai5BUlJBWV9CVUZGRVIsVmIsU2IpfWlmKGJjKXtmb3IoSmI9MDtKYjwkYjtKYisrKVViPUhiW0piXSxtYT0zKkpiLFdiW21hXT1VYi5yLFdiW21hKzFdPVViLmcsV2JbbWErMl09VWIuYjtqLmJpbmRCdWZmZXIoai5BUlJBWV9CVUZGRVIsWWEuX193ZWJnbENvbG9yQnVmZmVyKTtqLmJ1ZmZlckRhdGEoai5BUlJBWV9CVUZGRVIsV2IsU2IpfWlmKGNjKXtmb3IoS2I9MDtLYjxhYztLYisrKWxjW0tiXT1rY1tLYl07ai5iaW5kQnVmZmVyKGouQVJSQVlfQlVGRkVSLFlhLl9fd2ViZ2xMaW5lRGlzdGFuY2VCdWZmZXIpO1xuai5idWZmZXJEYXRhKGouQVJSQVlfQlVGRkVSLGxjLFNiKX1pZihnYyl7WGI9MDtmb3IobWM9Z2MubGVuZ3RoO1hiPG1jO1hiKyspaWYoamE9Z2NbWGJdLGphLm5lZWRzVXBkYXRlJiYodm9pZCAwPT09amEuYm91bmRUb3x8XCJ2ZXJ0aWNlc1wiPT09amEuYm91bmRUbykpe21hPTA7emI9amEudmFsdWUubGVuZ3RoO2lmKDE9PT1qYS5zaXplKWZvcih6YT0wO3phPHpiO3phKyspamEuYXJyYXlbemFdPWphLnZhbHVlW3phXTtlbHNlIGlmKDI9PT1qYS5zaXplKWZvcih6YT0wO3phPHpiO3phKyspSmE9amEudmFsdWVbemFdLGphLmFycmF5W21hXT1KYS54LGphLmFycmF5W21hKzFdPUphLnksbWErPTI7ZWxzZSBpZigzPT09amEuc2l6ZSlpZihcImNcIj09PWphLnR5cGUpZm9yKHphPTA7emE8emI7emErKylKYT1qYS52YWx1ZVt6YV0samEuYXJyYXlbbWFdPUphLnIsamEuYXJyYXlbbWErMV09SmEuZyxqYS5hcnJheVttYSsyXT1KYS5iLG1hKz0zO2Vsc2UgZm9yKHphPTA7emE8emI7emErKylKYT1cbmphLnZhbHVlW3phXSxqYS5hcnJheVttYV09SmEueCxqYS5hcnJheVttYSsxXT1KYS55LGphLmFycmF5W21hKzJdPUphLnosbWErPTM7ZWxzZSBpZig0PT09amEuc2l6ZSlmb3IoemE9MDt6YTx6Yjt6YSsrKUphPWphLnZhbHVlW3phXSxqYS5hcnJheVttYV09SmEueCxqYS5hcnJheVttYSsxXT1KYS55LGphLmFycmF5W21hKzJdPUphLnosamEuYXJyYXlbbWErM109SmEudyxtYSs9NDtqLmJpbmRCdWZmZXIoai5BUlJBWV9CVUZGRVIsamEuYnVmZmVyKTtqLmJ1ZmZlckRhdGEoai5BUlJBWV9CVUZGRVIsamEuYXJyYXksU2IpfX19bC52ZXJ0aWNlc05lZWRVcGRhdGU9ITE7bC5jb2xvcnNOZWVkVXBkYXRlPSExO2wubGluZURpc3RhbmNlc05lZWRVcGRhdGU9ITE7dC5hdHRyaWJ1dGVzJiZyKHQpfWVsc2UgaWYoaSBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlU3lzdGVtKXt0PWQoaSxsKTtwPXQuYXR0cmlidXRlcyYmbih0KTtpZihsLnZlcnRpY2VzTmVlZFVwZGF0ZXx8bC5jb2xvcnNOZWVkVXBkYXRlfHxcbmkuc29ydFBhcnRpY2xlc3x8cCl7dmFyIGxiPWwsaGM9ai5EWU5BTUlDX0RSQVcsTGI9aSxLYT12b2lkIDAsbWI9dm9pZCAwLG5iPXZvaWQgMCxUPXZvaWQgMCxvYj12b2lkIDAsdWI9dm9pZCAwLFliPWxiLnZlcnRpY2VzLGljPVliLmxlbmd0aCxqYz1sYi5jb2xvcnMsbmM9amMubGVuZ3RoLHdiPWxiLl9fdmVydGV4QXJyYXkseGI9bGIuX19jb2xvckFycmF5LHFiPWxiLl9fc29ydEFycmF5LG9jPWxiLnZlcnRpY2VzTmVlZFVwZGF0ZSxwYz1sYi5jb2xvcnNOZWVkVXBkYXRlLHJiPWxiLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdCwkYT12b2lkIDAsQWI9dm9pZCAwLFk9dm9pZCAwLGFiPXZvaWQgMCxoYT12b2lkIDAsUz12b2lkIDA7aWYoTGIuc29ydFBhcnRpY2xlcyl7Z2IuY29weShyYSk7Z2IubXVsdGlwbHkoTGIubWF0cml4V29ybGQpO2ZvcihLYT0wO0thPGljO0thKyspbmI9WWJbS2FdLHNhLmNvcHkobmIpLHNhLmFwcGx5UHJvamVjdGlvbihnYikscWJbS2FdPVtzYS56LFxuS2FdO3FiLnNvcnQoayk7Zm9yKEthPTA7S2E8aWM7S2ErKyluYj1ZYltxYltLYV1bMV1dLFQ9MypLYSx3YltUXT1uYi54LHdiW1QrMV09bmIueSx3YltUKzJdPW5iLno7Zm9yKG1iPTA7bWI8bmM7bWIrKylUPTMqbWIsdWI9amNbcWJbbWJdWzFdXSx4YltUXT11Yi5yLHhiW1QrMV09dWIuZyx4YltUKzJdPXViLmI7aWYocmIpeyRhPTA7Zm9yKEFiPXJiLmxlbmd0aDskYTxBYjskYSsrKWlmKFM9cmJbJGFdLHZvaWQgMD09PVMuYm91bmRUb3x8XCJ2ZXJ0aWNlc1wiPT09Uy5ib3VuZFRvKWlmKFQ9MCxhYj1TLnZhbHVlLmxlbmd0aCwxPT09Uy5zaXplKWZvcihZPTA7WTxhYjtZKyspb2I9cWJbWV1bMV0sUy5hcnJheVtZXT1TLnZhbHVlW29iXTtlbHNlIGlmKDI9PT1TLnNpemUpZm9yKFk9MDtZPGFiO1krKylvYj1xYltZXVsxXSxoYT1TLnZhbHVlW29iXSxTLmFycmF5W1RdPWhhLngsUy5hcnJheVtUKzFdPWhhLnksVCs9MjtlbHNlIGlmKDM9PT1TLnNpemUpaWYoXCJjXCI9PT1TLnR5cGUpZm9yKFk9XG4wO1k8YWI7WSsrKW9iPXFiW1ldWzFdLGhhPVMudmFsdWVbb2JdLFMuYXJyYXlbVF09aGEucixTLmFycmF5W1QrMV09aGEuZyxTLmFycmF5W1QrMl09aGEuYixUKz0zO2Vsc2UgZm9yKFk9MDtZPGFiO1krKylvYj1xYltZXVsxXSxoYT1TLnZhbHVlW29iXSxTLmFycmF5W1RdPWhhLngsUy5hcnJheVtUKzFdPWhhLnksUy5hcnJheVtUKzJdPWhhLnosVCs9MztlbHNlIGlmKDQ9PT1TLnNpemUpZm9yKFk9MDtZPGFiO1krKylvYj1xYltZXVsxXSxoYT1TLnZhbHVlW29iXSxTLmFycmF5W1RdPWhhLngsUy5hcnJheVtUKzFdPWhhLnksUy5hcnJheVtUKzJdPWhhLnosUy5hcnJheVtUKzNdPWhhLncsVCs9NH19ZWxzZXtpZihvYylmb3IoS2E9MDtLYTxpYztLYSsrKW5iPVliW0thXSxUPTMqS2Esd2JbVF09bmIueCx3YltUKzFdPW5iLnksd2JbVCsyXT1uYi56O2lmKHBjKWZvcihtYj0wO21iPG5jO21iKyspdWI9amNbbWJdLFQ9MyptYix4YltUXT11Yi5yLHhiW1QrMV09dWIuZyx4YltUKzJdPXViLmI7XG5pZihyYil7JGE9MDtmb3IoQWI9cmIubGVuZ3RoOyRhPEFiOyRhKyspaWYoUz1yYlskYV0sUy5uZWVkc1VwZGF0ZSYmKHZvaWQgMD09PVMuYm91bmRUb3x8XCJ2ZXJ0aWNlc1wiPT09Uy5ib3VuZFRvKSlpZihhYj1TLnZhbHVlLmxlbmd0aCxUPTAsMT09PVMuc2l6ZSlmb3IoWT0wO1k8YWI7WSsrKVMuYXJyYXlbWV09Uy52YWx1ZVtZXTtlbHNlIGlmKDI9PT1TLnNpemUpZm9yKFk9MDtZPGFiO1krKyloYT1TLnZhbHVlW1ldLFMuYXJyYXlbVF09aGEueCxTLmFycmF5W1QrMV09aGEueSxUKz0yO2Vsc2UgaWYoMz09PVMuc2l6ZSlpZihcImNcIj09PVMudHlwZSlmb3IoWT0wO1k8YWI7WSsrKWhhPVMudmFsdWVbWV0sUy5hcnJheVtUXT1oYS5yLFMuYXJyYXlbVCsxXT1oYS5nLFMuYXJyYXlbVCsyXT1oYS5iLFQrPTM7ZWxzZSBmb3IoWT0wO1k8YWI7WSsrKWhhPVMudmFsdWVbWV0sUy5hcnJheVtUXT1oYS54LFMuYXJyYXlbVCsxXT1oYS55LFMuYXJyYXlbVCsyXT1oYS56LFQrPTM7ZWxzZSBpZig0PT09XG5TLnNpemUpZm9yKFk9MDtZPGFiO1krKyloYT1TLnZhbHVlW1ldLFMuYXJyYXlbVF09aGEueCxTLmFycmF5W1QrMV09aGEueSxTLmFycmF5W1QrMl09aGEueixTLmFycmF5W1QrM109aGEudyxUKz00fX1pZihvY3x8TGIuc29ydFBhcnRpY2xlcylqLmJpbmRCdWZmZXIoai5BUlJBWV9CVUZGRVIsbGIuX193ZWJnbFZlcnRleEJ1ZmZlciksai5idWZmZXJEYXRhKGouQVJSQVlfQlVGRkVSLHdiLGhjKTtpZihwY3x8TGIuc29ydFBhcnRpY2xlcylqLmJpbmRCdWZmZXIoai5BUlJBWV9CVUZGRVIsbGIuX193ZWJnbENvbG9yQnVmZmVyKSxqLmJ1ZmZlckRhdGEoai5BUlJBWV9CVUZGRVIseGIsaGMpO2lmKHJiKXskYT0wO2ZvcihBYj1yYi5sZW5ndGg7JGE8QWI7JGErKylpZihTPXJiWyRhXSxTLm5lZWRzVXBkYXRlfHxMYi5zb3J0UGFydGljbGVzKWouYmluZEJ1ZmZlcihqLkFSUkFZX0JVRkZFUixTLmJ1ZmZlciksai5idWZmZXJEYXRhKGouQVJSQVlfQlVGRkVSLFMuYXJyYXksaGMpfX1sLnZlcnRpY2VzTmVlZFVwZGF0ZT1cbiExO2wuY29sb3JzTmVlZFVwZGF0ZT0hMTt0LmF0dHJpYnV0ZXMmJnIodCl9fX07dGhpcy5pbml0TWF0ZXJpYWw9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGUsZixoLGc7YS5hZGRFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLEZiKTt2YXIgaSxrLGwsbSxwO2EgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbD9wPVwiZGVwdGhcIjphIGluc3RhbmNlb2YgVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsP3A9XCJub3JtYWxcIjphIGluc3RhbmNlb2YgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWw/cD1cImJhc2ljXCI6YSBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWw/cD1cImxhbWJlcnRcIjphIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWw/cD1cInBob25nXCI6YSBpbnN0YW5jZW9mIFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsP3A9XCJiYXNpY1wiOmEgaW5zdGFuY2VvZiBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWw/cD1cImRhc2hlZFwiOmEgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsJiZcbihwPVwicGFydGljbGVfYmFzaWNcIik7aWYocCl7dmFyIG49VEhSRUUuU2hhZGVyTGliW3BdO2EudW5pZm9ybXM9VEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZShuLnVuaWZvcm1zKTthLnZlcnRleFNoYWRlcj1uLnZlcnRleFNoYWRlcjthLmZyYWdtZW50U2hhZGVyPW4uZnJhZ21lbnRTaGFkZXJ9dmFyIHE9ZT0wLHI9MCx0PW49MDtmb3IoZj1iLmxlbmd0aDt0PGY7dCsrKWg9Ylt0XSxoLm9ubHlTaGFkb3d8fChoIGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCYmZSsrLGggaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0JiZxKyssaCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCYmcisrLGggaW5zdGFuY2VvZiBUSFJFRS5IZW1pc3BoZXJlTGlnaHQmJm4rKyk7Zj1xO2g9cjtnPW47cj1uPTA7Zm9yKHE9Yi5sZW5ndGg7cjxxO3IrKyl0PWJbcl0sdC5jYXN0U2hhZG93JiYodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCYmbisrLHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0JiZcbiF0LnNoYWRvd0Nhc2NhZGUmJm4rKyk7bT1uO3liJiZkJiZkLnVzZVZlcnRleFRleHR1cmU/bD0xMDI0OihiPWouZ2V0UGFyYW1ldGVyKGouTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMpLGI9TWF0aC5mbG9vcigoYi0yMCkvNCksdm9pZCAwIT09ZCYmZCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoJiYoYj1NYXRoLm1pbihkLmJvbmVzLmxlbmd0aCxiKSxiPGQuYm9uZXMubGVuZ3RoJiZjb25zb2xlLndhcm4oXCJXZWJHTFJlbmRlcmVyOiB0b28gbWFueSBib25lcyAtIFwiK2QuYm9uZXMubGVuZ3RoK1wiLCB0aGlzIEdQVSBzdXBwb3J0cyBqdXN0IFwiK2IrXCIgKHRyeSBPcGVuR0wgaW5zdGVhZCBvZiBBTkdMRSlcIikpLGw9Yik7YTp7dmFyIHI9YS5mcmFnbWVudFNoYWRlcixxPWEudmVydGV4U2hhZGVyLG49YS51bmlmb3JtcyxiPWEuYXR0cmlidXRlcyx0PWEuZGVmaW5lcyxjPXttYXA6ISFhLm1hcCxlbnZNYXA6ISFhLmVudk1hcCxsaWdodE1hcDohIWEubGlnaHRNYXAsYnVtcE1hcDohIWEuYnVtcE1hcCxcbm5vcm1hbE1hcDohIWEubm9ybWFsTWFwLHNwZWN1bGFyTWFwOiEhYS5zcGVjdWxhck1hcCx2ZXJ0ZXhDb2xvcnM6YS52ZXJ0ZXhDb2xvcnMsZm9nOmMsdXNlRm9nOmEuZm9nLGZvZ0V4cDpjIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMixzaXplQXR0ZW51YXRpb246YS5zaXplQXR0ZW51YXRpb24sc2tpbm5pbmc6YS5za2lubmluZyxtYXhCb25lczpsLHVzZVZlcnRleFRleHR1cmU6eWImJmQmJmQudXNlVmVydGV4VGV4dHVyZSxtb3JwaFRhcmdldHM6YS5tb3JwaFRhcmdldHMsbW9ycGhOb3JtYWxzOmEubW9ycGhOb3JtYWxzLG1heE1vcnBoVGFyZ2V0czp0aGlzLm1heE1vcnBoVGFyZ2V0cyxtYXhNb3JwaE5vcm1hbHM6dGhpcy5tYXhNb3JwaE5vcm1hbHMsbWF4RGlyTGlnaHRzOmUsbWF4UG9pbnRMaWdodHM6ZixtYXhTcG90TGlnaHRzOmgsbWF4SGVtaUxpZ2h0czpnLG1heFNoYWRvd3M6bSxzaGFkb3dNYXBFbmFibGVkOnRoaXMuc2hhZG93TWFwRW5hYmxlZCYmZC5yZWNlaXZlU2hhZG93LFxuc2hhZG93TWFwVHlwZTp0aGlzLnNoYWRvd01hcFR5cGUsc2hhZG93TWFwRGVidWc6dGhpcy5zaGFkb3dNYXBEZWJ1ZyxzaGFkb3dNYXBDYXNjYWRlOnRoaXMuc2hhZG93TWFwQ2FzY2FkZSxhbHBoYVRlc3Q6YS5hbHBoYVRlc3QsbWV0YWw6YS5tZXRhbCxwZXJQaXhlbDphLnBlclBpeGVsLHdyYXBBcm91bmQ6YS53cmFwQXJvdW5kLGRvdWJsZVNpZGVkOmEuc2lkZT09PVRIUkVFLkRvdWJsZVNpZGUsZmxpcFNpZGVkOmEuc2lkZT09PVRIUkVFLkJhY2tTaWRlfSxkPWEuaW5kZXgwQXR0cmlidXRlTmFtZSxzLHUsdztlPVtdO3A/ZS5wdXNoKHApOihlLnB1c2gociksZS5wdXNoKHEpKTtmb3IodSBpbiB0KWUucHVzaCh1KSxlLnB1c2godFt1XSk7Zm9yKHMgaW4gYyllLnB1c2gocyksZS5wdXNoKGNbc10pO3A9ZS5qb2luKCk7cz0wO2Zvcih1PWNhLmxlbmd0aDtzPHU7cysrKWlmKGU9Y2Fbc10sZS5jb2RlPT09cCl7ZS51c2VkVGltZXMrKztrPWUucHJvZ3JhbTticmVhayBhfXM9XCJTSEFET1dNQVBfVFlQRV9CQVNJQ1wiO1xuYy5zaGFkb3dNYXBUeXBlPT09VEhSRUUuUENGU2hhZG93TWFwP3M9XCJTSEFET1dNQVBfVFlQRV9QQ0ZcIjpjLnNoYWRvd01hcFR5cGU9PT1USFJFRS5QQ0ZTb2Z0U2hhZG93TWFwJiYocz1cIlNIQURPV01BUF9UWVBFX1BDRl9TT0ZUXCIpO3U9W107Zm9yKHcgaW4gdCllPXRbd10sITEhPT1lJiYoZT1cIiNkZWZpbmUgXCIrdytcIiBcIitlLHUucHVzaChlKSk7ZT11LmpvaW4oXCJcXG5cIik7dz1qLmNyZWF0ZVByb2dyYW0oKTt1PVtcInByZWNpc2lvbiBcIitSK1wiIGZsb2F0O1wiLFwicHJlY2lzaW9uIFwiK1IrXCIgaW50O1wiLGUsQmI/XCIjZGVmaW5lIFZFUlRFWF9URVhUVVJFU1wiOlwiXCIsSy5nYW1tYUlucHV0P1wiI2RlZmluZSBHQU1NQV9JTlBVVFwiOlwiXCIsSy5nYW1tYU91dHB1dD9cIiNkZWZpbmUgR0FNTUFfT1VUUFVUXCI6XCJcIixLLnBoeXNpY2FsbHlCYXNlZFNoYWRpbmc/XCIjZGVmaW5lIFBIWVNJQ0FMTFlfQkFTRURfU0hBRElOR1wiOlwiXCIsXCIjZGVmaW5lIE1BWF9ESVJfTElHSFRTIFwiK2MubWF4RGlyTGlnaHRzLFwiI2RlZmluZSBNQVhfUE9JTlRfTElHSFRTIFwiK1xuYy5tYXhQb2ludExpZ2h0cyxcIiNkZWZpbmUgTUFYX1NQT1RfTElHSFRTIFwiK2MubWF4U3BvdExpZ2h0cyxcIiNkZWZpbmUgTUFYX0hFTUlfTElHSFRTIFwiK2MubWF4SGVtaUxpZ2h0cyxcIiNkZWZpbmUgTUFYX1NIQURPV1MgXCIrYy5tYXhTaGFkb3dzLFwiI2RlZmluZSBNQVhfQk9ORVMgXCIrYy5tYXhCb25lcyxjLm1hcD9cIiNkZWZpbmUgVVNFX01BUFwiOlwiXCIsYy5lbnZNYXA/XCIjZGVmaW5lIFVTRV9FTlZNQVBcIjpcIlwiLGMubGlnaHRNYXA/XCIjZGVmaW5lIFVTRV9MSUdIVE1BUFwiOlwiXCIsYy5idW1wTWFwP1wiI2RlZmluZSBVU0VfQlVNUE1BUFwiOlwiXCIsYy5ub3JtYWxNYXA/XCIjZGVmaW5lIFVTRV9OT1JNQUxNQVBcIjpcIlwiLGMuc3BlY3VsYXJNYXA/XCIjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUFwiOlwiXCIsYy52ZXJ0ZXhDb2xvcnM/XCIjZGVmaW5lIFVTRV9DT0xPUlwiOlwiXCIsYy5za2lubmluZz9cIiNkZWZpbmUgVVNFX1NLSU5OSU5HXCI6XCJcIixjLnVzZVZlcnRleFRleHR1cmU/XCIjZGVmaW5lIEJPTkVfVEVYVFVSRVwiOlxuXCJcIixjLm1vcnBoVGFyZ2V0cz9cIiNkZWZpbmUgVVNFX01PUlBIVEFSR0VUU1wiOlwiXCIsYy5tb3JwaE5vcm1hbHM/XCIjZGVmaW5lIFVTRV9NT1JQSE5PUk1BTFNcIjpcIlwiLGMucGVyUGl4ZWw/XCIjZGVmaW5lIFBIT05HX1BFUl9QSVhFTFwiOlwiXCIsYy53cmFwQXJvdW5kP1wiI2RlZmluZSBXUkFQX0FST1VORFwiOlwiXCIsYy5kb3VibGVTaWRlZD9cIiNkZWZpbmUgRE9VQkxFX1NJREVEXCI6XCJcIixjLmZsaXBTaWRlZD9cIiNkZWZpbmUgRkxJUF9TSURFRFwiOlwiXCIsYy5zaGFkb3dNYXBFbmFibGVkP1wiI2RlZmluZSBVU0VfU0hBRE9XTUFQXCI6XCJcIixjLnNoYWRvd01hcEVuYWJsZWQ/XCIjZGVmaW5lIFwiK3M6XCJcIixjLnNoYWRvd01hcERlYnVnP1wiI2RlZmluZSBTSEFET1dNQVBfREVCVUdcIjpcIlwiLGMuc2hhZG93TWFwQ2FzY2FkZT9cIiNkZWZpbmUgU0hBRE9XTUFQX0NBU0NBREVcIjpcIlwiLGMuc2l6ZUF0dGVudWF0aW9uP1wiI2RlZmluZSBVU0VfU0laRUFUVEVOVUFUSU9OXCI6XCJcIixcInVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7XFxudW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcXG5hdHRyaWJ1dGUgdmVjMiB1djtcXG5hdHRyaWJ1dGUgdmVjMiB1djI7XFxuI2lmZGVmIFVTRV9DT0xPUlxcbmF0dHJpYnV0ZSB2ZWMzIGNvbG9yO1xcbiNlbmRpZlxcbiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQwO1xcbmF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MTtcXG5hdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDI7XFxuYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQzO1xcbiNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuYXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwwO1xcbmF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMTtcXG5hdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDI7XFxuYXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwzO1xcbiNlbHNlXFxuYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ0O1xcbmF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NTtcXG5hdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDY7XFxuYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ3O1xcbiNlbmRpZlxcbiNlbmRpZlxcbiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5hdHRyaWJ1dGUgdmVjNCBza2luSW5kZXg7XFxuYXR0cmlidXRlIHZlYzQgc2tpbldlaWdodDtcXG4jZW5kaWZcXG5cIl0uam9pbihcIlxcblwiKTtcbnM9W1wicHJlY2lzaW9uIFwiK1IrXCIgZmxvYXQ7XCIsXCJwcmVjaXNpb24gXCIrUitcIiBpbnQ7XCIsYy5idW1wTWFwfHxjLm5vcm1hbE1hcD9cIiNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlXCI6XCJcIixlLFwiI2RlZmluZSBNQVhfRElSX0xJR0hUUyBcIitjLm1heERpckxpZ2h0cyxcIiNkZWZpbmUgTUFYX1BPSU5UX0xJR0hUUyBcIitjLm1heFBvaW50TGlnaHRzLFwiI2RlZmluZSBNQVhfU1BPVF9MSUdIVFMgXCIrYy5tYXhTcG90TGlnaHRzLFwiI2RlZmluZSBNQVhfSEVNSV9MSUdIVFMgXCIrYy5tYXhIZW1pTGlnaHRzLFwiI2RlZmluZSBNQVhfU0hBRE9XUyBcIitjLm1heFNoYWRvd3MsYy5hbHBoYVRlc3Q/XCIjZGVmaW5lIEFMUEhBVEVTVCBcIitjLmFscGhhVGVzdDpcIlwiLEsuZ2FtbWFJbnB1dD9cIiNkZWZpbmUgR0FNTUFfSU5QVVRcIjpcIlwiLEsuZ2FtbWFPdXRwdXQ/XCIjZGVmaW5lIEdBTU1BX09VVFBVVFwiOlwiXCIsSy5waHlzaWNhbGx5QmFzZWRTaGFkaW5nP1wiI2RlZmluZSBQSFlTSUNBTExZX0JBU0VEX1NIQURJTkdcIjpcblwiXCIsYy51c2VGb2cmJmMuZm9nP1wiI2RlZmluZSBVU0VfRk9HXCI6XCJcIixjLnVzZUZvZyYmYy5mb2dFeHA/XCIjZGVmaW5lIEZPR19FWFAyXCI6XCJcIixjLm1hcD9cIiNkZWZpbmUgVVNFX01BUFwiOlwiXCIsYy5lbnZNYXA/XCIjZGVmaW5lIFVTRV9FTlZNQVBcIjpcIlwiLGMubGlnaHRNYXA/XCIjZGVmaW5lIFVTRV9MSUdIVE1BUFwiOlwiXCIsYy5idW1wTWFwP1wiI2RlZmluZSBVU0VfQlVNUE1BUFwiOlwiXCIsYy5ub3JtYWxNYXA/XCIjZGVmaW5lIFVTRV9OT1JNQUxNQVBcIjpcIlwiLGMuc3BlY3VsYXJNYXA/XCIjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUFwiOlwiXCIsYy52ZXJ0ZXhDb2xvcnM/XCIjZGVmaW5lIFVTRV9DT0xPUlwiOlwiXCIsYy5tZXRhbD9cIiNkZWZpbmUgTUVUQUxcIjpcIlwiLGMucGVyUGl4ZWw/XCIjZGVmaW5lIFBIT05HX1BFUl9QSVhFTFwiOlwiXCIsYy53cmFwQXJvdW5kP1wiI2RlZmluZSBXUkFQX0FST1VORFwiOlwiXCIsYy5kb3VibGVTaWRlZD9cIiNkZWZpbmUgRE9VQkxFX1NJREVEXCI6XCJcIixjLmZsaXBTaWRlZD9cIiNkZWZpbmUgRkxJUF9TSURFRFwiOlxuXCJcIixjLnNoYWRvd01hcEVuYWJsZWQ/XCIjZGVmaW5lIFVTRV9TSEFET1dNQVBcIjpcIlwiLGMuc2hhZG93TWFwRW5hYmxlZD9cIiNkZWZpbmUgXCIrczpcIlwiLGMuc2hhZG93TWFwRGVidWc/XCIjZGVmaW5lIFNIQURPV01BUF9ERUJVR1wiOlwiXCIsYy5zaGFkb3dNYXBDYXNjYWRlP1wiI2RlZmluZSBTSEFET1dNQVBfQ0FTQ0FERVwiOlwiXCIsXCJ1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcXG51bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247XFxuXCJdLmpvaW4oXCJcXG5cIik7dT1DKFwidmVydGV4XCIsdStxKTtzPUMoXCJmcmFnbWVudFwiLHMrcik7ai5hdHRhY2hTaGFkZXIodyx1KTtqLmF0dGFjaFNoYWRlcih3LHMpO2QmJmouYmluZEF0dHJpYkxvY2F0aW9uKHcsMCxkKTtqLmxpbmtQcm9ncmFtKHcpO2ouZ2V0UHJvZ3JhbVBhcmFtZXRlcih3LGouTElOS19TVEFUVVMpfHwoY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBpbml0aWFsaXNlIHNoYWRlclxcblZBTElEQVRFX1NUQVRVUzogXCIrai5nZXRQcm9ncmFtUGFyYW1ldGVyKHcsXG5qLlZBTElEQVRFX1NUQVRVUykrXCIsIGdsIGVycm9yIFtcIitqLmdldEVycm9yKCkrXCJdXCIpLGNvbnNvbGUuZXJyb3IoXCJQcm9ncmFtIEluZm8gTG9nOiBcIitqLmdldFByb2dyYW1JbmZvTG9nKHcpKSk7ai5kZWxldGVTaGFkZXIocyk7ai5kZWxldGVTaGFkZXIodSk7dy51bmlmb3Jtcz17fTt3LmF0dHJpYnV0ZXM9e307dmFyIHY7cz1cInZpZXdNYXRyaXggbW9kZWxWaWV3TWF0cml4IHByb2plY3Rpb25NYXRyaXggbm9ybWFsTWF0cml4IG1vZGVsTWF0cml4IGNhbWVyYVBvc2l0aW9uIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1wiLnNwbGl0KFwiIFwiKTtjLnVzZVZlcnRleFRleHR1cmU/KHMucHVzaChcImJvbmVUZXh0dXJlXCIpLHMucHVzaChcImJvbmVUZXh0dXJlV2lkdGhcIikscy5wdXNoKFwiYm9uZVRleHR1cmVIZWlnaHRcIikpOnMucHVzaChcImJvbmVHbG9iYWxNYXRyaWNlc1wiKTtmb3IodiBpbiBuKXMucHVzaCh2KTt2PXM7cz0wO2Zvcih1PXYubGVuZ3RoO3M8dTtzKyspbj12W3NdLHcudW5pZm9ybXNbbl09XG5qLmdldFVuaWZvcm1Mb2NhdGlvbih3LG4pO3M9XCJwb3NpdGlvbiBub3JtYWwgdXYgdXYyIHRhbmdlbnQgY29sb3Igc2tpbkluZGV4IHNraW5XZWlnaHQgbGluZURpc3RhbmNlXCIuc3BsaXQoXCIgXCIpO2Zvcih2PTA7djxjLm1heE1vcnBoVGFyZ2V0czt2Kyspcy5wdXNoKFwibW9ycGhUYXJnZXRcIit2KTtmb3Iodj0wO3Y8Yy5tYXhNb3JwaE5vcm1hbHM7disrKXMucHVzaChcIm1vcnBoTm9ybWFsXCIrdik7Zm9yKGsgaW4gYilzLnB1c2goayk7az1zO3Y9MDtmb3IoYj1rLmxlbmd0aDt2PGI7disrKXM9a1t2XSx3LmF0dHJpYnV0ZXNbc109ai5nZXRBdHRyaWJMb2NhdGlvbih3LHMpO3cuaWQ9RmErKztjYS5wdXNoKHtwcm9ncmFtOncsY29kZTpwLHVzZWRUaW1lczoxfSk7Sy5pbmZvLm1lbW9yeS5wcm9ncmFtcz1jYS5sZW5ndGg7az13fWEucHJvZ3JhbT1rO3Y9YS5wcm9ncmFtLmF0dHJpYnV0ZXM7aWYoYS5tb3JwaFRhcmdldHMpe2EubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzPTA7Yj1cIm1vcnBoVGFyZ2V0XCI7XG5mb3Ioaz0wO2s8dGhpcy5tYXhNb3JwaFRhcmdldHM7aysrKXc9YitrLDA8PXZbd10mJmEubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzKyt9aWYoYS5tb3JwaE5vcm1hbHMpe2EubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzPTA7Yj1cIm1vcnBoTm9ybWFsXCI7Zm9yKGs9MDtrPHRoaXMubWF4TW9ycGhOb3JtYWxzO2srKyl3PWIraywwPD12W3ddJiZhLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscysrfWEudW5pZm9ybXNMaXN0PVtdO2ZvcihpIGluIGEudW5pZm9ybXMpYS51bmlmb3Jtc0xpc3QucHVzaChbYS51bmlmb3Jtc1tpXSxpXSl9O3RoaXMuc2V0RmFjZUN1bGxpbmc9ZnVuY3Rpb24oYSxiKXthPT09VEhSRUUuQ3VsbEZhY2VOb25lP2ouZGlzYWJsZShqLkNVTExfRkFDRSk6KGI9PT1USFJFRS5Gcm9udEZhY2VEaXJlY3Rpb25DVz9qLmZyb250RmFjZShqLkNXKTpqLmZyb250RmFjZShqLkNDVyksYT09PVRIUkVFLkN1bGxGYWNlQmFjaz9qLmN1bGxGYWNlKGouQkFDSyk6YT09PVRIUkVFLkN1bGxGYWNlRnJvbnQ/XG5qLmN1bGxGYWNlKGouRlJPTlQpOmouY3VsbEZhY2Uoai5GUk9OVF9BTkRfQkFDSyksai5lbmFibGUoai5DVUxMX0ZBQ0UpKX07dGhpcy5zZXRNYXRlcmlhbEZhY2VzPWZ1bmN0aW9uKGEpe3ZhciBiPWEuc2lkZT09PVRIUkVFLkRvdWJsZVNpZGUsYT1hLnNpZGU9PT1USFJFRS5CYWNrU2lkZTtaIT09YiYmKGI/ai5kaXNhYmxlKGouQ1VMTF9GQUNFKTpqLmVuYWJsZShqLkNVTExfRkFDRSksWj1iKTtVIT09YSYmKGE/ai5mcm9udEZhY2Uoai5DVyk6ai5mcm9udEZhY2Uoai5DQ1cpLFU9YSl9O3RoaXMuc2V0RGVwdGhUZXN0PWZ1bmN0aW9uKGEpe0dhIT09YSYmKGE/ai5lbmFibGUoai5ERVBUSF9URVNUKTpqLmRpc2FibGUoai5ERVBUSF9URVNUKSxHYT1hKX07dGhpcy5zZXREZXB0aFdyaXRlPWZ1bmN0aW9uKGEpe2ZhIT09YSYmKGouZGVwdGhNYXNrKGEpLGZhPWEpfTt0aGlzLnNldEJsZW5kaW5nPWZ1bmN0aW9uKGEsYixjLGQpe2EhPT1rYSYmKGE9PT1USFJFRS5Ob0JsZW5kaW5nP2ouZGlzYWJsZShqLkJMRU5EKTpcbmE9PT1USFJFRS5BZGRpdGl2ZUJsZW5kaW5nPyhqLmVuYWJsZShqLkJMRU5EKSxqLmJsZW5kRXF1YXRpb24oai5GVU5DX0FERCksai5ibGVuZEZ1bmMoai5TUkNfQUxQSEEsai5PTkUpKTphPT09VEhSRUUuU3VidHJhY3RpdmVCbGVuZGluZz8oai5lbmFibGUoai5CTEVORCksai5ibGVuZEVxdWF0aW9uKGouRlVOQ19BREQpLGouYmxlbmRGdW5jKGouWkVSTyxqLk9ORV9NSU5VU19TUkNfQ09MT1IpKTphPT09VEhSRUUuTXVsdGlwbHlCbGVuZGluZz8oai5lbmFibGUoai5CTEVORCksai5ibGVuZEVxdWF0aW9uKGouRlVOQ19BREQpLGouYmxlbmRGdW5jKGouWkVSTyxqLlNSQ19DT0xPUikpOmE9PT1USFJFRS5DdXN0b21CbGVuZGluZz9qLmVuYWJsZShqLkJMRU5EKTooai5lbmFibGUoai5CTEVORCksai5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoai5GVU5DX0FERCxqLkZVTkNfQUREKSxqLmJsZW5kRnVuY1NlcGFyYXRlKGouU1JDX0FMUEhBLGouT05FX01JTlVTX1NSQ19BTFBIQSxqLk9ORSxcbmouT05FX01JTlVTX1NSQ19BTFBIQSkpLGthPWEpO2lmKGE9PT1USFJFRS5DdXN0b21CbGVuZGluZyl7aWYoYiE9PXRhJiYoai5ibGVuZEVxdWF0aW9uKHYoYikpLHRhPWIpLGMhPT1pYXx8ZCE9PUxhKWouYmxlbmRGdW5jKHYoYyksdihkKSksaWE9YyxMYT1kfWVsc2UgTGE9aWE9dGE9bnVsbH07dGhpcy5zZXRUZXh0dXJlPWZ1bmN0aW9uKGEsYil7aWYoYS5uZWVkc1VwZGF0ZSl7YS5fX3dlYmdsSW5pdHx8KGEuX193ZWJnbEluaXQ9ITAsYS5hZGRFdmVudExpc3RlbmVyKFwiZGlzcG9zZVwiLERiKSxhLl9fd2ViZ2xUZXh0dXJlPWouY3JlYXRlVGV4dHVyZSgpLEsuaW5mby5tZW1vcnkudGV4dHVyZXMrKyk7ai5hY3RpdmVUZXh0dXJlKGouVEVYVFVSRTArYik7ai5iaW5kVGV4dHVyZShqLlRFWFRVUkVfMkQsYS5fX3dlYmdsVGV4dHVyZSk7ai5waXhlbFN0b3JlaShqLlVOUEFDS19GTElQX1lfV0VCR0wsYS5mbGlwWSk7ai5waXhlbFN0b3JlaShqLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCxcbmEucHJlbXVsdGlwbHlBbHBoYSk7ai5waXhlbFN0b3JlaShqLlVOUEFDS19BTElHTk1FTlQsYS51bnBhY2tBbGlnbm1lbnQpO3ZhciBjPWEuaW1hZ2UsZD0wPT09KGMud2lkdGgmYy53aWR0aC0xKSYmMD09PShjLmhlaWdodCZjLmhlaWdodC0xKSxlPXYoYS5mb3JtYXQpLGY9dihhLnR5cGUpO0Uoai5URVhUVVJFXzJELGEsZCk7dmFyIGg9YS5taXBtYXBzO2lmKGEgaW5zdGFuY2VvZiBUSFJFRS5EYXRhVGV4dHVyZSlpZigwPGgubGVuZ3RoJiZkKXtmb3IodmFyIGc9MCxpPWgubGVuZ3RoO2c8aTtnKyspYz1oW2ddLGoudGV4SW1hZ2UyRChqLlRFWFRVUkVfMkQsZyxlLGMud2lkdGgsYy5oZWlnaHQsMCxlLGYsYy5kYXRhKTthLmdlbmVyYXRlTWlwbWFwcz0hMX1lbHNlIGoudGV4SW1hZ2UyRChqLlRFWFRVUkVfMkQsMCxlLGMud2lkdGgsYy5oZWlnaHQsMCxlLGYsYy5kYXRhKTtlbHNlIGlmKGEgaW5zdGFuY2VvZiBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZSl7Zz0wO2ZvcihpPWgubGVuZ3RoO2c8XG5pO2crKyljPWhbZ10sYS5mb3JtYXQhPT1USFJFRS5SR0JBRm9ybWF0P2ouY29tcHJlc3NlZFRleEltYWdlMkQoai5URVhUVVJFXzJELGcsZSxjLndpZHRoLGMuaGVpZ2h0LDAsYy5kYXRhKTpqLnRleEltYWdlMkQoai5URVhUVVJFXzJELGcsZSxjLndpZHRoLGMuaGVpZ2h0LDAsZSxmLGMuZGF0YSl9ZWxzZSBpZigwPGgubGVuZ3RoJiZkKXtnPTA7Zm9yKGk9aC5sZW5ndGg7ZzxpO2crKyljPWhbZ10sai50ZXhJbWFnZTJEKGouVEVYVFVSRV8yRCxnLGUsZSxmLGMpO2EuZ2VuZXJhdGVNaXBtYXBzPSExfWVsc2Ugai50ZXhJbWFnZTJEKGouVEVYVFVSRV8yRCwwLGUsZSxmLGEuaW1hZ2UpO2EuZ2VuZXJhdGVNaXBtYXBzJiZkJiZqLmdlbmVyYXRlTWlwbWFwKGouVEVYVFVSRV8yRCk7YS5uZWVkc1VwZGF0ZT0hMTtpZihhLm9uVXBkYXRlKWEub25VcGRhdGUoKX1lbHNlIGouYWN0aXZlVGV4dHVyZShqLlRFWFRVUkUwK2IpLGouYmluZFRleHR1cmUoai5URVhUVVJFXzJELGEuX193ZWJnbFRleHR1cmUpfTtcbnRoaXMuc2V0UmVuZGVyVGFyZ2V0PWZ1bmN0aW9uKGEpe3ZhciBiPWEgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmU7aWYoYSYmIWEuX193ZWJnbEZyYW1lYnVmZmVyKXt2b2lkIDA9PT1hLmRlcHRoQnVmZmVyJiYoYS5kZXB0aEJ1ZmZlcj0hMCk7dm9pZCAwPT09YS5zdGVuY2lsQnVmZmVyJiYoYS5zdGVuY2lsQnVmZmVyPSEwKTthLmFkZEV2ZW50TGlzdGVuZXIoXCJkaXNwb3NlXCIsRWIpO2EuX193ZWJnbFRleHR1cmU9ai5jcmVhdGVUZXh0dXJlKCk7Sy5pbmZvLm1lbW9yeS50ZXh0dXJlcysrO3ZhciBjPTA9PT0oYS53aWR0aCZhLndpZHRoLTEpJiYwPT09KGEuaGVpZ2h0JmEuaGVpZ2h0LTEpLGQ9dihhLmZvcm1hdCksZT12KGEudHlwZSk7aWYoYil7YS5fX3dlYmdsRnJhbWVidWZmZXI9W107YS5fX3dlYmdsUmVuZGVyYnVmZmVyPVtdO2ouYmluZFRleHR1cmUoai5URVhUVVJFX0NVQkVfTUFQLGEuX193ZWJnbFRleHR1cmUpO0Uoai5URVhUVVJFX0NVQkVfTUFQLFxuYSxjKTtmb3IodmFyIGY9MDs2PmY7ZisrKXthLl9fd2ViZ2xGcmFtZWJ1ZmZlcltmXT1qLmNyZWF0ZUZyYW1lYnVmZmVyKCk7YS5fX3dlYmdsUmVuZGVyYnVmZmVyW2ZdPWouY3JlYXRlUmVuZGVyYnVmZmVyKCk7ai50ZXhJbWFnZTJEKGouVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YK2YsMCxkLGEud2lkdGgsYS5oZWlnaHQsMCxkLGUsbnVsbCk7dmFyIGg9YSxnPWouVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YK2Y7ai5iaW5kRnJhbWVidWZmZXIoai5GUkFNRUJVRkZFUixhLl9fd2ViZ2xGcmFtZWJ1ZmZlcltmXSk7ai5mcmFtZWJ1ZmZlclRleHR1cmUyRChqLkZSQU1FQlVGRkVSLGouQ09MT1JfQVRUQUNITUVOVDAsZyxoLl9fd2ViZ2xUZXh0dXJlLDApO0koYS5fX3dlYmdsUmVuZGVyYnVmZmVyW2ZdLGEpfWMmJmouZ2VuZXJhdGVNaXBtYXAoai5URVhUVVJFX0NVQkVfTUFQKX1lbHNlIGEuX193ZWJnbEZyYW1lYnVmZmVyPWouY3JlYXRlRnJhbWVidWZmZXIoKSxhLl9fd2ViZ2xSZW5kZXJidWZmZXI9XG5hLnNoYXJlRGVwdGhGcm9tP2Euc2hhcmVEZXB0aEZyb20uX193ZWJnbFJlbmRlcmJ1ZmZlcjpqLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpLGouYmluZFRleHR1cmUoai5URVhUVVJFXzJELGEuX193ZWJnbFRleHR1cmUpLEUoai5URVhUVVJFXzJELGEsYyksai50ZXhJbWFnZTJEKGouVEVYVFVSRV8yRCwwLGQsYS53aWR0aCxhLmhlaWdodCwwLGQsZSxudWxsKSxkPWouVEVYVFVSRV8yRCxqLmJpbmRGcmFtZWJ1ZmZlcihqLkZSQU1FQlVGRkVSLGEuX193ZWJnbEZyYW1lYnVmZmVyKSxqLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGouRlJBTUVCVUZGRVIsai5DT0xPUl9BVFRBQ0hNRU5UMCxkLGEuX193ZWJnbFRleHR1cmUsMCksYS5zaGFyZURlcHRoRnJvbT9hLmRlcHRoQnVmZmVyJiYhYS5zdGVuY2lsQnVmZmVyP2ouZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoai5GUkFNRUJVRkZFUixqLkRFUFRIX0FUVEFDSE1FTlQsai5SRU5ERVJCVUZGRVIsYS5fX3dlYmdsUmVuZGVyYnVmZmVyKTphLmRlcHRoQnVmZmVyJiZcbmEuc3RlbmNpbEJ1ZmZlciYmai5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihqLkZSQU1FQlVGRkVSLGouREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULGouUkVOREVSQlVGRkVSLGEuX193ZWJnbFJlbmRlcmJ1ZmZlcik6SShhLl9fd2ViZ2xSZW5kZXJidWZmZXIsYSksYyYmai5nZW5lcmF0ZU1pcG1hcChqLlRFWFRVUkVfMkQpO2I/ai5iaW5kVGV4dHVyZShqLlRFWFRVUkVfQ1VCRV9NQVAsbnVsbCk6ai5iaW5kVGV4dHVyZShqLlRFWFRVUkVfMkQsbnVsbCk7ai5iaW5kUmVuZGVyYnVmZmVyKGouUkVOREVSQlVGRkVSLG51bGwpO2ouYmluZEZyYW1lYnVmZmVyKGouRlJBTUVCVUZGRVIsbnVsbCl9YT8oYj1iP2EuX193ZWJnbEZyYW1lYnVmZmVyW2EuYWN0aXZlQ3ViZUZhY2VdOmEuX193ZWJnbEZyYW1lYnVmZmVyLGM9YS53aWR0aCxhPWEuaGVpZ2h0LGU9ZD0wKTooYj1udWxsLGM9TWEsYT1mYixkPWJiLGU9Y2IpO2IhPT1kYSYmKGouYmluZEZyYW1lYnVmZmVyKGouRlJBTUVCVUZGRVIsYiksXG5qLnZpZXdwb3J0KGQsZSxjLGEpLGRhPWIpO3NiPWM7cGI9YX07dGhpcy5zaGFkb3dNYXBQbHVnaW49bmV3IFRIUkVFLlNoYWRvd01hcFBsdWdpbjt0aGlzLmFkZFByZVBsdWdpbih0aGlzLnNoYWRvd01hcFBsdWdpbik7dGhpcy5hZGRQb3N0UGx1Z2luKG5ldyBUSFJFRS5TcHJpdGVQbHVnaW4pO3RoaXMuYWRkUG9zdFBsdWdpbihuZXcgVEhSRUUuTGVuc0ZsYXJlUGx1Z2luKX07VEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ9ZnVuY3Rpb24oYSxiLGMpe3RoaXMud2lkdGg9YTt0aGlzLmhlaWdodD1iO2M9Y3x8e307dGhpcy53cmFwUz12b2lkIDAhPT1jLndyYXBTP2Mud3JhcFM6VEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZzt0aGlzLndyYXBUPXZvaWQgMCE9PWMud3JhcFQ/Yy53cmFwVDpUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO3RoaXMubWFnRmlsdGVyPXZvaWQgMCE9PWMubWFnRmlsdGVyP2MubWFnRmlsdGVyOlRIUkVFLkxpbmVhckZpbHRlcjt0aGlzLm1pbkZpbHRlcj12b2lkIDAhPT1jLm1pbkZpbHRlcj9jLm1pbkZpbHRlcjpUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7dGhpcy5hbmlzb3Ryb3B5PXZvaWQgMCE9PWMuYW5pc290cm9weT9jLmFuaXNvdHJvcHk6MTt0aGlzLm9mZnNldD1uZXcgVEhSRUUuVmVjdG9yMigwLDApO3RoaXMucmVwZWF0PW5ldyBUSFJFRS5WZWN0b3IyKDEsMSk7dGhpcy5mb3JtYXQ9dm9pZCAwIT09Yy5mb3JtYXQ/Yy5mb3JtYXQ6XG5USFJFRS5SR0JBRm9ybWF0O3RoaXMudHlwZT12b2lkIDAhPT1jLnR5cGU/Yy50eXBlOlRIUkVFLlVuc2lnbmVkQnl0ZVR5cGU7dGhpcy5kZXB0aEJ1ZmZlcj12b2lkIDAhPT1jLmRlcHRoQnVmZmVyP2MuZGVwdGhCdWZmZXI6ITA7dGhpcy5zdGVuY2lsQnVmZmVyPXZvaWQgMCE9PWMuc3RlbmNpbEJ1ZmZlcj9jLnN0ZW5jaWxCdWZmZXI6ITA7dGhpcy5nZW5lcmF0ZU1pcG1hcHM9ITA7dGhpcy5zaGFyZURlcHRoRnJvbT1udWxsfTtcblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZT17Y29uc3RydWN0b3I6VEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQsY2xvbmU6ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQodGhpcy53aWR0aCx0aGlzLmhlaWdodCk7YS53cmFwUz10aGlzLndyYXBTO2Eud3JhcFQ9dGhpcy53cmFwVDthLm1hZ0ZpbHRlcj10aGlzLm1hZ0ZpbHRlcjthLm1pbkZpbHRlcj10aGlzLm1pbkZpbHRlcjthLmFuaXNvdHJvcHk9dGhpcy5hbmlzb3Ryb3B5O2Eub2Zmc2V0LmNvcHkodGhpcy5vZmZzZXQpO2EucmVwZWF0LmNvcHkodGhpcy5yZXBlYXQpO2EuZm9ybWF0PXRoaXMuZm9ybWF0O2EudHlwZT10aGlzLnR5cGU7YS5kZXB0aEJ1ZmZlcj10aGlzLmRlcHRoQnVmZmVyO2Euc3RlbmNpbEJ1ZmZlcj10aGlzLnN0ZW5jaWxCdWZmZXI7YS5nZW5lcmF0ZU1pcG1hcHM9dGhpcy5nZW5lcmF0ZU1pcG1hcHM7YS5zaGFyZURlcHRoRnJvbT10aGlzLnNoYXJlRGVwdGhGcm9tO1xucmV0dXJuIGF9LGRpc3Bvc2U6ZnVuY3Rpb24oKXt0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJkaXNwb3NlXCJ9KX19O1RIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlKTtUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmU9ZnVuY3Rpb24oYSxiLGMpe1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LmNhbGwodGhpcyxhLGIsYyk7dGhpcy5hY3RpdmVDdWJlRmFjZT0wfTtUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlKTtUSFJFRS5SZW5kZXJhYmxlVmVydGV4PWZ1bmN0aW9uKCl7dGhpcy5wb3NpdGlvbldvcmxkPW5ldyBUSFJFRS5WZWN0b3IzO3RoaXMucG9zaXRpb25TY3JlZW49bmV3IFRIUkVFLlZlY3RvcjQ7dGhpcy52aXNpYmxlPSEwfTtUSFJFRS5SZW5kZXJhYmxlVmVydGV4LnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKGEpe3RoaXMucG9zaXRpb25Xb3JsZC5jb3B5KGEucG9zaXRpb25Xb3JsZCk7dGhpcy5wb3NpdGlvblNjcmVlbi5jb3B5KGEucG9zaXRpb25TY3JlZW4pfTtUSFJFRS5SZW5kZXJhYmxlRmFjZTM9ZnVuY3Rpb24oKXt0aGlzLmlkPTA7dGhpcy52MT1uZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleDt0aGlzLnYyPW5ldyBUSFJFRS5SZW5kZXJhYmxlVmVydGV4O3RoaXMudjM9bmV3IFRIUkVFLlJlbmRlcmFibGVWZXJ0ZXg7dGhpcy5jZW50cm9pZE1vZGVsPW5ldyBUSFJFRS5WZWN0b3IzO3RoaXMubm9ybWFsTW9kZWw9bmV3IFRIUkVFLlZlY3RvcjM7dGhpcy5ub3JtYWxNb2RlbFZpZXc9bmV3IFRIUkVFLlZlY3RvcjM7dGhpcy52ZXJ0ZXhOb3JtYWxzTGVuZ3RoPTA7dGhpcy52ZXJ0ZXhOb3JtYWxzTW9kZWw9W25ldyBUSFJFRS5WZWN0b3IzLG5ldyBUSFJFRS5WZWN0b3IzLG5ldyBUSFJFRS5WZWN0b3IzXTt0aGlzLnZlcnRleE5vcm1hbHNNb2RlbFZpZXc9W25ldyBUSFJFRS5WZWN0b3IzLG5ldyBUSFJFRS5WZWN0b3IzLG5ldyBUSFJFRS5WZWN0b3IzXTt0aGlzLm1hdGVyaWFsPXRoaXMuY29sb3I9bnVsbDt0aGlzLnV2cz1bW11dO3RoaXMuej1cbjB9O1RIUkVFLlJlbmRlcmFibGVPYmplY3Q9ZnVuY3Rpb24oKXt0aGlzLmlkPTA7dGhpcy5vYmplY3Q9bnVsbDt0aGlzLno9MH07VEhSRUUuUmVuZGVyYWJsZVNwcml0ZT1mdW5jdGlvbigpe3RoaXMuaWQ9MDt0aGlzLm9iamVjdD1udWxsO3RoaXMucm90YXRpb249dGhpcy56PXRoaXMueT10aGlzLng9MDt0aGlzLnNjYWxlPW5ldyBUSFJFRS5WZWN0b3IyO3RoaXMubWF0ZXJpYWw9bnVsbH07VEhSRUUuUmVuZGVyYWJsZUxpbmU9ZnVuY3Rpb24oKXt0aGlzLmlkPTA7dGhpcy52MT1uZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleDt0aGlzLnYyPW5ldyBUSFJFRS5SZW5kZXJhYmxlVmVydGV4O3RoaXMudmVydGV4Q29sb3JzPVtuZXcgVEhSRUUuQ29sb3IsbmV3IFRIUkVFLkNvbG9yXTt0aGlzLm1hdGVyaWFsPW51bGw7dGhpcy56PTB9O1RIUkVFLkdlb21ldHJ5VXRpbHM9e21lcmdlOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGY9YS52ZXJ0aWNlcy5sZW5ndGgsaD1iIGluc3RhbmNlb2YgVEhSRUUuTWVzaD9iLmdlb21ldHJ5OmIsZz1hLnZlcnRpY2VzLGk9aC52ZXJ0aWNlcyxrPWEuZmFjZXMsbT1oLmZhY2VzLGE9YS5mYWNlVmVydGV4VXZzWzBdLGg9aC5mYWNlVmVydGV4VXZzWzBdO3ZvaWQgMD09PWMmJihjPTApO2IgaW5zdGFuY2VvZiBUSFJFRS5NZXNoJiYoYi5tYXRyaXhBdXRvVXBkYXRlJiZiLnVwZGF0ZU1hdHJpeCgpLGQ9Yi5tYXRyaXgsZT0obmV3IFRIUkVFLk1hdHJpeDMpLmdldE5vcm1hbE1hdHJpeChkKSk7Zm9yKHZhciBiPTAsbD1pLmxlbmd0aDtiPGw7YisrKXt2YXIgcD1pW2JdLmNsb25lKCk7ZCYmcC5hcHBseU1hdHJpeDQoZCk7Zy5wdXNoKHApfWI9MDtmb3IobD1tLmxlbmd0aDtiPGw7YisrKXt2YXIgcD1tW2JdLHMsdCxuPXAudmVydGV4Tm9ybWFscyxyPXAudmVydGV4Q29sb3JzO3M9bmV3IFRIUkVFLkZhY2UzKHAuYStcbmYscC5iK2YscC5jK2YpO3Mubm9ybWFsLmNvcHkocC5ub3JtYWwpO2UmJnMubm9ybWFsLmFwcGx5TWF0cml4MyhlKS5ub3JtYWxpemUoKTtnPTA7Zm9yKGk9bi5sZW5ndGg7ZzxpO2crKyl0PW5bZ10uY2xvbmUoKSxlJiZ0LmFwcGx5TWF0cml4MyhlKS5ub3JtYWxpemUoKSxzLnZlcnRleE5vcm1hbHMucHVzaCh0KTtzLmNvbG9yLmNvcHkocC5jb2xvcik7Zz0wO2ZvcihpPXIubGVuZ3RoO2c8aTtnKyspdD1yW2ddLHMudmVydGV4Q29sb3JzLnB1c2godC5jbG9uZSgpKTtzLm1hdGVyaWFsSW5kZXg9cC5tYXRlcmlhbEluZGV4K2M7cy5jZW50cm9pZC5jb3B5KHAuY2VudHJvaWQpO2QmJnMuY2VudHJvaWQuYXBwbHlNYXRyaXg0KGQpO2sucHVzaChzKX1iPTA7Zm9yKGw9aC5sZW5ndGg7YjxsO2IrKyl7Yz1oW2JdO2Q9W107Zz0wO2ZvcihpPWMubGVuZ3RoO2c8aTtnKyspZC5wdXNoKG5ldyBUSFJFRS5WZWN0b3IyKGNbZ10ueCxjW2ddLnkpKTthLnB1c2goZCl9fSxyYW5kb21Qb2ludEluVHJpYW5nbGU6ZnVuY3Rpb24oKXt2YXIgYT1cbm5ldyBUSFJFRS5WZWN0b3IzO3JldHVybiBmdW5jdGlvbihiLGMsZCl7dmFyIGU9bmV3IFRIUkVFLlZlY3RvcjMsZj1USFJFRS5NYXRoLnJhbmRvbTE2KCksaD1USFJFRS5NYXRoLnJhbmRvbTE2KCk7MTxmK2gmJihmPTEtZixoPTEtaCk7dmFyIGc9MS1mLWg7ZS5jb3B5KGIpO2UubXVsdGlwbHlTY2FsYXIoZik7YS5jb3B5KGMpO2EubXVsdGlwbHlTY2FsYXIoaCk7ZS5hZGQoYSk7YS5jb3B5KGQpO2EubXVsdGlwbHlTY2FsYXIoZyk7ZS5hZGQoYSk7cmV0dXJuIGV9fSgpLHJhbmRvbVBvaW50SW5GYWNlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIFRIUkVFLkdlb21ldHJ5VXRpbHMucmFuZG9tUG9pbnRJblRyaWFuZ2xlKGIudmVydGljZXNbYS5hXSxiLnZlcnRpY2VzW2EuYl0sYi52ZXJ0aWNlc1thLmNdKX0scmFuZG9tUG9pbnRzSW5HZW9tZXRyeTpmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSl7ZnVuY3Rpb24gYihjLGQpe2lmKGQ8YylyZXR1cm4gYzt2YXIgZT1jK01hdGguZmxvb3IoKGQtXG5jKS8yKTtyZXR1cm4ga1tlXT5hP2IoYyxlLTEpOmtbZV08YT9iKGUrMSxkKTplfXJldHVybiBiKDAsay5sZW5ndGgtMSl9dmFyIGQsZSxmPWEuZmFjZXMsaD1hLnZlcnRpY2VzLGc9Zi5sZW5ndGgsaT0wLGs9W10sbSxsLHA7Zm9yKGU9MDtlPGc7ZSsrKWQ9ZltlXSxtPWhbZC5hXSxsPWhbZC5iXSxwPWhbZC5jXSxkLl9hcmVhPVRIUkVFLkdlb21ldHJ5VXRpbHMudHJpYW5nbGVBcmVhKG0sbCxwKSxpKz1kLl9hcmVhLGtbZV09aTtkPVtdO2ZvcihlPTA7ZTxiO2UrKyloPVRIUkVFLk1hdGgucmFuZG9tMTYoKSppLGg9YyhoKSxkW2VdPVRIUkVFLkdlb21ldHJ5VXRpbHMucmFuZG9tUG9pbnRJbkZhY2UoZltoXSxhLCEwKTtyZXR1cm4gZH0sdHJpYW5nbGVBcmVhOmZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjMsYj1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oYyxkLGUpe2Euc3ViVmVjdG9ycyhkLGMpO2Iuc3ViVmVjdG9ycyhlLGMpO2EuY3Jvc3MoYik7cmV0dXJuIDAuNSpcbmEubGVuZ3RoKCl9fSgpLGNlbnRlcjpmdW5jdGlvbihhKXthLmNvbXB1dGVCb3VuZGluZ0JveCgpO3ZhciBiPWEuYm91bmRpbmdCb3gsYz1uZXcgVEhSRUUuVmVjdG9yMztjLmFkZFZlY3RvcnMoYi5taW4sYi5tYXgpO2MubXVsdGlwbHlTY2FsYXIoLTAuNSk7YS5hcHBseU1hdHJpeCgobmV3IFRIUkVFLk1hdHJpeDQpLm1ha2VUcmFuc2xhdGlvbihjLngsYy55LGMueikpO2EuY29tcHV0ZUJvdW5kaW5nQm94KCk7cmV0dXJuIGN9LHRyaWFuZ3VsYXRlUXVhZHM6ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZj1bXSxoPVtdO2I9MDtmb3IoYz1hLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoO2I8YztiKyspaFtiXT1bXTtiPTA7Zm9yKGM9YS5mYWNlcy5sZW5ndGg7YjxjO2IrKyl7Zi5wdXNoKGEuZmFjZXNbYl0pO2Q9MDtmb3IoZT1hLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoO2Q8ZTtkKyspaFtkXS5wdXNoKGEuZmFjZVZlcnRleFV2c1tkXVtiXSl9YS5mYWNlcz1mO2EuZmFjZVZlcnRleFV2cz1oO2EuY29tcHV0ZUNlbnRyb2lkcygpO1xuYS5jb21wdXRlRmFjZU5vcm1hbHMoKTthLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7YS5oYXNUYW5nZW50cyYmYS5jb21wdXRlVGFuZ2VudHMoKX19O1RIUkVFLkltYWdlVXRpbHM9e2Nyb3NzT3JpZ2luOlwiYW5vbnltb3VzXCIsbG9hZFRleHR1cmU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPW5ldyBUSFJFRS5JbWFnZUxvYWRlcjtkLmNyb3NzT3JpZ2luPXRoaXMuY3Jvc3NPcmlnaW47dmFyIGU9bmV3IFRIUkVFLlRleHR1cmUodm9pZCAwLGIpLGI9ZC5sb2FkKGEsZnVuY3Rpb24oKXtlLm5lZWRzVXBkYXRlPSEwO2MmJmMoZSl9KTtlLmltYWdlPWI7ZS5zb3VyY2VGaWxlPWE7cmV0dXJuIGV9LGxvYWRDb21wcmVzc2VkVGV4dHVyZTpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1uZXcgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmU7ZS5tYXBwaW5nPWI7dmFyIGY9bmV3IFhNTEh0dHBSZXF1ZXN0O2Yub25sb2FkPWZ1bmN0aW9uKCl7dmFyIGE9VEhSRUUuSW1hZ2VVdGlscy5wYXJzZUREUyhmLnJlc3BvbnNlLCEwKTtlLmZvcm1hdD1hLmZvcm1hdDtlLm1pcG1hcHM9YS5taXBtYXBzO2UuaW1hZ2Uud2lkdGg9YS53aWR0aDtlLmltYWdlLmhlaWdodD1hLmhlaWdodDtcbmUuZ2VuZXJhdGVNaXBtYXBzPSExO2UubmVlZHNVcGRhdGU9ITA7YyYmYyhlKX07Zi5vbmVycm9yPWQ7Zi5vcGVuKFwiR0VUXCIsYSwhMCk7Zi5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiO2Yuc2VuZChudWxsKTtyZXR1cm4gZX0sbG9hZFRleHR1cmVDdWJlOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPVtdO2UubG9hZENvdW50PTA7dmFyIGY9bmV3IFRIUkVFLlRleHR1cmU7Zi5pbWFnZT1lO3ZvaWQgMCE9PWImJihmLm1hcHBpbmc9Yik7Zi5mbGlwWT0hMTtmb3IodmFyIGI9MCxoPWEubGVuZ3RoO2I8aDsrK2Ipe3ZhciBnPW5ldyBJbWFnZTtlW2JdPWc7Zy5vbmxvYWQ9ZnVuY3Rpb24oKXtlLmxvYWRDb3VudCs9MTs2PT09ZS5sb2FkQ291bnQmJihmLm5lZWRzVXBkYXRlPSEwLGMmJmMoZikpfTtnLm9uZXJyb3I9ZDtnLmNyb3NzT3JpZ2luPXRoaXMuY3Jvc3NPcmlnaW47Zy5zcmM9YVtiXX1yZXR1cm4gZn0sbG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZTpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1cbltdO2UubG9hZENvdW50PTA7dmFyIGY9bmV3IFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlO2YuaW1hZ2U9ZTt2b2lkIDAhPT1iJiYoZi5tYXBwaW5nPWIpO2YuZmxpcFk9ITE7Zi5nZW5lcmF0ZU1pcG1hcHM9ITE7Yj1mdW5jdGlvbihhLGIpe3JldHVybiBmdW5jdGlvbigpe3ZhciBkPVRIUkVFLkltYWdlVXRpbHMucGFyc2VERFMoYS5yZXNwb25zZSwhMCk7Yi5mb3JtYXQ9ZC5mb3JtYXQ7Yi5taXBtYXBzPWQubWlwbWFwcztiLndpZHRoPWQud2lkdGg7Yi5oZWlnaHQ9ZC5oZWlnaHQ7ZS5sb2FkQ291bnQrPTE7Nj09PWUubG9hZENvdW50JiYoZi5mb3JtYXQ9ZC5mb3JtYXQsZi5uZWVkc1VwZGF0ZT0hMCxjJiZjKGYpKX19O2lmKGEgaW5zdGFuY2VvZiBBcnJheSlmb3IodmFyIGg9MCxnPWEubGVuZ3RoO2g8ZzsrK2gpe3ZhciBpPXt9O2VbaF09aTt2YXIgaz1uZXcgWE1MSHR0cFJlcXVlc3Q7ay5vbmxvYWQ9YihrLGkpO2sub25lcnJvcj1kO2k9YVtoXTtrLm9wZW4oXCJHRVRcIixpLCEwKTtrLnJlc3BvbnNlVHlwZT1cblwiYXJyYXlidWZmZXJcIjtrLnNlbmQobnVsbCl9ZWxzZSBrPW5ldyBYTUxIdHRwUmVxdWVzdCxrLm9ubG9hZD1mdW5jdGlvbigpe3ZhciBhPVRIUkVFLkltYWdlVXRpbHMucGFyc2VERFMoay5yZXNwb25zZSwhMCk7aWYoYS5pc0N1YmVtYXApe2Zvcih2YXIgYj1hLm1pcG1hcHMubGVuZ3RoL2EubWlwbWFwQ291bnQsZD0wO2Q8YjtkKyspe2VbZF09e21pcG1hcHM6W119O2Zvcih2YXIgaD0wO2g8YS5taXBtYXBDb3VudDtoKyspZVtkXS5taXBtYXBzLnB1c2goYS5taXBtYXBzW2QqYS5taXBtYXBDb3VudCtoXSksZVtkXS5mb3JtYXQ9YS5mb3JtYXQsZVtkXS53aWR0aD1hLndpZHRoLGVbZF0uaGVpZ2h0PWEuaGVpZ2h0fWYuZm9ybWF0PWEuZm9ybWF0O2YubmVlZHNVcGRhdGU9ITA7YyYmYyhmKX19LGsub25lcnJvcj1kLGsub3BlbihcIkdFVFwiLGEsITApLGsucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixrLnNlbmQobnVsbCk7cmV0dXJuIGZ9LGxvYWRERFNUZXh0dXJlOmZ1bmN0aW9uKGEsXG5iLGMsZCl7dmFyIGU9W107ZS5sb2FkQ291bnQ9MDt2YXIgZj1uZXcgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmU7Zi5pbWFnZT1lO3ZvaWQgMCE9PWImJihmLm1hcHBpbmc9Yik7Zi5mbGlwWT0hMTtmLmdlbmVyYXRlTWlwbWFwcz0hMTt2YXIgaD1uZXcgWE1MSHR0cFJlcXVlc3Q7aC5vbmxvYWQ9ZnVuY3Rpb24oKXt2YXIgYT1USFJFRS5JbWFnZVV0aWxzLnBhcnNlRERTKGgucmVzcG9uc2UsITApO2lmKGEuaXNDdWJlbWFwKWZvcih2YXIgYj1hLm1pcG1hcHMubGVuZ3RoL2EubWlwbWFwQ291bnQsZD0wO2Q8YjtkKyspe2VbZF09e21pcG1hcHM6W119O2Zvcih2YXIgbT0wO208YS5taXBtYXBDb3VudDttKyspZVtkXS5taXBtYXBzLnB1c2goYS5taXBtYXBzW2QqYS5taXBtYXBDb3VudCttXSksZVtkXS5mb3JtYXQ9YS5mb3JtYXQsZVtkXS53aWR0aD1hLndpZHRoLGVbZF0uaGVpZ2h0PWEuaGVpZ2h0fWVsc2UgZi5pbWFnZS53aWR0aD1hLndpZHRoLGYuaW1hZ2UuaGVpZ2h0PWEuaGVpZ2h0LFxuZi5taXBtYXBzPWEubWlwbWFwcztmLmZvcm1hdD1hLmZvcm1hdDtmLm5lZWRzVXBkYXRlPSEwO2MmJmMoZil9O2gub25lcnJvcj1kO2gub3BlbihcIkdFVFwiLGEsITApO2gucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIjtoLnNlbmQobnVsbCk7cmV0dXJuIGZ9LHBhcnNlRERTOmZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gYS5jaGFyQ29kZUF0KDApKyhhLmNoYXJDb2RlQXQoMSk8PDgpKyhhLmNoYXJDb2RlQXQoMik8PDE2KSsoYS5jaGFyQ29kZUF0KDMpPDwyNCl9dmFyIGQ9e21pcG1hcHM6W10sd2lkdGg6MCxoZWlnaHQ6MCxmb3JtYXQ6bnVsbCxtaXBtYXBDb3VudDoxfSxlPWMoXCJEWFQxXCIpLGY9YyhcIkRYVDNcIiksaD1jKFwiRFhUNVwiKSxnPW5ldyBJbnQzMkFycmF5KGEsMCwzMSk7aWYoNTQyMzI3ODc2IT09Z1swXSlyZXR1cm4gY29uc29sZS5lcnJvcihcIkltYWdlVXRpbHMucGFyc2VERFMoKTogSW52YWxpZCBtYWdpYyBudW1iZXIgaW4gRERTIGhlYWRlclwiKSxkO2lmKCFnWzIwXSZcbjQpcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJJbWFnZVV0aWxzLnBhcnNlRERTKCk6IFVuc3VwcG9ydGVkIGZvcm1hdCwgbXVzdCBjb250YWluIGEgRm91ckNDIGNvZGVcIiksZDt2YXIgaT1nWzIxXSxrPSExO3N3aXRjaChpKXtjYXNlIGU6ZT04O2QuZm9ybWF0PVRIUkVFLlJHQl9TM1RDX0RYVDFfRm9ybWF0O2JyZWFrO2Nhc2UgZjplPTE2O2QuZm9ybWF0PVRIUkVFLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdDticmVhaztjYXNlIGg6ZT0xNjtkLmZvcm1hdD1USFJFRS5SR0JBX1MzVENfRFhUNV9Gb3JtYXQ7YnJlYWs7ZGVmYXVsdDppZigzMj09Z1syMl0mJmdbMjNdJjE2NzExNjgwJiZnWzI0XSY2NTI4MCYmZ1syNV0mMjU1JiZnWzI2XSY0Mjc4MTkwMDgwKWs9ITAsZT02NCxkLmZvcm1hdD1USFJFRS5SR0JBRm9ybWF0O2Vsc2UgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJJbWFnZVV0aWxzLnBhcnNlRERTKCk6IFVuc3VwcG9ydGVkIEZvdXJDQyBjb2RlOiBcIixTdHJpbmcuZnJvbUNoYXJDb2RlKGkmXG4yNTUsaT4+OCYyNTUsaT4+MTYmMjU1LGk+PjI0JjI1NSkpLGR9ZC5taXBtYXBDb3VudD0xO2dbMl0mMTMxMDcyJiYhMSE9PWImJihkLm1pcG1hcENvdW50PU1hdGgubWF4KDEsZ1s3XSkpO2QuaXNDdWJlbWFwPWdbMjhdJjUxMj8hMDohMTtkLndpZHRoPWdbNF07ZC5oZWlnaHQ9Z1szXTtmb3IodmFyIGc9Z1sxXSs0LGY9ZC53aWR0aCxoPWQuaGVpZ2h0LGk9ZC5pc0N1YmVtYXA/NjoxLG09MDttPGk7bSsrKXtmb3IodmFyIGw9MDtsPGQubWlwbWFwQ291bnQ7bCsrKXtpZihrKXt2YXIgcDtwPWY7Zm9yKHZhciBzPWgsdD00KnAqcyxuPW5ldyBVaW50OEFycmF5KGEsZyx0KSx0PW5ldyBVaW50OEFycmF5KHQpLHI9MCxxPTAsdT0wO3U8czt1KyspZm9yKHZhciB3PTA7dzxwO3crKyl7dmFyIHo9bltxXTtxKys7dmFyIEI9bltxXTtxKys7dmFyIEQ9bltxXTtxKys7dmFyIHg9bltxXTtxKys7dFtyXT1EO3IrKzt0W3JdPUI7cisrO3Rbcl09ejtyKys7dFtyXT14O3IrK31wPXQ7cz1wLmxlbmd0aH1lbHNlIHM9XG5NYXRoLm1heCg0LGYpLzQqTWF0aC5tYXgoNCxoKS80KmUscD1uZXcgVWludDhBcnJheShhLGcscyk7ZC5taXBtYXBzLnB1c2goe2RhdGE6cCx3aWR0aDpmLGhlaWdodDpofSk7Zys9cztmPU1hdGgubWF4KDAuNSpmLDEpO2g9TWF0aC5tYXgoMC41KmgsMSl9Zj1kLndpZHRoO2g9ZC5oZWlnaHR9cmV0dXJuIGR9LGdldE5vcm1hbE1hcDpmdW5jdGlvbihhLGIpe3ZhciBjPWZ1bmN0aW9uKGEpe3ZhciBiPU1hdGguc3FydChhWzBdKmFbMF0rYVsxXSphWzFdK2FbMl0qYVsyXSk7cmV0dXJuW2FbMF0vYixhWzFdL2IsYVsyXS9iXX0sYj1ifDEsZD1hLndpZHRoLGU9YS5oZWlnaHQsZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO2Yud2lkdGg9ZDtmLmhlaWdodD1lO3ZhciBoPWYuZ2V0Q29udGV4dChcIjJkXCIpO2guZHJhd0ltYWdlKGEsMCwwKTtmb3IodmFyIGc9aC5nZXRJbWFnZURhdGEoMCwwLGQsZSkuZGF0YSxpPWguY3JlYXRlSW1hZ2VEYXRhKGQsZSksaz1pLmRhdGEsbT0wO208XG5kO20rKylmb3IodmFyIGw9MDtsPGU7bCsrKXt2YXIgcD0wPmwtMT8wOmwtMSxzPWwrMT5lLTE/ZS0xOmwrMSx0PTA+bS0xPzA6bS0xLG49bSsxPmQtMT9kLTE6bSsxLHI9W10scT1bMCwwLGdbNCoobCpkK20pXS8yNTUqYl07ci5wdXNoKFstMSwwLGdbNCoobCpkK3QpXS8yNTUqYl0pO3IucHVzaChbLTEsLTEsZ1s0KihwKmQrdCldLzI1NSpiXSk7ci5wdXNoKFswLC0xLGdbNCoocCpkK20pXS8yNTUqYl0pO3IucHVzaChbMSwtMSxnWzQqKHAqZCtuKV0vMjU1KmJdKTtyLnB1c2goWzEsMCxnWzQqKGwqZCtuKV0vMjU1KmJdKTtyLnB1c2goWzEsMSxnWzQqKHMqZCtuKV0vMjU1KmJdKTtyLnB1c2goWzAsMSxnWzQqKHMqZCttKV0vMjU1KmJdKTtyLnB1c2goWy0xLDEsZ1s0KihzKmQrdCldLzI1NSpiXSk7cD1bXTt0PXIubGVuZ3RoO2ZvcihzPTA7czx0O3MrKyl7dmFyIG49cltzXSx1PXJbKHMrMSkldF0sbj1bblswXS1xWzBdLG5bMV0tcVsxXSxuWzJdLXFbMl1dLHU9W3VbMF0tcVswXSxcbnVbMV0tcVsxXSx1WzJdLXFbMl1dO3AucHVzaChjKFtuWzFdKnVbMl0tblsyXSp1WzFdLG5bMl0qdVswXS1uWzBdKnVbMl0sblswXSp1WzFdLW5bMV0qdVswXV0pKX1yPVswLDAsMF07Zm9yKHM9MDtzPHAubGVuZ3RoO3MrKylyWzBdKz1wW3NdWzBdLHJbMV0rPXBbc11bMV0sclsyXSs9cFtzXVsyXTtyWzBdLz1wLmxlbmd0aDtyWzFdLz1wLmxlbmd0aDtyWzJdLz1wLmxlbmd0aDtxPTQqKGwqZCttKTtrW3FdPTI1NSooKHJbMF0rMSkvMil8MDtrW3ErMV09MjU1KigoclsxXSsxKS8yKXwwO2tbcSsyXT0yNTUqclsyXXwwO2tbcSszXT0yNTV9aC5wdXRJbWFnZURhdGEoaSwwLDApO3JldHVybiBmfSxnZW5lcmF0ZURhdGFUZXh0dXJlOmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9YSpiLGU9bmV3IFVpbnQ4QXJyYXkoMypkKSxmPU1hdGguZmxvb3IoMjU1KmMuciksaD1NYXRoLmZsb29yKDI1NSpjLmcpLGM9TWF0aC5mbG9vcigyNTUqYy5iKSxnPTA7ZzxkO2crKyllWzMqZ109ZixlWzMqZytcbjFdPWgsZVszKmcrMl09YzthPW5ldyBUSFJFRS5EYXRhVGV4dHVyZShlLGEsYixUSFJFRS5SR0JGb3JtYXQpO2EubmVlZHNVcGRhdGU9ITA7cmV0dXJuIGF9fTtUSFJFRS5TY2VuZVV0aWxzPXtjcmVhdGVNdWx0aU1hdGVyaWFsT2JqZWN0OmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPW5ldyBUSFJFRS5PYmplY3QzRCxkPTAsZT1iLmxlbmd0aDtkPGU7ZCsrKWMuYWRkKG5ldyBUSFJFRS5NZXNoKGEsYltkXSkpO3JldHVybiBjfSxkZXRhY2g6ZnVuY3Rpb24oYSxiLGMpe2EuYXBwbHlNYXRyaXgoYi5tYXRyaXhXb3JsZCk7Yi5yZW1vdmUoYSk7Yy5hZGQoYSl9LGF0dGFjaDpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9bmV3IFRIUkVFLk1hdHJpeDQ7ZC5nZXRJbnZlcnNlKGMubWF0cml4V29ybGQpO2EuYXBwbHlNYXRyaXgoZCk7Yi5yZW1vdmUoYSk7Yy5hZGQoYSl9fTtUSFJFRS5Gb250VXRpbHM9e2ZhY2VzOnt9LGZhY2U6XCJoZWx2ZXRpa2VyXCIsd2VpZ2h0Olwibm9ybWFsXCIsc3R5bGU6XCJub3JtYWxcIixzaXplOjE1MCxkaXZpc2lvbnM6MTAsZ2V0RmFjZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZhY2VzW3RoaXMuZmFjZV1bdGhpcy53ZWlnaHRdW3RoaXMuc3R5bGVdfSxsb2FkRmFjZTpmdW5jdGlvbihhKXt2YXIgYj1hLmZhbWlseU5hbWUudG9Mb3dlckNhc2UoKTt0aGlzLmZhY2VzW2JdPXRoaXMuZmFjZXNbYl18fHt9O3RoaXMuZmFjZXNbYl1bYS5jc3NGb250V2VpZ2h0XT10aGlzLmZhY2VzW2JdW2EuY3NzRm9udFdlaWdodF18fHt9O3RoaXMuZmFjZXNbYl1bYS5jc3NGb250V2VpZ2h0XVthLmNzc0ZvbnRTdHlsZV09YTtyZXR1cm4gdGhpcy5mYWNlc1tiXVthLmNzc0ZvbnRXZWlnaHRdW2EuY3NzRm9udFN0eWxlXT1hfSxkcmF3VGV4dDpmdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5nZXRGYWNlKCksYz10aGlzLnNpemUvYi5yZXNvbHV0aW9uLGQ9XG4wLGU9U3RyaW5nKGEpLnNwbGl0KFwiXCIpLGY9ZS5sZW5ndGgsaD1bXSxhPTA7YTxmO2ErKyl7dmFyIGc9bmV3IFRIUkVFLlBhdGgsZz10aGlzLmV4dHJhY3RHbHlwaFBvaW50cyhlW2FdLGIsYyxkLGcpLGQ9ZCtnLm9mZnNldDtoLnB1c2goZy5wYXRoKX1yZXR1cm57cGF0aHM6aCxvZmZzZXQ6ZC8yfX0sZXh0cmFjdEdseXBoUG9pbnRzOmZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9W10saCxnLGksayxtLGwscCxzLHQsbixyLHE9Yi5nbHlwaHNbYV18fGIuZ2x5cGhzW1wiP1wiXTtpZihxKXtpZihxLm8pe2I9cS5fY2FjaGVkT3V0bGluZXx8KHEuX2NhY2hlZE91dGxpbmU9cS5vLnNwbGl0KFwiIFwiKSk7az1iLmxlbmd0aDtmb3IoYT0wO2E8azspc3dpdGNoKGk9YlthKytdLGkpe2Nhc2UgXCJtXCI6aT1iW2ErK10qYytkO209YlthKytdKmM7ZS5tb3ZlVG8oaSxtKTticmVhaztjYXNlIFwibFwiOmk9YlthKytdKmMrZDttPWJbYSsrXSpjO2UubGluZVRvKGksbSk7YnJlYWs7Y2FzZSBcInFcIjppPWJbYSsrXSpcbmMrZDttPWJbYSsrXSpjO3M9YlthKytdKmMrZDt0PWJbYSsrXSpjO2UucXVhZHJhdGljQ3VydmVUbyhzLHQsaSxtKTtpZihoPWZbZi5sZW5ndGgtMV0pe2w9aC54O3A9aC55O2g9MTtmb3IoZz10aGlzLmRpdmlzaW9ucztoPD1nO2grKyl7dmFyIHU9aC9nO1RIUkVFLlNoYXBlLlV0aWxzLmIyKHUsbCxzLGkpO1RIUkVFLlNoYXBlLlV0aWxzLmIyKHUscCx0LG0pfX1icmVhaztjYXNlIFwiYlwiOmlmKGk9YlthKytdKmMrZCxtPWJbYSsrXSpjLHM9YlthKytdKmMrZCx0PWJbYSsrXSotYyxuPWJbYSsrXSpjK2Qscj1iW2ErK10qLWMsZS5iZXppZXJDdXJ2ZVRvKGksbSxzLHQsbixyKSxoPWZbZi5sZW5ndGgtMV0pe2w9aC54O3A9aC55O2g9MTtmb3IoZz10aGlzLmRpdmlzaW9ucztoPD1nO2grKyl1PWgvZyxUSFJFRS5TaGFwZS5VdGlscy5iMyh1LGwscyxuLGkpLFRIUkVFLlNoYXBlLlV0aWxzLmIzKHUscCx0LHIsbSl9fX1yZXR1cm57b2Zmc2V0OnEuaGEqYyxwYXRoOmV9fX19O1xuVEhSRUUuRm9udFV0aWxzLmdlbmVyYXRlU2hhcGVzPWZ1bmN0aW9uKGEsYil7dmFyIGI9Ynx8e30sYz12b2lkIDAhPT1iLmN1cnZlU2VnbWVudHM/Yi5jdXJ2ZVNlZ21lbnRzOjQsZD12b2lkIDAhPT1iLmZvbnQ/Yi5mb250OlwiaGVsdmV0aWtlclwiLGU9dm9pZCAwIT09Yi53ZWlnaHQ/Yi53ZWlnaHQ6XCJub3JtYWxcIixmPXZvaWQgMCE9PWIuc3R5bGU/Yi5zdHlsZTpcIm5vcm1hbFwiO1RIUkVFLkZvbnRVdGlscy5zaXplPXZvaWQgMCE9PWIuc2l6ZT9iLnNpemU6MTAwO1RIUkVFLkZvbnRVdGlscy5kaXZpc2lvbnM9YztUSFJFRS5Gb250VXRpbHMuZmFjZT1kO1RIUkVFLkZvbnRVdGlscy53ZWlnaHQ9ZTtUSFJFRS5Gb250VXRpbHMuc3R5bGU9ZjtjPVRIUkVFLkZvbnRVdGlscy5kcmF3VGV4dChhKS5wYXRocztkPVtdO2U9MDtmb3IoZj1jLmxlbmd0aDtlPGY7ZSsrKUFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGQsY1tlXS50b1NoYXBlcygpKTtyZXR1cm4gZH07XG4oZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPWEubGVuZ3RoLGU9MCxmPWItMSxoPTA7aDxiO2Y9aCsrKWUrPWFbZl0ueCphW2hdLnktYVtoXS54KmFbZl0ueTtyZXR1cm4gMC41KmV9O2EuVHJpYW5ndWxhdGU9ZnVuY3Rpb24oYSxkKXt2YXIgZT1hLmxlbmd0aDtpZigzPmUpcmV0dXJuIG51bGw7dmFyIGY9W10saD1bXSxnPVtdLGksayxtO2lmKDA8YihhKSlmb3Ioaz0wO2s8ZTtrKyspaFtrXT1rO2Vsc2UgZm9yKGs9MDtrPGU7aysrKWhba109ZS0xLWs7dmFyIGw9MiplO2ZvcihrPWUtMTsyPGU7KXtpZigwPj1sLS0pe2NvbnNvbGUubG9nKFwiV2FybmluZywgdW5hYmxlIHRvIHRyaWFuZ3VsYXRlIHBvbHlnb24hXCIpO2JyZWFrfWk9aztlPD1pJiYoaT0wKTtrPWkrMTtlPD1rJiYoaz0wKTttPWsrMTtlPD1tJiYobT0wKTt2YXIgcDthOnt2YXIgcz1wPXZvaWQgMCx0PXZvaWQgMCxuPXZvaWQgMCxyPXZvaWQgMCxxPXZvaWQgMCx1PXZvaWQgMCx3PXZvaWQgMCx6PVxudm9pZCAwLHM9YVtoW2ldXS54LHQ9YVtoW2ldXS55LG49YVtoW2tdXS54LHI9YVtoW2tdXS55LHE9YVtoW21dXS54LHU9YVtoW21dXS55O2lmKDFFLTEwPihuLXMpKih1LXQpLShyLXQpKihxLXMpKXA9ITE7ZWxzZXt2YXIgQj12b2lkIDAsRD12b2lkIDAseD12b2lkIDAsRj12b2lkIDAsQT12b2lkIDAsTz12b2lkIDAsQz12b2lkIDAsRT12b2lkIDAsST12b2lkIDAseT12b2lkIDAsST1FPUM9ej13PXZvaWQgMCxCPXEtbixEPXUtcix4PXMtcSxGPXQtdSxBPW4tcyxPPXItdDtmb3IocD0wO3A8ZTtwKyspaWYoIShwPT09aXx8cD09PWt8fHA9PT1tKSlpZih3PWFbaFtwXV0ueCx6PWFbaFtwXV0ueSxDPXctcyxFPXotdCxJPXctbix5PXotcix3LT1xLHotPXUsST1CKnktRCpJLEM9QSpFLU8qQyxFPXgqei1GKncsLTFFLTEwPD1JJiYtMUUtMTA8PUUmJi0xRS0xMDw9Qyl7cD0hMTticmVhayBhfXA9ITB9fWlmKHApe2YucHVzaChbYVtoW2ldXSxhW2hba11dLGFbaFttXV1dKTtnLnB1c2goW2hbaV0sXG5oW2tdLGhbbV1dKTtpPWs7Zm9yKG09aysxO208ZTtpKyssbSsrKWhbaV09aFttXTtlLS07bD0yKmV9fXJldHVybiBkP2c6Zn07YS5Ucmlhbmd1bGF0ZS5hcmVhPWI7cmV0dXJuIGF9KShUSFJFRS5Gb250VXRpbHMpO3NlbGYuX3R5cGVmYWNlX2pzPXtmYWNlczpUSFJFRS5Gb250VXRpbHMuZmFjZXMsbG9hZEZhY2U6VEhSRUUuRm9udFV0aWxzLmxvYWRGYWNlfTtUSFJFRS50eXBlZmFjZV9qcz1zZWxmLl90eXBlZmFjZV9qcztUSFJFRS5DdXJ2ZT1mdW5jdGlvbigpe307VEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFBvaW50PWZ1bmN0aW9uKCl7Y29uc29sZS5sb2coXCJXYXJuaW5nLCBnZXRQb2ludCgpIG5vdCBpbXBsZW1lbnRlZCFcIik7cmV0dXJuIG51bGx9O1RIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRQb2ludEF0PWZ1bmN0aW9uKGEpe2E9dGhpcy5nZXRVdG9UbWFwcGluZyhhKTtyZXR1cm4gdGhpcy5nZXRQb2ludChhKX07VEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFBvaW50cz1mdW5jdGlvbihhKXthfHwoYT01KTt2YXIgYixjPVtdO2ZvcihiPTA7Yjw9YTtiKyspYy5wdXNoKHRoaXMuZ2V0UG9pbnQoYi9hKSk7cmV0dXJuIGN9O1RIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRTcGFjZWRQb2ludHM9ZnVuY3Rpb24oYSl7YXx8KGE9NSk7dmFyIGIsYz1bXTtmb3IoYj0wO2I8PWE7YisrKWMucHVzaCh0aGlzLmdldFBvaW50QXQoYi9hKSk7cmV0dXJuIGN9O1xuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldExlbmd0aD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0TGVuZ3RocygpO3JldHVybiBhW2EubGVuZ3RoLTFdfTtUSFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0TGVuZ3Rocz1mdW5jdGlvbihhKXthfHwoYT10aGlzLl9fYXJjTGVuZ3RoRGl2aXNpb25zP3RoaXMuX19hcmNMZW5ndGhEaXZpc2lvbnM6MjAwKTtpZih0aGlzLmNhY2hlQXJjTGVuZ3RocyYmdGhpcy5jYWNoZUFyY0xlbmd0aHMubGVuZ3RoPT1hKzEmJiF0aGlzLm5lZWRzVXBkYXRlKXJldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3Roczt0aGlzLm5lZWRzVXBkYXRlPSExO3ZhciBiPVtdLGMsZD10aGlzLmdldFBvaW50KDApLGUsZj0wO2IucHVzaCgwKTtmb3IoZT0xO2U8PWE7ZSsrKWM9dGhpcy5nZXRQb2ludChlL2EpLGYrPWMuZGlzdGFuY2VUbyhkKSxiLnB1c2goZiksZD1jO3JldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3Rocz1ifTtcblRIUkVFLkN1cnZlLnByb3RvdHlwZS51cGRhdGVBcmNMZW5ndGhzPWZ1bmN0aW9uKCl7dGhpcy5uZWVkc1VwZGF0ZT0hMDt0aGlzLmdldExlbmd0aHMoKX07VEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFV0b1RtYXBwaW5nPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5nZXRMZW5ndGhzKCksZD0wLGU9Yy5sZW5ndGgsZjtmPWI/YjphKmNbZS0xXTtmb3IodmFyIGg9MCxnPWUtMSxpO2g8PWc7KWlmKGQ9TWF0aC5mbG9vcihoKyhnLWgpLzIpLGk9Y1tkXS1mLDA+aSloPWQrMTtlbHNlIGlmKDA8aSlnPWQtMTtlbHNle2c9ZDticmVha31kPWc7aWYoY1tkXT09ZilyZXR1cm4gZC8oZS0xKTtoPWNbZF07cmV0dXJuIGM9KGQrKGYtaCkvKGNbZCsxXS1oKSkvKGUtMSl9O1RIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50PWZ1bmN0aW9uKGEpe3ZhciBiPWEtMUUtNCxhPWErMUUtNDswPmImJihiPTApOzE8YSYmKGE9MSk7Yj10aGlzLmdldFBvaW50KGIpO3JldHVybiB0aGlzLmdldFBvaW50KGEpLmNsb25lKCkuc3ViKGIpLm5vcm1hbGl6ZSgpfTtcblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50QXQ9ZnVuY3Rpb24oYSl7YT10aGlzLmdldFV0b1RtYXBwaW5nKGEpO3JldHVybiB0aGlzLmdldFRhbmdlbnQoYSl9O1xuVEhSRUUuQ3VydmUuVXRpbHM9e3RhbmdlbnRRdWFkcmF0aWNCZXppZXI6ZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIDIqKDEtYSkqKGMtYikrMiphKihkLWMpfSx0YW5nZW50Q3ViaWNCZXppZXI6ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4tMypiKigxLWEpKigxLWEpKzMqYyooMS1hKSooMS1hKS02KmEqYyooMS1hKSs2KmEqZCooMS1hKS0zKmEqYSpkKzMqYSphKmV9LHRhbmdlbnRTcGxpbmU6ZnVuY3Rpb24oYSl7cmV0dXJuIDYqYSphLTYqYSsoMyphKmEtNCphKzEpKygtNiphKmErNiphKSsoMyphKmEtMiphKX0saW50ZXJwb2xhdGU6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgYT0wLjUqKGMtYSksZD0wLjUqKGQtYiksZj1lKmU7cmV0dXJuKDIqYi0yKmMrYStkKSplKmYrKC0zKmIrMypjLTIqYS1kKSpmK2EqZStifX07XG5USFJFRS5DdXJ2ZS5jcmVhdGU9ZnVuY3Rpb24oYSxiKXthLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkN1cnZlLnByb3RvdHlwZSk7YS5wcm90b3R5cGUuZ2V0UG9pbnQ9YjtyZXR1cm4gYX07VEhSRUUuQ3VydmVQYXRoPWZ1bmN0aW9uKCl7dGhpcy5jdXJ2ZXM9W107dGhpcy5iZW5kcz1bXTt0aGlzLmF1dG9DbG9zZT0hMX07VEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkN1cnZlLnByb3RvdHlwZSk7VEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24oYSl7dGhpcy5jdXJ2ZXMucHVzaChhKX07VEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jaGVja0Nvbm5lY3Rpb249ZnVuY3Rpb24oKXt9O1RIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY2xvc2VQYXRoPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jdXJ2ZXNbMF0uZ2V0UG9pbnQoMCksYj10aGlzLmN1cnZlc1t0aGlzLmN1cnZlcy5sZW5ndGgtMV0uZ2V0UG9pbnQoMSk7YS5lcXVhbHMoYil8fHRoaXMuY3VydmVzLnB1c2gobmV3IFRIUkVFLkxpbmVDdXJ2ZShiLGEpKX07XG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFBvaW50PWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1hKnRoaXMuZ2V0TGVuZ3RoKCksYz10aGlzLmdldEN1cnZlTGVuZ3RocygpLGE9MDthPGMubGVuZ3RoOyl7aWYoY1thXT49YilyZXR1cm4gYj1jW2FdLWIsYT10aGlzLmN1cnZlc1thXSxiPTEtYi9hLmdldExlbmd0aCgpLGEuZ2V0UG9pbnRBdChiKTthKyt9cmV0dXJuIG51bGx9O1RIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0TGVuZ3RoPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtyZXR1cm4gYVthLmxlbmd0aC0xXX07XG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldEN1cnZlTGVuZ3Rocz1mdW5jdGlvbigpe2lmKHRoaXMuY2FjaGVMZW5ndGhzJiZ0aGlzLmNhY2hlTGVuZ3Rocy5sZW5ndGg9PXRoaXMuY3VydmVzLmxlbmd0aClyZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHM7dmFyIGE9W10sYj0wLGMsZD10aGlzLmN1cnZlcy5sZW5ndGg7Zm9yKGM9MDtjPGQ7YysrKWIrPXRoaXMuY3VydmVzW2NdLmdldExlbmd0aCgpLGEucHVzaChiKTtyZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHM9YX07XG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldEJvdW5kaW5nQm94PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5nZXRQb2ludHMoKSxiLGMsZCxlLGYsaDtiPWM9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO2U9Zj1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7dmFyIGcsaSxrLG0sbD1hWzBdaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzO209bD9uZXcgVEhSRUUuVmVjdG9yMzpuZXcgVEhSRUUuVmVjdG9yMjtpPTA7Zm9yKGs9YS5sZW5ndGg7aTxrO2krKylnPWFbaV0sZy54PmI/Yj1nLng6Zy54PGUmJihlPWcueCksZy55PmM/Yz1nLnk6Zy55PGYmJihmPWcueSksbCYmKGcuej5kP2Q9Zy56OmcuejxoJiYoaD1nLnopKSxtLmFkZChnKTthPXttaW5YOmUsbWluWTpmLG1heFg6YixtYXhZOmMsY2VudHJvaWQ6bS5kaXZpZGVTY2FsYXIoayl9O2wmJihhLm1heFo9ZCxhLm1pblo9aCk7cmV0dXJuIGF9O1xuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVQb2ludHNHZW9tZXRyeT1mdW5jdGlvbihhKXthPXRoaXMuZ2V0UG9pbnRzKGEsITApO3JldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5KGEpfTtUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZVNwYWNlZFBvaW50c0dlb21ldHJ5PWZ1bmN0aW9uKGEpe2E9dGhpcy5nZXRTcGFjZWRQb2ludHMoYSwhMCk7cmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoYSl9O1RIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlR2VvbWV0cnk9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPW5ldyBUSFJFRS5HZW9tZXRyeSxjPTA7YzxhLmxlbmd0aDtjKyspYi52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKGFbY10ueCxhW2NdLnksYVtjXS56fHwwKSk7cmV0dXJuIGJ9O1RIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuYWRkV3JhcFBhdGg9ZnVuY3Rpb24oYSl7dGhpcy5iZW5kcy5wdXNoKGEpfTtcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtZWRQb2ludHM9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmdldFBvaW50cyhhKSxkLGU7Ynx8KGI9dGhpcy5iZW5kcyk7ZD0wO2ZvcihlPWIubGVuZ3RoO2Q8ZTtkKyspYz10aGlzLmdldFdyYXBQb2ludHMoYyxiW2RdKTtyZXR1cm4gY307VEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cz1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ2V0U3BhY2VkUG9pbnRzKGEpLGQsZTtifHwoYj10aGlzLmJlbmRzKTtkPTA7Zm9yKGU9Yi5sZW5ndGg7ZDxlO2QrKyljPXRoaXMuZ2V0V3JhcFBvaW50cyhjLGJbZF0pO3JldHVybiBjfTtcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0V3JhcFBvaW50cz1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuZ2V0Qm91bmRpbmdCb3goKSxkLGUsZixoLGcsaTtkPTA7Zm9yKGU9YS5sZW5ndGg7ZDxlO2QrKylmPWFbZF0saD1mLngsZz1mLnksaT1oL2MubWF4WCxpPWIuZ2V0VXRvVG1hcHBpbmcoaSxoKSxoPWIuZ2V0UG9pbnQoaSksZz1iLmdldE5vcm1hbFZlY3RvcihpKS5tdWx0aXBseVNjYWxhcihnKSxmLng9aC54K2cueCxmLnk9aC55K2cueTtyZXR1cm4gYX07VEhSRUUuR3lyb3Njb3BlPWZ1bmN0aW9uKCl7VEhSRUUuT2JqZWN0M0QuY2FsbCh0aGlzKX07VEhSRUUuR3lyb3Njb3BlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSk7XG5USFJFRS5HeXJvc2NvcGUucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkPWZ1bmN0aW9uKGEpe3RoaXMubWF0cml4QXV0b1VwZGF0ZSYmdGhpcy51cGRhdGVNYXRyaXgoKTtpZih0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGV8fGEpdGhpcy5wYXJlbnQ/KHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyh0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCx0aGlzLm1hdHJpeCksdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UodGhpcy50cmFuc2xhdGlvbldvcmxkLHRoaXMucXVhdGVybmlvbldvcmxkLHRoaXMuc2NhbGVXb3JsZCksdGhpcy5tYXRyaXguZGVjb21wb3NlKHRoaXMudHJhbnNsYXRpb25PYmplY3QsdGhpcy5xdWF0ZXJuaW9uT2JqZWN0LHRoaXMuc2NhbGVPYmplY3QpLHRoaXMubWF0cml4V29ybGQuY29tcG9zZSh0aGlzLnRyYW5zbGF0aW9uV29ybGQsdGhpcy5xdWF0ZXJuaW9uT2JqZWN0LHRoaXMuc2NhbGVXb3JsZCkpOnRoaXMubWF0cml4V29ybGQuY29weSh0aGlzLm1hdHJpeCksXG50aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITEsYT0hMDtmb3IodmFyIGI9MCxjPXRoaXMuY2hpbGRyZW4ubGVuZ3RoO2I8YztiKyspdGhpcy5jaGlsZHJlbltiXS51cGRhdGVNYXRyaXhXb3JsZChhKX07VEhSRUUuR3lyb3Njb3BlLnByb3RvdHlwZS50cmFuc2xhdGlvbldvcmxkPW5ldyBUSFJFRS5WZWN0b3IzO1RIUkVFLkd5cm9zY29wZS5wcm90b3R5cGUudHJhbnNsYXRpb25PYmplY3Q9bmV3IFRIUkVFLlZlY3RvcjM7VEhSRUUuR3lyb3Njb3BlLnByb3RvdHlwZS5xdWF0ZXJuaW9uV29ybGQ9bmV3IFRIUkVFLlF1YXRlcm5pb247VEhSRUUuR3lyb3Njb3BlLnByb3RvdHlwZS5xdWF0ZXJuaW9uT2JqZWN0PW5ldyBUSFJFRS5RdWF0ZXJuaW9uO1RIUkVFLkd5cm9zY29wZS5wcm90b3R5cGUuc2NhbGVXb3JsZD1uZXcgVEhSRUUuVmVjdG9yMztUSFJFRS5HeXJvc2NvcGUucHJvdG90eXBlLnNjYWxlT2JqZWN0PW5ldyBUSFJFRS5WZWN0b3IzO1RIUkVFLlBhdGg9ZnVuY3Rpb24oYSl7VEhSRUUuQ3VydmVQYXRoLmNhbGwodGhpcyk7dGhpcy5hY3Rpb25zPVtdO2EmJnRoaXMuZnJvbVBvaW50cyhhKX07VEhSRUUuUGF0aC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlKTtUSFJFRS5QYXRoQWN0aW9ucz17TU9WRV9UTzpcIm1vdmVUb1wiLExJTkVfVE86XCJsaW5lVG9cIixRVUFEUkFUSUNfQ1VSVkVfVE86XCJxdWFkcmF0aWNDdXJ2ZVRvXCIsQkVaSUVSX0NVUlZFX1RPOlwiYmV6aWVyQ3VydmVUb1wiLENTUExJTkVfVEhSVTpcInNwbGluZVRocnVcIixBUkM6XCJhcmNcIixFTExJUFNFOlwiZWxsaXBzZVwifTtUSFJFRS5QYXRoLnByb3RvdHlwZS5mcm9tUG9pbnRzPWZ1bmN0aW9uKGEpe3RoaXMubW92ZVRvKGFbMF0ueCxhWzBdLnkpO2Zvcih2YXIgYj0xLGM9YS5sZW5ndGg7YjxjO2IrKyl0aGlzLmxpbmVUbyhhW2JdLngsYVtiXS55KX07XG5USFJFRS5QYXRoLnByb3RvdHlwZS5tb3ZlVG89ZnVuY3Rpb24oYSxiKXt2YXIgYz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO3RoaXMuYWN0aW9ucy5wdXNoKHthY3Rpb246VEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTyxhcmdzOmN9KX07VEhSRUUuUGF0aC5wcm90b3R5cGUubGluZVRvPWZ1bmN0aW9uKGEsYil7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxkPXRoaXMuYWN0aW9uc1t0aGlzLmFjdGlvbnMubGVuZ3RoLTFdLmFyZ3MsZD1uZXcgVEhSRUUuTGluZUN1cnZlKG5ldyBUSFJFRS5WZWN0b3IyKGRbZC5sZW5ndGgtMl0sZFtkLmxlbmd0aC0xXSksbmV3IFRIUkVFLlZlY3RvcjIoYSxiKSk7dGhpcy5jdXJ2ZXMucHVzaChkKTt0aGlzLmFjdGlvbnMucHVzaCh7YWN0aW9uOlRIUkVFLlBhdGhBY3Rpb25zLkxJTkVfVE8sYXJnczpjfSl9O1xuVEhSRUUuUGF0aC5wcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbz1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGY9dGhpcy5hY3Rpb25zW3RoaXMuYWN0aW9ucy5sZW5ndGgtMV0uYXJncyxmPW5ldyBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZShuZXcgVEhSRUUuVmVjdG9yMihmW2YubGVuZ3RoLTJdLGZbZi5sZW5ndGgtMV0pLG5ldyBUSFJFRS5WZWN0b3IyKGEsYiksbmV3IFRIUkVFLlZlY3RvcjIoYyxkKSk7dGhpcy5jdXJ2ZXMucHVzaChmKTt0aGlzLmFjdGlvbnMucHVzaCh7YWN0aW9uOlRIUkVFLlBhdGhBY3Rpb25zLlFVQURSQVRJQ19DVVJWRV9UTyxhcmdzOmV9KX07XG5USFJFRS5QYXRoLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2YXIgaD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGc9dGhpcy5hY3Rpb25zW3RoaXMuYWN0aW9ucy5sZW5ndGgtMV0uYXJncyxnPW5ldyBUSFJFRS5DdWJpY0JlemllckN1cnZlKG5ldyBUSFJFRS5WZWN0b3IyKGdbZy5sZW5ndGgtMl0sZ1tnLmxlbmd0aC0xXSksbmV3IFRIUkVFLlZlY3RvcjIoYSxiKSxuZXcgVEhSRUUuVmVjdG9yMihjLGQpLG5ldyBUSFJFRS5WZWN0b3IyKGUsZikpO3RoaXMuY3VydmVzLnB1c2goZyk7dGhpcy5hY3Rpb25zLnB1c2goe2FjdGlvbjpUSFJFRS5QYXRoQWN0aW9ucy5CRVpJRVJfQ1VSVkVfVE8sYXJnczpofSl9O1xuVEhSRUUuUGF0aC5wcm90b3R5cGUuc3BsaW5lVGhydT1mdW5jdGlvbihhKXt2YXIgYj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGM9dGhpcy5hY3Rpb25zW3RoaXMuYWN0aW9ucy5sZW5ndGgtMV0uYXJncyxjPVtuZXcgVEhSRUUuVmVjdG9yMihjW2MubGVuZ3RoLTJdLGNbYy5sZW5ndGgtMV0pXTtBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShjLGEpO2M9bmV3IFRIUkVFLlNwbGluZUN1cnZlKGMpO3RoaXMuY3VydmVzLnB1c2goYyk7dGhpcy5hY3Rpb25zLnB1c2goe2FjdGlvbjpUSFJFRS5QYXRoQWN0aW9ucy5DU1BMSU5FX1RIUlUsYXJnczpifSl9O1RIUkVFLlBhdGgucHJvdG90eXBlLmFyYz1mdW5jdGlvbihhLGIsYyxkLGUsZil7dmFyIGg9dGhpcy5hY3Rpb25zW3RoaXMuYWN0aW9ucy5sZW5ndGgtMV0uYXJnczt0aGlzLmFic2FyYyhhK2hbaC5sZW5ndGgtMl0sYitoW2gubGVuZ3RoLTFdLGMsZCxlLGYpfTtcblRIUkVFLlBhdGgucHJvdG90eXBlLmFic2FyYz1mdW5jdGlvbihhLGIsYyxkLGUsZil7dGhpcy5hYnNlbGxpcHNlKGEsYixjLGMsZCxlLGYpfTtUSFJFRS5QYXRoLnByb3RvdHlwZS5lbGxpcHNlPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGgpe3ZhciBnPXRoaXMuYWN0aW9uc1t0aGlzLmFjdGlvbnMubGVuZ3RoLTFdLmFyZ3M7dGhpcy5hYnNlbGxpcHNlKGErZ1tnLmxlbmd0aC0yXSxiK2dbZy5sZW5ndGgtMV0sYyxkLGUsZixoKX07VEhSRUUuUGF0aC5wcm90b3R5cGUuYWJzZWxsaXBzZT1mdW5jdGlvbihhLGIsYyxkLGUsZixoKXt2YXIgZz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGk9bmV3IFRIUkVFLkVsbGlwc2VDdXJ2ZShhLGIsYyxkLGUsZixoKTt0aGlzLmN1cnZlcy5wdXNoKGkpO2k9aS5nZXRQb2ludCgxKTtnLnB1c2goaS54KTtnLnB1c2goaS55KTt0aGlzLmFjdGlvbnMucHVzaCh7YWN0aW9uOlRIUkVFLlBhdGhBY3Rpb25zLkVMTElQU0UsYXJnczpnfSl9O1xuVEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0U3BhY2VkUG9pbnRzPWZ1bmN0aW9uKGEpe2F8fChhPTQwKTtmb3IodmFyIGI9W10sYz0wO2M8YTtjKyspYi5wdXNoKHRoaXMuZ2V0UG9pbnQoYy9hKSk7cmV0dXJuIGJ9O1xuVEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0UG9pbnRzPWZ1bmN0aW9uKGEsYil7aWYodGhpcy51c2VTcGFjZWRQb2ludHMpcmV0dXJuIGNvbnNvbGUubG9nKFwidGF0YVwiKSx0aGlzLmdldFNwYWNlZFBvaW50cyhhLGIpO3ZhciBhPWF8fDEyLGM9W10sZCxlLGYsaCxnLGksayxtLGwscCxzLHQsbjtkPTA7Zm9yKGU9dGhpcy5hY3Rpb25zLmxlbmd0aDtkPGU7ZCsrKXN3aXRjaChmPXRoaXMuYWN0aW9uc1tkXSxoPWYuYWN0aW9uLGY9Zi5hcmdzLGgpe2Nhc2UgVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTzpjLnB1c2gobmV3IFRIUkVFLlZlY3RvcjIoZlswXSxmWzFdKSk7YnJlYWs7Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5MSU5FX1RPOmMucHVzaChuZXcgVEhSRUUuVmVjdG9yMihmWzBdLGZbMV0pKTticmVhaztjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLlFVQURSQVRJQ19DVVJWRV9UTzpnPWZbMl07aT1mWzNdO2w9ZlswXTtwPWZbMV07MDxjLmxlbmd0aD8oaD1jW2MubGVuZ3RoLTFdLHM9aC54LFxudD1oLnkpOihoPXRoaXMuYWN0aW9uc1tkLTFdLmFyZ3Mscz1oW2gubGVuZ3RoLTJdLHQ9aFtoLmxlbmd0aC0xXSk7Zm9yKGY9MTtmPD1hO2YrKyluPWYvYSxoPVRIUkVFLlNoYXBlLlV0aWxzLmIyKG4scyxsLGcpLG49VEhSRUUuU2hhcGUuVXRpbHMuYjIobix0LHAsaSksYy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IyKGgsbikpO2JyZWFrO2Nhc2UgVEhSRUUuUGF0aEFjdGlvbnMuQkVaSUVSX0NVUlZFX1RPOmc9Zls0XTtpPWZbNV07bD1mWzBdO3A9ZlsxXTtrPWZbMl07bT1mWzNdOzA8Yy5sZW5ndGg/KGg9Y1tjLmxlbmd0aC0xXSxzPWgueCx0PWgueSk6KGg9dGhpcy5hY3Rpb25zW2QtMV0uYXJncyxzPWhbaC5sZW5ndGgtMl0sdD1oW2gubGVuZ3RoLTFdKTtmb3IoZj0xO2Y8PWE7ZisrKW49Zi9hLGg9VEhSRUUuU2hhcGUuVXRpbHMuYjMobixzLGwsayxnKSxuPVRIUkVFLlNoYXBlLlV0aWxzLmIzKG4sdCxwLG0saSksYy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IyKGgsbikpO2JyZWFrO2Nhc2UgVEhSRUUuUGF0aEFjdGlvbnMuQ1NQTElORV9USFJVOmg9XG50aGlzLmFjdGlvbnNbZC0xXS5hcmdzO249W25ldyBUSFJFRS5WZWN0b3IyKGhbaC5sZW5ndGgtMl0saFtoLmxlbmd0aC0xXSldO2g9YSpmWzBdLmxlbmd0aDtuPW4uY29uY2F0KGZbMF0pO249bmV3IFRIUkVFLlNwbGluZUN1cnZlKG4pO2ZvcihmPTE7Zjw9aDtmKyspYy5wdXNoKG4uZ2V0UG9pbnRBdChmL2gpKTticmVhaztjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkFSQzpnPWZbMF07aT1mWzFdO3A9ZlsyXTtrPWZbM107aD1mWzRdO2w9ISFmWzVdO3M9aC1rO3Q9MiphO2ZvcihmPTE7Zjw9dDtmKyspbj1mL3QsbHx8KG49MS1uKSxuPWsrbipzLGg9ZytwKk1hdGguY29zKG4pLG49aStwKk1hdGguc2luKG4pLGMucHVzaChuZXcgVEhSRUUuVmVjdG9yMihoLG4pKTticmVhaztjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkVMTElQU0U6Zz1mWzBdO2k9ZlsxXTtwPWZbMl07bT1mWzNdO2s9Zls0XTtoPWZbNV07bD0hIWZbNl07cz1oLWs7dD0yKmE7Zm9yKGY9MTtmPD10O2YrKyluPWYvdCxsfHxcbihuPTEtbiksbj1rK24qcyxoPWcrcCpNYXRoLmNvcyhuKSxuPWkrbSpNYXRoLnNpbihuKSxjLnB1c2gobmV3IFRIUkVFLlZlY3RvcjIoaCxuKSl9ZD1jW2MubGVuZ3RoLTFdOzFFLTEwPk1hdGguYWJzKGQueC1jWzBdLngpJiYxRS0xMD5NYXRoLmFicyhkLnktY1swXS55KSYmYy5zcGxpY2UoYy5sZW5ndGgtMSwxKTtiJiZjLnB1c2goY1swXSk7cmV0dXJuIGN9O1xuVEhSRUUuUGF0aC5wcm90b3R5cGUudG9TaGFwZXM9ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZj1bXSxoPW5ldyBUSFJFRS5QYXRoO2I9MDtmb3IoYz10aGlzLmFjdGlvbnMubGVuZ3RoO2I8YztiKyspZD10aGlzLmFjdGlvbnNbYl0sZT1kLmFyZ3MsZD1kLmFjdGlvbixkPT1USFJFRS5QYXRoQWN0aW9ucy5NT1ZFX1RPJiYwIT1oLmFjdGlvbnMubGVuZ3RoJiYoZi5wdXNoKGgpLGg9bmV3IFRIUkVFLlBhdGgpLGhbZF0uYXBwbHkoaCxlKTswIT1oLmFjdGlvbnMubGVuZ3RoJiZmLnB1c2goaCk7aWYoMD09Zi5sZW5ndGgpcmV0dXJuW107dmFyIGc7ZT1bXTtpZigxPT1mLmxlbmd0aClyZXR1cm4gZD1mWzBdLGc9bmV3IFRIUkVFLlNoYXBlLGcuYWN0aW9ucz1kLmFjdGlvbnMsZy5jdXJ2ZXM9ZC5jdXJ2ZXMsZS5wdXNoKGcpLGU7Yj0hVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoZlswXS5nZXRQb2ludHMoKSk7aWYoYT8hYjpiKXtnPW5ldyBUSFJFRS5TaGFwZTtiPTA7Zm9yKGM9XG5mLmxlbmd0aDtiPGM7YisrKWQ9ZltiXSxoPVRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKGQuZ2V0UG9pbnRzKCkpLChoPWE/IWg6aCk/KGcuYWN0aW9ucz1kLmFjdGlvbnMsZy5jdXJ2ZXM9ZC5jdXJ2ZXMsZS5wdXNoKGcpLGc9bmV3IFRIUkVFLlNoYXBlKTpnLmhvbGVzLnB1c2goZCl9ZWxzZXtnPXZvaWQgMDtiPTA7Zm9yKGM9Zi5sZW5ndGg7YjxjO2IrKylkPWZbYl0saD1USFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZShkLmdldFBvaW50cygpKSwoaD1hPyFoOmgpPyhnJiZlLnB1c2goZyksZz1uZXcgVEhSRUUuU2hhcGUsZy5hY3Rpb25zPWQuYWN0aW9ucyxnLmN1cnZlcz1kLmN1cnZlcyk6Zy5ob2xlcy5wdXNoKGQpO2UucHVzaChnKX1yZXR1cm4gZX07VEhSRUUuU2hhcGU9ZnVuY3Rpb24oKXtUSFJFRS5QYXRoLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLmhvbGVzPVtdfTtUSFJFRS5TaGFwZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5QYXRoLnByb3RvdHlwZSk7VEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJ1ZGU9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBUSFJFRS5FeHRydWRlR2VvbWV0cnkodGhpcyxhKX07VEhSRUUuU2hhcGUucHJvdG90eXBlLm1ha2VHZW9tZXRyeT1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IFRIUkVFLlNoYXBlR2VvbWV0cnkodGhpcyxhKX07VEhSRUUuU2hhcGUucHJvdG90eXBlLmdldFBvaW50c0hvbGVzPWZ1bmN0aW9uKGEpe3ZhciBiLGM9dGhpcy5ob2xlcy5sZW5ndGgsZD1bXTtmb3IoYj0wO2I8YztiKyspZFtiXT10aGlzLmhvbGVzW2JdLmdldFRyYW5zZm9ybWVkUG9pbnRzKGEsdGhpcy5iZW5kcyk7cmV0dXJuIGR9O1xuVEhSRUUuU2hhcGUucHJvdG90eXBlLmdldFNwYWNlZFBvaW50c0hvbGVzPWZ1bmN0aW9uKGEpe3ZhciBiLGM9dGhpcy5ob2xlcy5sZW5ndGgsZD1bXTtmb3IoYj0wO2I8YztiKyspZFtiXT10aGlzLmhvbGVzW2JdLmdldFRyYW5zZm9ybWVkU3BhY2VkUG9pbnRzKGEsdGhpcy5iZW5kcyk7cmV0dXJuIGR9O1RIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRyYWN0QWxsUG9pbnRzPWZ1bmN0aW9uKGEpe3JldHVybntzaGFwZTp0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKGEpLGhvbGVzOnRoaXMuZ2V0UG9pbnRzSG9sZXMoYSl9fTtUSFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdFBvaW50cz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy51c2VTcGFjZWRQb2ludHM/dGhpcy5leHRyYWN0QWxsU3BhY2VkUG9pbnRzKGEpOnRoaXMuZXh0cmFjdEFsbFBvaW50cyhhKX07XG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFNwYWNlZFBvaW50cz1mdW5jdGlvbihhKXtyZXR1cm57c2hhcGU6dGhpcy5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cyhhKSxob2xlczp0aGlzLmdldFNwYWNlZFBvaW50c0hvbGVzKGEpfX07XG5USFJFRS5TaGFwZS5VdGlscz17cmVtb3ZlSG9sZXM6ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmNvbmNhdCgpLGQ9Yy5jb25jYXQoKSxlLGYsaCxnLGksayxtLGwscCxzLHQ9W107Zm9yKGk9MDtpPGIubGVuZ3RoO2krKyl7az1iW2ldO0FycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGQsayk7Zj1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7Zm9yKGU9MDtlPGsubGVuZ3RoO2UrKyl7cD1rW2VdO3M9W107Zm9yKGw9MDtsPGMubGVuZ3RoO2wrKyltPWNbbF0sbT1wLmRpc3RhbmNlVG9TcXVhcmVkKG0pLHMucHVzaChtKSxtPGYmJihmPW0saD1lLGc9bCl9ZT0wPD1nLTE/Zy0xOmMubGVuZ3RoLTE7Zj0wPD1oLTE/aC0xOmsubGVuZ3RoLTE7dmFyIG49W2tbaF0sY1tnXSxjW2VdXTtsPVRIUkVFLkZvbnRVdGlscy5Ucmlhbmd1bGF0ZS5hcmVhKG4pO3ZhciByPVtrW2hdLGtbZl0sY1tnXV07cD1USFJFRS5Gb250VXRpbHMuVHJpYW5ndWxhdGUuYXJlYShyKTtzPWc7bT1oO2crPTE7aCs9LTE7MD5cbmcmJihnKz1jLmxlbmd0aCk7ZyU9Yy5sZW5ndGg7MD5oJiYoaCs9ay5sZW5ndGgpO2glPWsubGVuZ3RoO2U9MDw9Zy0xP2ctMTpjLmxlbmd0aC0xO2Y9MDw9aC0xP2gtMTprLmxlbmd0aC0xO249W2tbaF0sY1tnXSxjW2VdXTtuPVRIUkVFLkZvbnRVdGlscy5Ucmlhbmd1bGF0ZS5hcmVhKG4pO3I9W2tbaF0sa1tmXSxjW2ddXTtyPVRIUkVFLkZvbnRVdGlscy5Ucmlhbmd1bGF0ZS5hcmVhKHIpO2wrcD5uK3ImJihnPXMsaD1tLDA+ZyYmKGcrPWMubGVuZ3RoKSxnJT1jLmxlbmd0aCwwPmgmJihoKz1rLmxlbmd0aCksaCU9ay5sZW5ndGgsZT0wPD1nLTE/Zy0xOmMubGVuZ3RoLTEsZj0wPD1oLTE/aC0xOmsubGVuZ3RoLTEpO2w9Yy5zbGljZSgwLGcpO3A9Yy5zbGljZShnKTtzPWsuc2xpY2UoaCk7bT1rLnNsaWNlKDAsaCk7Zj1ba1toXSxrW2ZdLGNbZ11dO3QucHVzaChba1toXSxjW2ddLGNbZV1dKTt0LnB1c2goZik7Yz1sLmNvbmNhdChzKS5jb25jYXQobSkuY29uY2F0KHApfXJldHVybntzaGFwZTpjLFxuaXNvbGF0ZWRQdHM6dCxhbGxwb2ludHM6ZH19LHRyaWFuZ3VsYXRlU2hhcGU6ZnVuY3Rpb24oYSxiKXt2YXIgYz1USFJFRS5TaGFwZS5VdGlscy5yZW1vdmVIb2xlcyhhLGIpLGQ9Yy5hbGxwb2ludHMsZT1jLmlzb2xhdGVkUHRzLGM9VEhSRUUuRm9udFV0aWxzLlRyaWFuZ3VsYXRlKGMuc2hhcGUsITEpLGYsaCxnLGksaz17fTtmPTA7Zm9yKGg9ZC5sZW5ndGg7ZjxoO2YrKylpPWRbZl0ueCtcIjpcIitkW2ZdLnksdm9pZCAwIT09a1tpXSYmY29uc29sZS5sb2coXCJEdXBsaWNhdGUgcG9pbnRcIixpKSxrW2ldPWY7Zj0wO2ZvcihoPWMubGVuZ3RoO2Y8aDtmKyspe2c9Y1tmXTtmb3IoZD0wOzM+ZDtkKyspaT1nW2RdLngrXCI6XCIrZ1tkXS55LGk9a1tpXSx2b2lkIDAhPT1pJiYoZ1tkXT1pKX1mPTA7Zm9yKGg9ZS5sZW5ndGg7ZjxoO2YrKyl7Zz1lW2ZdO2ZvcihkPTA7Mz5kO2QrKylpPWdbZF0ueCtcIjpcIitnW2RdLnksaT1rW2ldLHZvaWQgMCE9PWkmJihnW2RdPWkpfXJldHVybiBjLmNvbmNhdChlKX0sXG5pc0Nsb2NrV2lzZTpmdW5jdGlvbihhKXtyZXR1cm4gMD5USFJFRS5Gb250VXRpbHMuVHJpYW5ndWxhdGUuYXJlYShhKX0sYjJwMDpmdW5jdGlvbihhLGIpe3ZhciBjPTEtYTtyZXR1cm4gYypjKmJ9LGIycDE6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gMiooMS1hKSphKmJ9LGIycDI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYSphKmJ9LGIyOmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiB0aGlzLmIycDAoYSxiKSt0aGlzLmIycDEoYSxjKSt0aGlzLmIycDIoYSxkKX0sYjNwMDpmdW5jdGlvbihhLGIpe3ZhciBjPTEtYTtyZXR1cm4gYypjKmMqYn0sYjNwMTpmdW5jdGlvbihhLGIpe3ZhciBjPTEtYTtyZXR1cm4gMypjKmMqYSpifSxiM3AyOmZ1bmN0aW9uKGEsYil7cmV0dXJuIDMqKDEtYSkqYSphKmJ9LGIzcDM6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYSphKmEqYn0sYjM6ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gdGhpcy5iM3AwKGEsYikrdGhpcy5iM3AxKGEsYykrdGhpcy5iM3AyKGEsZCkrXG50aGlzLmIzcDMoYSxlKX19O1RIUkVFLkxpbmVDdXJ2ZT1mdW5jdGlvbihhLGIpe3RoaXMudjE9YTt0aGlzLnYyPWJ9O1RIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5DdXJ2ZS5wcm90b3R5cGUpO1RIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy52Mi5jbG9uZSgpLnN1Yih0aGlzLnYxKTtiLm11bHRpcGx5U2NhbGFyKGEpLmFkZCh0aGlzLnYxKTtyZXR1cm4gYn07VEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludEF0PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmdldFBvaW50KGEpfTtUSFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52Mi5jbG9uZSgpLnN1Yih0aGlzLnYxKS5ub3JtYWxpemUoKX07VEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmU9ZnVuY3Rpb24oYSxiLGMpe3RoaXMudjA9YTt0aGlzLnYxPWI7dGhpcy52Mj1jfTtUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5DdXJ2ZS5wcm90b3R5cGUpO1RIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludD1mdW5jdGlvbihhKXt2YXIgYjtiPVRIUkVFLlNoYXBlLlV0aWxzLmIyKGEsdGhpcy52MC54LHRoaXMudjEueCx0aGlzLnYyLngpO2E9VEhSRUUuU2hhcGUuVXRpbHMuYjIoYSx0aGlzLnYwLnksdGhpcy52MS55LHRoaXMudjIueSk7cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKGIsYSl9O1xuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQ9ZnVuY3Rpb24oYSl7dmFyIGI7Yj1USFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50UXVhZHJhdGljQmV6aWVyKGEsdGhpcy52MC54LHRoaXMudjEueCx0aGlzLnYyLngpO2E9VEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudFF1YWRyYXRpY0JlemllcihhLHRoaXMudjAueSx0aGlzLnYxLnksdGhpcy52Mi55KTtiPW5ldyBUSFJFRS5WZWN0b3IyKGIsYSk7Yi5ub3JtYWxpemUoKTtyZXR1cm4gYn07VEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZT1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLnYwPWE7dGhpcy52MT1iO3RoaXMudjI9Yzt0aGlzLnYzPWR9O1RIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuQ3VydmUucHJvdG90eXBlKTtUSFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludD1mdW5jdGlvbihhKXt2YXIgYjtiPVRIUkVFLlNoYXBlLlV0aWxzLmIzKGEsdGhpcy52MC54LHRoaXMudjEueCx0aGlzLnYyLngsdGhpcy52My54KTthPVRIUkVFLlNoYXBlLlV0aWxzLmIzKGEsdGhpcy52MC55LHRoaXMudjEueSx0aGlzLnYyLnksdGhpcy52My55KTtyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoYixhKX07XG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50PWZ1bmN0aW9uKGEpe3ZhciBiO2I9VEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudEN1YmljQmV6aWVyKGEsdGhpcy52MC54LHRoaXMudjEueCx0aGlzLnYyLngsdGhpcy52My54KTthPVRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRDdWJpY0JlemllcihhLHRoaXMudjAueSx0aGlzLnYxLnksdGhpcy52Mi55LHRoaXMudjMueSk7Yj1uZXcgVEhSRUUuVmVjdG9yMihiLGEpO2Iubm9ybWFsaXplKCk7cmV0dXJuIGJ9O1RIUkVFLlNwbGluZUN1cnZlPWZ1bmN0aW9uKGEpe3RoaXMucG9pbnRzPXZvaWQgMD09YT9bXTphfTtUSFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5DdXJ2ZS5wcm90b3R5cGUpO1RIUkVFLlNwbGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludD1mdW5jdGlvbihhKXt2YXIgYj1uZXcgVEhSRUUuVmVjdG9yMixjPVtdLGQ9dGhpcy5wb2ludHMsZTtlPShkLmxlbmd0aC0xKSphO2E9TWF0aC5mbG9vcihlKTtlLT1hO2NbMF09MD09YT9hOmEtMTtjWzFdPWE7Y1syXT1hPmQubGVuZ3RoLTI/ZC5sZW5ndGgtMTphKzE7Y1szXT1hPmQubGVuZ3RoLTM/ZC5sZW5ndGgtMTphKzI7Yi54PVRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKGRbY1swXV0ueCxkW2NbMV1dLngsZFtjWzJdXS54LGRbY1szXV0ueCxlKTtiLnk9VEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoZFtjWzBdXS55LGRbY1sxXV0ueSxkW2NbMl1dLnksZFtjWzNdXS55LGUpO3JldHVybiBifTtUSFJFRS5FbGxpcHNlQ3VydmU9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsaCl7dGhpcy5hWD1hO3RoaXMuYVk9Yjt0aGlzLnhSYWRpdXM9Yzt0aGlzLnlSYWRpdXM9ZDt0aGlzLmFTdGFydEFuZ2xlPWU7dGhpcy5hRW5kQW5nbGU9Zjt0aGlzLmFDbG9ja3dpc2U9aH07VEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkN1cnZlLnByb3RvdHlwZSk7XG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmdldFBvaW50PWZ1bmN0aW9uKGEpe3ZhciBiO2I9dGhpcy5hRW5kQW5nbGUtdGhpcy5hU3RhcnRBbmdsZTswPmImJihiKz0yKk1hdGguUEkpO2I+MipNYXRoLlBJJiYoYi09MipNYXRoLlBJKTtiPSEwPT09dGhpcy5hQ2xvY2t3aXNlP3RoaXMuYUVuZEFuZ2xlKygxLWEpKigyKk1hdGguUEktYik6dGhpcy5hU3RhcnRBbmdsZSthKmI7YT10aGlzLmFYK3RoaXMueFJhZGl1cypNYXRoLmNvcyhiKTtiPXRoaXMuYVkrdGhpcy55UmFkaXVzKk1hdGguc2luKGIpO3JldHVybiBuZXcgVEhSRUUuVmVjdG9yMihhLGIpfTtUSFJFRS5BcmNDdXJ2ZT1mdW5jdGlvbihhLGIsYyxkLGUsZil7VEhSRUUuRWxsaXBzZUN1cnZlLmNhbGwodGhpcyxhLGIsYyxjLGQsZSxmKX07VEhSRUUuQXJjQ3VydmUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZSk7VEhSRUUuTGluZUN1cnZlMz1USFJFRS5DdXJ2ZS5jcmVhdGUoZnVuY3Rpb24oYSxiKXt0aGlzLnYxPWE7dGhpcy52Mj1ifSxmdW5jdGlvbihhKXt2YXIgYj1uZXcgVEhSRUUuVmVjdG9yMztiLnN1YlZlY3RvcnModGhpcy52Mix0aGlzLnYxKTtiLm11bHRpcGx5U2NhbGFyKGEpO2IuYWRkKHRoaXMudjEpO3JldHVybiBifSk7VEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzPVRIUkVFLkN1cnZlLmNyZWF0ZShmdW5jdGlvbihhLGIsYyl7dGhpcy52MD1hO3RoaXMudjE9Yjt0aGlzLnYyPWN9LGZ1bmN0aW9uKGEpe3ZhciBiLGM7Yj1USFJFRS5TaGFwZS5VdGlscy5iMihhLHRoaXMudjAueCx0aGlzLnYxLngsdGhpcy52Mi54KTtjPVRIUkVFLlNoYXBlLlV0aWxzLmIyKGEsdGhpcy52MC55LHRoaXMudjEueSx0aGlzLnYyLnkpO2E9VEhSRUUuU2hhcGUuVXRpbHMuYjIoYSx0aGlzLnYwLnosdGhpcy52MS56LHRoaXMudjIueik7cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKGIsYyxhKX0pO1RIUkVFLkN1YmljQmV6aWVyQ3VydmUzPVRIUkVFLkN1cnZlLmNyZWF0ZShmdW5jdGlvbihhLGIsYyxkKXt0aGlzLnYwPWE7dGhpcy52MT1iO3RoaXMudjI9Yzt0aGlzLnYzPWR9LGZ1bmN0aW9uKGEpe3ZhciBiLGM7Yj1USFJFRS5TaGFwZS5VdGlscy5iMyhhLHRoaXMudjAueCx0aGlzLnYxLngsdGhpcy52Mi54LHRoaXMudjMueCk7Yz1USFJFRS5TaGFwZS5VdGlscy5iMyhhLHRoaXMudjAueSx0aGlzLnYxLnksdGhpcy52Mi55LHRoaXMudjMueSk7YT1USFJFRS5TaGFwZS5VdGlscy5iMyhhLHRoaXMudjAueix0aGlzLnYxLnosdGhpcy52Mi56LHRoaXMudjMueik7cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKGIsYyxhKX0pO1RIUkVFLlNwbGluZUN1cnZlMz1USFJFRS5DdXJ2ZS5jcmVhdGUoZnVuY3Rpb24oYSl7dGhpcy5wb2ludHM9dm9pZCAwPT1hP1tdOmF9LGZ1bmN0aW9uKGEpe3ZhciBiPW5ldyBUSFJFRS5WZWN0b3IzLGM9W10sZD10aGlzLnBvaW50cyxlLGE9KGQubGVuZ3RoLTEpKmE7ZT1NYXRoLmZsb29yKGEpO2EtPWU7Y1swXT0wPT1lP2U6ZS0xO2NbMV09ZTtjWzJdPWU+ZC5sZW5ndGgtMj9kLmxlbmd0aC0xOmUrMTtjWzNdPWU+ZC5sZW5ndGgtMz9kLmxlbmd0aC0xOmUrMjtlPWRbY1swXV07dmFyIGY9ZFtjWzFdXSxoPWRbY1syXV0sYz1kW2NbM11dO2IueD1USFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZShlLngsZi54LGgueCxjLngsYSk7Yi55PVRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKGUueSxmLnksaC55LGMueSxhKTtiLno9VEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoZS56LGYueixoLnosYy56LGEpO3JldHVybiBifSk7VEhSRUUuQ2xvc2VkU3BsaW5lQ3VydmUzPVRIUkVFLkN1cnZlLmNyZWF0ZShmdW5jdGlvbihhKXt0aGlzLnBvaW50cz12b2lkIDA9PWE/W106YX0sZnVuY3Rpb24oYSl7dmFyIGI9bmV3IFRIUkVFLlZlY3RvcjMsYz1bXSxkPXRoaXMucG9pbnRzLGU7ZT0oZC5sZW5ndGgtMCkqYTthPU1hdGguZmxvb3IoZSk7ZS09YTthKz0wPGE/MDooTWF0aC5mbG9vcihNYXRoLmFicyhhKS9kLmxlbmd0aCkrMSkqZC5sZW5ndGg7Y1swXT0oYS0xKSVkLmxlbmd0aDtjWzFdPWElZC5sZW5ndGg7Y1syXT0oYSsxKSVkLmxlbmd0aDtjWzNdPShhKzIpJWQubGVuZ3RoO2IueD1USFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZShkW2NbMF1dLngsZFtjWzFdXS54LGRbY1syXV0ueCxkW2NbM11dLngsZSk7Yi55PVRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKGRbY1swXV0ueSxkW2NbMV1dLnksZFtjWzJdXS55LGRbY1szXV0ueSxlKTtiLno9VEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoZFtjWzBdXS56LFxuZFtjWzFdXS56LGRbY1syXV0ueixkW2NbM11dLnosZSk7cmV0dXJuIGJ9KTtUSFJFRS5BbmltYXRpb25IYW5kbGVyPWZ1bmN0aW9uKCl7dmFyIGE9W10sYj17fSxjPXt1cGRhdGU6ZnVuY3Rpb24oYil7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspYVtjXS51cGRhdGUoYil9LGFkZFRvVXBkYXRlOmZ1bmN0aW9uKGIpey0xPT09YS5pbmRleE9mKGIpJiZhLnB1c2goYil9LHJlbW92ZUZyb21VcGRhdGU6ZnVuY3Rpb24oYil7Yj1hLmluZGV4T2YoYik7LTEhPT1iJiZhLnNwbGljZShiLDEpfSxhZGQ6ZnVuY3Rpb24oYSl7dm9pZCAwIT09YlthLm5hbWVdJiZjb25zb2xlLmxvZyhcIlRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuYWRkOiBXYXJuaW5nISBcIithLm5hbWUrXCIgYWxyZWFkeSBleGlzdHMgaW4gbGlicmFyeS4gT3ZlcndyaXRpbmcuXCIpO2JbYS5uYW1lXT1hO2lmKCEwIT09YS5pbml0aWFsaXplZCl7Zm9yKHZhciBjPTA7YzxhLmhpZXJhcmNoeS5sZW5ndGg7YysrKXtmb3IodmFyIGQ9MDtkPGEuaGllcmFyY2h5W2NdLmtleXMubGVuZ3RoO2QrKylpZigwPmEuaGllcmFyY2h5W2NdLmtleXNbZF0udGltZSYmXG4oYS5oaWVyYXJjaHlbY10ua2V5c1tkXS50aW1lPTApLHZvaWQgMCE9PWEuaGllcmFyY2h5W2NdLmtleXNbZF0ucm90JiYhKGEuaGllcmFyY2h5W2NdLmtleXNbZF0ucm90IGluc3RhbmNlb2YgVEhSRUUuUXVhdGVybmlvbikpe3ZhciBnPWEuaGllcmFyY2h5W2NdLmtleXNbZF0ucm90O2EuaGllcmFyY2h5W2NdLmtleXNbZF0ucm90PW5ldyBUSFJFRS5RdWF0ZXJuaW9uKGdbMF0sZ1sxXSxnWzJdLGdbM10pfWlmKGEuaGllcmFyY2h5W2NdLmtleXMubGVuZ3RoJiZ2b2lkIDAhPT1hLmhpZXJhcmNoeVtjXS5rZXlzWzBdLm1vcnBoVGFyZ2V0cyl7Zz17fTtmb3IoZD0wO2Q8YS5oaWVyYXJjaHlbY10ua2V5cy5sZW5ndGg7ZCsrKWZvcih2YXIgaT0wO2k8YS5oaWVyYXJjaHlbY10ua2V5c1tkXS5tb3JwaFRhcmdldHMubGVuZ3RoO2krKyl7dmFyIGs9YS5oaWVyYXJjaHlbY10ua2V5c1tkXS5tb3JwaFRhcmdldHNbaV07Z1trXT0tMX1hLmhpZXJhcmNoeVtjXS51c2VkTW9ycGhUYXJnZXRzPWc7XG5mb3IoZD0wO2Q8YS5oaWVyYXJjaHlbY10ua2V5cy5sZW5ndGg7ZCsrKXt2YXIgbT17fTtmb3IoayBpbiBnKXtmb3IoaT0wO2k8YS5oaWVyYXJjaHlbY10ua2V5c1tkXS5tb3JwaFRhcmdldHMubGVuZ3RoO2krKylpZihhLmhpZXJhcmNoeVtjXS5rZXlzW2RdLm1vcnBoVGFyZ2V0c1tpXT09PWspe21ba109YS5oaWVyYXJjaHlbY10ua2V5c1tkXS5tb3JwaFRhcmdldHNJbmZsdWVuY2VzW2ldO2JyZWFrfWk9PT1hLmhpZXJhcmNoeVtjXS5rZXlzW2RdLm1vcnBoVGFyZ2V0cy5sZW5ndGgmJihtW2tdPTApfWEuaGllcmFyY2h5W2NdLmtleXNbZF0ubW9ycGhUYXJnZXRzSW5mbHVlbmNlcz1tfX1mb3IoZD0xO2Q8YS5oaWVyYXJjaHlbY10ua2V5cy5sZW5ndGg7ZCsrKWEuaGllcmFyY2h5W2NdLmtleXNbZF0udGltZT09PWEuaGllcmFyY2h5W2NdLmtleXNbZC0xXS50aW1lJiYoYS5oaWVyYXJjaHlbY10ua2V5cy5zcGxpY2UoZCwxKSxkLS0pO2ZvcihkPTA7ZDxhLmhpZXJhcmNoeVtjXS5rZXlzLmxlbmd0aDtkKyspYS5oaWVyYXJjaHlbY10ua2V5c1tkXS5pbmRleD1cbmR9ZD1wYXJzZUludChhLmxlbmd0aCphLmZwcywxMCk7YS5KSVQ9e307YS5KSVQuaGllcmFyY2h5PVtdO2ZvcihjPTA7YzxhLmhpZXJhcmNoeS5sZW5ndGg7YysrKWEuSklULmhpZXJhcmNoeS5wdXNoKEFycmF5KGQpKTthLmluaXRpYWxpemVkPSEwfX0sZ2V0OmZ1bmN0aW9uKGEpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYSl7aWYoYlthXSlyZXR1cm4gYlthXTtjb25zb2xlLmxvZyhcIlRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuZ2V0OiBDb3VsZG4ndCBmaW5kIGFuaW1hdGlvbiBcIithKTtyZXR1cm4gbnVsbH19LHBhcnNlOmZ1bmN0aW9uKGEpe3ZhciBiPVtdO2lmKGEgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaClmb3IodmFyIGM9MDtjPGEuYm9uZXMubGVuZ3RoO2MrKyliLnB1c2goYS5ib25lc1tjXSk7ZWxzZSBkKGEsYik7cmV0dXJuIGJ9fSxkPWZ1bmN0aW9uKGEsYil7Yi5wdXNoKGEpO2Zvcih2YXIgYz0wO2M8YS5jaGlsZHJlbi5sZW5ndGg7YysrKWQoYS5jaGlsZHJlbltjXSxcbmIpfTtjLkxJTkVBUj0wO2MuQ0FUTVVMTFJPTT0xO2MuQ0FUTVVMTFJPTV9GT1JXQVJEPTI7cmV0dXJuIGN9KCk7VEhSRUUuQW5pbWF0aW9uPWZ1bmN0aW9uKGEsYixjKXt0aGlzLnJvb3Q9YTt0aGlzLmRhdGE9VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5nZXQoYik7dGhpcy5oaWVyYXJjaHk9VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5wYXJzZShhKTt0aGlzLmN1cnJlbnRUaW1lPTA7dGhpcy50aW1lU2NhbGU9MTt0aGlzLmlzUGxheWluZz0hMTt0aGlzLmxvb3A9dGhpcy5pc1BhdXNlZD0hMDt0aGlzLmludGVycG9sYXRpb25UeXBlPXZvaWQgMCE9PWM/YzpUSFJFRS5BbmltYXRpb25IYW5kbGVyLkxJTkVBUjt0aGlzLnBvaW50cz1bXTt0aGlzLnRhcmdldD1uZXcgVEhSRUUuVmVjdG9yM307XG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnBsYXk9ZnVuY3Rpb24oYSxiKXtpZighMT09PXRoaXMuaXNQbGF5aW5nKXt0aGlzLmlzUGxheWluZz0hMDt0aGlzLmxvb3A9dm9pZCAwIT09YT9hOiEwO3RoaXMuY3VycmVudFRpbWU9dm9pZCAwIT09Yj9iOjA7dmFyIGMsZD10aGlzLmhpZXJhcmNoeS5sZW5ndGgsZTtmb3IoYz0wO2M8ZDtjKyspe2U9dGhpcy5oaWVyYXJjaHlbY107ZS5tYXRyaXhBdXRvVXBkYXRlPSEwO3ZvaWQgMD09PWUuYW5pbWF0aW9uQ2FjaGUmJihlLmFuaW1hdGlvbkNhY2hlPXt9LGUuYW5pbWF0aW9uQ2FjaGUucHJldktleT17cG9zOjAscm90OjAsc2NsOjB9LGUuYW5pbWF0aW9uQ2FjaGUubmV4dEtleT17cG9zOjAscm90OjAsc2NsOjB9LGUuYW5pbWF0aW9uQ2FjaGUub3JpZ2luYWxNYXRyaXg9ZSBpbnN0YW5jZW9mIFRIUkVFLkJvbmU/ZS5za2luTWF0cml4OmUubWF0cml4KTt2YXIgZj1lLmFuaW1hdGlvbkNhY2hlLnByZXZLZXk7ZT1lLmFuaW1hdGlvbkNhY2hlLm5leHRLZXk7XG5mLnBvcz10aGlzLmRhdGEuaGllcmFyY2h5W2NdLmtleXNbMF07Zi5yb3Q9dGhpcy5kYXRhLmhpZXJhcmNoeVtjXS5rZXlzWzBdO2Yuc2NsPXRoaXMuZGF0YS5oaWVyYXJjaHlbY10ua2V5c1swXTtlLnBvcz10aGlzLmdldE5leHRLZXlXaXRoKFwicG9zXCIsYywxKTtlLnJvdD10aGlzLmdldE5leHRLZXlXaXRoKFwicm90XCIsYywxKTtlLnNjbD10aGlzLmdldE5leHRLZXlXaXRoKFwic2NsXCIsYywxKX10aGlzLnVwZGF0ZSgwKX10aGlzLmlzUGF1c2VkPSExO1RIUkVFLkFuaW1hdGlvbkhhbmRsZXIuYWRkVG9VcGRhdGUodGhpcyl9O1RIUkVFLkFuaW1hdGlvbi5wcm90b3R5cGUucGF1c2U9ZnVuY3Rpb24oKXshMD09PXRoaXMuaXNQYXVzZWQ/VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5hZGRUb1VwZGF0ZSh0aGlzKTpUSFJFRS5BbmltYXRpb25IYW5kbGVyLnJlbW92ZUZyb21VcGRhdGUodGhpcyk7dGhpcy5pc1BhdXNlZD0hdGhpcy5pc1BhdXNlZH07XG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnN0b3A9ZnVuY3Rpb24oKXt0aGlzLmlzUGF1c2VkPXRoaXMuaXNQbGF5aW5nPSExO1RIUkVFLkFuaW1hdGlvbkhhbmRsZXIucmVtb3ZlRnJvbVVwZGF0ZSh0aGlzKX07XG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihhKXtpZighMSE9PXRoaXMuaXNQbGF5aW5nKXt2YXIgYj1bXCJwb3NcIixcInJvdFwiLFwic2NsXCJdLGMsZCxlLGYsaCxnLGksayxtO209dGhpcy5jdXJyZW50VGltZSs9YSp0aGlzLnRpbWVTY2FsZTtrPXRoaXMuY3VycmVudFRpbWUlPXRoaXMuZGF0YS5sZW5ndGg7cGFyc2VJbnQoTWF0aC5taW4oayp0aGlzLmRhdGEuZnBzLHRoaXMuZGF0YS5sZW5ndGgqdGhpcy5kYXRhLmZwcyksMTApO2Zvcih2YXIgbD0wLHA9dGhpcy5oaWVyYXJjaHkubGVuZ3RoO2w8cDtsKyspe2E9dGhpcy5oaWVyYXJjaHlbbF07aT1hLmFuaW1hdGlvbkNhY2hlO2Zvcih2YXIgcz0wOzM+cztzKyspe2M9YltzXTtoPWkucHJldktleVtjXTtnPWkubmV4dEtleVtjXTtpZihnLnRpbWU8PW0pe2lmKGs8bSlpZih0aGlzLmxvb3Ape2g9dGhpcy5kYXRhLmhpZXJhcmNoeVtsXS5rZXlzWzBdO2ZvcihnPXRoaXMuZ2V0TmV4dEtleVdpdGgoYyxsLDEpO2cudGltZTxcbms7KWg9ZyxnPXRoaXMuZ2V0TmV4dEtleVdpdGgoYyxsLGcuaW5kZXgrMSl9ZWxzZXt0aGlzLnN0b3AoKTtyZXR1cm59ZWxzZXtkbyBoPWcsZz10aGlzLmdldE5leHRLZXlXaXRoKGMsbCxnLmluZGV4KzEpO3doaWxlKGcudGltZTxrKX1pLnByZXZLZXlbY109aDtpLm5leHRLZXlbY109Z31hLm1hdHJpeEF1dG9VcGRhdGU9ITA7YS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSEwO2Q9KGstaC50aW1lKS8oZy50aW1lLWgudGltZSk7ZT1oW2NdO2Y9Z1tjXTtpZigwPmR8fDE8ZCljb25zb2xlLmxvZyhcIlRIUkVFLkFuaW1hdGlvbi51cGRhdGU6IFdhcm5pbmchIFNjYWxlIG91dCBvZiBib3VuZHM6XCIrZCtcIiBvbiBib25lIFwiK2wpLGQ9MD5kPzA6MTtpZihcInBvc1wiPT09YylpZihjPWEucG9zaXRpb24sdGhpcy5pbnRlcnBvbGF0aW9uVHlwZT09PVRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuTElORUFSKWMueD1lWzBdKyhmWzBdLWVbMF0pKmQsYy55PWVbMV0rKGZbMV0tZVsxXSkqZCxjLno9ZVsyXStcbihmWzJdLWVbMl0pKmQ7ZWxzZXtpZih0aGlzLmludGVycG9sYXRpb25UeXBlPT09VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NfHx0aGlzLmludGVycG9sYXRpb25UeXBlPT09VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQpdGhpcy5wb2ludHNbMF09dGhpcy5nZXRQcmV2S2V5V2l0aChcInBvc1wiLGwsaC5pbmRleC0xKS5wb3MsdGhpcy5wb2ludHNbMV09ZSx0aGlzLnBvaW50c1syXT1mLHRoaXMucG9pbnRzWzNdPXRoaXMuZ2V0TmV4dEtleVdpdGgoXCJwb3NcIixsLGcuaW5kZXgrMSkucG9zLGQ9MC4zMypkKzAuMzMsZT10aGlzLmludGVycG9sYXRlQ2F0bXVsbFJvbSh0aGlzLnBvaW50cyxkKSxjLng9ZVswXSxjLnk9ZVsxXSxjLno9ZVsyXSx0aGlzLmludGVycG9sYXRpb25UeXBlPT09VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQmJihkPXRoaXMuaW50ZXJwb2xhdGVDYXRtdWxsUm9tKHRoaXMucG9pbnRzLDEuMDEqZCksXG50aGlzLnRhcmdldC5zZXQoZFswXSxkWzFdLGRbMl0pLHRoaXMudGFyZ2V0LnN1YihjKSx0aGlzLnRhcmdldC55PTAsdGhpcy50YXJnZXQubm9ybWFsaXplKCksZD1NYXRoLmF0YW4yKHRoaXMudGFyZ2V0LngsdGhpcy50YXJnZXQueiksYS5yb3RhdGlvbi5zZXQoMCxkLDApKX1lbHNlXCJyb3RcIj09PWM/VEhSRUUuUXVhdGVybmlvbi5zbGVycChlLGYsYS5xdWF0ZXJuaW9uLGQpOlwic2NsXCI9PT1jJiYoYz1hLnNjYWxlLGMueD1lWzBdKyhmWzBdLWVbMF0pKmQsYy55PWVbMV0rKGZbMV0tZVsxXSkqZCxjLno9ZVsyXSsoZlsyXS1lWzJdKSpkKX19fX07XG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLmludGVycG9sYXRlQ2F0bXVsbFJvbT1mdW5jdGlvbihhLGIpe3ZhciBjPVtdLGQ9W10sZSxmLGgsZyxpLGs7ZT0oYS5sZW5ndGgtMSkqYjtmPU1hdGguZmxvb3IoZSk7ZS09ZjtjWzBdPTA9PT1mP2Y6Zi0xO2NbMV09ZjtjWzJdPWY+YS5sZW5ndGgtMj9mOmYrMTtjWzNdPWY+YS5sZW5ndGgtMz9mOmYrMjtmPWFbY1swXV07Zz1hW2NbMV1dO2k9YVtjWzJdXTtrPWFbY1szXV07Yz1lKmU7aD1lKmM7ZFswXT10aGlzLmludGVycG9sYXRlKGZbMF0sZ1swXSxpWzBdLGtbMF0sZSxjLGgpO2RbMV09dGhpcy5pbnRlcnBvbGF0ZShmWzFdLGdbMV0saVsxXSxrWzFdLGUsYyxoKTtkWzJdPXRoaXMuaW50ZXJwb2xhdGUoZlsyXSxnWzJdLGlbMl0sa1syXSxlLGMsaCk7cmV0dXJuIGR9O1xuVEhSRUUuQW5pbWF0aW9uLnByb3RvdHlwZS5pbnRlcnBvbGF0ZT1mdW5jdGlvbihhLGIsYyxkLGUsZixoKXthPTAuNSooYy1hKTtkPTAuNSooZC1iKTtyZXR1cm4oMiooYi1jKSthK2QpKmgrKC0zKihiLWMpLTIqYS1kKSpmK2EqZStifTtUSFJFRS5BbmltYXRpb24ucHJvdG90eXBlLmdldE5leHRLZXlXaXRoPWZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9dGhpcy5kYXRhLmhpZXJhcmNoeVtiXS5rZXlzLGM9dGhpcy5pbnRlcnBvbGF0aW9uVHlwZT09PVRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTXx8dGhpcy5pbnRlcnBvbGF0aW9uVHlwZT09PVRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEP2M8ZC5sZW5ndGgtMT9jOmQubGVuZ3RoLTE6YyVkLmxlbmd0aDtjPGQubGVuZ3RoO2MrKylpZih2b2lkIDAhPT1kW2NdW2FdKXJldHVybiBkW2NdO3JldHVybiB0aGlzLmRhdGEuaGllcmFyY2h5W2JdLmtleXNbMF19O1xuVEhSRUUuQW5pbWF0aW9uLnByb3RvdHlwZS5nZXRQcmV2S2V5V2l0aD1mdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPXRoaXMuZGF0YS5oaWVyYXJjaHlbYl0ua2V5cyxjPXRoaXMuaW50ZXJwb2xhdGlvblR5cGU9PT1USFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST018fHRoaXMuaW50ZXJwb2xhdGlvblR5cGU9PT1USFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRD8wPGM/YzowOjA8PWM/YzpjK2QubGVuZ3RoOzA8PWM7Yy0tKWlmKHZvaWQgMCE9PWRbY11bYV0pcmV0dXJuIGRbY107cmV0dXJuIHRoaXMuZGF0YS5oaWVyYXJjaHlbYl0ua2V5c1tkLmxlbmd0aC0xXX07VEhSRUUuS2V5RnJhbWVBbmltYXRpb249ZnVuY3Rpb24oYSxiLGMpe3RoaXMucm9vdD1hO3RoaXMuZGF0YT1USFJFRS5BbmltYXRpb25IYW5kbGVyLmdldChiKTt0aGlzLmhpZXJhcmNoeT1USFJFRS5BbmltYXRpb25IYW5kbGVyLnBhcnNlKGEpO3RoaXMuY3VycmVudFRpbWU9MDt0aGlzLnRpbWVTY2FsZT0wLjAwMTt0aGlzLmlzUGxheWluZz0hMTt0aGlzLmxvb3A9dGhpcy5pc1BhdXNlZD0hMDt0aGlzLkpJVENvbXBpbGU9dm9pZCAwIT09Yz9jOiEwO2E9MDtmb3IoYj10aGlzLmhpZXJhcmNoeS5sZW5ndGg7YTxiO2ErKyl7dmFyIGM9dGhpcy5kYXRhLmhpZXJhcmNoeVthXS5zaWRzLGQ9dGhpcy5oaWVyYXJjaHlbYV07aWYodGhpcy5kYXRhLmhpZXJhcmNoeVthXS5rZXlzLmxlbmd0aCYmYyl7Zm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspe3ZhciBmPWNbZV0saD10aGlzLmdldE5leHRLZXlXaXRoKGYsYSwwKTtoJiZoLmFwcGx5KGYpfWQubWF0cml4QXV0b1VwZGF0ZT0hMTt0aGlzLmRhdGEuaGllcmFyY2h5W2FdLm5vZGUudXBkYXRlTWF0cml4KCk7XG5kLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITB9fX07XG5USFJFRS5LZXlGcmFtZUFuaW1hdGlvbi5wcm90b3R5cGUucGxheT1mdW5jdGlvbihhLGIpe2lmKCF0aGlzLmlzUGxheWluZyl7dGhpcy5pc1BsYXlpbmc9ITA7dGhpcy5sb29wPXZvaWQgMCE9PWE/YTohMDt0aGlzLmN1cnJlbnRUaW1lPXZvaWQgMCE9PWI/YjowO3RoaXMuc3RhcnRUaW1lTXM9Yjt0aGlzLnN0YXJ0VGltZT0xRTc7dGhpcy5lbmRUaW1lPS10aGlzLnN0YXJ0VGltZTt2YXIgYyxkPXRoaXMuaGllcmFyY2h5Lmxlbmd0aCxlLGY7Zm9yKGM9MDtjPGQ7YysrKWU9dGhpcy5oaWVyYXJjaHlbY10sZj10aGlzLmRhdGEuaGllcmFyY2h5W2NdLHZvaWQgMD09PWYuYW5pbWF0aW9uQ2FjaGUmJihmLmFuaW1hdGlvbkNhY2hlPXt9LGYuYW5pbWF0aW9uQ2FjaGUucHJldktleT1udWxsLGYuYW5pbWF0aW9uQ2FjaGUubmV4dEtleT1udWxsLGYuYW5pbWF0aW9uQ2FjaGUub3JpZ2luYWxNYXRyaXg9ZSBpbnN0YW5jZW9mIFRIUkVFLkJvbmU/ZS5za2luTWF0cml4OmUubWF0cml4KSxlPXRoaXMuZGF0YS5oaWVyYXJjaHlbY10ua2V5cyxcbmUubGVuZ3RoJiYoZi5hbmltYXRpb25DYWNoZS5wcmV2S2V5PWVbMF0sZi5hbmltYXRpb25DYWNoZS5uZXh0S2V5PWVbMV0sdGhpcy5zdGFydFRpbWU9TWF0aC5taW4oZVswXS50aW1lLHRoaXMuc3RhcnRUaW1lKSx0aGlzLmVuZFRpbWU9TWF0aC5tYXgoZVtlLmxlbmd0aC0xXS50aW1lLHRoaXMuZW5kVGltZSkpO3RoaXMudXBkYXRlKDApfXRoaXMuaXNQYXVzZWQ9ITE7VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5hZGRUb1VwZGF0ZSh0aGlzKX07VEhSRUUuS2V5RnJhbWVBbmltYXRpb24ucHJvdG90eXBlLnBhdXNlPWZ1bmN0aW9uKCl7dGhpcy5pc1BhdXNlZD9USFJFRS5BbmltYXRpb25IYW5kbGVyLmFkZFRvVXBkYXRlKHRoaXMpOlRIUkVFLkFuaW1hdGlvbkhhbmRsZXIucmVtb3ZlRnJvbVVwZGF0ZSh0aGlzKTt0aGlzLmlzUGF1c2VkPSF0aGlzLmlzUGF1c2VkfTtcblRIUkVFLktleUZyYW1lQW5pbWF0aW9uLnByb3RvdHlwZS5zdG9wPWZ1bmN0aW9uKCl7dGhpcy5pc1BhdXNlZD10aGlzLmlzUGxheWluZz0hMTtUSFJFRS5BbmltYXRpb25IYW5kbGVyLnJlbW92ZUZyb21VcGRhdGUodGhpcyk7Zm9yKHZhciBhPTA7YTx0aGlzLmRhdGEuaGllcmFyY2h5Lmxlbmd0aDthKyspe3ZhciBiPXRoaXMuaGllcmFyY2h5W2FdLGM9dGhpcy5kYXRhLmhpZXJhcmNoeVthXTtpZih2b2lkIDAhPT1jLmFuaW1hdGlvbkNhY2hlKXt2YXIgZD1jLmFuaW1hdGlvbkNhY2hlLm9yaWdpbmFsTWF0cml4O2IgaW5zdGFuY2VvZiBUSFJFRS5Cb25lPyhkLmNvcHkoYi5za2luTWF0cml4KSxiLnNraW5NYXRyaXg9ZCk6KGQuY29weShiLm1hdHJpeCksYi5tYXRyaXg9ZCk7ZGVsZXRlIGMuYW5pbWF0aW9uQ2FjaGV9fX07XG5USFJFRS5LZXlGcmFtZUFuaW1hdGlvbi5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEpe2lmKHRoaXMuaXNQbGF5aW5nKXt2YXIgYixjLGQsZSxmPXRoaXMuZGF0YS5KSVQuaGllcmFyY2h5LGgsZyxpO2c9dGhpcy5jdXJyZW50VGltZSs9YSp0aGlzLnRpbWVTY2FsZTtoPXRoaXMuY3VycmVudFRpbWUlPXRoaXMuZGF0YS5sZW5ndGg7aDx0aGlzLnN0YXJ0VGltZU1zJiYoaD10aGlzLmN1cnJlbnRUaW1lPXRoaXMuc3RhcnRUaW1lTXMraCk7ZT1wYXJzZUludChNYXRoLm1pbihoKnRoaXMuZGF0YS5mcHMsdGhpcy5kYXRhLmxlbmd0aCp0aGlzLmRhdGEuZnBzKSwxMCk7aWYoKGk9aDxnKSYmIXRoaXMubG9vcCl7Zm9yKHZhciBhPTAsaz10aGlzLmhpZXJhcmNoeS5sZW5ndGg7YTxrO2ErKyl7dmFyIG09dGhpcy5kYXRhLmhpZXJhcmNoeVthXS5rZXlzLGY9dGhpcy5kYXRhLmhpZXJhcmNoeVthXS5zaWRzO2Q9bS5sZW5ndGgtMTtlPXRoaXMuaGllcmFyY2h5W2FdO2lmKG0ubGVuZ3RoKXtmb3IobT1cbjA7bTxmLmxlbmd0aDttKyspaD1mW21dLChnPXRoaXMuZ2V0UHJldktleVdpdGgoaCxhLGQpKSYmZy5hcHBseShoKTt0aGlzLmRhdGEuaGllcmFyY2h5W2FdLm5vZGUudXBkYXRlTWF0cml4KCk7ZS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSEwfX10aGlzLnN0b3AoKX1lbHNlIGlmKCEoaDx0aGlzLnN0YXJ0VGltZSkpe2E9MDtmb3Ioaz10aGlzLmhpZXJhcmNoeS5sZW5ndGg7YTxrO2ErKyl7ZD10aGlzLmhpZXJhcmNoeVthXTtiPXRoaXMuZGF0YS5oaWVyYXJjaHlbYV07dmFyIG09Yi5rZXlzLGw9Yi5hbmltYXRpb25DYWNoZTtpZih0aGlzLkpJVENvbXBpbGUmJnZvaWQgMCE9PWZbYV1bZV0pZCBpbnN0YW5jZW9mIFRIUkVFLkJvbmU/KGQuc2tpbk1hdHJpeD1mW2FdW2VdLGQubWF0cml4V29ybGROZWVkc1VwZGF0ZT0hMSk6KGQubWF0cml4PWZbYV1bZV0sZC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlPSEwKTtlbHNlIGlmKG0ubGVuZ3RoKXt0aGlzLkpJVENvbXBpbGUmJmwmJihkIGluc3RhbmNlb2ZcblRIUkVFLkJvbmU/ZC5za2luTWF0cml4PWwub3JpZ2luYWxNYXRyaXg6ZC5tYXRyaXg9bC5vcmlnaW5hbE1hdHJpeCk7Yj1sLnByZXZLZXk7Yz1sLm5leHRLZXk7aWYoYiYmYyl7aWYoYy50aW1lPD1nKXtpZihpJiZ0aGlzLmxvb3Ape2I9bVswXTtmb3IoYz1tWzFdO2MudGltZTxoOyliPWMsYz1tW2IuaW5kZXgrMV19ZWxzZSBpZighaSlmb3IodmFyIHA9bS5sZW5ndGgtMTtjLnRpbWU8aCYmYy5pbmRleCE9PXA7KWI9YyxjPW1bYi5pbmRleCsxXTtsLnByZXZLZXk9YjtsLm5leHRLZXk9Y31jLnRpbWU+PWg/Yi5pbnRlcnBvbGF0ZShjLGgpOmIuaW50ZXJwb2xhdGUoYyxjLnRpbWUpfXRoaXMuZGF0YS5oaWVyYXJjaHlbYV0ubm9kZS51cGRhdGVNYXRyaXgoKTtkLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU9ITB9fWlmKHRoaXMuSklUQ29tcGlsZSYmdm9pZCAwPT09ZlswXVtlXSl7dGhpcy5oaWVyYXJjaHlbMF0udXBkYXRlTWF0cml4V29ybGQoITApO2ZvcihhPTA7YTx0aGlzLmhpZXJhcmNoeS5sZW5ndGg7YSsrKWZbYV1bZV09XG50aGlzLmhpZXJhcmNoeVthXWluc3RhbmNlb2YgVEhSRUUuQm9uZT90aGlzLmhpZXJhcmNoeVthXS5za2luTWF0cml4LmNsb25lKCk6dGhpcy5oaWVyYXJjaHlbYV0ubWF0cml4LmNsb25lKCl9fX19O1RIUkVFLktleUZyYW1lQW5pbWF0aW9uLnByb3RvdHlwZS5nZXROZXh0S2V5V2l0aD1mdW5jdGlvbihhLGIsYyl7Yj10aGlzLmRhdGEuaGllcmFyY2h5W2JdLmtleXM7Zm9yKGMlPWIubGVuZ3RoO2M8Yi5sZW5ndGg7YysrKWlmKGJbY10uaGFzVGFyZ2V0KGEpKXJldHVybiBiW2NdO3JldHVybiBiWzBdfTtUSFJFRS5LZXlGcmFtZUFuaW1hdGlvbi5wcm90b3R5cGUuZ2V0UHJldktleVdpdGg9ZnVuY3Rpb24oYSxiLGMpe2I9dGhpcy5kYXRhLmhpZXJhcmNoeVtiXS5rZXlzO2ZvcihjPTA8PWM/YzpjK2IubGVuZ3RoOzA8PWM7Yy0tKWlmKGJbY10uaGFzVGFyZ2V0KGEpKXJldHVybiBiW2NdO3JldHVybiBiW2IubGVuZ3RoLTFdfTtUSFJFRS5DdWJlQ2FtZXJhPWZ1bmN0aW9uKGEsYixjKXtUSFJFRS5PYmplY3QzRC5jYWxsKHRoaXMpO3ZhciBkPW5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg5MCwxLGEsYik7ZC51cC5zZXQoMCwtMSwwKTtkLmxvb2tBdChuZXcgVEhSRUUuVmVjdG9yMygxLDAsMCkpO3RoaXMuYWRkKGQpO3ZhciBlPW5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg5MCwxLGEsYik7ZS51cC5zZXQoMCwtMSwwKTtlLmxvb2tBdChuZXcgVEhSRUUuVmVjdG9yMygtMSwwLDApKTt0aGlzLmFkZChlKTt2YXIgZj1uZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoOTAsMSxhLGIpO2YudXAuc2V0KDAsMCwxKTtmLmxvb2tBdChuZXcgVEhSRUUuVmVjdG9yMygwLDEsMCkpO3RoaXMuYWRkKGYpO3ZhciBoPW5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg5MCwxLGEsYik7aC51cC5zZXQoMCwwLC0xKTtoLmxvb2tBdChuZXcgVEhSRUUuVmVjdG9yMygwLC0xLDApKTt0aGlzLmFkZChoKTt2YXIgZz1uZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoOTAsXG4xLGEsYik7Zy51cC5zZXQoMCwtMSwwKTtnLmxvb2tBdChuZXcgVEhSRUUuVmVjdG9yMygwLDAsMSkpO3RoaXMuYWRkKGcpO3ZhciBpPW5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg5MCwxLGEsYik7aS51cC5zZXQoMCwtMSwwKTtpLmxvb2tBdChuZXcgVEhSRUUuVmVjdG9yMygwLDAsLTEpKTt0aGlzLmFkZChpKTt0aGlzLnJlbmRlclRhcmdldD1uZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlKGMsYyx7Zm9ybWF0OlRIUkVFLlJHQkZvcm1hdCxtYWdGaWx0ZXI6VEhSRUUuTGluZWFyRmlsdGVyLG1pbkZpbHRlcjpUSFJFRS5MaW5lYXJGaWx0ZXJ9KTt0aGlzLnVwZGF0ZUN1YmVNYXA9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLnJlbmRlclRhcmdldCxwPWMuZ2VuZXJhdGVNaXBtYXBzO2MuZ2VuZXJhdGVNaXBtYXBzPSExO2MuYWN0aXZlQ3ViZUZhY2U9MDthLnJlbmRlcihiLGQsYyk7Yy5hY3RpdmVDdWJlRmFjZT0xO2EucmVuZGVyKGIsZSxjKTtjLmFjdGl2ZUN1YmVGYWNlPVxuMjthLnJlbmRlcihiLGYsYyk7Yy5hY3RpdmVDdWJlRmFjZT0zO2EucmVuZGVyKGIsaCxjKTtjLmFjdGl2ZUN1YmVGYWNlPTQ7YS5yZW5kZXIoYixnLGMpO2MuZ2VuZXJhdGVNaXBtYXBzPXA7Yy5hY3RpdmVDdWJlRmFjZT01O2EucmVuZGVyKGIsaSxjKX19O1RIUkVFLkN1YmVDYW1lcmEucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlKTtUSFJFRS5Db21iaW5lZENhbWVyYT1mdW5jdGlvbihhLGIsYyxkLGUsZixoKXtUSFJFRS5DYW1lcmEuY2FsbCh0aGlzKTt0aGlzLmZvdj1jO3RoaXMubGVmdD0tYS8yO3RoaXMucmlnaHQ9YS8yO3RoaXMudG9wPWIvMjt0aGlzLmJvdHRvbT0tYi8yO3RoaXMuY2FtZXJhTz1uZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKGEvLTIsYS8yLGIvMixiLy0yLGYsaCk7dGhpcy5jYW1lcmFQPW5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYShjLGEvYixkLGUpO3RoaXMuem9vbT0xO3RoaXMudG9QZXJzcGVjdGl2ZSgpfTtUSFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5DYW1lcmEucHJvdG90eXBlKTtcblRIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS50b1BlcnNwZWN0aXZlPWZ1bmN0aW9uKCl7dGhpcy5uZWFyPXRoaXMuY2FtZXJhUC5uZWFyO3RoaXMuZmFyPXRoaXMuY2FtZXJhUC5mYXI7dGhpcy5jYW1lcmFQLmZvdj10aGlzLmZvdi90aGlzLnpvb207dGhpcy5jYW1lcmFQLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTt0aGlzLnByb2plY3Rpb25NYXRyaXg9dGhpcy5jYW1lcmFQLnByb2plY3Rpb25NYXRyaXg7dGhpcy5pblBlcnNwZWN0aXZlTW9kZT0hMDt0aGlzLmluT3J0aG9ncmFwaGljTW9kZT0hMX07XG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUudG9PcnRob2dyYXBoaWM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNhbWVyYVAuYXNwZWN0LGI9KHRoaXMuY2FtZXJhUC5uZWFyK3RoaXMuY2FtZXJhUC5mYXIpLzIsYj1NYXRoLnRhbih0aGlzLmZvdi8yKSpiLGE9MipiKmEvMixiPWIvdGhpcy56b29tLGE9YS90aGlzLnpvb207dGhpcy5jYW1lcmFPLmxlZnQ9LWE7dGhpcy5jYW1lcmFPLnJpZ2h0PWE7dGhpcy5jYW1lcmFPLnRvcD1iO3RoaXMuY2FtZXJhTy5ib3R0b209LWI7dGhpcy5jYW1lcmFPLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTt0aGlzLm5lYXI9dGhpcy5jYW1lcmFPLm5lYXI7dGhpcy5mYXI9dGhpcy5jYW1lcmFPLmZhcjt0aGlzLnByb2plY3Rpb25NYXRyaXg9dGhpcy5jYW1lcmFPLnByb2plY3Rpb25NYXRyaXg7dGhpcy5pblBlcnNwZWN0aXZlTW9kZT0hMTt0aGlzLmluT3J0aG9ncmFwaGljTW9kZT0hMH07XG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUuc2V0U2l6ZT1mdW5jdGlvbihhLGIpe3RoaXMuY2FtZXJhUC5hc3BlY3Q9YS9iO3RoaXMubGVmdD0tYS8yO3RoaXMucmlnaHQ9YS8yO3RoaXMudG9wPWIvMjt0aGlzLmJvdHRvbT0tYi8yfTtUSFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUuc2V0Rm92PWZ1bmN0aW9uKGEpe3RoaXMuZm92PWE7dGhpcy5pblBlcnNwZWN0aXZlTW9kZT90aGlzLnRvUGVyc3BlY3RpdmUoKTp0aGlzLnRvT3J0aG9ncmFwaGljKCl9O1RIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVQcm9qZWN0aW9uTWF0cml4PWZ1bmN0aW9uKCl7dGhpcy5pblBlcnNwZWN0aXZlTW9kZT90aGlzLnRvUGVyc3BlY3RpdmUoKToodGhpcy50b1BlcnNwZWN0aXZlKCksdGhpcy50b09ydGhvZ3JhcGhpYygpKX07XG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUuc2V0TGVucz1mdW5jdGlvbihhLGIpe3ZvaWQgMD09PWImJihiPTI0KTt2YXIgYz0yKlRIUkVFLk1hdGgucmFkVG9EZWcoTWF0aC5hdGFuKGIvKDIqYSkpKTt0aGlzLnNldEZvdihjKTtyZXR1cm4gY307VEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnNldFpvb209ZnVuY3Rpb24oYSl7dGhpcy56b29tPWE7dGhpcy5pblBlcnNwZWN0aXZlTW9kZT90aGlzLnRvUGVyc3BlY3RpdmUoKTp0aGlzLnRvT3J0aG9ncmFwaGljKCl9O1RIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS50b0Zyb250Vmlldz1mdW5jdGlvbigpe3RoaXMucm90YXRpb24ueD0wO3RoaXMucm90YXRpb24ueT0wO3RoaXMucm90YXRpb24uej0wO3RoaXMucm90YXRpb25BdXRvVXBkYXRlPSExfTtcblRIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS50b0JhY2tWaWV3PWZ1bmN0aW9uKCl7dGhpcy5yb3RhdGlvbi54PTA7dGhpcy5yb3RhdGlvbi55PU1hdGguUEk7dGhpcy5yb3RhdGlvbi56PTA7dGhpcy5yb3RhdGlvbkF1dG9VcGRhdGU9ITF9O1RIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS50b0xlZnRWaWV3PWZ1bmN0aW9uKCl7dGhpcy5yb3RhdGlvbi54PTA7dGhpcy5yb3RhdGlvbi55PS1NYXRoLlBJLzI7dGhpcy5yb3RhdGlvbi56PTA7dGhpcy5yb3RhdGlvbkF1dG9VcGRhdGU9ITF9O1RIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS50b1JpZ2h0Vmlldz1mdW5jdGlvbigpe3RoaXMucm90YXRpb24ueD0wO3RoaXMucm90YXRpb24ueT1NYXRoLlBJLzI7dGhpcy5yb3RhdGlvbi56PTA7dGhpcy5yb3RhdGlvbkF1dG9VcGRhdGU9ITF9O1xuVEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnRvVG9wVmlldz1mdW5jdGlvbigpe3RoaXMucm90YXRpb24ueD0tTWF0aC5QSS8yO3RoaXMucm90YXRpb24ueT0wO3RoaXMucm90YXRpb24uej0wO3RoaXMucm90YXRpb25BdXRvVXBkYXRlPSExfTtUSFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUudG9Cb3R0b21WaWV3PWZ1bmN0aW9uKCl7dGhpcy5yb3RhdGlvbi54PU1hdGguUEkvMjt0aGlzLnJvdGF0aW9uLnk9MDt0aGlzLnJvdGF0aW9uLno9MDt0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZT0hMX07VEhSRUUuQ2lyY2xlR2VvbWV0cnk9ZnVuY3Rpb24oYSxiLGMsZCl7VEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKTt0aGlzLnJhZGl1cz1hPWF8fDUwO3RoaXMuc2VnbWVudHM9Yj12b2lkIDAhPT1iP01hdGgubWF4KDMsYik6ODt0aGlzLnRoZXRhU3RhcnQ9Yz12b2lkIDAhPT1jP2M6MDt0aGlzLnRoZXRhTGVuZ3RoPWQ9dm9pZCAwIT09ZD9kOjIqTWF0aC5QSTt2YXIgZSxmPVtdO2U9bmV3IFRIUkVFLlZlY3RvcjM7dmFyIGg9bmV3IFRIUkVFLlZlY3RvcjIoMC41LDAuNSk7dGhpcy52ZXJ0aWNlcy5wdXNoKGUpO2YucHVzaChoKTtmb3IoZT0wO2U8PWI7ZSsrKXt2YXIgZz1uZXcgVEhSRUUuVmVjdG9yMyxpPWMrZS9iKmQ7Zy54PWEqTWF0aC5jb3MoaSk7Zy55PWEqTWF0aC5zaW4oaSk7dGhpcy52ZXJ0aWNlcy5wdXNoKGcpO2YucHVzaChuZXcgVEhSRUUuVmVjdG9yMigoZy54L2ErMSkvMiwoZy55L2ErMSkvMikpfWM9bmV3IFRIUkVFLlZlY3RvcjMoMCwwLDEpO2ZvcihlPTE7ZTw9YjtlKyspdGhpcy5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMyhlLFxuZSsxLDAsW2MsYyxjXSkpLHRoaXMuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtmW2VdLGZbZSsxXSxoXSk7dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTt0aGlzLmJvdW5kaW5nU3BoZXJlPW5ldyBUSFJFRS5TcGhlcmUobmV3IFRIUkVFLlZlY3RvcjMsYSl9O1RIUkVFLkNpcmNsZUdlb21ldHJ5LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSk7VEhSRUUuQ3ViZUdlb21ldHJ5PWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtmdW5jdGlvbiBoKGEsYixjLGQsZSxmLGgsbil7dmFyIHIscT1nLndpZHRoU2VnbWVudHMsdT1nLmhlaWdodFNlZ21lbnRzLHc9ZS8yLHo9Zi8yLEI9Zy52ZXJ0aWNlcy5sZW5ndGg7aWYoXCJ4XCI9PT1hJiZcInlcIj09PWJ8fFwieVwiPT09YSYmXCJ4XCI9PT1iKXI9XCJ6XCI7ZWxzZSBpZihcInhcIj09PWEmJlwielwiPT09Ynx8XCJ6XCI9PT1hJiZcInhcIj09PWIpcj1cInlcIix1PWcuZGVwdGhTZWdtZW50cztlbHNlIGlmKFwielwiPT09YSYmXCJ5XCI9PT1ifHxcInlcIj09PWEmJlwielwiPT09YilyPVwieFwiLHE9Zy5kZXB0aFNlZ21lbnRzO3ZhciBEPXErMSx4PXUrMSxGPWUvcSxBPWYvdSxPPW5ldyBUSFJFRS5WZWN0b3IzO09bcl09MDxoPzE6LTE7Zm9yKGU9MDtlPHg7ZSsrKWZvcihmPTA7ZjxEO2YrKyl7dmFyIEM9bmV3IFRIUkVFLlZlY3RvcjM7Q1thXT0oZipGLXcpKmM7Q1tiXT0oZSpBLXopKmQ7Q1tyXT1oO2cudmVydGljZXMucHVzaChDKX1mb3IoZT1cbjA7ZTx1O2UrKylmb3IoZj0wO2Y8cTtmKyspej1mK0QqZSxhPWYrRCooZSsxKSxiPWYrMStEKihlKzEpLGM9ZisxK0QqZSxkPW5ldyBUSFJFRS5WZWN0b3IyKGYvcSwxLWUvdSksaD1uZXcgVEhSRUUuVmVjdG9yMihmL3EsMS0oZSsxKS91KSxyPW5ldyBUSFJFRS5WZWN0b3IyKChmKzEpL3EsMS0oZSsxKS91KSx3PW5ldyBUSFJFRS5WZWN0b3IyKChmKzEpL3EsMS1lL3UpLHo9bmV3IFRIUkVFLkZhY2UzKHorQixhK0IsYytCKSx6Lm5vcm1hbC5jb3B5KE8pLHoudmVydGV4Tm9ybWFscy5wdXNoKE8uY2xvbmUoKSxPLmNsb25lKCksTy5jbG9uZSgpKSx6Lm1hdGVyaWFsSW5kZXg9bixnLmZhY2VzLnB1c2goeiksZy5mYWNlVmVydGV4VXZzWzBdLnB1c2goW2QsaCx3XSksej1uZXcgVEhSRUUuRmFjZTMoYStCLGIrQixjK0IpLHoubm9ybWFsLmNvcHkoTyksei52ZXJ0ZXhOb3JtYWxzLnB1c2goTy5jbG9uZSgpLE8uY2xvbmUoKSxPLmNsb25lKCkpLHoubWF0ZXJpYWxJbmRleD1uLGcuZmFjZXMucHVzaCh6KSxcbmcuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtoLmNsb25lKCkscix3LmNsb25lKCldKX1USFJFRS5HZW9tZXRyeS5jYWxsKHRoaXMpO3ZhciBnPXRoaXM7dGhpcy53aWR0aD1hO3RoaXMuaGVpZ2h0PWI7dGhpcy5kZXB0aD1jO3RoaXMud2lkdGhTZWdtZW50cz1kfHwxO3RoaXMuaGVpZ2h0U2VnbWVudHM9ZXx8MTt0aGlzLmRlcHRoU2VnbWVudHM9Znx8MTthPXRoaXMud2lkdGgvMjtiPXRoaXMuaGVpZ2h0LzI7Yz10aGlzLmRlcHRoLzI7aChcInpcIixcInlcIiwtMSwtMSx0aGlzLmRlcHRoLHRoaXMuaGVpZ2h0LGEsMCk7aChcInpcIixcInlcIiwxLC0xLHRoaXMuZGVwdGgsdGhpcy5oZWlnaHQsLWEsMSk7aChcInhcIixcInpcIiwxLDEsdGhpcy53aWR0aCx0aGlzLmRlcHRoLGIsMik7aChcInhcIixcInpcIiwxLC0xLHRoaXMud2lkdGgsdGhpcy5kZXB0aCwtYiwzKTtoKFwieFwiLFwieVwiLDEsLTEsdGhpcy53aWR0aCx0aGlzLmhlaWdodCxjLDQpO2goXCJ4XCIsXCJ5XCIsLTEsLTEsdGhpcy53aWR0aCx0aGlzLmhlaWdodCwtYyxcbjUpO3RoaXMuY29tcHV0ZUNlbnRyb2lkcygpO3RoaXMubWVyZ2VWZXJ0aWNlcygpfTtUSFJFRS5DdWJlR2VvbWV0cnkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlKTtUSFJFRS5DeWxpbmRlckdlb21ldHJ5PWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtUSFJFRS5HZW9tZXRyeS5jYWxsKHRoaXMpO3RoaXMucmFkaXVzVG9wPWE9dm9pZCAwIT09YT9hOjIwO3RoaXMucmFkaXVzQm90dG9tPWI9dm9pZCAwIT09Yj9iOjIwO3RoaXMuaGVpZ2h0PWM9dm9pZCAwIT09Yz9jOjEwMDt0aGlzLnJhZGlhbFNlZ21lbnRzPWQ9ZHx8ODt0aGlzLmhlaWdodFNlZ21lbnRzPWU9ZXx8MTt0aGlzLm9wZW5FbmRlZD1mPXZvaWQgMCE9PWY/ZjohMTt2YXIgaD1jLzIsZyxpLGs9W10sbT1bXTtmb3IoaT0wO2k8PWU7aSsrKXt2YXIgbD1bXSxwPVtdLHM9aS9lLHQ9cyooYi1hKSthO2ZvcihnPTA7Zzw9ZDtnKyspe3ZhciBuPWcvZCxyPW5ldyBUSFJFRS5WZWN0b3IzO3IueD10Kk1hdGguc2luKDIqbipNYXRoLlBJKTtyLnk9LXMqYytoO3Iuej10Kk1hdGguY29zKDIqbipNYXRoLlBJKTt0aGlzLnZlcnRpY2VzLnB1c2gocik7bC5wdXNoKHRoaXMudmVydGljZXMubGVuZ3RoLTEpO3AucHVzaChuZXcgVEhSRUUuVmVjdG9yMihuLFxuMS1zKSl9ay5wdXNoKGwpO20ucHVzaChwKX1jPShiLWEpL2M7Zm9yKGc9MDtnPGQ7ZysrKXswIT09YT8obD10aGlzLnZlcnRpY2VzW2tbMF1bZ11dLmNsb25lKCkscD10aGlzLnZlcnRpY2VzW2tbMF1bZysxXV0uY2xvbmUoKSk6KGw9dGhpcy52ZXJ0aWNlc1trWzFdW2ddXS5jbG9uZSgpLHA9dGhpcy52ZXJ0aWNlc1trWzFdW2crMV1dLmNsb25lKCkpO2wuc2V0WShNYXRoLnNxcnQobC54KmwueCtsLnoqbC56KSpjKS5ub3JtYWxpemUoKTtwLnNldFkoTWF0aC5zcXJ0KHAueCpwLngrcC56KnAueikqYykubm9ybWFsaXplKCk7Zm9yKGk9MDtpPGU7aSsrKXt2YXIgcz1rW2ldW2ddLHQ9a1tpKzFdW2ddLG49a1tpKzFdW2crMV0scj1rW2ldW2crMV0scT1sLmNsb25lKCksdT1sLmNsb25lKCksdz1wLmNsb25lKCksej1wLmNsb25lKCksQj1tW2ldW2ddLmNsb25lKCksRD1tW2krMV1bZ10uY2xvbmUoKSx4PW1baSsxXVtnKzFdLmNsb25lKCksRj1tW2ldW2crMV0uY2xvbmUoKTt0aGlzLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKHMsXG50LHIsW3EsdSx6XSkpO3RoaXMuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtCLEQsRl0pO3RoaXMuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTModCxuLHIsW3Usdyx6XSkpO3RoaXMuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtELHgsRl0pfX1pZighMT09PWYmJjA8YSl7dGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKDAsaCwwKSk7Zm9yKGc9MDtnPGQ7ZysrKXM9a1swXVtnXSx0PWtbMF1bZysxXSxuPXRoaXMudmVydGljZXMubGVuZ3RoLTEscT1uZXcgVEhSRUUuVmVjdG9yMygwLDEsMCksdT1uZXcgVEhSRUUuVmVjdG9yMygwLDEsMCksdz1uZXcgVEhSRUUuVmVjdG9yMygwLDEsMCksQj1tWzBdW2ddLmNsb25lKCksRD1tWzBdW2crMV0uY2xvbmUoKSx4PW5ldyBUSFJFRS5WZWN0b3IyKEQudSwwKSx0aGlzLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKHMsdCxuLFtxLHUsd10pKSx0aGlzLmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaChbQixELHhdKX1pZighMT09PWYmJjA8XG5iKXt0aGlzLnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoMCwtaCwwKSk7Zm9yKGc9MDtnPGQ7ZysrKXM9a1tpXVtnKzFdLHQ9a1tpXVtnXSxuPXRoaXMudmVydGljZXMubGVuZ3RoLTEscT1uZXcgVEhSRUUuVmVjdG9yMygwLC0xLDApLHU9bmV3IFRIUkVFLlZlY3RvcjMoMCwtMSwwKSx3PW5ldyBUSFJFRS5WZWN0b3IzKDAsLTEsMCksQj1tW2ldW2crMV0uY2xvbmUoKSxEPW1baV1bZ10uY2xvbmUoKSx4PW5ldyBUSFJFRS5WZWN0b3IyKEQudSwxKSx0aGlzLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKHMsdCxuLFtxLHUsd10pKSx0aGlzLmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaChbQixELHhdKX10aGlzLmNvbXB1dGVDZW50cm9pZHMoKTt0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpfTtUSFJFRS5DeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSk7VEhSRUUuRXh0cnVkZUdlb21ldHJ5PWZ1bmN0aW9uKGEsYil7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhJiYoVEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKSxhPWEgaW5zdGFuY2VvZiBBcnJheT9hOlthXSx0aGlzLnNoYXBlYmI9YVthLmxlbmd0aC0xXS5nZXRCb3VuZGluZ0JveCgpLHRoaXMuYWRkU2hhcGVMaXN0KGEsYiksdGhpcy5jb21wdXRlQ2VudHJvaWRzKCksdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKSl9O1RIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUpO1RIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0PWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPWEubGVuZ3RoLGQ9MDtkPGM7ZCsrKXRoaXMuYWRkU2hhcGUoYVtkXSxiKX07XG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlPWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIsYyl7Ynx8Y29uc29sZS5sb2coXCJkaWVcIik7cmV0dXJuIGIuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihjKS5hZGQoYSl9ZnVuY3Rpb24gZChhLGIsYyl7dmFyIGQ9VEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjEsZT1USFJFRS5FeHRydWRlR2VvbWV0cnkuX192MixmPVRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5fX3YzLGc9VEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjQsaD1USFJFRS5FeHRydWRlR2VvbWV0cnkuX192NSxpPVRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5fX3Y2O2Quc2V0KGEueC1iLngsYS55LWIueSk7ZS5zZXQoYS54LWMueCxhLnktYy55KTtkPWQubm9ybWFsaXplKCk7ZT1lLm5vcm1hbGl6ZSgpO2Yuc2V0KC1kLnksZC54KTtnLnNldChlLnksLWUueCk7aC5jb3B5KGEpLmFkZChmKTtpLmNvcHkoYSkuYWRkKGcpO2lmKGguZXF1YWxzKGkpKXJldHVybiBnLmNsb25lKCk7XG5oLmNvcHkoYikuYWRkKGYpO2kuY29weShjKS5hZGQoZyk7Zj1kLmRvdChnKTtnPWkuc3ViKGgpLmRvdChnKTswPT09ZiYmKGNvbnNvbGUubG9nKFwiRWl0aGVyIGluZmluaXRlIG9yIG5vIHNvbHV0aW9ucyFcIiksMD09PWc/Y29uc29sZS5sb2coXCJJdHMgZmluaXRlIHNvbHV0aW9ucy5cIik6Y29uc29sZS5sb2coXCJUb28gYmFkLCBubyBzb2x1dGlvbnMuXCIpKTtnLz1mO3JldHVybiAwPmc/KGI9TWF0aC5hdGFuMihiLnktYS55LGIueC1hLngpLGE9TWF0aC5hdGFuMihjLnktYS55LGMueC1hLngpLGI+YSYmKGErPTIqTWF0aC5QSSksYz0oYithKS8yLGE9LU1hdGguY29zKGMpLGM9LU1hdGguc2luKGMpLG5ldyBUSFJFRS5WZWN0b3IyKGEsYykpOmQubXVsdGlwbHlTY2FsYXIoZykuYWRkKGgpLnN1YihhKS5jbG9uZSgpfWZ1bmN0aW9uIGUoYyxkKXt2YXIgZSxmO2ZvcihOPWMubGVuZ3RoOzA8PS0tTjspe2U9TjtmPU4tMTswPmYmJihmPWMubGVuZ3RoLTEpO2Zvcih2YXIgZz0wLGg9cysyKm0sXG5nPTA7ZzxoO2crKyl7dmFyIGk9YmEqZyxrPWJhKihnKzEpLGw9ZCtlK2ksaT1kK2YraSxwPWQrZitrLGs9ZCtlK2ssbj1jLHE9ZyxyPWgsdD1lLHY9ZixsPWwrRSxpPWkrRSxwPXArRSxrPWsrRTtDLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKGwsaSxrLG51bGwsbnVsbCx1KSk7Qy5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMyhpLHAsayxudWxsLG51bGwsdSkpO2w9dy5nZW5lcmF0ZVNpZGVXYWxsVVYoQyxhLG4sYixsLGkscCxrLHEscix0LHYpO0MuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtsWzBdLGxbMV0sbFszXV0pO0MuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtsWzFdLGxbMl0sbFszXV0pfX19ZnVuY3Rpb24gZihhLGIsYyl7Qy52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKGEsYixjKSl9ZnVuY3Rpb24gaChjLGQsZSxmKXtjKz1FO2QrPUU7ZSs9RTtDLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKGMsZCxlLG51bGwsbnVsbCxxKSk7Yz1mP3cuZ2VuZXJhdGVCb3R0b21VVihDLFxuYSxiLGMsZCxlKTp3LmdlbmVyYXRlVG9wVVYoQyxhLGIsYyxkLGUpO0MuZmFjZVZlcnRleFV2c1swXS5wdXNoKGMpfXZhciBnPXZvaWQgMCE9PWIuYW1vdW50P2IuYW1vdW50OjEwMCxpPXZvaWQgMCE9PWIuYmV2ZWxUaGlja25lc3M/Yi5iZXZlbFRoaWNrbmVzczo2LGs9dm9pZCAwIT09Yi5iZXZlbFNpemU/Yi5iZXZlbFNpemU6aS0yLG09dm9pZCAwIT09Yi5iZXZlbFNlZ21lbnRzP2IuYmV2ZWxTZWdtZW50czozLGw9dm9pZCAwIT09Yi5iZXZlbEVuYWJsZWQ/Yi5iZXZlbEVuYWJsZWQ6ITAscD12b2lkIDAhPT1iLmN1cnZlU2VnbWVudHM/Yi5jdXJ2ZVNlZ21lbnRzOjEyLHM9dm9pZCAwIT09Yi5zdGVwcz9iLnN0ZXBzOjEsdD1iLmV4dHJ1ZGVQYXRoLG4scj0hMSxxPWIubWF0ZXJpYWwsdT1iLmV4dHJ1ZGVNYXRlcmlhbCx3PXZvaWQgMCE9PWIuVVZHZW5lcmF0b3I/Yi5VVkdlbmVyYXRvcjpUSFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvcix6LEIsRCx4O3QmJihuPVxudC5nZXRTcGFjZWRQb2ludHMocykscj0hMCxsPSExLHo9dm9pZCAwIT09Yi5mcmFtZXM/Yi5mcmFtZXM6bmV3IFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXModCxzLCExKSxCPW5ldyBUSFJFRS5WZWN0b3IzLEQ9bmV3IFRIUkVFLlZlY3RvcjMseD1uZXcgVEhSRUUuVmVjdG9yMyk7bHx8KGs9aT1tPTApO3ZhciBGLEEsTyxDPXRoaXMsRT10aGlzLnZlcnRpY2VzLmxlbmd0aCxwPWEuZXh0cmFjdFBvaW50cyhwKSxJPXAuc2hhcGUscD1wLmhvbGVzO2lmKHQ9IVRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKEkpKXtJPUkucmV2ZXJzZSgpO0E9MDtmb3IoTz1wLmxlbmd0aDtBPE87QSsrKUY9cFtBXSxUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZShGKSYmKHBbQV09Ri5yZXZlcnNlKCkpO3Q9ITF9dmFyIHk9VEhSRUUuU2hhcGUuVXRpbHMudHJpYW5ndWxhdGVTaGFwZShJLHApLHQ9STtBPTA7Zm9yKE89cC5sZW5ndGg7QTxPO0ErKylGPXBbQV0sST1JLmNvbmNhdChGKTtcbnZhciB2LEcsUixKLGJhPUkubGVuZ3RoLG9hPXkubGVuZ3RoLHBhPVtdLE49MCxNPXQubGVuZ3RoO3Y9TS0xO2ZvcihHPU4rMTtOPE07TisrLHYrKyxHKyspdj09PU0mJih2PTApLEc9PT1NJiYoRz0wKSxwYVtOXT1kKHRbTl0sdFt2XSx0W0ddKTt2YXIgUT1bXSxLLGNhPXBhLmNvbmNhdCgpO0E9MDtmb3IoTz1wLmxlbmd0aDtBPE87QSsrKXtGPXBbQV07Sz1bXTtOPTA7TT1GLmxlbmd0aDt2PU0tMTtmb3IoRz1OKzE7TjxNO04rKyx2KyssRysrKXY9PT1NJiYodj0wKSxHPT09TSYmKEc9MCksS1tOXT1kKEZbTl0sRlt2XSxGW0ddKTtRLnB1c2goSyk7Y2E9Y2EuY29uY2F0KEspfWZvcih2PTA7djxtO3YrKyl7Rj12L207Uj1pKigxLUYpO0c9aypNYXRoLnNpbihGKk1hdGguUEkvMik7Tj0wO2ZvcihNPXQubGVuZ3RoO048TTtOKyspSj1jKHRbTl0scGFbTl0sRyksZihKLngsSi55LC1SKTtBPTA7Zm9yKE89cC5sZW5ndGg7QTxPO0ErKyl7Rj1wW0FdO0s9UVtBXTtOPTA7Zm9yKE09Ri5sZW5ndGg7Tjxcbk07TisrKUo9YyhGW05dLEtbTl0sRyksZihKLngsSi55LC1SKX19Rz1rO2ZvcihOPTA7TjxiYTtOKyspSj1sP2MoSVtOXSxjYVtOXSxHKTpJW05dLHI/KEQuY29weSh6Lm5vcm1hbHNbMF0pLm11bHRpcGx5U2NhbGFyKEoueCksQi5jb3B5KHouYmlub3JtYWxzWzBdKS5tdWx0aXBseVNjYWxhcihKLnkpLHguY29weShuWzBdKS5hZGQoRCkuYWRkKEIpLGYoeC54LHgueSx4LnopKTpmKEoueCxKLnksMCk7Zm9yKEY9MTtGPD1zO0YrKylmb3IoTj0wO048YmE7TisrKUo9bD9jKElbTl0sY2FbTl0sRyk6SVtOXSxyPyhELmNvcHkoei5ub3JtYWxzW0ZdKS5tdWx0aXBseVNjYWxhcihKLngpLEIuY29weSh6LmJpbm9ybWFsc1tGXSkubXVsdGlwbHlTY2FsYXIoSi55KSx4LmNvcHkobltGXSkuYWRkKEQpLmFkZChCKSxmKHgueCx4LnkseC56KSk6ZihKLngsSi55LGcvcypGKTtmb3Iodj1tLTE7MDw9djt2LS0pe0Y9di9tO1I9aSooMS1GKTtHPWsqTWF0aC5zaW4oRipNYXRoLlBJLzIpO049MDtmb3IoTT1cbnQubGVuZ3RoO048TTtOKyspSj1jKHRbTl0scGFbTl0sRyksZihKLngsSi55LGcrUik7QT0wO2ZvcihPPXAubGVuZ3RoO0E8TztBKyspe0Y9cFtBXTtLPVFbQV07Tj0wO2ZvcihNPUYubGVuZ3RoO048TTtOKyspSj1jKEZbTl0sS1tOXSxHKSxyP2YoSi54LEoueStuW3MtMV0ueSxuW3MtMV0ueCtSKTpmKEoueCxKLnksZytSKX19aWYobCl7aT0wKmJhO2ZvcihOPTA7TjxvYTtOKyspZz15W05dLGgoZ1syXStpLGdbMV0raSxnWzBdK2ksITApO2k9YmEqKHMrMiptKTtmb3IoTj0wO048b2E7TisrKWc9eVtOXSxoKGdbMF0raSxnWzFdK2ksZ1syXStpLCExKX1lbHNle2ZvcihOPTA7TjxvYTtOKyspZz15W05dLGgoZ1syXSxnWzFdLGdbMF0sITApO2ZvcihOPTA7TjxvYTtOKyspZz15W05dLGgoZ1swXStiYSpzLGdbMV0rYmEqcyxnWzJdK2JhKnMsITEpfWc9MDtlKHQsZyk7Zys9dC5sZW5ndGg7QT0wO2ZvcihPPXAubGVuZ3RoO0E8TztBKyspRj1wW0FdLGUoRixnKSxnKz1GLmxlbmd0aH07XG5USFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvcj17Z2VuZXJhdGVUb3BVVjpmdW5jdGlvbihhLGIsYyxkLGUsZil7Yj1hLnZlcnRpY2VzW2VdLng7ZT1hLnZlcnRpY2VzW2VdLnk7Yz1hLnZlcnRpY2VzW2ZdLng7Zj1hLnZlcnRpY2VzW2ZdLnk7cmV0dXJuW25ldyBUSFJFRS5WZWN0b3IyKGEudmVydGljZXNbZF0ueCxhLnZlcnRpY2VzW2RdLnkpLG5ldyBUSFJFRS5WZWN0b3IyKGIsZSksbmV3IFRIUkVFLlZlY3RvcjIoYyxmKV19LGdlbmVyYXRlQm90dG9tVVY6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3JldHVybiB0aGlzLmdlbmVyYXRlVG9wVVYoYSxiLGMsZCxlLGYpfSxnZW5lcmF0ZVNpZGVXYWxsVVY6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsaCxnKXt2YXIgYj1hLnZlcnRpY2VzW2VdLngsYz1hLnZlcnRpY2VzW2VdLnksZT1hLnZlcnRpY2VzW2VdLnosZD1hLnZlcnRpY2VzW2ZdLngsaT1hLnZlcnRpY2VzW2ZdLnksZj1hLnZlcnRpY2VzW2ZdLnosaz1hLnZlcnRpY2VzW2hdLngsXG5tPWEudmVydGljZXNbaF0ueSxoPWEudmVydGljZXNbaF0ueixsPWEudmVydGljZXNbZ10ueCxwPWEudmVydGljZXNbZ10ueSxhPWEudmVydGljZXNbZ10uejtyZXR1cm4gMC4wMT5NYXRoLmFicyhjLWkpP1tuZXcgVEhSRUUuVmVjdG9yMihiLDEtZSksbmV3IFRIUkVFLlZlY3RvcjIoZCwxLWYpLG5ldyBUSFJFRS5WZWN0b3IyKGssMS1oKSxuZXcgVEhSRUUuVmVjdG9yMihsLDEtYSldOltuZXcgVEhSRUUuVmVjdG9yMihjLDEtZSksbmV3IFRIUkVFLlZlY3RvcjIoaSwxLWYpLG5ldyBUSFJFRS5WZWN0b3IyKG0sMS1oKSxuZXcgVEhSRUUuVmVjdG9yMihwLDEtYSldfX07VEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjE9bmV3IFRIUkVFLlZlY3RvcjI7VEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjI9bmV3IFRIUkVFLlZlY3RvcjI7VEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjM9bmV3IFRIUkVFLlZlY3RvcjI7VEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjQ9bmV3IFRIUkVFLlZlY3RvcjI7XG5USFJFRS5FeHRydWRlR2VvbWV0cnkuX192NT1uZXcgVEhSRUUuVmVjdG9yMjtUSFJFRS5FeHRydWRlR2VvbWV0cnkuX192Nj1uZXcgVEhSRUUuVmVjdG9yMjtUSFJFRS5TaGFwZUdlb21ldHJ5PWZ1bmN0aW9uKGEsYil7VEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKTshMT09PWEgaW5zdGFuY2VvZiBBcnJheSYmKGE9W2FdKTt0aGlzLnNoYXBlYmI9YVthLmxlbmd0aC0xXS5nZXRCb3VuZGluZ0JveCgpO3RoaXMuYWRkU2hhcGVMaXN0KGEsYik7dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKX07VEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUpO1RIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlTGlzdD1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wLGQ9YS5sZW5ndGg7YzxkO2MrKyl0aGlzLmFkZFNoYXBlKGFbY10sYik7cmV0dXJuIHRoaXN9O1xuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGU9ZnVuY3Rpb24oYSxiKXt2b2lkIDA9PT1iJiYoYj17fSk7dmFyIGM9Yi5tYXRlcmlhbCxkPXZvaWQgMD09PWIuVVZHZW5lcmF0b3I/VEhSRUUuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3I6Yi5VVkdlbmVyYXRvcixlLGYsaCxnPXRoaXMudmVydGljZXMubGVuZ3RoO2U9YS5leHRyYWN0UG9pbnRzKHZvaWQgMCE9PWIuY3VydmVTZWdtZW50cz9iLmN1cnZlU2VnbWVudHM6MTIpO3ZhciBpPWUuc2hhcGUsaz1lLmhvbGVzO2lmKCFUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZShpKSl7aT1pLnJldmVyc2UoKTtlPTA7Zm9yKGY9ay5sZW5ndGg7ZTxmO2UrKyloPWtbZV0sVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoaCkmJihrW2VdPWgucmV2ZXJzZSgpKX12YXIgbT1USFJFRS5TaGFwZS5VdGlscy50cmlhbmd1bGF0ZVNoYXBlKGksayk7ZT0wO2ZvcihmPWsubGVuZ3RoO2U8ZjtlKyspaD1rW2VdLFxuaT1pLmNvbmNhdChoKTtrPWkubGVuZ3RoO2Y9bS5sZW5ndGg7Zm9yKGU9MDtlPGs7ZSsrKWg9aVtlXSx0aGlzLnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoaC54LGgueSwwKSk7Zm9yKGU9MDtlPGY7ZSsrKWs9bVtlXSxpPWtbMF0rZyxoPWtbMV0rZyxrPWtbMl0rZyx0aGlzLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKGksaCxrLG51bGwsbnVsbCxjKSksdGhpcy5mYWNlVmVydGV4VXZzWzBdLnB1c2goZC5nZW5lcmF0ZUJvdHRvbVVWKHRoaXMsYSxiLGksaCxrKSl9O1RIUkVFLkxhdGhlR2VvbWV0cnk9ZnVuY3Rpb24oYSxiLGMsZCl7VEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKTtmb3IodmFyIGI9Ynx8MTIsYz1jfHwwLGQ9ZHx8MipNYXRoLlBJLGU9MS8oYS5sZW5ndGgtMSksZj0xL2IsaD0wLGc9YjtoPD1nO2grKylmb3IodmFyIGk9YytoKmYqZCxrPU1hdGguY29zKGkpLG09TWF0aC5zaW4oaSksaT0wLGw9YS5sZW5ndGg7aTxsO2krKyl7dmFyIHA9YVtpXSxzPW5ldyBUSFJFRS5WZWN0b3IzO3MueD1rKnAueC1tKnAueTtzLnk9bSpwLngraypwLnk7cy56PXAuejt0aGlzLnZlcnRpY2VzLnB1c2gocyl9Yz1hLmxlbmd0aDtoPTA7Zm9yKGc9YjtoPGc7aCsrKXtpPTA7Zm9yKGw9YS5sZW5ndGgtMTtpPGw7aSsrKXt2YXIgYj1tPWkrYypoLGQ9bStjLGs9bSsxK2MsbT1tKzEscD1oKmYscz1pKmUsdD1wK2Ysbj1zK2U7dGhpcy5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMyhiLGQsbSkpO3RoaXMuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtuZXcgVEhSRUUuVmVjdG9yMihwLFxucyksbmV3IFRIUkVFLlZlY3RvcjIodCxzKSxuZXcgVEhSRUUuVmVjdG9yMihwLG4pXSk7dGhpcy5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMyhkLGssbSkpO3RoaXMuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtuZXcgVEhSRUUuVmVjdG9yMih0LHMpLG5ldyBUSFJFRS5WZWN0b3IyKHQsbiksbmV3IFRIUkVFLlZlY3RvcjIocCxuKV0pfX10aGlzLm1lcmdlVmVydGljZXMoKTt0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTt0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO3RoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKX07VEhSRUUuTGF0aGVHZW9tZXRyeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUpO1RIUkVFLlBsYW5lR2VvbWV0cnk9ZnVuY3Rpb24oYSxiLGMsZCl7VEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKTt0aGlzLndpZHRoPWE7dGhpcy5oZWlnaHQ9Yjt0aGlzLndpZHRoU2VnbWVudHM9Y3x8MTt0aGlzLmhlaWdodFNlZ21lbnRzPWR8fDE7Zm9yKHZhciBlPWEvMixmPWIvMixjPXRoaXMud2lkdGhTZWdtZW50cyxkPXRoaXMuaGVpZ2h0U2VnbWVudHMsaD1jKzEsZz1kKzEsaT10aGlzLndpZHRoL2Msaz10aGlzLmhlaWdodC9kLG09bmV3IFRIUkVFLlZlY3RvcjMoMCwwLDEpLGE9MDthPGc7YSsrKWZvcihiPTA7YjxoO2IrKyl0aGlzLnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoYippLWUsLShhKmstZiksMCkpO2ZvcihhPTA7YTxkO2ErKylmb3IoYj0wO2I8YztiKyspe3ZhciBsPWIraCphLGU9YitoKihhKzEpLGY9YisxK2gqKGErMSksZz1iKzEraCphLGk9bmV3IFRIUkVFLlZlY3RvcjIoYi9jLDEtYS9kKSxrPW5ldyBUSFJFRS5WZWN0b3IyKGIvYywxLShhKzEpL1xuZCkscD1uZXcgVEhSRUUuVmVjdG9yMigoYisxKS9jLDEtKGErMSkvZCkscz1uZXcgVEhSRUUuVmVjdG9yMigoYisxKS9jLDEtYS9kKSxsPW5ldyBUSFJFRS5GYWNlMyhsLGUsZyk7bC5ub3JtYWwuY29weShtKTtsLnZlcnRleE5vcm1hbHMucHVzaChtLmNsb25lKCksbS5jbG9uZSgpLG0uY2xvbmUoKSk7dGhpcy5mYWNlcy5wdXNoKGwpO3RoaXMuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtpLGssc10pO2w9bmV3IFRIUkVFLkZhY2UzKGUsZixnKTtsLm5vcm1hbC5jb3B5KG0pO2wudmVydGV4Tm9ybWFscy5wdXNoKG0uY2xvbmUoKSxtLmNsb25lKCksbS5jbG9uZSgpKTt0aGlzLmZhY2VzLnB1c2gobCk7dGhpcy5mYWNlVmVydGV4VXZzWzBdLnB1c2goW2suY2xvbmUoKSxwLHMuY2xvbmUoKV0pfXRoaXMuY29tcHV0ZUNlbnRyb2lkcygpfTtUSFJFRS5QbGFuZUdlb21ldHJ5LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSk7VEhSRUUuUmluZ0dlb21ldHJ5PWZ1bmN0aW9uKGEsYixjLGQsZSxmKXtUSFJFRS5HZW9tZXRyeS5jYWxsKHRoaXMpO2Zvcih2YXIgYT1hfHwwLGI9Ynx8NTAsZT12b2lkIDAhPT1lP2U6MCxmPXZvaWQgMCE9PWY/ZjoyKk1hdGguUEksYz12b2lkIDAhPT1jP01hdGgubWF4KDMsYyk6OCxkPXZvaWQgMCE9PWQ/TWF0aC5tYXgoMyxkKTo4LGg9W10sZz1hLGk9KGItYSkvZCxhPTA7YTw9ZDthKyspe2ZvcihiPTA7Yjw9YztiKyspe3ZhciBrPW5ldyBUSFJFRS5WZWN0b3IzLG09ZStiL2MqZjtrLng9ZypNYXRoLmNvcyhtKTtrLnk9ZypNYXRoLnNpbihtKTt0aGlzLnZlcnRpY2VzLnB1c2goayk7aC5wdXNoKG5ldyBUSFJFRS5WZWN0b3IyKChrLngvZysxKS8yLC0oay55L2crMSkvMisxKSl9Zys9aX1lPW5ldyBUSFJFRS5WZWN0b3IzKDAsMCwxKTtmb3IoYT0wO2E8ZDthKyspe2Y9YSpjO2ZvcihiPTA7Yjw9YztiKyspe3ZhciBtPWIrZixpPW0rYSxrPW0rYythLGw9bStjKzErYTt0aGlzLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKGksXG5rLGwsW2UsZSxlXSkpO3RoaXMuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtoW2ldLGhba10saFtsXV0pO2k9bSthO2s9bStjKzErYTtsPW0rMSthO3RoaXMuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoaSxrLGwsW2UsZSxlXSkpO3RoaXMuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtoW2ldLGhba10saFtsXV0pfX10aGlzLmNvbXB1dGVDZW50cm9pZHMoKTt0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO3RoaXMuYm91bmRpbmdTcGhlcmU9bmV3IFRIUkVFLlNwaGVyZShuZXcgVEhSRUUuVmVjdG9yMyxnKX07VEhSRUUuUmluZ0dlb21ldHJ5LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSk7VEhSRUUuU3BoZXJlR2VvbWV0cnk9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsaCl7VEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKTt0aGlzLnJhZGl1cz1hPWF8fDUwO3RoaXMud2lkdGhTZWdtZW50cz1iPU1hdGgubWF4KDMsTWF0aC5mbG9vcihiKXx8OCk7dGhpcy5oZWlnaHRTZWdtZW50cz1jPU1hdGgubWF4KDIsTWF0aC5mbG9vcihjKXx8Nik7dGhpcy5waGlTdGFydD1kPXZvaWQgMCE9PWQ/ZDowO3RoaXMucGhpTGVuZ3RoPWU9dm9pZCAwIT09ZT9lOjIqTWF0aC5QSTt0aGlzLnRoZXRhU3RhcnQ9Zj12b2lkIDAhPT1mP2Y6MDt0aGlzLnRoZXRhTGVuZ3RoPWg9dm9pZCAwIT09aD9oOk1hdGguUEk7dmFyIGcsaSxrPVtdLG09W107Zm9yKGk9MDtpPD1jO2krKyl7dmFyIGw9W10scD1bXTtmb3IoZz0wO2c8PWI7ZysrKXt2YXIgcz1nL2IsdD1pL2Msbj1uZXcgVEhSRUUuVmVjdG9yMztuLng9LWEqTWF0aC5jb3MoZCtzKmUpKk1hdGguc2luKGYrdCpoKTtuLnk9YSpNYXRoLmNvcyhmK3QqaCk7XG5uLno9YSpNYXRoLnNpbihkK3MqZSkqTWF0aC5zaW4oZit0KmgpO3RoaXMudmVydGljZXMucHVzaChuKTtsLnB1c2godGhpcy52ZXJ0aWNlcy5sZW5ndGgtMSk7cC5wdXNoKG5ldyBUSFJFRS5WZWN0b3IyKHMsMS10KSl9ay5wdXNoKGwpO20ucHVzaChwKX1mb3IoaT0wO2k8dGhpcy5oZWlnaHRTZWdtZW50cztpKyspZm9yKGc9MDtnPHRoaXMud2lkdGhTZWdtZW50cztnKyspe3ZhciBiPWtbaV1bZysxXSxjPWtbaV1bZ10sZD1rW2krMV1bZ10sZT1rW2krMV1bZysxXSxmPXRoaXMudmVydGljZXNbYl0uY2xvbmUoKS5ub3JtYWxpemUoKSxoPXRoaXMudmVydGljZXNbY10uY2xvbmUoKS5ub3JtYWxpemUoKSxsPXRoaXMudmVydGljZXNbZF0uY2xvbmUoKS5ub3JtYWxpemUoKSxwPXRoaXMudmVydGljZXNbZV0uY2xvbmUoKS5ub3JtYWxpemUoKSxzPW1baV1bZysxXS5jbG9uZSgpLHQ9bVtpXVtnXS5jbG9uZSgpLG49bVtpKzFdW2ddLmNsb25lKCkscj1tW2krMV1bZysxXS5jbG9uZSgpO01hdGguYWJzKHRoaXMudmVydGljZXNbYl0ueSk9PT1cbnRoaXMucmFkaXVzPyh0aGlzLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKGIsZCxlLFtmLGwscF0pKSx0aGlzLmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaChbcyxuLHJdKSk6TWF0aC5hYnModGhpcy52ZXJ0aWNlc1tkXS55KT09PXRoaXMucmFkaXVzPyh0aGlzLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKGIsYyxkLFtmLGgsbF0pKSx0aGlzLmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaChbcyx0LG5dKSk6KHRoaXMuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoYixjLGUsW2YsaCxwXSkpLHRoaXMuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtzLHQscl0pLHRoaXMuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoYyxkLGUsW2gsbCxwXSkpLHRoaXMuZmFjZVZlcnRleFV2c1swXS5wdXNoKFt0LmNsb25lKCksbixyLmNsb25lKCldKSl9dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTt0aGlzLmJvdW5kaW5nU3BoZXJlPW5ldyBUSFJFRS5TcGhlcmUobmV3IFRIUkVFLlZlY3RvcjMsXG5hKX07VEhSRUUuU3BoZXJlR2VvbWV0cnkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlKTtUSFJFRS5UZXh0R2VvbWV0cnk9ZnVuY3Rpb24oYSxiKXt2YXIgYj1ifHx7fSxjPVRIUkVFLkZvbnRVdGlscy5nZW5lcmF0ZVNoYXBlcyhhLGIpO2IuYW1vdW50PXZvaWQgMCE9PWIuaGVpZ2h0P2IuaGVpZ2h0OjUwO3ZvaWQgMD09PWIuYmV2ZWxUaGlja25lc3MmJihiLmJldmVsVGhpY2tuZXNzPTEwKTt2b2lkIDA9PT1iLmJldmVsU2l6ZSYmKGIuYmV2ZWxTaXplPTgpO3ZvaWQgMD09PWIuYmV2ZWxFbmFibGVkJiYoYi5iZXZlbEVuYWJsZWQ9ITEpO1RIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5jYWxsKHRoaXMsYyxiKX07VEhSRUUuVGV4dEdlb21ldHJ5LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUpO1RIUkVFLlRvcnVzR2VvbWV0cnk9ZnVuY3Rpb24oYSxiLGMsZCxlKXtUSFJFRS5HZW9tZXRyeS5jYWxsKHRoaXMpO3RoaXMucmFkaXVzPWF8fDEwMDt0aGlzLnR1YmU9Ynx8NDA7dGhpcy5yYWRpYWxTZWdtZW50cz1jfHw4O3RoaXMudHVidWxhclNlZ21lbnRzPWR8fDY7dGhpcy5hcmM9ZXx8MipNYXRoLlBJO2U9bmV3IFRIUkVFLlZlY3RvcjM7YT1bXTtiPVtdO2ZvcihjPTA7Yzw9dGhpcy5yYWRpYWxTZWdtZW50cztjKyspZm9yKGQ9MDtkPD10aGlzLnR1YnVsYXJTZWdtZW50cztkKyspe3ZhciBmPWQvdGhpcy50dWJ1bGFyU2VnbWVudHMqdGhpcy5hcmMsaD0yKmMvdGhpcy5yYWRpYWxTZWdtZW50cypNYXRoLlBJO2UueD10aGlzLnJhZGl1cypNYXRoLmNvcyhmKTtlLnk9dGhpcy5yYWRpdXMqTWF0aC5zaW4oZik7dmFyIGc9bmV3IFRIUkVFLlZlY3RvcjM7Zy54PSh0aGlzLnJhZGl1cyt0aGlzLnR1YmUqTWF0aC5jb3MoaCkpKk1hdGguY29zKGYpO2cueT0odGhpcy5yYWRpdXMrdGhpcy50dWJlKlxuTWF0aC5jb3MoaCkpKk1hdGguc2luKGYpO2cuej10aGlzLnR1YmUqTWF0aC5zaW4oaCk7dGhpcy52ZXJ0aWNlcy5wdXNoKGcpO2EucHVzaChuZXcgVEhSRUUuVmVjdG9yMihkL3RoaXMudHVidWxhclNlZ21lbnRzLGMvdGhpcy5yYWRpYWxTZWdtZW50cykpO2IucHVzaChnLmNsb25lKCkuc3ViKGUpLm5vcm1hbGl6ZSgpKX1mb3IoYz0xO2M8PXRoaXMucmFkaWFsU2VnbWVudHM7YysrKWZvcihkPTE7ZDw9dGhpcy50dWJ1bGFyU2VnbWVudHM7ZCsrKXt2YXIgZT0odGhpcy50dWJ1bGFyU2VnbWVudHMrMSkqYytkLTEsZj0odGhpcy50dWJ1bGFyU2VnbWVudHMrMSkqKGMtMSkrZC0xLGg9KHRoaXMudHVidWxhclNlZ21lbnRzKzEpKihjLTEpK2QsZz0odGhpcy50dWJ1bGFyU2VnbWVudHMrMSkqYytkLGk9bmV3IFRIUkVFLkZhY2UzKGUsZixnLFtiW2VdLGJbZl0sYltnXV0pO2kubm9ybWFsLmFkZChiW2VdKTtpLm5vcm1hbC5hZGQoYltmXSk7aS5ub3JtYWwuYWRkKGJbZ10pO2kubm9ybWFsLm5vcm1hbGl6ZSgpO1xudGhpcy5mYWNlcy5wdXNoKGkpO3RoaXMuZmFjZVZlcnRleFV2c1swXS5wdXNoKFthW2VdLmNsb25lKCksYVtmXS5jbG9uZSgpLGFbZ10uY2xvbmUoKV0pO2k9bmV3IFRIUkVFLkZhY2UzKGYsaCxnLFtiW2ZdLGJbaF0sYltnXV0pO2kubm9ybWFsLmFkZChiW2ZdKTtpLm5vcm1hbC5hZGQoYltoXSk7aS5ub3JtYWwuYWRkKGJbZ10pO2kubm9ybWFsLm5vcm1hbGl6ZSgpO3RoaXMuZmFjZXMucHVzaChpKTt0aGlzLmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaChbYVtmXS5jbG9uZSgpLGFbaF0uY2xvbmUoKSxhW2ddLmNsb25lKCldKX10aGlzLmNvbXB1dGVDZW50cm9pZHMoKX07VEhSRUUuVG9ydXNHZW9tZXRyeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUpO1RIUkVFLlRvcnVzS25vdEdlb21ldHJ5PWZ1bmN0aW9uKGEsYixjLGQsZSxmLGgpe2Z1bmN0aW9uIGcoYSxiLGMsZCxlKXt2YXIgZj1NYXRoLmNvcyhhKSxnPU1hdGguc2luKGEpLGE9Yi9jKmEsYj1NYXRoLmNvcyhhKSxmPTAuNSooZCooMitiKSkqZixnPTAuNSpkKigyK2IpKmcsZD0wLjUqZSpkKk1hdGguc2luKGEpO3JldHVybiBuZXcgVEhSRUUuVmVjdG9yMyhmLGcsZCl9VEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKTt0aGlzLnJhZGl1cz1hfHwxMDA7dGhpcy50dWJlPWJ8fDQwO3RoaXMucmFkaWFsU2VnbWVudHM9Y3x8NjQ7dGhpcy50dWJ1bGFyU2VnbWVudHM9ZHx8ODt0aGlzLnA9ZXx8Mjt0aGlzLnE9Znx8Mzt0aGlzLmhlaWdodFNjYWxlPWh8fDE7dGhpcy5ncmlkPUFycmF5KHRoaXMucmFkaWFsU2VnbWVudHMpO2M9bmV3IFRIUkVFLlZlY3RvcjM7ZD1uZXcgVEhSRUUuVmVjdG9yMztlPW5ldyBUSFJFRS5WZWN0b3IzO2ZvcihhPTA7YTx0aGlzLnJhZGlhbFNlZ21lbnRzOysrYSl7dGhpcy5ncmlkW2FdPVxuQXJyYXkodGhpcy50dWJ1bGFyU2VnbWVudHMpO2I9MiooYS90aGlzLnJhZGlhbFNlZ21lbnRzKSp0aGlzLnAqTWF0aC5QSTtmPWcoYix0aGlzLnEsdGhpcy5wLHRoaXMucmFkaXVzLHRoaXMuaGVpZ2h0U2NhbGUpO2I9ZyhiKzAuMDEsdGhpcy5xLHRoaXMucCx0aGlzLnJhZGl1cyx0aGlzLmhlaWdodFNjYWxlKTtjLnN1YlZlY3RvcnMoYixmKTtkLmFkZFZlY3RvcnMoYixmKTtlLmNyb3NzVmVjdG9ycyhjLGQpO2QuY3Jvc3NWZWN0b3JzKGUsYyk7ZS5ub3JtYWxpemUoKTtkLm5vcm1hbGl6ZSgpO2ZvcihiPTA7Yjx0aGlzLnR1YnVsYXJTZWdtZW50czsrK2Ipe3ZhciBpPTIqKGIvdGhpcy50dWJ1bGFyU2VnbWVudHMpKk1hdGguUEksaD0tdGhpcy50dWJlKk1hdGguY29zKGkpLGk9dGhpcy50dWJlKk1hdGguc2luKGkpLGs9bmV3IFRIUkVFLlZlY3RvcjM7ay54PWYueCtoKmQueCtpKmUueDtrLnk9Zi55K2gqZC55K2kqZS55O2suej1mLnoraCpkLnoraSplLno7dGhpcy5ncmlkW2FdW2JdPVxudGhpcy52ZXJ0aWNlcy5wdXNoKGspLTF9fWZvcihhPTA7YTx0aGlzLnJhZGlhbFNlZ21lbnRzOysrYSlmb3IoYj0wO2I8dGhpcy50dWJ1bGFyU2VnbWVudHM7KytiKXt2YXIgZT0oYSsxKSV0aGlzLnJhZGlhbFNlZ21lbnRzLGY9KGIrMSkldGhpcy50dWJ1bGFyU2VnbWVudHMsYz10aGlzLmdyaWRbYV1bYl0sZD10aGlzLmdyaWRbZV1bYl0sZT10aGlzLmdyaWRbZV1bZl0sZj10aGlzLmdyaWRbYV1bZl0saD1uZXcgVEhSRUUuVmVjdG9yMihhL3RoaXMucmFkaWFsU2VnbWVudHMsYi90aGlzLnR1YnVsYXJTZWdtZW50cyksaT1uZXcgVEhSRUUuVmVjdG9yMigoYSsxKS90aGlzLnJhZGlhbFNlZ21lbnRzLGIvdGhpcy50dWJ1bGFyU2VnbWVudHMpLGs9bmV3IFRIUkVFLlZlY3RvcjIoKGErMSkvdGhpcy5yYWRpYWxTZWdtZW50cywoYisxKS90aGlzLnR1YnVsYXJTZWdtZW50cyksbT1uZXcgVEhSRUUuVmVjdG9yMihhL3RoaXMucmFkaWFsU2VnbWVudHMsKGIrMSkvdGhpcy50dWJ1bGFyU2VnbWVudHMpO1xudGhpcy5mYWNlcy5wdXNoKG5ldyBUSFJFRS5GYWNlMyhjLGQsZikpO3RoaXMuZmFjZVZlcnRleFV2c1swXS5wdXNoKFtoLGksbV0pO3RoaXMuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoZCxlLGYpKTt0aGlzLmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaChbaS5jbG9uZSgpLGssbS5jbG9uZSgpXSl9dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTt0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCl9O1RIUkVFLlRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSk7VEhSRUUuVHViZUdlb21ldHJ5PWZ1bmN0aW9uKGEsYixjLGQsZSl7VEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKTt0aGlzLnBhdGg9YTt0aGlzLnNlZ21lbnRzPWJ8fDY0O3RoaXMucmFkaXVzPWN8fDE7dGhpcy5yYWRpYWxTZWdtZW50cz1kfHw4O3RoaXMuY2xvc2VkPWV8fCExO3RoaXMuZ3JpZD1bXTt2YXIgZixoLGQ9dGhpcy5zZWdtZW50cysxLGcsaSxrLGU9bmV3IFRIUkVFLlZlY3RvcjMsbSxsLGI9bmV3IFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXModGhpcy5wYXRoLHRoaXMuc2VnbWVudHMsdGhpcy5jbG9zZWQpO209Yi5ub3JtYWxzO2w9Yi5iaW5vcm1hbHM7dGhpcy50YW5nZW50cz1iLnRhbmdlbnRzO3RoaXMubm9ybWFscz1tO3RoaXMuYmlub3JtYWxzPWw7Zm9yKGI9MDtiPGQ7YisrKXt0aGlzLmdyaWRbYl09W107Yz1iLyhkLTEpO2s9YS5nZXRQb2ludEF0KGMpO2Y9bVtiXTtoPWxbYl07Zm9yKGM9MDtjPHRoaXMucmFkaWFsU2VnbWVudHM7YysrKWc9MiooYy90aGlzLnJhZGlhbFNlZ21lbnRzKSpcbk1hdGguUEksaT0tdGhpcy5yYWRpdXMqTWF0aC5jb3MoZyksZz10aGlzLnJhZGl1cypNYXRoLnNpbihnKSxlLmNvcHkoayksZS54Kz1pKmYueCtnKmgueCxlLnkrPWkqZi55K2cqaC55LGUueis9aSpmLnorZypoLnosdGhpcy5ncmlkW2JdW2NdPXRoaXMudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhlLngsZS55LGUueikpLTF9Zm9yKGI9MDtiPHRoaXMuc2VnbWVudHM7YisrKWZvcihjPTA7Yzx0aGlzLnJhZGlhbFNlZ21lbnRzO2MrKyllPXRoaXMuY2xvc2VkPyhiKzEpJXRoaXMuc2VnbWVudHM6YisxLG09KGMrMSkldGhpcy5yYWRpYWxTZWdtZW50cyxhPXRoaXMuZ3JpZFtiXVtjXSxkPXRoaXMuZ3JpZFtlXVtjXSxlPXRoaXMuZ3JpZFtlXVttXSxtPXRoaXMuZ3JpZFtiXVttXSxsPW5ldyBUSFJFRS5WZWN0b3IyKGIvdGhpcy5zZWdtZW50cyxjL3RoaXMucmFkaWFsU2VnbWVudHMpLGY9bmV3IFRIUkVFLlZlY3RvcjIoKGIrMSkvdGhpcy5zZWdtZW50cyxjL3RoaXMucmFkaWFsU2VnbWVudHMpLFxuaD1uZXcgVEhSRUUuVmVjdG9yMigoYisxKS90aGlzLnNlZ21lbnRzLChjKzEpL3RoaXMucmFkaWFsU2VnbWVudHMpLGk9bmV3IFRIUkVFLlZlY3RvcjIoYi90aGlzLnNlZ21lbnRzLChjKzEpL3RoaXMucmFkaWFsU2VnbWVudHMpLHRoaXMuZmFjZXMucHVzaChuZXcgVEhSRUUuRmFjZTMoYSxkLG0pKSx0aGlzLmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaChbbCxmLGldKSx0aGlzLmZhY2VzLnB1c2gobmV3IFRIUkVFLkZhY2UzKGQsZSxtKSksdGhpcy5mYWNlVmVydGV4VXZzWzBdLnB1c2goW2YuY2xvbmUoKSxoLGkuY2xvbmUoKV0pO3RoaXMuY29tcHV0ZUNlbnRyb2lkcygpO3RoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpfTtUSFJFRS5UdWJlR2VvbWV0cnkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlKTtcblRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXM9ZnVuY3Rpb24oYSxiLGMpe25ldyBUSFJFRS5WZWN0b3IzO3ZhciBkPW5ldyBUSFJFRS5WZWN0b3IzO25ldyBUSFJFRS5WZWN0b3IzO3ZhciBlPVtdLGY9W10saD1bXSxnPW5ldyBUSFJFRS5WZWN0b3IzLGk9bmV3IFRIUkVFLk1hdHJpeDQsYj1iKzEsayxtLGw7dGhpcy50YW5nZW50cz1lO3RoaXMubm9ybWFscz1mO3RoaXMuYmlub3JtYWxzPWg7Zm9yKGs9MDtrPGI7aysrKW09ay8oYi0xKSxlW2tdPWEuZ2V0VGFuZ2VudEF0KG0pLGVba10ubm9ybWFsaXplKCk7ZlswXT1uZXcgVEhSRUUuVmVjdG9yMztoWzBdPW5ldyBUSFJFRS5WZWN0b3IzO2E9TnVtYmVyLk1BWF9WQUxVRTtrPU1hdGguYWJzKGVbMF0ueCk7bT1NYXRoLmFicyhlWzBdLnkpO2w9TWF0aC5hYnMoZVswXS56KTtrPD1hJiYoYT1rLGQuc2V0KDEsMCwwKSk7bTw9YSYmKGE9bSxkLnNldCgwLDEsMCkpO2w8PWEmJmQuc2V0KDAsMCwxKTtnLmNyb3NzVmVjdG9ycyhlWzBdLFxuZCkubm9ybWFsaXplKCk7ZlswXS5jcm9zc1ZlY3RvcnMoZVswXSxnKTtoWzBdLmNyb3NzVmVjdG9ycyhlWzBdLGZbMF0pO2ZvcihrPTE7azxiO2srKylmW2tdPWZbay0xXS5jbG9uZSgpLGhba109aFtrLTFdLmNsb25lKCksZy5jcm9zc1ZlY3RvcnMoZVtrLTFdLGVba10pLDFFLTQ8Zy5sZW5ndGgoKSYmKGcubm9ybWFsaXplKCksZD1NYXRoLmFjb3MoVEhSRUUuTWF0aC5jbGFtcChlW2stMV0uZG90KGVba10pLC0xLDEpKSxmW2tdLmFwcGx5TWF0cml4NChpLm1ha2VSb3RhdGlvbkF4aXMoZyxkKSkpLGhba10uY3Jvc3NWZWN0b3JzKGVba10sZltrXSk7aWYoYyl7ZD1NYXRoLmFjb3MoVEhSRUUuTWF0aC5jbGFtcChmWzBdLmRvdChmW2ItMV0pLC0xLDEpKTtkLz1iLTE7MDxlWzBdLmRvdChnLmNyb3NzVmVjdG9ycyhmWzBdLGZbYi0xXSkpJiYoZD0tZCk7Zm9yKGs9MTtrPGI7aysrKWZba10uYXBwbHlNYXRyaXg0KGkubWFrZVJvdGF0aW9uQXhpcyhlW2tdLGQqaykpLGhba10uY3Jvc3NWZWN0b3JzKGVba10sXG5mW2tdKX19O1RIUkVFLlBvbHloZWRyb25HZW9tZXRyeT1mdW5jdGlvbihhLGIsYyxkKXtmdW5jdGlvbiBlKGEpe3ZhciBiPWEubm9ybWFsaXplKCkuY2xvbmUoKTtiLmluZGV4PWcudmVydGljZXMucHVzaChiKS0xO3ZhciBjPU1hdGguYXRhbjIoYS56LC1hLngpLzIvTWF0aC5QSSswLjUsYT1NYXRoLmF0YW4yKC1hLnksTWF0aC5zcXJ0KGEueCphLngrYS56KmEueikpL01hdGguUEkrMC41O2IudXY9bmV3IFRIUkVFLlZlY3RvcjIoYywxLWEpO3JldHVybiBifWZ1bmN0aW9uIGYoYSxiLGMpe3ZhciBkPW5ldyBUSFJFRS5GYWNlMyhhLmluZGV4LGIuaW5kZXgsYy5pbmRleCxbYS5jbG9uZSgpLGIuY2xvbmUoKSxjLmNsb25lKCldKTtkLmNlbnRyb2lkLmFkZChhKS5hZGQoYikuYWRkKGMpLmRpdmlkZVNjYWxhcigzKTtnLmZhY2VzLnB1c2goZCk7ZD1NYXRoLmF0YW4yKGQuY2VudHJvaWQueiwtZC5jZW50cm9pZC54KTtnLmZhY2VWZXJ0ZXhVdnNbMF0ucHVzaChbaChhLnV2LGEsZCksaChiLnV2LGIsZCksXG5oKGMudXYsYyxkKV0pfWZ1bmN0aW9uIGgoYSxiLGMpezA+YyYmMT09PWEueCYmKGE9bmV3IFRIUkVFLlZlY3RvcjIoYS54LTEsYS55KSk7MD09PWIueCYmMD09PWIueiYmKGE9bmV3IFRIUkVFLlZlY3RvcjIoYy8yL01hdGguUEkrMC41LGEueSkpO3JldHVybiBhLmNsb25lKCl9VEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKTtmb3IodmFyIGM9Y3x8MSxkPWR8fDAsZz10aGlzLGk9MCxrPWEubGVuZ3RoO2k8aztpKyspZShuZXcgVEhSRUUuVmVjdG9yMyhhW2ldWzBdLGFbaV1bMV0sYVtpXVsyXSkpO2Zvcih2YXIgbT10aGlzLnZlcnRpY2VzLGE9W10saT0wLGs9Yi5sZW5ndGg7aTxrO2krKyl7dmFyIGw9bVtiW2ldWzBdXSxwPW1bYltpXVsxXV0scz1tW2JbaV1bMl1dO2FbaV09bmV3IFRIUkVFLkZhY2UzKGwuaW5kZXgscC5pbmRleCxzLmluZGV4LFtsLmNsb25lKCkscC5jbG9uZSgpLHMuY2xvbmUoKV0pfWk9MDtmb3Ioaz1hLmxlbmd0aDtpPGs7aSsrKXtwPWFbaV07bT1kO2I9TWF0aC5wb3coMixcbm0pO01hdGgucG93KDQsbSk7Zm9yKHZhciBtPWUoZy52ZXJ0aWNlc1twLmFdKSxsPWUoZy52ZXJ0aWNlc1twLmJdKSx0PWUoZy52ZXJ0aWNlc1twLmNdKSxwPVtdLHM9MDtzPD1iO3MrKyl7cFtzXT1bXTtmb3IodmFyIG49ZShtLmNsb25lKCkubGVycCh0LHMvYikpLHI9ZShsLmNsb25lKCkubGVycCh0LHMvYikpLHE9Yi1zLHU9MDt1PD1xO3UrKylwW3NdW3VdPTA9PXUmJnM9PWI/bjplKG4uY2xvbmUoKS5sZXJwKHIsdS9xKSl9Zm9yKHM9MDtzPGI7cysrKWZvcih1PTA7dTwyKihiLXMpLTE7dSsrKW09TWF0aC5mbG9vcih1LzIpLDA9PXUlMj9mKHBbc11bbSsxXSxwW3MrMV1bbV0scFtzXVttXSk6ZihwW3NdW20rMV0scFtzKzFdW20rMV0scFtzKzFdW21dKX1pPTA7Zm9yKGs9dGhpcy5mYWNlVmVydGV4VXZzWzBdLmxlbmd0aDtpPGs7aSsrKWQ9dGhpcy5mYWNlVmVydGV4VXZzWzBdW2ldLGE9ZFswXS54LGI9ZFsxXS54LG09ZFsyXS54LGw9TWF0aC5tYXgoYSxNYXRoLm1heChiLG0pKSxcbnA9TWF0aC5taW4oYSxNYXRoLm1pbihiLG0pKSwwLjk8bCYmMC4xPnAmJigwLjI+YSYmKGRbMF0ueCs9MSksMC4yPmImJihkWzFdLngrPTEpLDAuMj5tJiYoZFsyXS54Kz0xKSk7aT0wO2ZvcihrPXRoaXMudmVydGljZXMubGVuZ3RoO2k8aztpKyspdGhpcy52ZXJ0aWNlc1tpXS5tdWx0aXBseVNjYWxhcihjKTt0aGlzLm1lcmdlVmVydGljZXMoKTt0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTt0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO3RoaXMuYm91bmRpbmdTcGhlcmU9bmV3IFRIUkVFLlNwaGVyZShuZXcgVEhSRUUuVmVjdG9yMyxjKX07VEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSk7VEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeT1mdW5jdGlvbihhLGIpe3RoaXMucmFkaXVzPWE7dGhpcy5kZXRhaWw9Yjt2YXIgYz0oMStNYXRoLnNxcnQoNSkpLzI7VEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwodGhpcyxbWy0xLGMsMF0sWzEsYywwXSxbLTEsLWMsMF0sWzEsLWMsMF0sWzAsLTEsY10sWzAsMSxjXSxbMCwtMSwtY10sWzAsMSwtY10sW2MsMCwtMV0sW2MsMCwxXSxbLWMsMCwtMV0sWy1jLDAsMV1dLFtbMCwxMSw1XSxbMCw1LDFdLFswLDEsN10sWzAsNywxMF0sWzAsMTAsMTFdLFsxLDUsOV0sWzUsMTEsNF0sWzExLDEwLDJdLFsxMCw3LDZdLFs3LDEsOF0sWzMsOSw0XSxbMyw0LDJdLFszLDIsNl0sWzMsNiw4XSxbMyw4LDldLFs0LDksNV0sWzIsNCwxMV0sWzYsMiwxMF0sWzgsNiw3XSxbOSw4LDFdXSxhLGIpfTtUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSk7VEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5PWZ1bmN0aW9uKGEsYil7VEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwodGhpcyxbWzEsMCwwXSxbLTEsMCwwXSxbMCwxLDBdLFswLC0xLDBdLFswLDAsMV0sWzAsMCwtMV1dLFtbMCwyLDRdLFswLDQsM10sWzAsMyw1XSxbMCw1LDJdLFsxLDIsNV0sWzEsNSwzXSxbMSwzLDRdLFsxLDQsMl1dLGEsYil9O1RIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUpO1RIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnk9ZnVuY3Rpb24oYSxiKXtUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCh0aGlzLFtbMSwxLDFdLFstMSwtMSwxXSxbLTEsMSwtMV0sWzEsLTEsLTFdXSxbWzIsMSwwXSxbMCwzLDJdLFsxLDMsMF0sWzIsMywxXV0sYSxiKX07VEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUpO1RIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeT1mdW5jdGlvbihhLGIsYyl7VEhSRUUuR2VvbWV0cnkuY2FsbCh0aGlzKTt2YXIgZD10aGlzLnZlcnRpY2VzLGU9dGhpcy5mYWNlcyxmPXRoaXMuZmFjZVZlcnRleFV2c1swXSxoLGcsaSxrLG09YisxO2ZvcihoPTA7aDw9YztoKyspe2s9aC9jO2ZvcihnPTA7Zzw9YjtnKyspaT1nL2IsaT1hKGksayksZC5wdXNoKGkpfXZhciBsLHAscyx0O2ZvcihoPTA7aDxjO2grKylmb3IoZz0wO2c8YjtnKyspYT1oKm0rZyxkPWgqbStnKzEsaz0oaCsxKSptK2crMSxpPShoKzEpKm0rZyxsPW5ldyBUSFJFRS5WZWN0b3IyKGcvYixoL2MpLHA9bmV3IFRIUkVFLlZlY3RvcjIoKGcrMSkvYixoL2MpLHM9bmV3IFRIUkVFLlZlY3RvcjIoKGcrMSkvYiwoaCsxKS9jKSx0PW5ldyBUSFJFRS5WZWN0b3IyKGcvYiwoaCsxKS9jKSxlLnB1c2gobmV3IFRIUkVFLkZhY2UzKGEsZCxpKSksZi5wdXNoKFtsLHAsdF0pLGUucHVzaChuZXcgVEhSRUUuRmFjZTMoZCxrLGkpKSxcbmYucHVzaChbcC5jbG9uZSgpLHMsdC5jbG9uZSgpXSk7dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTt0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCl9O1RIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUpO1RIUkVFLkF4aXNIZWxwZXI9ZnVuY3Rpb24oYSl7dmFyIGE9YXx8MSxiPW5ldyBUSFJFRS5HZW9tZXRyeTtiLnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMsbmV3IFRIUkVFLlZlY3RvcjMoYSwwLDApLG5ldyBUSFJFRS5WZWN0b3IzLG5ldyBUSFJFRS5WZWN0b3IzKDAsYSwwKSxuZXcgVEhSRUUuVmVjdG9yMyxuZXcgVEhSRUUuVmVjdG9yMygwLDAsYSkpO2IuY29sb3JzLnB1c2gobmV3IFRIUkVFLkNvbG9yKDE2NzExNjgwKSxuZXcgVEhSRUUuQ29sb3IoMTY3NTUyMDApLG5ldyBUSFJFRS5Db2xvcig2NTI4MCksbmV3IFRIUkVFLkNvbG9yKDExMjA2NDAwKSxuZXcgVEhSRUUuQ29sb3IoMjU1KSxuZXcgVEhSRUUuQ29sb3IoNDM3NzUpKTthPW5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7dmVydGV4Q29sb3JzOlRIUkVFLlZlcnRleENvbG9yc30pO1RIUkVFLkxpbmUuY2FsbCh0aGlzLGIsYSxUSFJFRS5MaW5lUGllY2VzKX07XG5USFJFRS5BeGlzSGVscGVyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkxpbmUucHJvdG90eXBlKTtUSFJFRS5BcnJvd0hlbHBlcj1mdW5jdGlvbihhLGIsYyxkKXtUSFJFRS5PYmplY3QzRC5jYWxsKHRoaXMpO3ZvaWQgMD09PWQmJihkPTE2Nzc2OTYwKTt2b2lkIDA9PT1jJiYoYz0xKTt0aGlzLnBvc2l0aW9uPWI7Yj1uZXcgVEhSRUUuR2VvbWV0cnk7Yi52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKDAsMCwwKSk7Yi52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKDAsMSwwKSk7dGhpcy5saW5lPW5ldyBUSFJFRS5MaW5lKGIsbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHtjb2xvcjpkfSkpO3RoaXMubGluZS5tYXRyaXhBdXRvVXBkYXRlPSExO3RoaXMuYWRkKHRoaXMubGluZSk7Yj1uZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSgwLDAuMDUsMC4yNSw1LDEpO2IuYXBwbHlNYXRyaXgoKG5ldyBUSFJFRS5NYXRyaXg0KS5tYWtlVHJhbnNsYXRpb24oMCwwLjg3NSwwKSk7dGhpcy5jb25lPW5ldyBUSFJFRS5NZXNoKGIsbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtjb2xvcjpkfSkpO1xudGhpcy5jb25lLm1hdHJpeEF1dG9VcGRhdGU9ITE7dGhpcy5hZGQodGhpcy5jb25lKTt0aGlzLnNldERpcmVjdGlvbihhKTt0aGlzLnNldExlbmd0aChjKX07VEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlKTtUSFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0RGlyZWN0aW9uPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjMsYjtyZXR1cm4gZnVuY3Rpb24oYyl7MC45OTk5OTxjLnk/dGhpcy5xdWF0ZXJuaW9uLnNldCgwLDAsMCwxKTotMC45OTk5OT5jLnk/dGhpcy5xdWF0ZXJuaW9uLnNldCgxLDAsMCwwKTooYS5zZXQoYy56LDAsLWMueCkubm9ybWFsaXplKCksYj1NYXRoLmFjb3MoYy55KSx0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZShhLGIpKX19KCk7VEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLnNldExlbmd0aD1mdW5jdGlvbihhKXt0aGlzLnNjYWxlLnNldChhLGEsYSl9O1xuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLnNldENvbG9yPWZ1bmN0aW9uKGEpe3RoaXMubGluZS5tYXRlcmlhbC5jb2xvci5zZXRIZXgoYSk7dGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLnNldEhleChhKX07VEhSRUUuQm94SGVscGVyPWZ1bmN0aW9uKGEpe3ZhciBiPVtuZXcgVEhSRUUuVmVjdG9yMygxLDEsMSksbmV3IFRIUkVFLlZlY3RvcjMoLTEsMSwxKSxuZXcgVEhSRUUuVmVjdG9yMygtMSwtMSwxKSxuZXcgVEhSRUUuVmVjdG9yMygxLC0xLDEpLG5ldyBUSFJFRS5WZWN0b3IzKDEsMSwtMSksbmV3IFRIUkVFLlZlY3RvcjMoLTEsMSwtMSksbmV3IFRIUkVFLlZlY3RvcjMoLTEsLTEsLTEpLG5ldyBUSFJFRS5WZWN0b3IzKDEsLTEsLTEpXTt0aGlzLnZlcnRpY2VzPWI7dmFyIGM9bmV3IFRIUkVFLkdlb21ldHJ5O2MudmVydGljZXMucHVzaChiWzBdLGJbMV0sYlsxXSxiWzJdLGJbMl0sYlszXSxiWzNdLGJbMF0sYls0XSxiWzVdLGJbNV0sYls2XSxiWzZdLGJbN10sYls3XSxiWzRdLGJbMF0sYls0XSxiWzFdLGJbNV0sYlsyXSxiWzZdLGJbM10sYls3XSk7VEhSRUUuTGluZS5jYWxsKHRoaXMsYyxuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoe2NvbG9yOjE2Nzc2OTYwfSksVEhSRUUuTGluZVBpZWNlcyk7XG52b2lkIDAhPT1hJiZ0aGlzLnVwZGF0ZShhKX07VEhSRUUuQm94SGVscGVyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkxpbmUucHJvdG90eXBlKTtcblRIUkVFLkJveEhlbHBlci5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEpe3ZhciBiPWEuZ2VvbWV0cnk7bnVsbD09PWIuYm91bmRpbmdCb3gmJmIuY29tcHV0ZUJvdW5kaW5nQm94KCk7dmFyIGM9Yi5ib3VuZGluZ0JveC5taW4sYj1iLmJvdW5kaW5nQm94Lm1heCxkPXRoaXMudmVydGljZXM7ZFswXS5zZXQoYi54LGIueSxiLnopO2RbMV0uc2V0KGMueCxiLnksYi56KTtkWzJdLnNldChjLngsYy55LGIueik7ZFszXS5zZXQoYi54LGMueSxiLnopO2RbNF0uc2V0KGIueCxiLnksYy56KTtkWzVdLnNldChjLngsYi55LGMueik7ZFs2XS5zZXQoYy54LGMueSxjLnopO2RbN10uc2V0KGIueCxjLnksYy56KTt0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO3RoaXMuZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlPSEwO3RoaXMubWF0cml4QXV0b1VwZGF0ZT0hMTt0aGlzLm1hdHJpeFdvcmxkPWEubWF0cml4V29ybGR9O1RIUkVFLkJvdW5kaW5nQm94SGVscGVyPWZ1bmN0aW9uKGEsYil7dmFyIGM9Ynx8ODk0Nzg0ODt0aGlzLm9iamVjdD1hO3RoaXMuYm94PW5ldyBUSFJFRS5Cb3gzO1RIUkVFLk1lc2guY2FsbCh0aGlzLG5ldyBUSFJFRS5DdWJlR2VvbWV0cnkoMSwxLDEpLG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7Y29sb3I6Yyx3aXJlZnJhbWU6ITB9KSl9O1RIUkVFLkJvdW5kaW5nQm94SGVscGVyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk1lc2gucHJvdG90eXBlKTtUSFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5ib3guc2V0RnJvbU9iamVjdCh0aGlzLm9iamVjdCk7dGhpcy5ib3guc2l6ZSh0aGlzLnNjYWxlKTt0aGlzLmJveC5jZW50ZXIodGhpcy5wb3NpdGlvbil9O1RIUkVFLkNhbWVyYUhlbHBlcj1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEsYixkKXtjKGEsZCk7YyhiLGQpfWZ1bmN0aW9uIGMoYSxiKXtkLnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMpO2QuY29sb3JzLnB1c2gobmV3IFRIUkVFLkNvbG9yKGIpKTt2b2lkIDA9PT1mW2FdJiYoZlthXT1bXSk7ZlthXS5wdXNoKGQudmVydGljZXMubGVuZ3RoLTEpfXZhciBkPW5ldyBUSFJFRS5HZW9tZXRyeSxlPW5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7Y29sb3I6MTY3NzcyMTUsdmVydGV4Q29sb3JzOlRIUkVFLkZhY2VDb2xvcnN9KSxmPXt9O2IoXCJuMVwiLFwibjJcIiwxNjc1NTIwMCk7YihcIm4yXCIsXCJuNFwiLDE2NzU1MjAwKTtiKFwibjRcIixcIm4zXCIsMTY3NTUyMDApO2IoXCJuM1wiLFwibjFcIiwxNjc1NTIwMCk7YihcImYxXCIsXCJmMlwiLDE2NzU1MjAwKTtiKFwiZjJcIixcImY0XCIsMTY3NTUyMDApO2IoXCJmNFwiLFwiZjNcIiwxNjc1NTIwMCk7YihcImYzXCIsXCJmMVwiLDE2NzU1MjAwKTtiKFwibjFcIixcImYxXCIsMTY3NTUyMDApO1xuYihcIm4yXCIsXCJmMlwiLDE2NzU1MjAwKTtiKFwibjNcIixcImYzXCIsMTY3NTUyMDApO2IoXCJuNFwiLFwiZjRcIiwxNjc1NTIwMCk7YihcInBcIixcIm4xXCIsMTY3MTE2ODApO2IoXCJwXCIsXCJuMlwiLDE2NzExNjgwKTtiKFwicFwiLFwibjNcIiwxNjcxMTY4MCk7YihcInBcIixcIm40XCIsMTY3MTE2ODApO2IoXCJ1MVwiLFwidTJcIiw0Mzc3NSk7YihcInUyXCIsXCJ1M1wiLDQzNzc1KTtiKFwidTNcIixcInUxXCIsNDM3NzUpO2IoXCJjXCIsXCJ0XCIsMTY3NzcyMTUpO2IoXCJwXCIsXCJjXCIsMzM1NTQ0Myk7YihcImNuMVwiLFwiY24yXCIsMzM1NTQ0Myk7YihcImNuM1wiLFwiY240XCIsMzM1NTQ0Myk7YihcImNmMVwiLFwiY2YyXCIsMzM1NTQ0Myk7YihcImNmM1wiLFwiY2Y0XCIsMzM1NTQ0Myk7VEhSRUUuTGluZS5jYWxsKHRoaXMsZCxlLFRIUkVFLkxpbmVQaWVjZXMpO3RoaXMuY2FtZXJhPWE7dGhpcy5tYXRyaXhXb3JsZD1hLm1hdHJpeFdvcmxkO3RoaXMubWF0cml4QXV0b1VwZGF0ZT0hMTt0aGlzLnBvaW50TWFwPWY7dGhpcy51cGRhdGUoKX07XG5USFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuTGluZS5wcm90b3R5cGUpO1xuVEhSRUUuQ2FtZXJhSGVscGVyLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMyxiPW5ldyBUSFJFRS5DYW1lcmEsYz1uZXcgVEhSRUUuUHJvamVjdG9yO3JldHVybiBmdW5jdGlvbigpe2Z1bmN0aW9uIGQoZCxoLGcsaSl7YS5zZXQoaCxnLGkpO2MudW5wcm9qZWN0VmVjdG9yKGEsYik7ZD1lLnBvaW50TWFwW2RdO2lmKHZvaWQgMCE9PWQpe2g9MDtmb3IoZz1kLmxlbmd0aDtoPGc7aCsrKWUuZ2VvbWV0cnkudmVydGljZXNbZFtoXV0uY29weShhKX19dmFyIGU9dGhpcztiLnByb2plY3Rpb25NYXRyaXguY29weSh0aGlzLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KTtkKFwiY1wiLDAsMCwtMSk7ZChcInRcIiwwLDAsMSk7ZChcIm4xXCIsLTEsLTEsLTEpO2QoXCJuMlwiLDEsLTEsLTEpO2QoXCJuM1wiLC0xLDEsLTEpO2QoXCJuNFwiLDEsMSwtMSk7ZChcImYxXCIsLTEsLTEsMSk7ZChcImYyXCIsMSwtMSwxKTtkKFwiZjNcIiwtMSwxLDEpO2QoXCJmNFwiLDEsMSwxKTtkKFwidTFcIixcbjAuNywxLjEsLTEpO2QoXCJ1MlwiLC0wLjcsMS4xLC0xKTtkKFwidTNcIiwwLDIsLTEpO2QoXCJjZjFcIiwtMSwwLDEpO2QoXCJjZjJcIiwxLDAsMSk7ZChcImNmM1wiLDAsLTEsMSk7ZChcImNmNFwiLDAsMSwxKTtkKFwiY24xXCIsLTEsMCwtMSk7ZChcImNuMlwiLDEsMCwtMSk7ZChcImNuM1wiLDAsLTEsLTEpO2QoXCJjbjRcIiwwLDEsLTEpO3RoaXMuZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlPSEwfX0oKTtUSFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyPWZ1bmN0aW9uKGEsYil7VEhSRUUuT2JqZWN0M0QuY2FsbCh0aGlzKTt0aGlzLmxpZ2h0PWE7dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO3RoaXMubWF0cml4V29ybGQ9YS5tYXRyaXhXb3JsZDt0aGlzLm1hdHJpeEF1dG9VcGRhdGU9ITE7dmFyIGM9bmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoYixiKSxkPW5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7d2lyZWZyYW1lOiEwLGZvZzohMX0pO2QuY29sb3IuY29weSh0aGlzLmxpZ2h0LmNvbG9yKS5tdWx0aXBseVNjYWxhcih0aGlzLmxpZ2h0LmludGVuc2l0eSk7dGhpcy5saWdodFBsYW5lPW5ldyBUSFJFRS5NZXNoKGMsZCk7dGhpcy5hZGQodGhpcy5saWdodFBsYW5lKTtjPW5ldyBUSFJFRS5HZW9tZXRyeTtjLnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMpO2MudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyk7Yy5jb21wdXRlTGluZURpc3RhbmNlcygpO1xuZD1uZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoe2ZvZzohMX0pO2QuY29sb3IuY29weSh0aGlzLmxpZ2h0LmNvbG9yKS5tdWx0aXBseVNjYWxhcih0aGlzLmxpZ2h0LmludGVuc2l0eSk7dGhpcy50YXJnZXRMaW5lPW5ldyBUSFJFRS5MaW5lKGMsZCk7dGhpcy5hZGQodGhpcy50YXJnZXRMaW5lKTt0aGlzLnVwZGF0ZSgpfTtUSFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSk7VEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMubGlnaHRQbGFuZS5nZW9tZXRyeS5kaXNwb3NlKCk7dGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTt0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO3RoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5kaXNwb3NlKCl9O1xuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKCl7YS5nZXRQb3NpdGlvbkZyb21NYXRyaXgodGhpcy5saWdodC5tYXRyaXhXb3JsZCkubmVnYXRlKCk7dGhpcy5saWdodFBsYW5lLmxvb2tBdChhKTt0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IuY29weSh0aGlzLmxpZ2h0LmNvbG9yKS5tdWx0aXBseVNjYWxhcih0aGlzLmxpZ2h0LmludGVuc2l0eSk7dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LnZlcnRpY2VzWzFdLmNvcHkoYSk7dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZT0hMDt0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuY29sb3IuY29weSh0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IpfX0oKTtUSFJFRS5GYWNlTm9ybWFsc0hlbHBlcj1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLm9iamVjdD1hO3RoaXMuc2l6ZT1ifHwxO2Zvcih2YXIgYT1jfHwxNjc3Njk2MCxkPWR8fDEsYj1uZXcgVEhSRUUuR2VvbWV0cnksYz0wLGU9dGhpcy5vYmplY3QuZ2VvbWV0cnkuZmFjZXMubGVuZ3RoO2M8ZTtjKyspYi52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKSxiLnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMpO1RIUkVFLkxpbmUuY2FsbCh0aGlzLGIsbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHtjb2xvcjphLGxpbmV3aWR0aDpkfSksVEhSRUUuTGluZVBpZWNlcyk7dGhpcy5tYXRyaXhBdXRvVXBkYXRlPSExO3RoaXMubm9ybWFsTWF0cml4PW5ldyBUSFJFRS5NYXRyaXgzO3RoaXMudXBkYXRlKCl9O1RIUkVFLkZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkxpbmUucHJvdG90eXBlKTtcblRIUkVFLkZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oKXt0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCghMCk7dGhpcy5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkKTtmb3IodmFyIGI9dGhpcy5nZW9tZXRyeS52ZXJ0aWNlcyxjPXRoaXMub2JqZWN0Lmdlb21ldHJ5LmZhY2VzLGQ9dGhpcy5vYmplY3QubWF0cml4V29ybGQsZT0wLGY9Yy5sZW5ndGg7ZTxmO2UrKyl7dmFyIGg9Y1tlXTthLmNvcHkoaC5ub3JtYWwpLmFwcGx5TWF0cml4Myh0aGlzLm5vcm1hbE1hdHJpeCkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodGhpcy5zaXplKTt2YXIgZz0yKmU7YltnXS5jb3B5KGguY2VudHJvaWQpLmFwcGx5TWF0cml4NChkKTtiW2crMV0uYWRkVmVjdG9ycyhiW2ddLGEpfXRoaXMuZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlPVxuITA7cmV0dXJuIHRoaXN9fSgpO1RIUkVFLkdyaWRIZWxwZXI9ZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgVEhSRUUuR2VvbWV0cnksZD1uZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoe3ZlcnRleENvbG9yczpUSFJFRS5WZXJ0ZXhDb2xvcnN9KTt0aGlzLmNvbG9yMT1uZXcgVEhSRUUuQ29sb3IoNDQ3MzkyNCk7dGhpcy5jb2xvcjI9bmV3IFRIUkVFLkNvbG9yKDg5NDc4NDgpO2Zvcih2YXIgZT0tYTtlPD1hO2UrPWIpe2MudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMygtYSwwLGUpLG5ldyBUSFJFRS5WZWN0b3IzKGEsMCxlKSxuZXcgVEhSRUUuVmVjdG9yMyhlLDAsLWEpLG5ldyBUSFJFRS5WZWN0b3IzKGUsMCxhKSk7dmFyIGY9MD09PWU/dGhpcy5jb2xvcjE6dGhpcy5jb2xvcjI7Yy5jb2xvcnMucHVzaChmLGYsZixmKX1USFJFRS5MaW5lLmNhbGwodGhpcyxjLGQsVEhSRUUuTGluZVBpZWNlcyl9O1RIUkVFLkdyaWRIZWxwZXIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuTGluZS5wcm90b3R5cGUpO1xuVEhSRUUuR3JpZEhlbHBlci5wcm90b3R5cGUuc2V0Q29sb3JzPWZ1bmN0aW9uKGEsYil7dGhpcy5jb2xvcjEuc2V0KGEpO3RoaXMuY29sb3IyLnNldChiKTt0aGlzLmdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGU9ITB9O1RIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlcj1mdW5jdGlvbihhLGIpe1RIUkVFLk9iamVjdDNELmNhbGwodGhpcyk7dGhpcy5saWdodD1hO3RoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTt0aGlzLm1hdHJpeFdvcmxkPWEubWF0cml4V29ybGQ7dGhpcy5tYXRyaXhBdXRvVXBkYXRlPSExO3RoaXMuY29sb3JzPVtuZXcgVEhSRUUuQ29sb3IsbmV3IFRIUkVFLkNvbG9yXTt2YXIgYz1uZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoYiw0LDIpO2MuYXBwbHlNYXRyaXgoKG5ldyBUSFJFRS5NYXRyaXg0KS5tYWtlUm90YXRpb25YKC1NYXRoLlBJLzIpKTtmb3IodmFyIGQ9MDs4PmQ7ZCsrKWMuZmFjZXNbZF0uY29sb3I9dGhpcy5jb2xvcnNbND5kPzA6MV07ZD1uZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe3ZlcnRleENvbG9yczpUSFJFRS5GYWNlQ29sb3JzLHdpcmVmcmFtZTohMH0pO3RoaXMubGlnaHRTcGhlcmU9bmV3IFRIUkVFLk1lc2goYyxkKTt0aGlzLmFkZCh0aGlzLmxpZ2h0U3BoZXJlKTtcbnRoaXMudXBkYXRlKCl9O1RIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUpO1RIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMubGlnaHRTcGhlcmUuZ2VvbWV0cnkuZGlzcG9zZSgpO3RoaXMubGlnaHRTcGhlcmUubWF0ZXJpYWwuZGlzcG9zZSgpfTtcblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKCl7dGhpcy5jb2xvcnNbMF0uY29weSh0aGlzLmxpZ2h0LmNvbG9yKS5tdWx0aXBseVNjYWxhcih0aGlzLmxpZ2h0LmludGVuc2l0eSk7dGhpcy5jb2xvcnNbMV0uY29weSh0aGlzLmxpZ2h0Lmdyb3VuZENvbG9yKS5tdWx0aXBseVNjYWxhcih0aGlzLmxpZ2h0LmludGVuc2l0eSk7dGhpcy5saWdodFNwaGVyZS5sb29rQXQoYS5nZXRQb3NpdGlvbkZyb21NYXRyaXgodGhpcy5saWdodC5tYXRyaXhXb3JsZCkubmVnYXRlKCkpO3RoaXMubGlnaHRTcGhlcmUuZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZT0hMH19KCk7VEhSRUUuUG9pbnRMaWdodEhlbHBlcj1mdW5jdGlvbihhLGIpe3RoaXMubGlnaHQ9YTt0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7dmFyIGM9bmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KGIsNCwyKSxkPW5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7d2lyZWZyYW1lOiEwLGZvZzohMX0pO2QuY29sb3IuY29weSh0aGlzLmxpZ2h0LmNvbG9yKS5tdWx0aXBseVNjYWxhcih0aGlzLmxpZ2h0LmludGVuc2l0eSk7VEhSRUUuTWVzaC5jYWxsKHRoaXMsYyxkKTt0aGlzLm1hdHJpeFdvcmxkPXRoaXMubGlnaHQubWF0cml4V29ybGQ7dGhpcy5tYXRyaXhBdXRvVXBkYXRlPSExfTtUSFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk1lc2gucHJvdG90eXBlKTtUSFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7dGhpcy5tYXRlcmlhbC5kaXNwb3NlKCl9O1xuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5tYXRlcmlhbC5jb2xvci5jb3B5KHRoaXMubGlnaHQuY29sb3IpLm11bHRpcGx5U2NhbGFyKHRoaXMubGlnaHQuaW50ZW5zaXR5KX07VEhSRUUuU3BvdExpZ2h0SGVscGVyPWZ1bmN0aW9uKGEpe1RIUkVFLk9iamVjdDNELmNhbGwodGhpcyk7dGhpcy5saWdodD1hO3RoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTt0aGlzLm1hdHJpeFdvcmxkPWEubWF0cml4V29ybGQ7dGhpcy5tYXRyaXhBdXRvVXBkYXRlPSExO2E9bmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoMCwxLDEsOCwxLCEwKTthLmFwcGx5TWF0cml4KChuZXcgVEhSRUUuTWF0cml4NCkubWFrZVRyYW5zbGF0aW9uKDAsLTAuNSwwKSk7YS5hcHBseU1hdHJpeCgobmV3IFRIUkVFLk1hdHJpeDQpLm1ha2VSb3RhdGlvblgoLU1hdGguUEkvMikpO3ZhciBiPW5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7d2lyZWZyYW1lOiEwLGZvZzohMX0pO3RoaXMuY29uZT1uZXcgVEhSRUUuTWVzaChhLGIpO3RoaXMuYWRkKHRoaXMuY29uZSk7dGhpcy51cGRhdGUoKX07VEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSk7XG5USFJFRS5TcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmNvbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO3RoaXMuY29uZS5tYXRlcmlhbC5kaXNwb3NlKCl9O1RIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjMsYj1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYz10aGlzLmxpZ2h0LmRpc3RhbmNlP3RoaXMubGlnaHQuZGlzdGFuY2U6MUU0LGQ9YypNYXRoLnRhbih0aGlzLmxpZ2h0LmFuZ2xlKTt0aGlzLmNvbmUuc2NhbGUuc2V0KGQsZCxjKTthLmdldFBvc2l0aW9uRnJvbU1hdHJpeCh0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkKTtiLmdldFBvc2l0aW9uRnJvbU1hdHJpeCh0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCk7dGhpcy5jb25lLmxvb2tBdChiLnN1YihhKSk7dGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLmNvcHkodGhpcy5saWdodC5jb2xvcikubXVsdGlwbHlTY2FsYXIodGhpcy5saWdodC5pbnRlbnNpdHkpfX0oKTtUSFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMub2JqZWN0PWE7dGhpcy5zaXplPWJ8fDE7Zm9yKHZhciBiPWN8fDE2NzExNjgwLGQ9ZHx8MSxjPW5ldyBUSFJFRS5HZW9tZXRyeSxhPWEuZ2VvbWV0cnkuZmFjZXMsZT0wLGY9YS5sZW5ndGg7ZTxmO2UrKylmb3IodmFyIGg9MCxnPWFbZV0udmVydGV4Tm9ybWFscy5sZW5ndGg7aDxnO2grKyljLnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMpLGMudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyk7VEhSRUUuTGluZS5jYWxsKHRoaXMsYyxuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoe2NvbG9yOmIsbGluZXdpZHRoOmR9KSxUSFJFRS5MaW5lUGllY2VzKTt0aGlzLm1hdHJpeEF1dG9VcGRhdGU9ITE7dGhpcy5ub3JtYWxNYXRyaXg9bmV3IFRIUkVFLk1hdHJpeDM7dGhpcy51cGRhdGUoKX07VEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5MaW5lLnByb3RvdHlwZSk7XG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oKXt2YXIgYT1uZXcgVEhSRUUuVmVjdG9yMztyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYj1bXCJhXCIsXCJiXCIsXCJjXCIsXCJkXCJdO3RoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCEwKTt0aGlzLm5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgodGhpcy5vYmplY3QubWF0cml4V29ybGQpO2Zvcih2YXIgYz10aGlzLmdlb21ldHJ5LnZlcnRpY2VzLGQ9dGhpcy5vYmplY3QuZ2VvbWV0cnkudmVydGljZXMsZT10aGlzLm9iamVjdC5nZW9tZXRyeS5mYWNlcyxmPXRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkLGg9MCxnPTAsaT1lLmxlbmd0aDtnPGk7ZysrKWZvcih2YXIgaz1lW2ddLG09MCxsPWsudmVydGV4Tm9ybWFscy5sZW5ndGg7bTxsO20rKyl7dmFyIHA9ay52ZXJ0ZXhOb3JtYWxzW21dO2NbaF0uY29weShkW2tbYlttXV1dKS5hcHBseU1hdHJpeDQoZik7YS5jb3B5KHApLmFwcGx5TWF0cml4Myh0aGlzLm5vcm1hbE1hdHJpeCkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodGhpcy5zaXplKTtcbmEuYWRkKGNbaF0pO2grPTE7Y1toXS5jb3B5KGEpO2grPTF9dGhpcy5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGU9ITA7cmV0dXJuIHRoaXN9fSgpO1RIUkVFLlZlcnRleFRhbmdlbnRzSGVscGVyPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMub2JqZWN0PWE7dGhpcy5zaXplPWJ8fDE7Zm9yKHZhciBiPWN8fDI1NSxkPWR8fDEsYz1uZXcgVEhSRUUuR2VvbWV0cnksYT1hLmdlb21ldHJ5LmZhY2VzLGU9MCxmPWEubGVuZ3RoO2U8ZjtlKyspZm9yKHZhciBoPTAsZz1hW2VdLnZlcnRleFRhbmdlbnRzLmxlbmd0aDtoPGc7aCsrKWMudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyksYy52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKTtUSFJFRS5MaW5lLmNhbGwodGhpcyxjLG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7Y29sb3I6YixsaW5ld2lkdGg6ZH0pLFRIUkVFLkxpbmVQaWVjZXMpO3RoaXMubWF0cml4QXV0b1VwZGF0ZT0hMTt0aGlzLnVwZGF0ZSgpfTtUSFJFRS5WZXJ0ZXhUYW5nZW50c0hlbHBlci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5MaW5lLnByb3RvdHlwZSk7XG5USFJFRS5WZXJ0ZXhUYW5nZW50c0hlbHBlci5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFRIUkVFLlZlY3RvcjM7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGI9W1wiYVwiLFwiYlwiLFwiY1wiLFwiZFwiXTt0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCghMCk7Zm9yKHZhciBjPXRoaXMuZ2VvbWV0cnkudmVydGljZXMsZD10aGlzLm9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcyxlPXRoaXMub2JqZWN0Lmdlb21ldHJ5LmZhY2VzLGY9dGhpcy5vYmplY3QubWF0cml4V29ybGQsaD0wLGc9MCxpPWUubGVuZ3RoO2c8aTtnKyspZm9yKHZhciBrPWVbZ10sbT0wLGw9ay52ZXJ0ZXhUYW5nZW50cy5sZW5ndGg7bTxsO20rKyl7dmFyIHA9ay52ZXJ0ZXhUYW5nZW50c1ttXTtjW2hdLmNvcHkoZFtrW2JbbV1dXSkuYXBwbHlNYXRyaXg0KGYpO2EuY29weShwKS50cmFuc2Zvcm1EaXJlY3Rpb24oZikubXVsdGlwbHlTY2FsYXIodGhpcy5zaXplKTthLmFkZChjW2hdKTtoKz0xO2NbaF0uY29weShhKTtcbmgrPTF9dGhpcy5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGU9ITA7cmV0dXJuIHRoaXN9fSgpO1RIUkVFLldpcmVmcmFtZUhlbHBlcj1mdW5jdGlvbihhKXtmb3IodmFyIGI9WzAsMF0sYz17fSxkPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGEtYn0sZT1bXCJhXCIsXCJiXCIsXCJjXCIsXCJkXCJdLGY9bmV3IFRIUkVFLkdlb21ldHJ5LGg9YS5nZW9tZXRyeS52ZXJ0aWNlcyxnPWEuZ2VvbWV0cnkuZmFjZXMsaT0wLGs9Zy5sZW5ndGg7aTxrO2krKylmb3IodmFyIG09Z1tpXSxsPTA7Mz5sO2wrKyl7YlswXT1tW2VbbF1dO2JbMV09bVtlWyhsKzEpJTNdXTtiLnNvcnQoZCk7dmFyIHA9Yi50b1N0cmluZygpO3ZvaWQgMD09PWNbcF0mJihmLnZlcnRpY2VzLnB1c2goaFtiWzBdXSksZi52ZXJ0aWNlcy5wdXNoKGhbYlsxXV0pLGNbcF09ITApfVRIUkVFLkxpbmUuY2FsbCh0aGlzLGYsbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHtjb2xvcjoxNjc3NzIxNX0pLFRIUkVFLkxpbmVQaWVjZXMpO3RoaXMubWF0cml4QXV0b1VwZGF0ZT0hMTt0aGlzLm1hdHJpeFdvcmxkPWEubWF0cml4V29ybGR9O1xuVEhSRUUuV2lyZWZyYW1lSGVscGVyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLkxpbmUucHJvdG90eXBlKTtUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3Q9ZnVuY3Rpb24oKXtUSFJFRS5PYmplY3QzRC5jYWxsKHRoaXMpO3RoaXMucmVuZGVyPWZ1bmN0aW9uKCl7fX07VEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSk7VEhSRUUuTGVuc0ZsYXJlPWZ1bmN0aW9uKGEsYixjLGQsZSl7VEhSRUUuT2JqZWN0M0QuY2FsbCh0aGlzKTt0aGlzLmxlbnNGbGFyZXM9W107dGhpcy5wb3NpdGlvblNjcmVlbj1uZXcgVEhSRUUuVmVjdG9yMzt0aGlzLmN1c3RvbVVwZGF0ZUNhbGxiYWNrPXZvaWQgMDt2b2lkIDAhPT1hJiZ0aGlzLmFkZChhLGIsYyxkLGUpfTtUSFJFRS5MZW5zRmxhcmUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlKTtcblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGEsYixjLGQsZSxmKXt2b2lkIDA9PT1iJiYoYj0tMSk7dm9pZCAwPT09YyYmKGM9MCk7dm9pZCAwPT09ZiYmKGY9MSk7dm9pZCAwPT09ZSYmKGU9bmV3IFRIUkVFLkNvbG9yKDE2Nzc3MjE1KSk7dm9pZCAwPT09ZCYmKGQ9VEhSRUUuTm9ybWFsQmxlbmRpbmcpO2M9TWF0aC5taW4oYyxNYXRoLm1heCgwLGMpKTt0aGlzLmxlbnNGbGFyZXMucHVzaCh7dGV4dHVyZTphLHNpemU6YixkaXN0YW5jZTpjLHg6MCx5OjAsejowLHNjYWxlOjEscm90YXRpb246MSxvcGFjaXR5OmYsY29sb3I6ZSxibGVuZGluZzpkfSl9O1xuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS51cGRhdGVMZW5zRmxhcmVzPWZ1bmN0aW9uKCl7dmFyIGEsYj10aGlzLmxlbnNGbGFyZXMubGVuZ3RoLGMsZD0yKi10aGlzLnBvc2l0aW9uU2NyZWVuLngsZT0yKi10aGlzLnBvc2l0aW9uU2NyZWVuLnk7Zm9yKGE9MDthPGI7YSsrKWM9dGhpcy5sZW5zRmxhcmVzW2FdLGMueD10aGlzLnBvc2l0aW9uU2NyZWVuLngrZCpjLmRpc3RhbmNlLGMueT10aGlzLnBvc2l0aW9uU2NyZWVuLnkrZSpjLmRpc3RhbmNlLGMud2FudGVkUm90YXRpb249MC4yNSpjLngqTWF0aC5QSSxjLnJvdGF0aW9uKz0wLjI1KihjLndhbnRlZFJvdGF0aW9uLWMucm90YXRpb24pfTtUSFJFRS5Nb3JwaEJsZW5kTWVzaD1mdW5jdGlvbihhLGIpe1RIUkVFLk1lc2guY2FsbCh0aGlzLGEsYik7dGhpcy5hbmltYXRpb25zTWFwPXt9O3RoaXMuYW5pbWF0aW9uc0xpc3Q9W107dmFyIGM9dGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoO3RoaXMuY3JlYXRlQW5pbWF0aW9uKFwiX19kZWZhdWx0XCIsMCxjLTEsYy8xKTt0aGlzLnNldEFuaW1hdGlvbldlaWdodChcIl9fZGVmYXVsdFwiLDEpfTtUSFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShUSFJFRS5NZXNoLnByb3RvdHlwZSk7XG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuY3JlYXRlQW5pbWF0aW9uPWZ1bmN0aW9uKGEsYixjLGQpe2I9e3N0YXJ0RnJhbWU6YixlbmRGcmFtZTpjLGxlbmd0aDpjLWIrMSxmcHM6ZCxkdXJhdGlvbjooYy1iKS9kLGxhc3RGcmFtZTowLGN1cnJlbnRGcmFtZTowLGFjdGl2ZTohMSx0aW1lOjAsZGlyZWN0aW9uOjEsd2VpZ2h0OjEsZGlyZWN0aW9uQmFja3dhcmRzOiExLG1pcnJvcmVkTG9vcDohMX07dGhpcy5hbmltYXRpb25zTWFwW2FdPWI7dGhpcy5hbmltYXRpb25zTGlzdC5wdXNoKGIpfTtcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5hdXRvQ3JlYXRlQW5pbWF0aW9ucz1mdW5jdGlvbihhKXtmb3IodmFyIGI9LyhbYS16XSspKFxcZCspLyxjLGQ9e30sZT10aGlzLmdlb21ldHJ5LGY9MCxoPWUubW9ycGhUYXJnZXRzLmxlbmd0aDtmPGg7ZisrKXt2YXIgZz1lLm1vcnBoVGFyZ2V0c1tmXS5uYW1lLm1hdGNoKGIpO2lmKGcmJjE8Zy5sZW5ndGgpe3ZhciBpPWdbMV07ZFtpXXx8KGRbaV09e3N0YXJ0OkluZmluaXR5LGVuZDotSW5maW5pdHl9KTtnPWRbaV07ZjxnLnN0YXJ0JiYoZy5zdGFydD1mKTtmPmcuZW5kJiYoZy5lbmQ9Zik7Y3x8KGM9aSl9fWZvcihpIGluIGQpZz1kW2ldLHRoaXMuY3JlYXRlQW5pbWF0aW9uKGksZy5zdGFydCxnLmVuZCxhKTt0aGlzLmZpcnN0QW5pbWF0aW9uPWN9O1xuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkZvcndhcmQ9ZnVuY3Rpb24oYSl7aWYoYT10aGlzLmFuaW1hdGlvbnNNYXBbYV0pYS5kaXJlY3Rpb249MSxhLmRpcmVjdGlvbkJhY2t3YXJkcz0hMX07VEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkJhY2t3YXJkPWZ1bmN0aW9uKGEpe2lmKGE9dGhpcy5hbmltYXRpb25zTWFwW2FdKWEuZGlyZWN0aW9uPS0xLGEuZGlyZWN0aW9uQmFja3dhcmRzPSEwfTtUSFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRlBTPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5hbmltYXRpb25zTWFwW2FdO2MmJihjLmZwcz1iLGMuZHVyYXRpb249KGMuZW5kLWMuc3RhcnQpL2MuZnBzKX07XG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRHVyYXRpb249ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmFuaW1hdGlvbnNNYXBbYV07YyYmKGMuZHVyYXRpb249YixjLmZwcz0oYy5lbmQtYy5zdGFydCkvYy5kdXJhdGlvbil9O1RIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25XZWlnaHQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmFuaW1hdGlvbnNNYXBbYV07YyYmKGMud2VpZ2h0PWIpfTtUSFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uVGltZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuYW5pbWF0aW9uc01hcFthXTtjJiYoYy50aW1lPWIpfTtUSFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uVGltZT1mdW5jdGlvbihhKXt2YXIgYj0wO2lmKGE9dGhpcy5hbmltYXRpb25zTWFwW2FdKWI9YS50aW1lO3JldHVybiBifTtcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5nZXRBbmltYXRpb25EdXJhdGlvbj1mdW5jdGlvbihhKXt2YXIgYj0tMTtpZihhPXRoaXMuYW5pbWF0aW9uc01hcFthXSliPWEuZHVyYXRpb247cmV0dXJuIGJ9O1RIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5wbGF5QW5pbWF0aW9uPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuYW5pbWF0aW9uc01hcFthXTtiPyhiLnRpbWU9MCxiLmFjdGl2ZT0hMCk6Y29uc29sZS53YXJuKFwiYW5pbWF0aW9uW1wiK2ErXCJdIHVuZGVmaW5lZFwiKX07VEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnN0b3BBbmltYXRpb249ZnVuY3Rpb24oYSl7aWYoYT10aGlzLmFuaW1hdGlvbnNNYXBbYV0pYS5hY3RpdmU9ITF9O1xuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihhKXtmb3IodmFyIGI9MCxjPXRoaXMuYW5pbWF0aW9uc0xpc3QubGVuZ3RoO2I8YztiKyspe3ZhciBkPXRoaXMuYW5pbWF0aW9uc0xpc3RbYl07aWYoZC5hY3RpdmUpe3ZhciBlPWQuZHVyYXRpb24vZC5sZW5ndGg7ZC50aW1lKz1kLmRpcmVjdGlvbiphO2lmKGQubWlycm9yZWRMb29wKXtpZihkLnRpbWU+ZC5kdXJhdGlvbnx8MD5kLnRpbWUpZC5kaXJlY3Rpb24qPS0xLGQudGltZT5kLmR1cmF0aW9uJiYoZC50aW1lPWQuZHVyYXRpb24sZC5kaXJlY3Rpb25CYWNrd2FyZHM9ITApLDA+ZC50aW1lJiYoZC50aW1lPTAsZC5kaXJlY3Rpb25CYWNrd2FyZHM9ITEpfWVsc2UgZC50aW1lJT1kLmR1cmF0aW9uLDA+ZC50aW1lJiYoZC50aW1lKz1kLmR1cmF0aW9uKTt2YXIgZj1kLnN0YXJ0RnJhbWUrVEhSRUUuTWF0aC5jbGFtcChNYXRoLmZsb29yKGQudGltZS9lKSwwLGQubGVuZ3RoLTEpLGg9ZC53ZWlnaHQ7XG5mIT09ZC5jdXJyZW50RnJhbWUmJih0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tkLmxhc3RGcmFtZV09MCx0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tkLmN1cnJlbnRGcmFtZV09MSpoLHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzW2ZdPTAsZC5sYXN0RnJhbWU9ZC5jdXJyZW50RnJhbWUsZC5jdXJyZW50RnJhbWU9Zik7ZT1kLnRpbWUlZS9lO2QuZGlyZWN0aW9uQmFja3dhcmRzJiYoZT0xLWUpO3RoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzW2QuY3VycmVudEZyYW1lXT1lKmg7dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbZC5sYXN0RnJhbWVdPSgxLWUpKmh9fX07VEhSRUUuTGVuc0ZsYXJlUGx1Z2luPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGMpe3ZhciBkPWIuY3JlYXRlUHJvZ3JhbSgpLGU9Yi5jcmVhdGVTaGFkZXIoYi5GUkFHTUVOVF9TSEFERVIpLGY9Yi5jcmVhdGVTaGFkZXIoYi5WRVJURVhfU0hBREVSKSxnPVwicHJlY2lzaW9uIFwiK2MrXCIgZmxvYXQ7XFxuXCI7Yi5zaGFkZXJTb3VyY2UoZSxnK2EuZnJhZ21lbnRTaGFkZXIpO2Iuc2hhZGVyU291cmNlKGYsZythLnZlcnRleFNoYWRlcik7Yi5jb21waWxlU2hhZGVyKGUpO2IuY29tcGlsZVNoYWRlcihmKTtiLmF0dGFjaFNoYWRlcihkLGUpO2IuYXR0YWNoU2hhZGVyKGQsZik7Yi5saW5rUHJvZ3JhbShkKTtyZXR1cm4gZH12YXIgYixjLGQsZSxmLGgsZyxpLGssbSxsLHAsczt0aGlzLmluaXQ9ZnVuY3Rpb24odCl7Yj10LmNvbnRleHQ7Yz10O2Q9dC5nZXRQcmVjaXNpb24oKTtlPW5ldyBGbG9hdDMyQXJyYXkoMTYpO2Y9bmV3IFVpbnQxNkFycmF5KDYpO3Q9MDtlW3QrK109LTE7ZVt0KytdPS0xO1xuZVt0KytdPTA7ZVt0KytdPTA7ZVt0KytdPTE7ZVt0KytdPS0xO2VbdCsrXT0xO2VbdCsrXT0wO2VbdCsrXT0xO2VbdCsrXT0xO2VbdCsrXT0xO2VbdCsrXT0xO2VbdCsrXT0tMTtlW3QrK109MTtlW3QrK109MDtlW3QrK109MTt0PTA7Zlt0KytdPTA7Zlt0KytdPTE7Zlt0KytdPTI7Zlt0KytdPTA7Zlt0KytdPTI7Zlt0KytdPTM7aD1iLmNyZWF0ZUJ1ZmZlcigpO2c9Yi5jcmVhdGVCdWZmZXIoKTtiLmJpbmRCdWZmZXIoYi5BUlJBWV9CVUZGRVIsaCk7Yi5idWZmZXJEYXRhKGIuQVJSQVlfQlVGRkVSLGUsYi5TVEFUSUNfRFJBVyk7Yi5iaW5kQnVmZmVyKGIuRUxFTUVOVF9BUlJBWV9CVUZGRVIsZyk7Yi5idWZmZXJEYXRhKGIuRUxFTUVOVF9BUlJBWV9CVUZGRVIsZixiLlNUQVRJQ19EUkFXKTtpPWIuY3JlYXRlVGV4dHVyZSgpO2s9Yi5jcmVhdGVUZXh0dXJlKCk7Yi5iaW5kVGV4dHVyZShiLlRFWFRVUkVfMkQsaSk7Yi50ZXhJbWFnZTJEKGIuVEVYVFVSRV8yRCwwLGIuUkdCLDE2LDE2LFxuMCxiLlJHQixiLlVOU0lHTkVEX0JZVEUsbnVsbCk7Yi50ZXhQYXJhbWV0ZXJpKGIuVEVYVFVSRV8yRCxiLlRFWFRVUkVfV1JBUF9TLGIuQ0xBTVBfVE9fRURHRSk7Yi50ZXhQYXJhbWV0ZXJpKGIuVEVYVFVSRV8yRCxiLlRFWFRVUkVfV1JBUF9ULGIuQ0xBTVBfVE9fRURHRSk7Yi50ZXhQYXJhbWV0ZXJpKGIuVEVYVFVSRV8yRCxiLlRFWFRVUkVfTUFHX0ZJTFRFUixiLk5FQVJFU1QpO2IudGV4UGFyYW1ldGVyaShiLlRFWFRVUkVfMkQsYi5URVhUVVJFX01JTl9GSUxURVIsYi5ORUFSRVNUKTtiLmJpbmRUZXh0dXJlKGIuVEVYVFVSRV8yRCxrKTtiLnRleEltYWdlMkQoYi5URVhUVVJFXzJELDAsYi5SR0JBLDE2LDE2LDAsYi5SR0JBLGIuVU5TSUdORURfQllURSxudWxsKTtiLnRleFBhcmFtZXRlcmkoYi5URVhUVVJFXzJELGIuVEVYVFVSRV9XUkFQX1MsYi5DTEFNUF9UT19FREdFKTtiLnRleFBhcmFtZXRlcmkoYi5URVhUVVJFXzJELGIuVEVYVFVSRV9XUkFQX1QsYi5DTEFNUF9UT19FREdFKTtcbmIudGV4UGFyYW1ldGVyaShiLlRFWFRVUkVfMkQsYi5URVhUVVJFX01BR19GSUxURVIsYi5ORUFSRVNUKTtiLnRleFBhcmFtZXRlcmkoYi5URVhUVVJFXzJELGIuVEVYVFVSRV9NSU5fRklMVEVSLGIuTkVBUkVTVCk7MD49Yi5nZXRQYXJhbWV0ZXIoYi5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMpPyhtPSExLGw9YShUSFJFRS5TaGFkZXJGbGFyZXMubGVuc0ZsYXJlLGQpKToobT0hMCxsPWEoVEhSRUUuU2hhZGVyRmxhcmVzLmxlbnNGbGFyZVZlcnRleFRleHR1cmUsZCkpO3A9e307cz17fTtwLnZlcnRleD1iLmdldEF0dHJpYkxvY2F0aW9uKGwsXCJwb3NpdGlvblwiKTtwLnV2PWIuZ2V0QXR0cmliTG9jYXRpb24obCxcInV2XCIpO3MucmVuZGVyVHlwZT1iLmdldFVuaWZvcm1Mb2NhdGlvbihsLFwicmVuZGVyVHlwZVwiKTtzLm1hcD1iLmdldFVuaWZvcm1Mb2NhdGlvbihsLFwibWFwXCIpO3Mub2NjbHVzaW9uTWFwPWIuZ2V0VW5pZm9ybUxvY2F0aW9uKGwsXCJvY2NsdXNpb25NYXBcIik7cy5vcGFjaXR5PVxuYi5nZXRVbmlmb3JtTG9jYXRpb24obCxcIm9wYWNpdHlcIik7cy5jb2xvcj1iLmdldFVuaWZvcm1Mb2NhdGlvbihsLFwiY29sb3JcIik7cy5zY2FsZT1iLmdldFVuaWZvcm1Mb2NhdGlvbihsLFwic2NhbGVcIik7cy5yb3RhdGlvbj1iLmdldFVuaWZvcm1Mb2NhdGlvbihsLFwicm90YXRpb25cIik7cy5zY3JlZW5Qb3NpdGlvbj1iLmdldFVuaWZvcm1Mb2NhdGlvbihsLFwic2NyZWVuUG9zaXRpb25cIil9O3RoaXMucmVuZGVyPWZ1bmN0aW9uKGEsZCxlLGYpe3ZhciBhPWEuX193ZWJnbEZsYXJlcyx1PWEubGVuZ3RoO2lmKHUpe3ZhciB3PW5ldyBUSFJFRS5WZWN0b3IzLHo9Zi9lLEI9MC41KmUsRD0wLjUqZix4PTE2L2YsRj1uZXcgVEhSRUUuVmVjdG9yMih4KnoseCksQT1uZXcgVEhSRUUuVmVjdG9yMygxLDEsMCksTz1uZXcgVEhSRUUuVmVjdG9yMigxLDEpLEM9cyx4PXA7Yi51c2VQcm9ncmFtKGwpO2IuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocC52ZXJ0ZXgpO2IuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocC51dik7XG5iLnVuaWZvcm0xaShDLm9jY2x1c2lvbk1hcCwwKTtiLnVuaWZvcm0xaShDLm1hcCwxKTtiLmJpbmRCdWZmZXIoYi5BUlJBWV9CVUZGRVIsaCk7Yi52ZXJ0ZXhBdHRyaWJQb2ludGVyKHgudmVydGV4LDIsYi5GTE9BVCwhMSwxNiwwKTtiLnZlcnRleEF0dHJpYlBvaW50ZXIoeC51diwyLGIuRkxPQVQsITEsMTYsOCk7Yi5iaW5kQnVmZmVyKGIuRUxFTUVOVF9BUlJBWV9CVUZGRVIsZyk7Yi5kaXNhYmxlKGIuQ1VMTF9GQUNFKTtiLmRlcHRoTWFzayghMSk7dmFyIEUsSSx5LHYsRztmb3IoRT0wO0U8dTtFKyspaWYoeD0xNi9mLEYuc2V0KHgqeix4KSx2PWFbRV0sdy5zZXQodi5tYXRyaXhXb3JsZC5lbGVtZW50c1sxMl0sdi5tYXRyaXhXb3JsZC5lbGVtZW50c1sxM10sdi5tYXRyaXhXb3JsZC5lbGVtZW50c1sxNF0pLHcuYXBwbHlNYXRyaXg0KGQubWF0cml4V29ybGRJbnZlcnNlKSx3LmFwcGx5UHJvamVjdGlvbihkLnByb2plY3Rpb25NYXRyaXgpLEEuY29weSh3KSxPLng9QS54KkIrQixcbk8ueT1BLnkqRCtELG18fDA8Ty54JiZPLng8ZSYmMDxPLnkmJk8ueTxmKXtiLmFjdGl2ZVRleHR1cmUoYi5URVhUVVJFMSk7Yi5iaW5kVGV4dHVyZShiLlRFWFRVUkVfMkQsaSk7Yi5jb3B5VGV4SW1hZ2UyRChiLlRFWFRVUkVfMkQsMCxiLlJHQixPLngtOCxPLnktOCwxNiwxNiwwKTtiLnVuaWZvcm0xaShDLnJlbmRlclR5cGUsMCk7Yi51bmlmb3JtMmYoQy5zY2FsZSxGLngsRi55KTtiLnVuaWZvcm0zZihDLnNjcmVlblBvc2l0aW9uLEEueCxBLnksQS56KTtiLmRpc2FibGUoYi5CTEVORCk7Yi5lbmFibGUoYi5ERVBUSF9URVNUKTtiLmRyYXdFbGVtZW50cyhiLlRSSUFOR0xFUyw2LGIuVU5TSUdORURfU0hPUlQsMCk7Yi5hY3RpdmVUZXh0dXJlKGIuVEVYVFVSRTApO2IuYmluZFRleHR1cmUoYi5URVhUVVJFXzJELGspO2IuY29weVRleEltYWdlMkQoYi5URVhUVVJFXzJELDAsYi5SR0JBLE8ueC04LE8ueS04LDE2LDE2LDApO2IudW5pZm9ybTFpKEMucmVuZGVyVHlwZSwxKTtiLmRpc2FibGUoYi5ERVBUSF9URVNUKTtcbmIuYWN0aXZlVGV4dHVyZShiLlRFWFRVUkUxKTtiLmJpbmRUZXh0dXJlKGIuVEVYVFVSRV8yRCxpKTtiLmRyYXdFbGVtZW50cyhiLlRSSUFOR0xFUyw2LGIuVU5TSUdORURfU0hPUlQsMCk7di5wb3NpdGlvblNjcmVlbi5jb3B5KEEpO3YuY3VzdG9tVXBkYXRlQ2FsbGJhY2s/di5jdXN0b21VcGRhdGVDYWxsYmFjayh2KTp2LnVwZGF0ZUxlbnNGbGFyZXMoKTtiLnVuaWZvcm0xaShDLnJlbmRlclR5cGUsMik7Yi5lbmFibGUoYi5CTEVORCk7ST0wO2Zvcih5PXYubGVuc0ZsYXJlcy5sZW5ndGg7STx5O0krKylHPXYubGVuc0ZsYXJlc1tJXSwwLjAwMTxHLm9wYWNpdHkmJjAuMDAxPEcuc2NhbGUmJihBLng9Ry54LEEueT1HLnksQS56PUcueix4PUcuc2l6ZSpHLnNjYWxlL2YsRi54PXgqeixGLnk9eCxiLnVuaWZvcm0zZihDLnNjcmVlblBvc2l0aW9uLEEueCxBLnksQS56KSxiLnVuaWZvcm0yZihDLnNjYWxlLEYueCxGLnkpLGIudW5pZm9ybTFmKEMucm90YXRpb24sRy5yb3RhdGlvbiksYi51bmlmb3JtMWYoQy5vcGFjaXR5LFxuRy5vcGFjaXR5KSxiLnVuaWZvcm0zZihDLmNvbG9yLEcuY29sb3IucixHLmNvbG9yLmcsRy5jb2xvci5iKSxjLnNldEJsZW5kaW5nKEcuYmxlbmRpbmcsRy5ibGVuZEVxdWF0aW9uLEcuYmxlbmRTcmMsRy5ibGVuZERzdCksYy5zZXRUZXh0dXJlKEcudGV4dHVyZSwxKSxiLmRyYXdFbGVtZW50cyhiLlRSSUFOR0xFUyw2LGIuVU5TSUdORURfU0hPUlQsMCkpfWIuZW5hYmxlKGIuQ1VMTF9GQUNFKTtiLmVuYWJsZShiLkRFUFRIX1RFU1QpO2IuZGVwdGhNYXNrKCEwKX19fTtUSFJFRS5TaGFkb3dNYXBQbHVnaW49ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlLGYsaD1uZXcgVEhSRUUuRnJ1c3R1bSxnPW5ldyBUSFJFRS5NYXRyaXg0LGk9bmV3IFRIUkVFLlZlY3RvcjMsaz1uZXcgVEhSRUUuVmVjdG9yMyxtPW5ldyBUSFJFRS5WZWN0b3IzO3RoaXMuaW5pdD1mdW5jdGlvbihnKXthPWcuY29udGV4dDtiPWc7dmFyIGc9VEhSRUUuU2hhZGVyTGliLmRlcHRoUkdCQSxoPVRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoZy51bmlmb3Jtcyk7Yz1uZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe2ZyYWdtZW50U2hhZGVyOmcuZnJhZ21lbnRTaGFkZXIsdmVydGV4U2hhZGVyOmcudmVydGV4U2hhZGVyLHVuaWZvcm1zOmh9KTtkPW5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7ZnJhZ21lbnRTaGFkZXI6Zy5mcmFnbWVudFNoYWRlcix2ZXJ0ZXhTaGFkZXI6Zy52ZXJ0ZXhTaGFkZXIsdW5pZm9ybXM6aCxtb3JwaFRhcmdldHM6ITB9KTtlPW5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7ZnJhZ21lbnRTaGFkZXI6Zy5mcmFnbWVudFNoYWRlcixcbnZlcnRleFNoYWRlcjpnLnZlcnRleFNoYWRlcix1bmlmb3JtczpoLHNraW5uaW5nOiEwfSk7Zj1uZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoe2ZyYWdtZW50U2hhZGVyOmcuZnJhZ21lbnRTaGFkZXIsdmVydGV4U2hhZGVyOmcudmVydGV4U2hhZGVyLHVuaWZvcm1zOmgsbW9ycGhUYXJnZXRzOiEwLHNraW5uaW5nOiEwfSk7Yy5fc2hhZG93UGFzcz0hMDtkLl9zaGFkb3dQYXNzPSEwO2UuX3NoYWRvd1Bhc3M9ITA7Zi5fc2hhZG93UGFzcz0hMH07dGhpcy5yZW5kZXI9ZnVuY3Rpb24oYSxjKXtiLnNoYWRvd01hcEVuYWJsZWQmJmIuc2hhZG93TWFwQXV0b1VwZGF0ZSYmdGhpcy51cGRhdGUoYSxjKX07dGhpcy51cGRhdGU9ZnVuY3Rpb24obCxwKXt2YXIgcyx0LG4scixxLHUsdyx6LEIsRD1bXTtyPTA7YS5jbGVhckNvbG9yKDEsMSwxLDEpO2EuZGlzYWJsZShhLkJMRU5EKTthLmVuYWJsZShhLkNVTExfRkFDRSk7YS5mcm9udEZhY2UoYS5DQ1cpO2Iuc2hhZG93TWFwQ3VsbEZhY2U9PT1USFJFRS5DdWxsRmFjZUZyb250P1xuYS5jdWxsRmFjZShhLkZST05UKTphLmN1bGxGYWNlKGEuQkFDSyk7Yi5zZXREZXB0aFRlc3QoITApO3M9MDtmb3IodD1sLl9fbGlnaHRzLmxlbmd0aDtzPHQ7cysrKWlmKG49bC5fX2xpZ2h0c1tzXSxuLmNhc3RTaGFkb3cpaWYobiBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQmJm4uc2hhZG93Q2FzY2FkZSlmb3IocT0wO3E8bi5zaGFkb3dDYXNjYWRlQ291bnQ7cSsrKXt2YXIgeDtpZihuLnNoYWRvd0Nhc2NhZGVBcnJheVtxXSl4PW4uc2hhZG93Q2FzY2FkZUFycmF5W3FdO2Vsc2V7Qj1uO3c9cTt4PW5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0O3guaXNWaXJ0dWFsPSEwO3gub25seVNoYWRvdz0hMDt4LmNhc3RTaGFkb3c9ITA7eC5zaGFkb3dDYW1lcmFOZWFyPUIuc2hhZG93Q2FtZXJhTmVhcjt4LnNoYWRvd0NhbWVyYUZhcj1CLnNoYWRvd0NhbWVyYUZhcjt4LnNoYWRvd0NhbWVyYUxlZnQ9Qi5zaGFkb3dDYW1lcmFMZWZ0O3guc2hhZG93Q2FtZXJhUmlnaHQ9Qi5zaGFkb3dDYW1lcmFSaWdodDtcbnguc2hhZG93Q2FtZXJhQm90dG9tPUIuc2hhZG93Q2FtZXJhQm90dG9tO3guc2hhZG93Q2FtZXJhVG9wPUIuc2hhZG93Q2FtZXJhVG9wO3guc2hhZG93Q2FtZXJhVmlzaWJsZT1CLnNoYWRvd0NhbWVyYVZpc2libGU7eC5zaGFkb3dEYXJrbmVzcz1CLnNoYWRvd0RhcmtuZXNzO3guc2hhZG93Qmlhcz1CLnNoYWRvd0Nhc2NhZGVCaWFzW3ddO3guc2hhZG93TWFwV2lkdGg9Qi5zaGFkb3dDYXNjYWRlV2lkdGhbd107eC5zaGFkb3dNYXBIZWlnaHQ9Qi5zaGFkb3dDYXNjYWRlSGVpZ2h0W3ddO3gucG9pbnRzV29ybGQ9W107eC5wb2ludHNGcnVzdHVtPVtdO3o9eC5wb2ludHNXb3JsZDt1PXgucG9pbnRzRnJ1c3R1bTtmb3IodmFyIEY9MDs4PkY7RisrKXpbRl09bmV3IFRIUkVFLlZlY3RvcjMsdVtGXT1uZXcgVEhSRUUuVmVjdG9yMzt6PUIuc2hhZG93Q2FzY2FkZU5lYXJaW3ddO0I9Qi5zaGFkb3dDYXNjYWRlRmFyWlt3XTt1WzBdLnNldCgtMSwtMSx6KTt1WzFdLnNldCgxLC0xLHopO3VbMl0uc2V0KC0xLFxuMSx6KTt1WzNdLnNldCgxLDEseik7dVs0XS5zZXQoLTEsLTEsQik7dVs1XS5zZXQoMSwtMSxCKTt1WzZdLnNldCgtMSwxLEIpO3VbN10uc2V0KDEsMSxCKTt4Lm9yaWdpbmFsQ2FtZXJhPXA7dT1uZXcgVEhSRUUuR3lyb3Njb3BlO3UucG9zaXRpb249bi5zaGFkb3dDYXNjYWRlT2Zmc2V0O3UuYWRkKHgpO3UuYWRkKHgudGFyZ2V0KTtwLmFkZCh1KTtuLnNoYWRvd0Nhc2NhZGVBcnJheVtxXT14O2NvbnNvbGUubG9nKFwiQ3JlYXRlZCB2aXJ0dWFsTGlnaHRcIix4KX13PW47ej1xO0I9dy5zaGFkb3dDYXNjYWRlQXJyYXlbel07Qi5wb3NpdGlvbi5jb3B5KHcucG9zaXRpb24pO0IudGFyZ2V0LnBvc2l0aW9uLmNvcHkody50YXJnZXQucG9zaXRpb24pO0IubG9va0F0KEIudGFyZ2V0KTtCLnNoYWRvd0NhbWVyYVZpc2libGU9dy5zaGFkb3dDYW1lcmFWaXNpYmxlO0Iuc2hhZG93RGFya25lc3M9dy5zaGFkb3dEYXJrbmVzcztCLnNoYWRvd0JpYXM9dy5zaGFkb3dDYXNjYWRlQmlhc1t6XTt1PXcuc2hhZG93Q2FzY2FkZU5lYXJaW3pdO1xudz13LnNoYWRvd0Nhc2NhZGVGYXJaW3pdO0I9Qi5wb2ludHNGcnVzdHVtO0JbMF0uej11O0JbMV0uej11O0JbMl0uej11O0JbM10uej11O0JbNF0uej13O0JbNV0uej13O0JbNl0uej13O0JbN10uej13O0Rbcl09eDtyKyt9ZWxzZSBEW3JdPW4scisrO3M9MDtmb3IodD1ELmxlbmd0aDtzPHQ7cysrKXtuPURbc107bi5zaGFkb3dNYXB8fChxPVRIUkVFLkxpbmVhckZpbHRlcixiLnNoYWRvd01hcFR5cGU9PT1USFJFRS5QQ0ZTb2Z0U2hhZG93TWFwJiYocT1USFJFRS5OZWFyZXN0RmlsdGVyKSxuLnNoYWRvd01hcD1uZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQobi5zaGFkb3dNYXBXaWR0aCxuLnNoYWRvd01hcEhlaWdodCx7bWluRmlsdGVyOnEsbWFnRmlsdGVyOnEsZm9ybWF0OlRIUkVFLlJHQkFGb3JtYXR9KSxuLnNoYWRvd01hcFNpemU9bmV3IFRIUkVFLlZlY3RvcjIobi5zaGFkb3dNYXBXaWR0aCxuLnNoYWRvd01hcEhlaWdodCksbi5zaGFkb3dNYXRyaXg9bmV3IFRIUkVFLk1hdHJpeDQpO1xuaWYoIW4uc2hhZG93Q2FtZXJhKXtpZihuIGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0KW4uc2hhZG93Q2FtZXJhPW5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYShuLnNoYWRvd0NhbWVyYUZvdixuLnNoYWRvd01hcFdpZHRoL24uc2hhZG93TWFwSGVpZ2h0LG4uc2hhZG93Q2FtZXJhTmVhcixuLnNoYWRvd0NhbWVyYUZhcik7ZWxzZSBpZihuIGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCluLnNoYWRvd0NhbWVyYT1uZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKG4uc2hhZG93Q2FtZXJhTGVmdCxuLnNoYWRvd0NhbWVyYVJpZ2h0LG4uc2hhZG93Q2FtZXJhVG9wLG4uc2hhZG93Q2FtZXJhQm90dG9tLG4uc2hhZG93Q2FtZXJhTmVhcixuLnNoYWRvd0NhbWVyYUZhcik7ZWxzZXtjb25zb2xlLmVycm9yKFwiVW5zdXBwb3J0ZWQgbGlnaHQgdHlwZSBmb3Igc2hhZG93XCIpO2NvbnRpbnVlfWwuYWRkKG4uc2hhZG93Q2FtZXJhKTshMD09PWwuYXV0b1VwZGF0ZSYmbC51cGRhdGVNYXRyaXhXb3JsZCgpfW4uc2hhZG93Q2FtZXJhVmlzaWJsZSYmXG4hbi5jYW1lcmFIZWxwZXImJihuLmNhbWVyYUhlbHBlcj1uZXcgVEhSRUUuQ2FtZXJhSGVscGVyKG4uc2hhZG93Q2FtZXJhKSxuLnNoYWRvd0NhbWVyYS5hZGQobi5jYW1lcmFIZWxwZXIpKTtpZihuLmlzVmlydHVhbCYmeC5vcmlnaW5hbENhbWVyYT09cCl7cT1wO3I9bi5zaGFkb3dDYW1lcmE7dT1uLnBvaW50c0ZydXN0dW07Qj1uLnBvaW50c1dvcmxkO2kuc2V0KEluZmluaXR5LEluZmluaXR5LEluZmluaXR5KTtrLnNldCgtSW5maW5pdHksLUluZmluaXR5LC1JbmZpbml0eSk7Zm9yKHc9MDs4Pnc7dysrKXo9Qlt3XSx6LmNvcHkodVt3XSksVEhSRUUuU2hhZG93TWFwUGx1Z2luLl9fcHJvamVjdG9yLnVucHJvamVjdFZlY3Rvcih6LHEpLHouYXBwbHlNYXRyaXg0KHIubWF0cml4V29ybGRJbnZlcnNlKSx6Lng8aS54JiYoaS54PXoueCksei54PmsueCYmKGsueD16LngpLHoueTxpLnkmJihpLnk9ei55KSx6Lnk+ay55JiYoay55PXoueSksei56PGkueiYmKGkuej16LnopLHouej5rLnomJlxuKGsuej16LnopO3IubGVmdD1pLng7ci5yaWdodD1rLng7ci50b3A9ay55O3IuYm90dG9tPWkueTtyLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKX1yPW4uc2hhZG93TWFwO3U9bi5zaGFkb3dNYXRyaXg7cT1uLnNoYWRvd0NhbWVyYTtxLnBvc2l0aW9uLmdldFBvc2l0aW9uRnJvbU1hdHJpeChuLm1hdHJpeFdvcmxkKTttLmdldFBvc2l0aW9uRnJvbU1hdHJpeChuLnRhcmdldC5tYXRyaXhXb3JsZCk7cS5sb29rQXQobSk7cS51cGRhdGVNYXRyaXhXb3JsZCgpO3EubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UocS5tYXRyaXhXb3JsZCk7bi5jYW1lcmFIZWxwZXImJihuLmNhbWVyYUhlbHBlci52aXNpYmxlPW4uc2hhZG93Q2FtZXJhVmlzaWJsZSk7bi5zaGFkb3dDYW1lcmFWaXNpYmxlJiZuLmNhbWVyYUhlbHBlci51cGRhdGUoKTt1LnNldCgwLjUsMCwwLDAuNSwwLDAuNSwwLDAuNSwwLDAsMC41LDAuNSwwLDAsMCwxKTt1Lm11bHRpcGx5KHEucHJvamVjdGlvbk1hdHJpeCk7dS5tdWx0aXBseShxLm1hdHJpeFdvcmxkSW52ZXJzZSk7XG5nLm11bHRpcGx5TWF0cmljZXMocS5wcm9qZWN0aW9uTWF0cml4LHEubWF0cml4V29ybGRJbnZlcnNlKTtoLnNldEZyb21NYXRyaXgoZyk7Yi5zZXRSZW5kZXJUYXJnZXQocik7Yi5jbGVhcigpO0I9bC5fX3dlYmdsT2JqZWN0cztuPTA7Zm9yKHI9Qi5sZW5ndGg7bjxyO24rKylpZih3PUJbbl0sdT13Lm9iamVjdCx3LnJlbmRlcj0hMSx1LnZpc2libGUmJnUuY2FzdFNoYWRvdyYmKCEodSBpbnN0YW5jZW9mIFRIUkVFLk1lc2h8fHUgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZVN5c3RlbSl8fCF1LmZydXN0dW1DdWxsZWR8fGguaW50ZXJzZWN0c09iamVjdCh1KSkpdS5fbW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMocS5tYXRyaXhXb3JsZEludmVyc2UsdS5tYXRyaXhXb3JsZCksdy5yZW5kZXI9ITA7bj0wO2ZvcihyPUIubGVuZ3RoO248cjtuKyspdz1CW25dLHcucmVuZGVyJiYodT13Lm9iamVjdCx3PXcuYnVmZmVyLEY9dS5tYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWw/XG51Lm1hdGVyaWFsLm1hdGVyaWFsc1swXTp1Lm1hdGVyaWFsLHo9MDx1Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGgmJkYubW9ycGhUYXJnZXRzLEY9dSBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoJiZGLnNraW5uaW5nLHo9dS5jdXN0b21EZXB0aE1hdGVyaWFsP3UuY3VzdG9tRGVwdGhNYXRlcmlhbDpGP3o/ZjplOno/ZDpjLHcgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeT9iLnJlbmRlckJ1ZmZlckRpcmVjdChxLGwuX19saWdodHMsbnVsbCx6LHcsdSk6Yi5yZW5kZXJCdWZmZXIocSxsLl9fbGlnaHRzLG51bGwseix3LHUpKTtCPWwuX193ZWJnbE9iamVjdHNJbW1lZGlhdGU7bj0wO2ZvcihyPUIubGVuZ3RoO248cjtuKyspdz1CW25dLHU9dy5vYmplY3QsdS52aXNpYmxlJiZ1LmNhc3RTaGFkb3cmJih1Ll9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhxLm1hdHJpeFdvcmxkSW52ZXJzZSx1Lm1hdHJpeFdvcmxkKSxiLnJlbmRlckltbWVkaWF0ZU9iamVjdChxLFxubC5fX2xpZ2h0cyxudWxsLGMsdSkpfXM9Yi5nZXRDbGVhckNvbG9yKCk7dD1iLmdldENsZWFyQWxwaGEoKTthLmNsZWFyQ29sb3Iocy5yLHMuZyxzLmIsdCk7YS5lbmFibGUoYS5CTEVORCk7Yi5zaGFkb3dNYXBDdWxsRmFjZT09PVRIUkVFLkN1bGxGYWNlRnJvbnQmJmEuY3VsbEZhY2UoYS5CQUNLKX19O1RIUkVFLlNoYWRvd01hcFBsdWdpbi5fX3Byb2plY3Rvcj1uZXcgVEhSRUUuUHJvamVjdG9yO1RIUkVFLlNwcml0ZVBsdWdpbj1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSxiKXtyZXR1cm4gYS56IT09Yi56P2Iuei1hLno6Yi5pZC1hLmlkfXZhciBiLGMsZCxlLGYsaCxnLGksayxtO3RoaXMuaW5pdD1mdW5jdGlvbihhKXtiPWEuY29udGV4dDtjPWE7ZD1hLmdldFByZWNpc2lvbigpO2U9bmV3IEZsb2F0MzJBcnJheSgxNik7Zj1uZXcgVWludDE2QXJyYXkoNik7YT0wO2VbYSsrXT0tMC41O2VbYSsrXT0tMC41O2VbYSsrXT0wO2VbYSsrXT0wO2VbYSsrXT0wLjU7ZVthKytdPS0wLjU7ZVthKytdPTE7ZVthKytdPTA7ZVthKytdPTAuNTtlW2ErK109MC41O2VbYSsrXT0xO2VbYSsrXT0xO2VbYSsrXT0tMC41O2VbYSsrXT0wLjU7ZVthKytdPTA7ZVthKytdPTE7YT0wO2ZbYSsrXT0wO2ZbYSsrXT0xO2ZbYSsrXT0yO2ZbYSsrXT0wO2ZbYSsrXT0yO2ZbYSsrXT0zO2g9Yi5jcmVhdGVCdWZmZXIoKTtnPWIuY3JlYXRlQnVmZmVyKCk7Yi5iaW5kQnVmZmVyKGIuQVJSQVlfQlVGRkVSLGgpO1xuYi5idWZmZXJEYXRhKGIuQVJSQVlfQlVGRkVSLGUsYi5TVEFUSUNfRFJBVyk7Yi5iaW5kQnVmZmVyKGIuRUxFTUVOVF9BUlJBWV9CVUZGRVIsZyk7Yi5idWZmZXJEYXRhKGIuRUxFTUVOVF9BUlJBWV9CVUZGRVIsZixiLlNUQVRJQ19EUkFXKTt2YXIgYT1USFJFRS5TaGFkZXJTcHJpdGUuc3ByaXRlLHA9Yi5jcmVhdGVQcm9ncmFtKCkscz1iLmNyZWF0ZVNoYWRlcihiLkZSQUdNRU5UX1NIQURFUiksdD1iLmNyZWF0ZVNoYWRlcihiLlZFUlRFWF9TSEFERVIpLG49XCJwcmVjaXNpb24gXCIrZCtcIiBmbG9hdDtcXG5cIjtiLnNoYWRlclNvdXJjZShzLG4rYS5mcmFnbWVudFNoYWRlcik7Yi5zaGFkZXJTb3VyY2UodCxuK2EudmVydGV4U2hhZGVyKTtiLmNvbXBpbGVTaGFkZXIocyk7Yi5jb21waWxlU2hhZGVyKHQpO2IuYXR0YWNoU2hhZGVyKHAscyk7Yi5hdHRhY2hTaGFkZXIocCx0KTtiLmxpbmtQcm9ncmFtKHApO2k9cDtrPXt9O209e307ay5wb3NpdGlvbj1iLmdldEF0dHJpYkxvY2F0aW9uKGksXG5cInBvc2l0aW9uXCIpO2sudXY9Yi5nZXRBdHRyaWJMb2NhdGlvbihpLFwidXZcIik7bS51dk9mZnNldD1iLmdldFVuaWZvcm1Mb2NhdGlvbihpLFwidXZPZmZzZXRcIik7bS51dlNjYWxlPWIuZ2V0VW5pZm9ybUxvY2F0aW9uKGksXCJ1dlNjYWxlXCIpO20ucm90YXRpb249Yi5nZXRVbmlmb3JtTG9jYXRpb24oaSxcInJvdGF0aW9uXCIpO20uc2NhbGU9Yi5nZXRVbmlmb3JtTG9jYXRpb24oaSxcInNjYWxlXCIpO20uYWxpZ25tZW50PWIuZ2V0VW5pZm9ybUxvY2F0aW9uKGksXCJhbGlnbm1lbnRcIik7bS5oYWxmVmlld3BvcnQ9Yi5nZXRVbmlmb3JtTG9jYXRpb24oaSxcImhhbGZWaWV3cG9ydFwiKTttLmNvbG9yPWIuZ2V0VW5pZm9ybUxvY2F0aW9uKGksXCJjb2xvclwiKTttLm1hcD1iLmdldFVuaWZvcm1Mb2NhdGlvbihpLFwibWFwXCIpO20ub3BhY2l0eT1iLmdldFVuaWZvcm1Mb2NhdGlvbihpLFwib3BhY2l0eVwiKTttLnVzZVNjcmVlbkNvb3JkaW5hdGVzPWIuZ2V0VW5pZm9ybUxvY2F0aW9uKGksXCJ1c2VTY3JlZW5Db29yZGluYXRlc1wiKTtcbm0uc2l6ZUF0dGVudWF0aW9uPWIuZ2V0VW5pZm9ybUxvY2F0aW9uKGksXCJzaXplQXR0ZW51YXRpb25cIik7bS5zY3JlZW5Qb3NpdGlvbj1iLmdldFVuaWZvcm1Mb2NhdGlvbihpLFwic2NyZWVuUG9zaXRpb25cIik7bS5tb2RlbFZpZXdNYXRyaXg9Yi5nZXRVbmlmb3JtTG9jYXRpb24oaSxcIm1vZGVsVmlld01hdHJpeFwiKTttLnByb2plY3Rpb25NYXRyaXg9Yi5nZXRVbmlmb3JtTG9jYXRpb24oaSxcInByb2plY3Rpb25NYXRyaXhcIik7bS5mb2dUeXBlPWIuZ2V0VW5pZm9ybUxvY2F0aW9uKGksXCJmb2dUeXBlXCIpO20uZm9nRGVuc2l0eT1iLmdldFVuaWZvcm1Mb2NhdGlvbihpLFwiZm9nRGVuc2l0eVwiKTttLmZvZ05lYXI9Yi5nZXRVbmlmb3JtTG9jYXRpb24oaSxcImZvZ05lYXJcIik7bS5mb2dGYXI9Yi5nZXRVbmlmb3JtTG9jYXRpb24oaSxcImZvZ0ZhclwiKTttLmZvZ0NvbG9yPWIuZ2V0VW5pZm9ybUxvY2F0aW9uKGksXCJmb2dDb2xvclwiKTttLmFscGhhVGVzdD1iLmdldFVuaWZvcm1Mb2NhdGlvbihpLFxuXCJhbHBoYVRlc3RcIil9O3RoaXMucmVuZGVyPWZ1bmN0aW9uKGQsZSxmLHQpe3ZhciBuPWQuX193ZWJnbFNwcml0ZXMscj1uLmxlbmd0aDtpZihyKXt2YXIgcT1rLHU9bSxmPTAuNSpmLHQ9MC41KnQ7Yi51c2VQcm9ncmFtKGkpO2IuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocS5wb3NpdGlvbik7Yi5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShxLnV2KTtiLmRpc2FibGUoYi5DVUxMX0ZBQ0UpO2IuZW5hYmxlKGIuQkxFTkQpO2IuYmluZEJ1ZmZlcihiLkFSUkFZX0JVRkZFUixoKTtiLnZlcnRleEF0dHJpYlBvaW50ZXIocS5wb3NpdGlvbiwyLGIuRkxPQVQsITEsMTYsMCk7Yi52ZXJ0ZXhBdHRyaWJQb2ludGVyKHEudXYsMixiLkZMT0FULCExLDE2LDgpO2IuYmluZEJ1ZmZlcihiLkVMRU1FTlRfQVJSQVlfQlVGRkVSLGcpO2IudW5pZm9ybU1hdHJpeDRmdih1LnByb2plY3Rpb25NYXRyaXgsITEsZS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzKTtiLmFjdGl2ZVRleHR1cmUoYi5URVhUVVJFMCk7XG5iLnVuaWZvcm0xaSh1Lm1hcCwwKTt2YXIgdz1xPTAsej1kLmZvZzt6PyhiLnVuaWZvcm0zZih1LmZvZ0NvbG9yLHouY29sb3Iucix6LmNvbG9yLmcsei5jb2xvci5iKSx6IGluc3RhbmNlb2YgVEhSRUUuRm9nPyhiLnVuaWZvcm0xZih1LmZvZ05lYXIsei5uZWFyKSxiLnVuaWZvcm0xZih1LmZvZ0Zhcix6LmZhciksYi51bmlmb3JtMWkodS5mb2dUeXBlLDEpLHc9cT0xKTp6IGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMiYmKGIudW5pZm9ybTFmKHUuZm9nRGVuc2l0eSx6LmRlbnNpdHkpLGIudW5pZm9ybTFpKHUuZm9nVHlwZSwyKSx3PXE9MikpOihiLnVuaWZvcm0xaSh1LmZvZ1R5cGUsMCksdz1xPTApO2Zvcih2YXIgQixELHg9W10sej0wO3o8cjt6KyspQj1uW3pdLEQ9Qi5tYXRlcmlhbCxCLnZpc2libGUmJjAhPT1ELm9wYWNpdHkmJihELnVzZVNjcmVlbkNvb3JkaW5hdGVzP0Iuej0tQi5wb3NpdGlvbi56OihCLl9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhlLm1hdHJpeFdvcmxkSW52ZXJzZSxcbkIubWF0cml4V29ybGQpLEIuej0tQi5fbW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzWzE0XSkpO24uc29ydChhKTtmb3Ioej0wO3o8cjt6KyspQj1uW3pdLEQ9Qi5tYXRlcmlhbCxCLnZpc2libGUmJjAhPT1ELm9wYWNpdHkmJihELm1hcCYmRC5tYXAuaW1hZ2UmJkQubWFwLmltYWdlLndpZHRoKSYmKGIudW5pZm9ybTFmKHUuYWxwaGFUZXN0LEQuYWxwaGFUZXN0KSwhMD09PUQudXNlU2NyZWVuQ29vcmRpbmF0ZXM/KGIudW5pZm9ybTFpKHUudXNlU2NyZWVuQ29vcmRpbmF0ZXMsMSksYi51bmlmb3JtM2YodS5zY3JlZW5Qb3NpdGlvbiwoQi5wb3NpdGlvbi54KmMuZGV2aWNlUGl4ZWxSYXRpby1mKS9mLCh0LUIucG9zaXRpb24ueSpjLmRldmljZVBpeGVsUmF0aW8pL3QsTWF0aC5tYXgoMCxNYXRoLm1pbigxLEIucG9zaXRpb24ueikpKSx4WzBdPWMuZGV2aWNlUGl4ZWxSYXRpbypCLnNjYWxlLngseFsxXT1jLmRldmljZVBpeGVsUmF0aW8qQi5zY2FsZS55KTooYi51bmlmb3JtMWkodS51c2VTY3JlZW5Db29yZGluYXRlcyxcbjApLGIudW5pZm9ybTFpKHUuc2l6ZUF0dGVudWF0aW9uLEQuc2l6ZUF0dGVudWF0aW9uPzE6MCksYi51bmlmb3JtTWF0cml4NGZ2KHUubW9kZWxWaWV3TWF0cml4LCExLEIuX21vZGVsVmlld01hdHJpeC5lbGVtZW50cykseFswXT1CLnNjYWxlLngseFsxXT1CLnNjYWxlLnkpLGU9ZC5mb2cmJkQuZm9nP3c6MCxxIT09ZSYmKGIudW5pZm9ybTFpKHUuZm9nVHlwZSxlKSxxPWUpLGIudW5pZm9ybTJmKHUudXZTY2FsZSxELnV2U2NhbGUueCxELnV2U2NhbGUueSksYi51bmlmb3JtMmYodS51dk9mZnNldCxELnV2T2Zmc2V0LngsRC51dk9mZnNldC55KSxiLnVuaWZvcm0yZih1LmFsaWdubWVudCxELmFsaWdubWVudC54LEQuYWxpZ25tZW50LnkpLGIudW5pZm9ybTFmKHUub3BhY2l0eSxELm9wYWNpdHkpLGIudW5pZm9ybTNmKHUuY29sb3IsRC5jb2xvci5yLEQuY29sb3IuZyxELmNvbG9yLmIpLGIudW5pZm9ybTFmKHUucm90YXRpb24sQi5yb3RhdGlvbiksYi51bmlmb3JtMmZ2KHUuc2NhbGUsXG54KSxiLnVuaWZvcm0yZih1LmhhbGZWaWV3cG9ydCxmLHQpLGMuc2V0QmxlbmRpbmcoRC5ibGVuZGluZyxELmJsZW5kRXF1YXRpb24sRC5ibGVuZFNyYyxELmJsZW5kRHN0KSxjLnNldERlcHRoVGVzdChELmRlcHRoVGVzdCksYy5zZXREZXB0aFdyaXRlKEQuZGVwdGhXcml0ZSksYy5zZXRUZXh0dXJlKEQubWFwLDApLGIuZHJhd0VsZW1lbnRzKGIuVFJJQU5HTEVTLDYsYi5VTlNJR05FRF9TSE9SVCwwKSk7Yi5lbmFibGUoYi5DVUxMX0ZBQ0UpfX19O1RIUkVFLkRlcHRoUGFzc1BsdWdpbj1mdW5jdGlvbigpe3RoaXMuZW5hYmxlZD0hMTt0aGlzLnJlbmRlclRhcmdldD1udWxsO3ZhciBhLGIsYyxkLGUsZixoPW5ldyBUSFJFRS5GcnVzdHVtLGc9bmV3IFRIUkVFLk1hdHJpeDQ7dGhpcy5pbml0PWZ1bmN0aW9uKGcpe2E9Zy5jb250ZXh0O2I9Zzt2YXIgZz1USFJFRS5TaGFkZXJMaWIuZGVwdGhSR0JBLGg9VEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZShnLnVuaWZvcm1zKTtjPW5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7ZnJhZ21lbnRTaGFkZXI6Zy5mcmFnbWVudFNoYWRlcix2ZXJ0ZXhTaGFkZXI6Zy52ZXJ0ZXhTaGFkZXIsdW5pZm9ybXM6aH0pO2Q9bmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtmcmFnbWVudFNoYWRlcjpnLmZyYWdtZW50U2hhZGVyLHZlcnRleFNoYWRlcjpnLnZlcnRleFNoYWRlcix1bmlmb3JtczpoLG1vcnBoVGFyZ2V0czohMH0pO2U9bmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKHtmcmFnbWVudFNoYWRlcjpnLmZyYWdtZW50U2hhZGVyLFxudmVydGV4U2hhZGVyOmcudmVydGV4U2hhZGVyLHVuaWZvcm1zOmgsc2tpbm5pbmc6ITB9KTtmPW5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCh7ZnJhZ21lbnRTaGFkZXI6Zy5mcmFnbWVudFNoYWRlcix2ZXJ0ZXhTaGFkZXI6Zy52ZXJ0ZXhTaGFkZXIsdW5pZm9ybXM6aCxtb3JwaFRhcmdldHM6ITAsc2tpbm5pbmc6ITB9KTtjLl9zaGFkb3dQYXNzPSEwO2QuX3NoYWRvd1Bhc3M9ITA7ZS5fc2hhZG93UGFzcz0hMDtmLl9zaGFkb3dQYXNzPSEwfTt0aGlzLnJlbmRlcj1mdW5jdGlvbihhLGIpe3RoaXMuZW5hYmxlZCYmdGhpcy51cGRhdGUoYSxiKX07dGhpcy51cGRhdGU9ZnVuY3Rpb24oaSxrKXt2YXIgbSxsLHAscyx0LG47YS5jbGVhckNvbG9yKDEsMSwxLDEpO2EuZGlzYWJsZShhLkJMRU5EKTtiLnNldERlcHRoVGVzdCghMCk7ITA9PT1pLmF1dG9VcGRhdGUmJmkudXBkYXRlTWF0cml4V29ybGQoKTtrLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKGsubWF0cml4V29ybGQpO2cubXVsdGlwbHlNYXRyaWNlcyhrLnByb2plY3Rpb25NYXRyaXgsXG5rLm1hdHJpeFdvcmxkSW52ZXJzZSk7aC5zZXRGcm9tTWF0cml4KGcpO2Iuc2V0UmVuZGVyVGFyZ2V0KHRoaXMucmVuZGVyVGFyZ2V0KTtiLmNsZWFyKCk7bj1pLl9fd2ViZ2xPYmplY3RzO209MDtmb3IobD1uLmxlbmd0aDttPGw7bSsrKWlmKHA9blttXSx0PXAub2JqZWN0LHAucmVuZGVyPSExLHQudmlzaWJsZSYmKCEodCBpbnN0YW5jZW9mIFRIUkVFLk1lc2h8fHQgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZVN5c3RlbSl8fCF0LmZydXN0dW1DdWxsZWR8fGguaW50ZXJzZWN0c09iamVjdCh0KSkpdC5fbW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoay5tYXRyaXhXb3JsZEludmVyc2UsdC5tYXRyaXhXb3JsZCkscC5yZW5kZXI9ITA7dmFyIHI7bT0wO2ZvcihsPW4ubGVuZ3RoO208bDttKyspaWYocD1uW21dLHAucmVuZGVyJiYodD1wLm9iamVjdCxwPXAuYnVmZmVyLCEodCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlU3lzdGVtKXx8dC5jdXN0b21EZXB0aE1hdGVyaWFsKSkocj1cbnQubWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsP3QubWF0ZXJpYWwubWF0ZXJpYWxzWzBdOnQubWF0ZXJpYWwpJiZiLnNldE1hdGVyaWFsRmFjZXModC5tYXRlcmlhbCkscz0wPHQuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCYmci5tb3JwaFRhcmdldHMscj10IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2gmJnIuc2tpbm5pbmcscz10LmN1c3RvbURlcHRoTWF0ZXJpYWw/dC5jdXN0b21EZXB0aE1hdGVyaWFsOnI/cz9mOmU6cz9kOmMscCBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5P2IucmVuZGVyQnVmZmVyRGlyZWN0KGssaS5fX2xpZ2h0cyxudWxsLHMscCx0KTpiLnJlbmRlckJ1ZmZlcihrLGkuX19saWdodHMsbnVsbCxzLHAsdCk7bj1pLl9fd2ViZ2xPYmplY3RzSW1tZWRpYXRlO209MDtmb3IobD1uLmxlbmd0aDttPGw7bSsrKXA9blttXSx0PXAub2JqZWN0LHQudmlzaWJsZSYmKHQuX21vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKGsubWF0cml4V29ybGRJbnZlcnNlLFxudC5tYXRyaXhXb3JsZCksYi5yZW5kZXJJbW1lZGlhdGVPYmplY3QoayxpLl9fbGlnaHRzLG51bGwsYyx0KSk7bT1iLmdldENsZWFyQ29sb3IoKTtsPWIuZ2V0Q2xlYXJBbHBoYSgpO2EuY2xlYXJDb2xvcihtLnIsbS5nLG0uYixsKTthLmVuYWJsZShhLkJMRU5EKX19O1RIUkVFLlNoYWRlckZsYXJlcz17bGVuc0ZsYXJlVmVydGV4VGV4dHVyZTp7dmVydGV4U2hhZGVyOlwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1xcbnVuaWZvcm0gdmVjMyBzY3JlZW5Qb3NpdGlvbjtcXG51bmlmb3JtIHZlYzIgc2NhbGU7XFxudW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcXG51bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XFxuYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgdXY7XFxudmFyeWluZyB2ZWMyIHZVVjtcXG52YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5O1xcbnZvaWQgbWFpbigpIHtcXG52VVYgPSB1djtcXG52ZWMyIHBvcyA9IHBvc2l0aW9uO1xcbmlmKCByZW5kZXJUeXBlID09IDIgKSB7XFxudmVjNCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC4xICkgKTtcXG52aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuMSApICk7XFxudmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjEgKSApO1xcbnZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC41ICkgKTtcXG52aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuOSApICk7XFxudmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjkgKSApO1xcbnZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC45ICkgKTtcXG52aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuNSApICk7XFxudmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjUgKSApO1xcbnZWaXNpYmlsaXR5ID0gICAgICAgIHZpc2liaWxpdHkuciAvIDkuMDtcXG52VmlzaWJpbGl0eSAqPSAxLjAgLSB2aXNpYmlsaXR5LmcgLyA5LjA7XFxudlZpc2liaWxpdHkgKj0gICAgICAgdmlzaWJpbGl0eS5iIC8gOS4wO1xcbnZWaXNpYmlsaXR5ICo9IDEuMCAtIHZpc2liaWxpdHkuYSAvIDkuMDtcXG5wb3MueCA9IGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1xcbnBvcy55ID0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XFxufVxcbmdsX1Bvc2l0aW9uID0gdmVjNCggKCBwb3MgKiBzY2FsZSArIHNjcmVlblBvc2l0aW9uLnh5ICkueHksIHNjcmVlblBvc2l0aW9uLnosIDEuMCApO1xcbn1cIixcbmZyYWdtZW50U2hhZGVyOlwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSB2ZWMzIGNvbG9yO1xcbnZhcnlpbmcgdmVjMiB2VVY7XFxudmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTtcXG52b2lkIG1haW4oKSB7XFxuaWYoIHJlbmRlclR5cGUgPT0gMCApIHtcXG5nbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMS4wLCAwLjAgKTtcXG59IGVsc2UgaWYoIHJlbmRlclR5cGUgPT0gMSApIHtcXG5nbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XFxufSBlbHNlIHtcXG52ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XFxudGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2VmlzaWJpbGl0eTtcXG5nbF9GcmFnQ29sb3IgPSB0ZXh0dXJlO1xcbmdsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3I7XFxufVxcbn1cIn0sbGVuc0ZsYXJlOnt2ZXJ0ZXhTaGFkZXI6XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XFxudW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1xcbnVuaWZvcm0gdmVjMiBzY2FsZTtcXG51bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIHV2O1xcbnZhcnlpbmcgdmVjMiB2VVY7XFxudm9pZCBtYWluKCkge1xcbnZVViA9IHV2O1xcbnZlYzIgcG9zID0gcG9zaXRpb247XFxuaWYoIHJlbmRlclR5cGUgPT0gMiApIHtcXG5wb3MueCA9IGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1xcbnBvcy55ID0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XFxufVxcbmdsX1Bvc2l0aW9uID0gdmVjNCggKCBwb3MgKiBzY2FsZSArIHNjcmVlblBvc2l0aW9uLnh5ICkueHksIHNjcmVlblBvc2l0aW9uLnosIDEuMCApO1xcbn1cIixcbmZyYWdtZW50U2hhZGVyOlwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG51bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gdmVjMyBjb2xvcjtcXG52YXJ5aW5nIHZlYzIgdlVWO1xcbnZvaWQgbWFpbigpIHtcXG5pZiggcmVuZGVyVHlwZSA9PSAwICkge1xcbmdsX0ZyYWdDb2xvciA9IHZlYzQoIHRleHR1cmUyRCggbWFwLCB2VVYgKS5yZ2IsIDAuMCApO1xcbn0gZWxzZSBpZiggcmVuZGVyVHlwZSA9PSAxICkge1xcbmdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcXG59IGVsc2Uge1xcbmZsb2F0IHZpc2liaWxpdHkgPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjEgKSApLmE7XFxudmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjUgKSApLmE7XFxudmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjkgKSApLmE7XFxudmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjUgKSApLmE7XFxudmlzaWJpbGl0eSA9ICggMS4wIC0gdmlzaWJpbGl0eSAvIDQuMCApO1xcbnZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcXG50ZXh0dXJlLmEgKj0gb3BhY2l0eSAqIHZpc2liaWxpdHk7XFxuZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTtcXG5nbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yO1xcbn1cXG59XCJ9fTtUSFJFRS5TaGFkZXJTcHJpdGU9e3Nwcml0ZTp7dmVydGV4U2hhZGVyOlwidW5pZm9ybSBpbnQgdXNlU2NyZWVuQ29vcmRpbmF0ZXM7XFxudW5pZm9ybSBpbnQgc2l6ZUF0dGVudWF0aW9uO1xcbnVuaWZvcm0gdmVjMyBzY3JlZW5Qb3NpdGlvbjtcXG51bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4O1xcbnVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgcm90YXRpb247XFxudW5pZm9ybSB2ZWMyIHNjYWxlO1xcbnVuaWZvcm0gdmVjMiBhbGlnbm1lbnQ7XFxudW5pZm9ybSB2ZWMyIHV2T2Zmc2V0O1xcbnVuaWZvcm0gdmVjMiB1dlNjYWxlO1xcbnVuaWZvcm0gdmVjMiBoYWxmVmlld3BvcnQ7XFxuYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgdXY7XFxudmFyeWluZyB2ZWMyIHZVVjtcXG52b2lkIG1haW4oKSB7XFxudlVWID0gdXZPZmZzZXQgKyB1diAqIHV2U2NhbGU7XFxudmVjMiBhbGlnbmVkUG9zaXRpb24gPSAoIHBvc2l0aW9uICsgYWxpZ25tZW50ICkgKiBzY2FsZTtcXG52ZWMyIHJvdGF0ZWRQb3NpdGlvbjtcXG5yb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7XFxucm90YXRlZFBvc2l0aW9uLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55O1xcbnZlYzQgZmluYWxQb3NpdGlvbjtcXG5pZiggdXNlU2NyZWVuQ29vcmRpbmF0ZXMgIT0gMCApIHtcXG5maW5hbFBvc2l0aW9uID0gdmVjNCggc2NyZWVuUG9zaXRpb24ueHkgKyAoIHJvdGF0ZWRQb3NpdGlvbiAvIGhhbGZWaWV3cG9ydCApLCBzY3JlZW5Qb3NpdGlvbi56LCAxLjAgKTtcXG59IGVsc2Uge1xcbmZpbmFsUG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTtcXG5maW5hbFBvc2l0aW9uLnh5ICs9IHJvdGF0ZWRQb3NpdGlvbiAqICggc2l6ZUF0dGVudWF0aW9uID09IDEgPyAxLjAgOiBmaW5hbFBvc2l0aW9uLnogKTtcXG5maW5hbFBvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIGZpbmFsUG9zaXRpb247XFxufVxcbmdsX1Bvc2l0aW9uID0gZmluYWxQb3NpdGlvbjtcXG59XCIsXG5mcmFnbWVudFNoYWRlcjpcInVuaWZvcm0gdmVjMyBjb2xvcjtcXG51bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnVuaWZvcm0gaW50IGZvZ1R5cGU7XFxudW5pZm9ybSB2ZWMzIGZvZ0NvbG9yO1xcbnVuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTtcXG51bmlmb3JtIGZsb2F0IGZvZ05lYXI7XFxudW5pZm9ybSBmbG9hdCBmb2dGYXI7XFxudW5pZm9ybSBmbG9hdCBhbHBoYVRlc3Q7XFxudmFyeWluZyB2ZWMyIHZVVjtcXG52b2lkIG1haW4oKSB7XFxudmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1xcbmlmICggdGV4dHVyZS5hIDwgYWxwaGFUZXN0ICkgZGlzY2FyZDtcXG5nbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2xvciAqIHRleHR1cmUueHl6LCB0ZXh0dXJlLmEgKiBvcGFjaXR5ICk7XFxuaWYgKCBmb2dUeXBlID4gMCApIHtcXG5mbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XFxuZmxvYXQgZm9nRmFjdG9yID0gMC4wO1xcbmlmICggZm9nVHlwZSA9PSAxICkge1xcbmZvZ0ZhY3RvciA9IHNtb290aHN0ZXAoIGZvZ05lYXIsIGZvZ0ZhciwgZGVwdGggKTtcXG59IGVsc2Uge1xcbmNvbnN0IGZsb2F0IExPRzIgPSAxLjQ0MjY5NTtcXG5mbG9hdCBmb2dGYWN0b3IgPSBleHAyKCAtIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5ICogZGVwdGggKiBkZXB0aCAqIExPRzIgKTtcXG5mb2dGYWN0b3IgPSAxLjAgLSBjbGFtcCggZm9nRmFjdG9yLCAwLjAsIDEuMCApO1xcbn1cXG5nbF9GcmFnQ29sb3IgPSBtaXgoIGdsX0ZyYWdDb2xvciwgdmVjNCggZm9nQ29sb3IsIGdsX0ZyYWdDb2xvci53ICksIGZvZ0ZhY3RvciApO1xcbn1cXG59XCJ9fTtcblxubW9kdWxlLmV4cG9ydHMgPSBUSFJFRTtcbiIsIi8qKlxuKiBAanN4IFJlYWN0LkRPTVxuKi9cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKSxcbkRldGVjdG9yID0gcmVxdWlyZSgnLi90aGlyZC1wYXJ0eS9EZXRlY3Rvci5qcycpLFxuVFdFRU4gPSByZXF1aXJlKCcuL3RoaXJkLXBhcnR5L1R3ZWVuLmpzJyksXG5EQVQgPSByZXF1aXJlKCcuL2dsb2JlLmpzJyk7XG5cbnZhciBXZWJHTEdsb2JlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiAnV2ViR0xHbG9iZScsXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtjbGFzc05hbWU6IFwiY29udGFpbmVyXCIsIHJlZjogXCJjb250YWluZXJcIn0pLCBcblxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7aWQ6IFwiaW5mb1wifSwgXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3Ryb25nXCIsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHtocmVmOiBcImh0dHA6Ly93d3cuY2hyb21lZXhwZXJpbWVudHMuY29tL2dsb2JlXCJ9LCBcIldlYkdMIEdsb2JlXCIpKSwgXCIgXCIsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwiYnVsbFwifSwgXCLigKJcIiksIFwiwqBDcmVhdGVkIGJ5IHRoZSBHb29nbGUgRGF0YSBBcnRzIFRlYW0gXCIsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwiYnVsbFwifSwgXCLigKJcIiksIFwiIERhdGEgYWNxdWlyZWQgZnJvbSBcIiwgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwge2hyZWY6IFwiaHR0cDovL3NlZGFjLmNpZXNpbi5jb2x1bWJpYS5lZHUvZ3B3L1wifSwgXCJTRURBQ1wiKVxuICAgICAgKSwgXG5cbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2lkOiBcImN1cnJlbnRJbmZvXCJ9LCBcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtyZWY6IFwieWVhcjE5OTBcIiwgY2xhc3NOYW1lOiBcInllYXJcIn0sIFwiMTk5MFwiKSwgXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7cmVmOiBcInllYXIxOTk1XCIsIGNsYXNzTmFtZTogXCJ5ZWFyXCJ9LCBcIjE5OTVcIiksIFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge3JlZjogXCJ5ZWFyMjAwMFwiLCBjbGFzc05hbWU6IFwieWVhclwifSwgXCIyMDAwXCIpXG4gICAgICApLCBcblxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7aWQ6IFwidGl0bGVcIn0sIFxuICAgICAgXCJXb3JsZCBQb3B1bGF0aW9uXCJcbiAgICAgICksIFxuXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7aWQ6IFwiY2VcIiwgaHJlZjogXCJodHRwOi8vd3d3LmNocm9tZWV4cGVyaW1lbnRzLmNvbS9nbG9iZVwifSwgXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBcIlRoaXMgaXMgYSBDaHJvbWUgRXhwZXJpbWVudFwiKVxuICAgICAgKVxuXG4gICAgICApXG4gICAgKTtcbiAgfSxcbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLnJlZnMuY29udGFpbmVyLmdldERPTU5vZGUoKTtcbiAgICBpZighRGV0ZWN0b3Iud2ViZ2wpe1xuICAgICAgRGV0ZWN0b3IuYWRkR2V0V2ViR0xNZXNzYWdlKCk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgdmFyIHllYXJzID0gWycxOTkwJywnMTk5NScsJzIwMDAnXTtcbiAgICAgIC8vIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyJyk7XG5cbiAgICAgIHZhciBvcHRzID0ge2ltZ0RpcjogJ2Fzc2V0cy8nfTtcbiAgICAgIHZhciBnbG9iZSA9IG5ldyBEQVQuR2xvYmUoY29udGFpbmVyLCBvcHRzKTtcbiAgICAgIHZhciBpLCB0d2VlbnMgPSBbXTtcblxuICAgICAgdmFyIHNldHRpbWUgPSBmdW5jdGlvbihnbG9iZSwgdCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbmV3IFRXRUVOLlR3ZWVuKGdsb2JlKS50byh7dGltZTogdC95ZWFycy5sZW5ndGh9LDUwMCkuZWFzaW5nKFRXRUVOLkVhc2luZy5DdWJpYy5FYXNlT3V0KS5zdGFydCgpO1xuICAgICAgICAgIHZhciB5ID0gdGhpcy5yZWZzWygneWVhcicreWVhcnNbdF0pXS5nZXRET01Ob2RlKCk7XG4gICAgICAgICAgaWYgKHkuZ2V0QXR0cmlidXRlKCdjbGFzcycpID09PSAneWVhciBhY3RpdmUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB5eSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3llYXInKTtcbiAgICAgICAgICBmb3IoaT0wOyBpPHl5Lmxlbmd0aDsgaSsrKSB7aVxuICAgICAgICAgICAgeXlbaV0uc2V0QXR0cmlidXRlKCdjbGFzcycsJ3llYXInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgeS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3llYXIgYWN0aXZlJyk7XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBmb3IodmFyIGkgPSAwOyBpPHllYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy5yZWZzWygneWVhcicreWVhcnNbaV0pXS5nZXRET01Ob2RlKCk7XG4gICAgICAgIHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgc2V0dGltZShnbG9iZSxpKSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgeGhyO1xuICAgICAgVFdFRU4uc3RhcnQoKTtcblxuXG4gICAgICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCAnYXNzZXRzL3BvcHVsYXRpb245MDk1MDAuanNvbicsIHRydWUpO1xuICAgICAgdmFyIG9ucmVhZHlzdGF0ZWNoYW5nZWNhbGxiYWNrID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICB3aW5kb3cuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBmb3IgKGk9MDtpPGRhdGEubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgICBnbG9iZS5hZGREYXRhKGRhdGFbaV1bMV0sIHtmb3JtYXQ6ICdtYWduaXR1ZGUnLCBuYW1lOiBkYXRhW2ldWzBdLCBhbmltYXRlZDogdHJ1ZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2xvYmUuY3JlYXRlUG9pbnRzKCk7XG4gICAgICAgICAgICAoc2V0dGltZShnbG9iZSwwKS5iaW5kKHRoaXMpKSgpO1xuICAgICAgICAgICAgZ2xvYmUuYW5pbWF0ZSgpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAnbm9uZSc7IC8vIHJlbW92ZSBsb2FkaW5nXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG9ucmVhZHlzdGF0ZWNoYW5nZWNhbGxiYWNrLmJpbmQodGhpcyk7XG4gICAgICB4aHIuc2VuZChudWxsKTtcbiAgICB9XG5cbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJHTEdsb2JlO1xuIl19
